---------------------------------------------
-- Export file for user ILMSPEC@ILMSPEC    --
-- Created by zhuol on 2019/11/10, 8:48:52 --
---------------------------------------------

set define off
spool iLMS_PEC.log

prompt
prompt Creating table BASE_REL_RESOURCES
prompt =================================
prompt
create table BASE_REL_RESOURCES
(
  id_      VARCHAR2(50) not null,
  res_id_  VARCHAR2(50),
  name_    VARCHAR2(50),
  res_url_ VARCHAR2(100)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table BASE_REL_RESOURCES
  is '????';
comment on column BASE_REL_RESOURCES.id_
  is '??';
comment on column BASE_REL_RESOURCES.res_id_
  is '??ID';
comment on column BASE_REL_RESOURCES.name_
  is '??';
comment on column BASE_REL_RESOURCES.res_url_
  is '????';
alter table BASE_REL_RESOURCES
  add constraint PK_BASE_REL_RESOURCES primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table BASE_RES_ROLE
prompt ============================
prompt
create table BASE_RES_ROLE
(
  id_        VARCHAR2(50) not null,
  system_id_ VARCHAR2(50) not null,
  res_id_    VARCHAR2(50) not null,
  role_id_   VARCHAR2(50) not null
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table BASE_RES_ROLE
  is '??????';
comment on column BASE_RES_ROLE.id_
  is '??';
comment on column BASE_RES_ROLE.system_id_
  is '??ID';
comment on column BASE_RES_ROLE.res_id_
  is '??ID';
comment on column BASE_RES_ROLE.role_id_
  is '??ID';
alter table BASE_RES_ROLE
  add constraint PK_BASE_RES_ROLE primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table BASE_SUBSYSTEM
prompt =============================
prompt
create table BASE_SUBSYSTEM
(
  id_          VARCHAR2(50) not null,
  name_        VARCHAR2(100),
  alias_       VARCHAR2(50),
  logo_        VARCHAR2(100),
  enabled_     NUMBER,
  home_url_    VARCHAR2(100),
  base_url_    VARCHAR2(100),
  tenant_      VARCHAR2(50),
  memo_        VARCHAR2(200),
  creator_id_  VARCHAR2(50),
  creator_     VARCHAR2(50),
  create_time_ TIMESTAMP(6),
  is_default_  NUMBER
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table BASE_SUBSYSTEM
  is '?????';
comment on column BASE_SUBSYSTEM.id_
  is '??';
comment on column BASE_SUBSYSTEM.name_
  is '????';
comment on column BASE_SUBSYSTEM.alias_
  is '????';
comment on column BASE_SUBSYSTEM.logo_
  is 'LOGO';
comment on column BASE_SUBSYSTEM.enabled_
  is '???? 1 ???0 ????';
comment on column BASE_SUBSYSTEM.home_url_
  is '????';
comment on column BASE_SUBSYSTEM.base_url_
  is '????';
comment on column BASE_SUBSYSTEM.tenant_
  is '????';
comment on column BASE_SUBSYSTEM.memo_
  is '??';
comment on column BASE_SUBSYSTEM.creator_id_
  is '???ID';
comment on column BASE_SUBSYSTEM.creator_
  is '???';
comment on column BASE_SUBSYSTEM.create_time_
  is '????';
comment on column BASE_SUBSYSTEM.is_default_
  is '?????';
alter table BASE_SUBSYSTEM
  add constraint PK_BASE_SUBSYSTEM primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table BASE_SYS_RESOURCE
prompt ================================
prompt
create table BASE_SYS_RESOURCE
(
  id_           VARCHAR2(50) not null,
  system_id_    VARCHAR2(50),
  alias_        VARCHAR2(50),
  name_         VARCHAR2(100),
  default_url_  VARCHAR2(100),
  enable_menu_  NUMBER,
  has_children_ NUMBER,
  opened_       NUMBER,
  icon_         VARCHAR2(100),
  new_window_   NUMBER,
  sn_           NUMBER,
  parent_id_    VARCHAR2(50),
  create_time_  TIMESTAMP(6),
  sys_res_type_ VARCHAR2(32)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table BASE_SYS_RESOURCE
  is '?????';
comment on column BASE_SYS_RESOURCE.id_
  is '??';
comment on column BASE_SYS_RESOURCE.system_id_
  is '???ID';
comment on column BASE_SYS_RESOURCE.alias_
  is '????';
comment on column BASE_SYS_RESOURCE.name_
  is '???';
comment on column BASE_SYS_RESOURCE.default_url_
  is '??URL';
comment on column BASE_SYS_RESOURCE.enable_menu_
  is '?????(1,??,0 ,???)';
comment on column BASE_SYS_RESOURCE.has_children_
  is '??????';
comment on column BASE_SYS_RESOURCE.opened_
  is '????';
comment on column BASE_SYS_RESOURCE.icon_
  is '??';
comment on column BASE_SYS_RESOURCE.new_window_
  is '?????';
comment on column BASE_SYS_RESOURCE.sn_
  is '??';
comment on column BASE_SYS_RESOURCE.parent_id_
  is '???ID';
comment on column BASE_SYS_RESOURCE.create_time_
  is '????';
comment on column BASE_SYS_RESOURCE.sys_res_type_
  is '????';
alter table BASE_SYS_RESOURCE
  add constraint PK_BASE_SYS_RESOURCE primary key (ID_)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CUSTOM_DIALOG
prompt ============================
prompt
create table CUSTOM_DIALOG
(
  id_             VARCHAR2(64) not null,
  name_           VARCHAR2(64) not null,
  alias_          VARCHAR2(64) not null,
  style_          NUMBER,
  obj_name_       VARCHAR2(64) not null,
  need_page_      NUMBER,
  page_size_      NUMBER,
  displayfield_   CLOB,
  conditionfield_ CLOB,
  resultfield_    CLOB,
  sortfield_      VARCHAR2(200),
  dsalias_        VARCHAR2(64) not null,
  is_table_       NUMBER not null,
  diy_sql_        VARCHAR2(510),
  sql_build_type_ NUMBER,
  width_          NUMBER,
  height_         NUMBER,
  select_num_     NUMBER,
  system_         NUMBER default 0,
  parent_check_   NUMBER,
  children_check_ NUMBER
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table CUSTOM_DIALOG
  is '??????';
comment on column CUSTOM_DIALOG.id_
  is '??';
comment on column CUSTOM_DIALOG.name_
  is '??';
comment on column CUSTOM_DIALOG.alias_
  is '??';
comment on column CUSTOM_DIALOG.style_
  is '?????0-???1-??';
comment on column CUSTOM_DIALOG.obj_name_
  is '????????????????????';
comment on column CUSTOM_DIALOG.need_page_
  is '????';
comment on column CUSTOM_DIALOG.page_size_
  is '????';
comment on column CUSTOM_DIALOG.displayfield_
  is '????';
comment on column CUSTOM_DIALOG.conditionfield_
  is '?????json';
comment on column CUSTOM_DIALOG.resultfield_
  is '????json';
comment on column CUSTOM_DIALOG.sortfield_
  is '????';
comment on column CUSTOM_DIALOG.dsalias_
  is '??????';
comment on column CUSTOM_DIALOG.is_table_
  is '??????0:??,1:????';
comment on column CUSTOM_DIALOG.diy_sql_
  is '???SQL';
comment on column CUSTOM_DIALOG.sql_build_type_
  is 'SQL????';
comment on column CUSTOM_DIALOG.width_
  is '??????';
comment on column CUSTOM_DIALOG.height_
  is '??????';
comment on column CUSTOM_DIALOG.select_num_
  is '???? -1:??';
comment on column CUSTOM_DIALOG.system_
  is '????';
comment on column CUSTOM_DIALOG.parent_check_
  is '???????';
comment on column CUSTOM_DIALOG.children_check_
  is '???????';
alter table CUSTOM_DIALOG
  add constraint PK_CUSTOM_DIALOG primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table CUSTOM_QUERY
prompt ===========================
prompt
create table CUSTOM_QUERY
(
  id_             VARCHAR2(64) not null,
  name_           VARCHAR2(64) not null,
  alias_          VARCHAR2(64) not null,
  obj_name_       VARCHAR2(64) not null,
  need_page_      NUMBER,
  page_size_      NUMBER,
  conditionfield_ CLOB,
  resultfield_    CLOB,
  sortfield_      CLOB,
  dsalias_        VARCHAR2(64) not null,
  is_table_       NUMBER not null,
  diy_sql_        VARCHAR2(510),
  sql_build_type_ NUMBER
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table CUSTOM_QUERY
  is '?????';
comment on column CUSTOM_QUERY.id_
  is '??';
comment on column CUSTOM_QUERY.name_
  is '??';
comment on column CUSTOM_QUERY.alias_
  is '??';
comment on column CUSTOM_QUERY.obj_name_
  is '????????????????????';
comment on column CUSTOM_QUERY.need_page_
  is '????';
comment on column CUSTOM_QUERY.page_size_
  is '????';
comment on column CUSTOM_QUERY.conditionfield_
  is '?????json';
comment on column CUSTOM_QUERY.resultfield_
  is '????json';
comment on column CUSTOM_QUERY.sortfield_
  is '????';
comment on column CUSTOM_QUERY.dsalias_
  is '??????';
comment on column CUSTOM_QUERY.is_table_
  is '??????0:??,1:????';
comment on column CUSTOM_QUERY.diy_sql_
  is '???SQL';
comment on column CUSTOM_QUERY.sql_build_type_
  is 'SQL????';
alter table CUSTOM_QUERY
  add constraint PK_CUSTOM_QUERY primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_ASSEMBLY_MOULD
prompt ================================
prompt
create table IF_ASSEMBLY_MOULD
(
  id            NUMBER(19) not null,
  assembly_name VARCHAR2(64),
  model_code    VARCHAR2(32),
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50),
  do_flag       VARCHAR2(2),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate,
  guid          VARCHAR2(50),
  file_key      VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_ASSEMBLY_MOULD
  is 'IF_ASSEMBLY_MOULD???????
IF_ASSEMBLY_MOULD???????
';
comment on column IF_ASSEMBLY_MOULD.id
  is 'ID
ID
';
comment on column IF_ASSEMBLY_MOULD.assembly_name
  is '?????
?????
';
comment on column IF_ASSEMBLY_MOULD.model_code
  is '??
??
';
comment on column IF_ASSEMBLY_MOULD.uda1
  is '????1
????1
';
comment on column IF_ASSEMBLY_MOULD.uda2
  is '????2
????2
';
comment on column IF_ASSEMBLY_MOULD.uda3
  is '????3
????3
';
comment on column IF_ASSEMBLY_MOULD.uda4
  is '????4
????4
';
comment on column IF_ASSEMBLY_MOULD.uda5
  is '????5
????5
';
comment on column IF_ASSEMBLY_MOULD.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_ASSEMBLY_MOULD.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_ASSEMBLY_MOULD.deal_time
  is '????
????
';
comment on column IF_ASSEMBLY_MOULD.creation_time
  is '????
????
';
comment on column IF_ASSEMBLY_MOULD.guid
  is 'GUID
GUID
';
comment on column IF_ASSEMBLY_MOULD.file_key
  is '????
????
';
create index IDX_IF_ASSEMBLY_MOULD_1 on IF_ASSEMBLY_MOULD (DEAL_FLAG)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table IF_ASSEMBLY_MOULD
  add constraint PK_IF_ASSEMBLY_MOULD primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_ASSEMBLY_MOULD_CONFIG
prompt =======================================
prompt
create table IF_ASSEMBLY_MOULD_CONFIG
(
  id          NUMBER(19) not null,
  location    VARCHAR2(32),
  config_name VARCHAR2(64),
  area_code   VARCHAR2(80),
  uda1        VARCHAR2(50),
  uda2        VARCHAR2(50),
  uda3        VARCHAR2(50),
  uda4        VARCHAR2(50),
  uda5        VARCHAR2(50),
  deal_flag   NUMBER(1) default 0,
  deal_time   DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_ASSEMBLY_MOULD_CONFIG
  is 'IF_ASSEMBLY_MOULD_CONFIG???????
IF_ASSEMBLY_MOULD_CONFIG???????
';
comment on column IF_ASSEMBLY_MOULD_CONFIG.id
  is 'ID
ID
';
comment on column IF_ASSEMBLY_MOULD_CONFIG.location
  is '??
??
';
comment on column IF_ASSEMBLY_MOULD_CONFIG.config_name
  is '?????
?????
';
comment on column IF_ASSEMBLY_MOULD_CONFIG.area_code
  is '??
??
?????10???20???';
comment on column IF_ASSEMBLY_MOULD_CONFIG.uda1
  is '????1
????1
';
comment on column IF_ASSEMBLY_MOULD_CONFIG.uda2
  is '????2
????2
';
comment on column IF_ASSEMBLY_MOULD_CONFIG.uda3
  is '????3
????3
';
comment on column IF_ASSEMBLY_MOULD_CONFIG.uda4
  is '????4
????4
';
comment on column IF_ASSEMBLY_MOULD_CONFIG.uda5
  is '????5
????5
';
comment on column IF_ASSEMBLY_MOULD_CONFIG.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_ASSEMBLY_MOULD_CONFIG.deal_time
  is '????
????
';

prompt
prompt Creating table IF_FEATURE_GROUP
prompt ===============================
prompt
create table IF_FEATURE_GROUP
(
  id                 NUMBER(19) not null,
  feature_group      VARCHAR2(64) not null,
  feature_group_desc VARCHAR2(256),
  default_value      VARCHAR2(64),
  uda1               VARCHAR2(50),
  uda2               VARCHAR2(50),
  uda3               VARCHAR2(50),
  uda4               VARCHAR2(50),
  uda5               VARCHAR2(50),
  do_flag            VARCHAR2(2),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  creation_time      DATE default sysdate,
  guid               VARCHAR2(50),
  file_key           VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_FEATURE_GROUP
  is 'IF_FEATURE_GROUP??????
IF_FEATURE_GROUP??????
';
comment on column IF_FEATURE_GROUP.id
  is 'ID
ID
';
comment on column IF_FEATURE_GROUP.feature_group
  is '?????
?????
';
comment on column IF_FEATURE_GROUP.feature_group_desc
  is '?????
?????
';
comment on column IF_FEATURE_GROUP.default_value
  is '???
???
';
comment on column IF_FEATURE_GROUP.uda1
  is '????1
????1
';
comment on column IF_FEATURE_GROUP.uda2
  is '????2
????2
';
comment on column IF_FEATURE_GROUP.uda3
  is '????3
????3
';
comment on column IF_FEATURE_GROUP.uda4
  is '????4
????4
';
comment on column IF_FEATURE_GROUP.uda5
  is '????5
????5
';
comment on column IF_FEATURE_GROUP.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_FEATURE_GROUP.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_FEATURE_GROUP.deal_time
  is '????
????
';
comment on column IF_FEATURE_GROUP.creation_time
  is '????
????
';
comment on column IF_FEATURE_GROUP.guid
  is 'GUID
GUID
';
comment on column IF_FEATURE_GROUP.file_key
  is '????
????
';
create index IDX_IF_FEATURE_GROUP_1 on IF_FEATURE_GROUP (DEAL_FLAG)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table IF_FEATURE_GROUP
  add constraint PK_IF_FEATURE_GROUP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_FEATURE_GROUP_DETAIL
prompt ======================================
prompt
create table IF_FEATURE_GROUP_DETAIL
(
  id             NUMBER(19) not null,
  feature_code1  VARCHAR2(32),
  feature_value1 VARCHAR2(32),
  feature_code2  VARCHAR2(32),
  feature_value2 VARCHAR2(32),
  feature_code3  VARCHAR2(32),
  feature_value3 VARCHAR2(32),
  feature_code4  VARCHAR2(32),
  feature_value4 VARCHAR2(32),
  display_value  VARCHAR2(64),
  uda1           VARCHAR2(50),
  uda2           VARCHAR2(50),
  uda3           VARCHAR2(50),
  uda4           VARCHAR2(50),
  uda5           VARCHAR2(50),
  deal_flag      NUMBER(1) default 0,
  deal_time      DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_FEATURE_GROUP_DETAIL
  is 'IF_FEATURE_GROUP_DETAIL????????
IF_FEATURE_GROUP_DETAIL????????
';
comment on column IF_FEATURE_GROUP_DETAIL.id
  is 'ID
ID
';
comment on column IF_FEATURE_GROUP_DETAIL.feature_code1
  is '???1
???1
';
comment on column IF_FEATURE_GROUP_DETAIL.feature_value1
  is '???1
???1
';
comment on column IF_FEATURE_GROUP_DETAIL.feature_code2
  is '???2
???2
';
comment on column IF_FEATURE_GROUP_DETAIL.feature_value2
  is '???2
???2
';
comment on column IF_FEATURE_GROUP_DETAIL.feature_code3
  is '???3
???3
';
comment on column IF_FEATURE_GROUP_DETAIL.feature_value3
  is '???3
???3
';
comment on column IF_FEATURE_GROUP_DETAIL.feature_code4
  is '???4
???4
';
comment on column IF_FEATURE_GROUP_DETAIL.feature_value4
  is '???4
???4
';
comment on column IF_FEATURE_GROUP_DETAIL.display_value
  is '???
???
';
comment on column IF_FEATURE_GROUP_DETAIL.uda1
  is '????1
????1
';
comment on column IF_FEATURE_GROUP_DETAIL.uda2
  is '????2
????2
';
comment on column IF_FEATURE_GROUP_DETAIL.uda3
  is '????3
????3
';
comment on column IF_FEATURE_GROUP_DETAIL.uda4
  is '????4
????4
';
comment on column IF_FEATURE_GROUP_DETAIL.uda5
  is '????5
????5
';
comment on column IF_FEATURE_GROUP_DETAIL.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_FEATURE_GROUP_DETAIL.deal_time
  is '????
????
';

prompt
prompt Creating table IF_INV_REC
prompt =========================
prompt
create table IF_INV_REC
(
  logistics_rec_order VARCHAR2(50) not null,
  comp                VARCHAR2(10),
  purchase_order_no   VARCHAR2(50),
  user_id             VARCHAR2(30),
  rec_date            DATE,
  uda1                VARCHAR2(50),
  uda2                VARCHAR2(50),
  uda3                VARCHAR2(50),
  uda4                VARCHAR2(50),
  uda5                VARCHAR2(50),
  deal_flag           NUMBER(1) default 0,
  deal_time           DATE,
  creation_time       DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_INV_REC
  is 'IF_INV_REC?????????
IF_INV_REC?????????
';
comment on column IF_INV_REC.logistics_rec_order
  is '??????
??????
';
comment on column IF_INV_REC.comp
  is '??
??
';
comment on column IF_INV_REC.purchase_order_no
  is '????
????
';
comment on column IF_INV_REC.user_id
  is '???
???
??';
comment on column IF_INV_REC.rec_date
  is '??????
??????
???yyyy-MM-dd HH:mm:ss';
comment on column IF_INV_REC.uda1
  is '????1
????1
';
comment on column IF_INV_REC.uda2
  is '????2
????2
';
comment on column IF_INV_REC.uda3
  is '????3
????3
';
comment on column IF_INV_REC.uda4
  is '????4
????4
';
comment on column IF_INV_REC.uda5
  is '????5
????5
';
comment on column IF_INV_REC.deal_flag
  is '????
????
0 ??? 1??? 2??';
comment on column IF_INV_REC.deal_time
  is '????
????
';
comment on column IF_INV_REC.creation_time
  is '????
????
????';
create index IDX_IF_INV_REC1 on IF_INV_REC (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_INV_REC
  add constraint PK_IF_INV_REC primary key (LOGISTICS_REC_ORDER)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_INV_REC_DETAIL
prompt ================================
prompt
create table IF_INV_REC_DETAIL
(
  logistics_rec_order    VARCHAR2(50) not null,
  rec_row_no             NUMBER(10) not null,
  logistics_order_row_no NUMBER(10),
  purchase_order_no      VARCHAR2(50),
  purchase_order_row_no  NUMBER(10),
  depot_no               VARCHAR2(20),
  part_id                VARCHAR2(30),
  rec_num                NUMBER(10,2),
  deal_flag              NUMBER(1),
  deal_time              DATE,
  uda1                   VARCHAR2(50),
  uda2                   VARCHAR2(50),
  uda3                   VARCHAR2(50),
  uda4                   VARCHAR2(50),
  uda5                   VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_INV_REC_DETAIL
  is 'IF_INV_REC_DETAIL???????????
IF_INV_REC_DETAIL???????????
';
comment on column IF_INV_REC_DETAIL.logistics_rec_order
  is '??????
??????
';
comment on column IF_INV_REC_DETAIL.rec_row_no
  is '???????
???????
';
comment on column IF_INV_REC_DETAIL.logistics_order_row_no
  is '??????
??????
?????????';
comment on column IF_INV_REC_DETAIL.purchase_order_no
  is '????
????
';
comment on column IF_INV_REC_DETAIL.purchase_order_row_no
  is '??????
??????
ERP?????????ERP????????';
comment on column IF_INV_REC_DETAIL.depot_no
  is '????
????
???????????';
comment on column IF_INV_REC_DETAIL.part_id
  is '????
????
';
comment on column IF_INV_REC_DETAIL.rec_num
  is '????
????
';
comment on column IF_INV_REC_DETAIL.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_INV_REC_DETAIL.deal_time
  is '????
????
';
comment on column IF_INV_REC_DETAIL.uda1
  is '????1
????1
';
comment on column IF_INV_REC_DETAIL.uda2
  is '????2
????2
';
comment on column IF_INV_REC_DETAIL.uda3
  is '????3
????3
';
comment on column IF_INV_REC_DETAIL.uda4
  is '????4
????4
';
comment on column IF_INV_REC_DETAIL.uda5
  is '????5
????5
';
create index IDX_IF_INV_REC_DETAIL1 on IF_INV_REC_DETAIL (LOGISTICS_REC_ORDER)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_INV_TRAN_ERP
prompt ==============================
prompt
create table IF_INV_TRAN_ERP
(
  id          NUMBER(19) not null,
  business_no VARCHAR2(50) not null,
  comp        VARCHAR2(20) not null,
  tran_type   VARCHAR2(10),
  user_id     VARCHAR2(30),
  create_date VARCHAR2(30),
  uda1        VARCHAR2(50),
  uda2        VARCHAR2(50),
  uda3        VARCHAR2(50),
  uda4        VARCHAR2(50),
  uda5        VARCHAR2(50),
  deal_flag   NUMBER(1) default 0,
  deal_time   DATE,
  guid        VARCHAR2(50),
  file_key    VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_INV_TRAN_ERP
  is 'IF_INV_TRAN_ERP ERP?????????
IF_INV_TRAN_ERP ERP?????????
';
comment on column IF_INV_TRAN_ERP.id
  is 'ID
ID
';
comment on column IF_INV_TRAN_ERP.business_no
  is '????
????
';
comment on column IF_INV_TRAN_ERP.comp
  is '??
??
';
comment on column IF_INV_TRAN_ERP.tran_type
  is '????
????
551??????????201??????';
comment on column IF_INV_TRAN_ERP.user_id
  is '???
???
???yyyy-MM-dd HH:mm:ss';
comment on column IF_INV_TRAN_ERP.create_date
  is '????
????
???yyyy-MM-dd HH:mm:ss';
comment on column IF_INV_TRAN_ERP.uda1
  is '????1
????1
';
comment on column IF_INV_TRAN_ERP.uda2
  is '????2
????2
';
comment on column IF_INV_TRAN_ERP.uda3
  is '????3
????3
';
comment on column IF_INV_TRAN_ERP.uda4
  is '????4
????4
';
comment on column IF_INV_TRAN_ERP.uda5
  is '????5
????5
';
comment on column IF_INV_TRAN_ERP.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_INV_TRAN_ERP.deal_time
  is '????
????
';
comment on column IF_INV_TRAN_ERP.guid
  is 'GUID
GUID
GUID';
comment on column IF_INV_TRAN_ERP.file_key
  is '????
????
????';
create index IDX_IF_INV_TRAN_ERP1 on IF_INV_TRAN_ERP (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_INV_TRAN_ERP
  add constraint PK_IF_INV_TRAN_ERP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_INV_TRAN_ERP_DETAIL
prompt =====================================
prompt
create table IF_INV_TRAN_ERP_DETAIL
(
  id              NUMBER(19) not null,
  business_no     VARCHAR2(50) not null,
  business_row_no VARCHAR2(10) not null,
  from_depot_no   VARCHAR2(20),
  to_depot_no     VARCHAR2(20),
  part_id         VARCHAR2(30),
  part_num        VARCHAR2(10),
  kostl           VARCHAR2(20),
  uda1            VARCHAR2(50),
  uda2            VARCHAR2(50),
  uda3            VARCHAR2(50),
  uda4            VARCHAR2(50),
  uda5            VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_INV_TRAN_ERP_DETAIL
  is 'IF_INV_TRAN_ERP_DETAIL ERP???????????
IF_INV_TRAN_ERP_DETAIL ERP???????????
';
comment on column IF_INV_TRAN_ERP_DETAIL.id
  is '??ID
??ID
';
comment on column IF_INV_TRAN_ERP_DETAIL.business_no
  is '????
????
';
comment on column IF_INV_TRAN_ERP_DETAIL.business_row_no
  is '?????
?????
';
comment on column IF_INV_TRAN_ERP_DETAIL.from_depot_no
  is '???????
???????
???????????';
comment on column IF_INV_TRAN_ERP_DETAIL.to_depot_no
  is '???????
???????
???????????';
comment on column IF_INV_TRAN_ERP_DETAIL.part_id
  is '????
????
';
comment on column IF_INV_TRAN_ERP_DETAIL.part_num
  is '????
????
????';
comment on column IF_INV_TRAN_ERP_DETAIL.kostl
  is '????
????
';
comment on column IF_INV_TRAN_ERP_DETAIL.uda1
  is '????1
????1
';
comment on column IF_INV_TRAN_ERP_DETAIL.uda2
  is '????2
????2
';
comment on column IF_INV_TRAN_ERP_DETAIL.uda3
  is '????3
????3
';
comment on column IF_INV_TRAN_ERP_DETAIL.uda4
  is '????4
????4
';
comment on column IF_INV_TRAN_ERP_DETAIL.uda5
  is '????5
????5
';
create index IDX_IF_INV_TRAN_ERP_DETAIL1 on IF_INV_TRAN_ERP_DETAIL (ID)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_INV_TRAN_LMS
prompt ==============================
prompt
create table IF_INV_TRAN_LMS
(
  business_no VARCHAR2(50) not null,
  comp        VARCHAR2(10) not null,
  tran_type   VARCHAR2(10),
  supplier_no VARCHAR2(10),
  user_id     VARCHAR2(30),
  create_date DATE,
  uda1        VARCHAR2(50),
  uda2        VARCHAR2(50),
  uda3        VARCHAR2(50),
  uda4        VARCHAR2(50),
  uda5        VARCHAR2(50),
  deal_flag   NUMBER(1) default 0,
  deal_time   DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_INV_TRAN_LMS
  is 'IF_INV_TRAN_LMS i-LMS?????????
IF_INV_TRAN_LMS i-LMS?????????
';
comment on column IF_INV_TRAN_LMS.business_no
  is '????
????
';
comment on column IF_INV_TRAN_LMS.comp
  is '??
??
';
comment on column IF_INV_TRAN_LMS.tran_type
  is '????
????
?????????';
comment on column IF_INV_TRAN_LMS.supplier_no
  is '?????
?????
';
comment on column IF_INV_TRAN_LMS.user_id
  is '???
???
ERP?????????ERP????????';
comment on column IF_INV_TRAN_LMS.create_date
  is '????
????
???????????';
comment on column IF_INV_TRAN_LMS.uda1
  is '????1
????1
';
comment on column IF_INV_TRAN_LMS.uda2
  is '????2
????2
';
comment on column IF_INV_TRAN_LMS.uda3
  is '????3
????3
';
comment on column IF_INV_TRAN_LMS.uda4
  is '????4
????4
';
comment on column IF_INV_TRAN_LMS.uda5
  is '????5
????5
';
comment on column IF_INV_TRAN_LMS.deal_flag
  is '????
????
0 ??? 1??? 2??';
comment on column IF_INV_TRAN_LMS.deal_time
  is '????
????
';
create index IDX_IF_INV_TRAN_LMS1 on IF_INV_TRAN_LMS (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_INV_TRAN_LMS
  add constraint PK_IF_INV_TRAN_LMS primary key (BUSINESS_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_INV_TRAN_LMS_DETAIL
prompt =====================================
prompt
create table IF_INV_TRAN_LMS_DETAIL
(
  comp            VARCHAR2(10) not null,
  business_no     VARCHAR2(50) not null,
  business_row_no NUMBER(10) not null,
  from_depot_no   VARCHAR2(20),
  to_depot_no     VARCHAR2(20),
  part_id         VARCHAR2(30),
  part_num        VARCHAR2(10),
  cost_center     VARCHAR2(20),
  uda1            VARCHAR2(50),
  uda2            VARCHAR2(50),
  uda3            VARCHAR2(50),
  uda4            VARCHAR2(50),
  uda5            VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_INV_TRAN_LMS_DETAIL
  is 'IF_INV_TRAN_LMS_DETAIL i-LMS???????????
IF_INV_TRAN_LMS_DETAIL i-LMS???????????
';
comment on column IF_INV_TRAN_LMS_DETAIL.comp
  is '??
??
';
comment on column IF_INV_TRAN_LMS_DETAIL.business_no
  is '????
????
';
comment on column IF_INV_TRAN_LMS_DETAIL.business_row_no
  is '?????
?????
';
comment on column IF_INV_TRAN_LMS_DETAIL.from_depot_no
  is '???????
???????
???????????';
comment on column IF_INV_TRAN_LMS_DETAIL.to_depot_no
  is '???????
???????
???????????';
comment on column IF_INV_TRAN_LMS_DETAIL.part_id
  is '????
????
';
comment on column IF_INV_TRAN_LMS_DETAIL.part_num
  is '????
????
?????????????????';
comment on column IF_INV_TRAN_LMS_DETAIL.cost_center
  is '????
????
';
comment on column IF_INV_TRAN_LMS_DETAIL.uda1
  is '????1
????1
';
comment on column IF_INV_TRAN_LMS_DETAIL.uda2
  is '????2
????2
';
comment on column IF_INV_TRAN_LMS_DETAIL.uda3
  is '????3
????3
';
comment on column IF_INV_TRAN_LMS_DETAIL.uda4
  is '????4
????4
';
comment on column IF_INV_TRAN_LMS_DETAIL.uda5
  is '????5
????5
';
create index IDX_IF_INV_TRAN_LMS_DETAIL on IF_INV_TRAN_LMS_DETAIL (BUSINESS_NO, COMP)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_INV_WAREHOUSE
prompt ===============================
prompt
create table IF_INV_WAREHOUSE
(
  id             NUMBER(19) not null,
  comp           VARCHAR2(10) not null,
  warehouse_id   VARCHAR2(20) not null,
  warehouse_name VARCHAR2(150),
  uda1           VARCHAR2(50),
  uda2           VARCHAR2(50),
  uda3           VARCHAR2(50),
  uda4           VARCHAR2(50),
  uda5           VARCHAR2(50),
  deal_flag      NUMBER(1) default 0,
  deal_time      DATE,
  creation_time  DATE default sysdate,
  guid           VARCHAR2(50),
  file_key       VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_INV_WAREHOUSE
  is 'IF_INV_WAREHOUSE????????
IF_INV_WAREHOUSE????????
';
comment on column IF_INV_WAREHOUSE.id
  is 'ID
ID
';
comment on column IF_INV_WAREHOUSE.comp
  is '??
??
';
comment on column IF_INV_WAREHOUSE.warehouse_id
  is '????
????
';
comment on column IF_INV_WAREHOUSE.warehouse_name
  is '????
????
';
comment on column IF_INV_WAREHOUSE.uda1
  is '????1
????1
';
comment on column IF_INV_WAREHOUSE.uda2
  is '????2
????2
';
comment on column IF_INV_WAREHOUSE.uda3
  is '????3
????3
';
comment on column IF_INV_WAREHOUSE.uda4
  is '????4
????4
';
comment on column IF_INV_WAREHOUSE.uda5
  is '????5
????5
';
comment on column IF_INV_WAREHOUSE.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_INV_WAREHOUSE.deal_time
  is '????
????
';
comment on column IF_INV_WAREHOUSE.creation_time
  is '????
????
';
comment on column IF_INV_WAREHOUSE.guid
  is 'GUID
GUID
GUID';
comment on column IF_INV_WAREHOUSE.file_key
  is '????
????
????';
create index IDX_IF_INV_WAREHOUSE1 on IF_INV_WAREHOUSE (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_INV_WAREHOUSE
  add constraint PK_IF_INV_WAREHOUSE primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_JISO_INS
prompt ==========================
prompt
create table IF_JISO_INS
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10),
  ins_no        VARCHAR2(50),
  vin           VARCHAR2(20),
  part_no       VARCHAR2(30),
  part_short_no VARCHAR2(10),
  pass_time     VARCHAR2(50),
  num           VARCHAR2(10),
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate,
  guid          VARCHAR2(50),
  file_key      VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_JISO_INS
  is '同步指示票';
comment on column IF_JISO_INS.id
  is 'ID
ID
';
comment on column IF_JISO_INS.uda1
  is '预留字段1
预留字段1
';
comment on column IF_JISO_INS.uda2
  is '预留字段2
预留字段2
';
comment on column IF_JISO_INS.uda3
  is '预留字段3
预留字段3
';
comment on column IF_JISO_INS.uda4
  is '预留字段4
预留字段4
';
comment on column IF_JISO_INS.uda5
  is '预留字段5
预留字段5
';
comment on column IF_JISO_INS.deal_flag
  is '处理标识
处理标识
0 未处理 1已处理';
comment on column IF_JISO_INS.deal_time
  is '处理时间
处理时间
';
comment on column IF_JISO_INS.creation_time
  is '创建时间
创建时间
';
comment on column IF_JISO_INS.guid
  is 'GUID
GUID
GUID';
comment on column IF_JISO_INS.file_key
  is '文件标识
文件标识
文件标识';

prompt
prompt Creating table IF_KEYPART_BIND
prompt ==============================
prompt
create table IF_KEYPART_BIND
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10) not null,
  order_no      VARCHAR2(50) not null,
  station_code  VARCHAR2(20) not null,
  part_bar_code VARCHAR2(150) not null,
  part_no       VARCHAR2(30),
  bind_num      VARCHAR2(10),
  vin           VARCHAR2(20),
  key_part_type VARCHAR2(10),
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_KEYPART_BIND
  is 'IF_KEYPART_BIND????????????
IF_KEYPART_BIND????????????
';
comment on column IF_KEYPART_BIND.id
  is 'ID
ID
';
comment on column IF_KEYPART_BIND.factory_code
  is '??
??
';
comment on column IF_KEYPART_BIND.order_no
  is '?????
?????
';
comment on column IF_KEYPART_BIND.station_code
  is '????
????
';
comment on column IF_KEYPART_BIND.part_bar_code
  is '???????
???????
?????????????????';
comment on column IF_KEYPART_BIND.part_no
  is '???
???
';
comment on column IF_KEYPART_BIND.bind_num
  is '????
????
???????????????????';
comment on column IF_KEYPART_BIND.vin
  is 'VIN?
VIN?
';
comment on column IF_KEYPART_BIND.key_part_type
  is '?????
?????
1-?????2-????';
comment on column IF_KEYPART_BIND.uda1
  is '????1
????1
';
comment on column IF_KEYPART_BIND.uda2
  is '????2
????2
';
comment on column IF_KEYPART_BIND.uda3
  is '????3
????3
';
comment on column IF_KEYPART_BIND.uda4
  is '????4
????4
';
comment on column IF_KEYPART_BIND.uda5
  is '????5
????5
';
comment on column IF_KEYPART_BIND.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_KEYPART_BIND.deal_time
  is '????
????
';
comment on column IF_KEYPART_BIND.creation_time
  is '????
????
';
create index IDX_IF_KEYPART_BIND1 on IF_KEYPART_BIND (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_KEYPART_BIND
  add constraint PK_IF_KEYPART_BIND primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_LOGISTICS_ORDER
prompt =================================
prompt
create table IF_LOGISTICS_ORDER
(
  logistics_orderno VARCHAR2(50) not null,
  comp              VARCHAR2(10) not null,
  purchase_orderno  VARCHAR2(50),
  order_type        VARCHAR2(10),
  supplier_id       VARCHAR2(20),
  factory_id        VARCHAR2(20),
  assembly_sup      VARCHAR2(20),
  orderissue_date   DATE,
  issue_user        VARCHAR2(30),
  uda1              VARCHAR2(50),
  uda2              VARCHAR2(50),
  uda3              VARCHAR2(50),
  uda4              VARCHAR2(50),
  uda5              VARCHAR2(50),
  deal_flag         NUMBER(1) default 0,
  deal_time         DATE,
  creation_time     DATE default sysdate,
  system_flag       NUMBER(1) default 1
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_LOGISTICS_ORDER
  is 'IF_LOGISTICS_ORDER???????
IF_LOGISTICS_ORDER???????
';
comment on column IF_LOGISTICS_ORDER.logistics_orderno
  is '????
????
';
comment on column IF_LOGISTICS_ORDER.comp
  is '??
??
';
comment on column IF_LOGISTICS_ORDER.purchase_orderno
  is '????
????
?????PDA????????????????????????';
comment on column IF_LOGISTICS_ORDER.order_type
  is '????
????
01:?????02:?????03:????:?04:?????05:??????14??????';
comment on column IF_LOGISTICS_ORDER.supplier_id
  is '?????
?????
';
comment on column IF_LOGISTICS_ORDER.factory_id
  is '????(??????)
????(??????)
';
comment on column IF_LOGISTICS_ORDER.assembly_sup
  is '???????(????)
???????(????)
???????????????????????????????';
comment on column IF_LOGISTICS_ORDER.orderissue_date
  is '??????
??????
??????';
comment on column IF_LOGISTICS_ORDER.issue_user
  is '?????
?????
??';
comment on column IF_LOGISTICS_ORDER.uda1
  is '????1
????1
';
comment on column IF_LOGISTICS_ORDER.uda2
  is '????2
????2
';
comment on column IF_LOGISTICS_ORDER.uda3
  is '????3
????3
';
comment on column IF_LOGISTICS_ORDER.uda4
  is '????4
????4
';
comment on column IF_LOGISTICS_ORDER.uda5
  is '????5
????5
';
comment on column IF_LOGISTICS_ORDER.deal_flag
  is '????
????
0 ??? 1??? 2??';
comment on column IF_LOGISTICS_ORDER.deal_time
  is '????
????
';
comment on column IF_LOGISTICS_ORDER.creation_time
  is '????
????
????';
comment on column IF_LOGISTICS_ORDER.system_flag
  is '????
????
????????1';
create index IDX_IF_LOGISTICS_ORDER1 on IF_LOGISTICS_ORDER (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_LOGISTICS_ORDER
  add constraint PK_IF_LOGISTICS_ORDER primary key (LOGISTICS_ORDERNO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_LOGISTICS_ORDER_DETAIL
prompt ========================================
prompt
create table IF_LOGISTICS_ORDER_DETAIL
(
  logistics_orderno VARCHAR2(50) not null,
  logistics_rowno   VARCHAR2(10) not null,
  purchase_orderno  VARCHAR2(50),
  purchase_row_no   VARCHAR2(10),
  plan_arrive_time  DATE,
  order_depot       VARCHAR2(20),
  part_id           VARCHAR2(30),
  order_num         NUMBER(10),
  part_unit         VARCHAR2(20),
  assembly_flag     VARCHAR2(10),
  lgpbe             VARCHAR2(20),
  zkostl            VARCHAR2(10),
  zbzgg             VARCHAR2(10),
  zstock            VARCHAR2(10),
  uda1              VARCHAR2(50),
  uda2              VARCHAR2(50),
  uda3              VARCHAR2(50),
  uda4              VARCHAR2(50),
  uda5              VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_LOGISTICS_ORDER_DETAIL
  is 'IF_LOGISTICS_ORDER_DETAIL?????????
IF_LOGISTICS_ORDER_DETAIL?????????
';
comment on column IF_LOGISTICS_ORDER_DETAIL.logistics_orderno
  is '????
????
';
comment on column IF_LOGISTICS_ORDER_DETAIL.logistics_rowno
  is '??????
??????
';
comment on column IF_LOGISTICS_ORDER_DETAIL.purchase_orderno
  is '????
????
?????????';
comment on column IF_LOGISTICS_ORDER_DETAIL.purchase_row_no
  is '??????
??????
';
comment on column IF_LOGISTICS_ORDER_DETAIL.plan_arrive_time
  is '??????
??????
????????????';
comment on column IF_LOGISTICS_ORDER_DETAIL.order_depot
  is '????
????
???????????';
comment on column IF_LOGISTICS_ORDER_DETAIL.part_id
  is '????
????
';
comment on column IF_LOGISTICS_ORDER_DETAIL.order_num
  is '????
????
';
comment on column IF_LOGISTICS_ORDER_DETAIL.part_unit
  is '????
????
';
comment on column IF_LOGISTICS_ORDER_DETAIL.assembly_flag
  is '??????
??????
0-????1-?????';
comment on column IF_LOGISTICS_ORDER_DETAIL.lgpbe
  is '?????
?????
????????';
comment on column IF_LOGISTICS_ORDER_DETAIL.zkostl
  is '????(??)
????(??)
????????';
comment on column IF_LOGISTICS_ORDER_DETAIL.zbzgg
  is '????
????
????????';
comment on column IF_LOGISTICS_ORDER_DETAIL.zstock
  is '????
????
????????';
comment on column IF_LOGISTICS_ORDER_DETAIL.uda1
  is '????1
????1
';
comment on column IF_LOGISTICS_ORDER_DETAIL.uda2
  is '????2
????2
';
comment on column IF_LOGISTICS_ORDER_DETAIL.uda3
  is '????3
????3
';
comment on column IF_LOGISTICS_ORDER_DETAIL.uda4
  is '????4
????4
';
comment on column IF_LOGISTICS_ORDER_DETAIL.uda5
  is '????5
????5
';
create index IDX_IF_LOGISTICS_ORDER_DETAIL1 on IF_LOGISTICS_ORDER_DETAIL (LOGISTICS_ORDERNO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_LONG_CYCLE_ORDER
prompt ==================================
prompt
create table IF_LONG_CYCLE_ORDER
(
  id                NUMBER(19) not null,
  version_no        VARCHAR2(30),
  order_no          VARCHAR2(50),
  curr_month        NUMBER(10),
  obj_month         VARCHAR2(30),
  order_period      NUMBER(19),
  obj_period        NUMBER(19),
  obj_first         VARCHAR2(30),
  obj_first_num     NUMBER(19),
  ojb_second        VARCHAR2(30),
  ojb_third         VARCHAR2(30),
  ojb_third_num     NUMBER(19),
  part_no           VARCHAR2(30),
  car_type          VARCHAR2(10),
  supplier_no       VARCHAR2(10),
  sup_factory       VARCHAR2(10),
  reuire_num        NUMBER(19),
  part_unit         VARCHAR2(10),
  order_num         NUMBER(19),
  order_box         NUMBER(19),
  order_require_num NUMBER(19),
  ojb_second_num    NUMBER(19),
  do_flag           VARCHAR2(10),
  uda1              VARCHAR2(50),
  uda2              VARCHAR2(50),
  uda3              VARCHAR2(50),
  uda4              VARCHAR2(50),
  uda5              VARCHAR2(50),
  deal_flag         NUMBER(1) default 0,
  deal_time         DATE,
  creation_time     DATE default sysdate,
  guid              VARCHAR2(50),
  file_key          VARCHAR2(50),
  factory_code      VARCHAR2(10) not null,
  sale_no           VARCHAR2(50),
  sale_row_no       NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_LONG_CYCLE_ORDER
  is '?????';
comment on column IF_LONG_CYCLE_ORDER.id
  is 'ID
ID
';
comment on column IF_LONG_CYCLE_ORDER.version_no
  is '???';
comment on column IF_LONG_CYCLE_ORDER.order_no
  is '???
';
comment on column IF_LONG_CYCLE_ORDER.curr_month
  is '???';
comment on column IF_LONG_CYCLE_ORDER.obj_month
  is '???';
comment on column IF_LONG_CYCLE_ORDER.order_period
  is '????';
comment on column IF_LONG_CYCLE_ORDER.obj_period
  is '????';
comment on column IF_LONG_CYCLE_ORDER.obj_first
  is '?????1';
comment on column IF_LONG_CYCLE_ORDER.obj_first_num
  is '?????1??';
comment on column IF_LONG_CYCLE_ORDER.ojb_second
  is '?????2';
comment on column IF_LONG_CYCLE_ORDER.ojb_third
  is '?????3';
comment on column IF_LONG_CYCLE_ORDER.ojb_third_num
  is '?????3??';
comment on column IF_LONG_CYCLE_ORDER.part_no
  is '???';
comment on column IF_LONG_CYCLE_ORDER.car_type
  is '??';
comment on column IF_LONG_CYCLE_ORDER.supplier_no
  is '?????';
comment on column IF_LONG_CYCLE_ORDER.sup_factory
  is 'ERP?????';
comment on column IF_LONG_CYCLE_ORDER.reuire_num
  is '???';
comment on column IF_LONG_CYCLE_ORDER.part_unit
  is '??';
comment on column IF_LONG_CYCLE_ORDER.order_num
  is '????';
comment on column IF_LONG_CYCLE_ORDER.order_box
  is '????';
comment on column IF_LONG_CYCLE_ORDER.order_require_num
  is '?????';
comment on column IF_LONG_CYCLE_ORDER.ojb_second_num
  is '?????2??';
comment on column IF_LONG_CYCLE_ORDER.do_flag
  is '????';
comment on column IF_LONG_CYCLE_ORDER.uda1
  is '?????NOR ?? SPE ??
????1
';
comment on column IF_LONG_CYCLE_ORDER.uda2
  is '????2
????2
';
comment on column IF_LONG_CYCLE_ORDER.uda3
  is '????3
????3
';
comment on column IF_LONG_CYCLE_ORDER.uda4
  is '????4
????4
';
comment on column IF_LONG_CYCLE_ORDER.uda5
  is '????5
????5
';
comment on column IF_LONG_CYCLE_ORDER.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_LONG_CYCLE_ORDER.deal_time
  is '????
????
';
comment on column IF_LONG_CYCLE_ORDER.creation_time
  is '????
????
????';
comment on column IF_LONG_CYCLE_ORDER.guid
  is 'GUID
GUID
GUID';
comment on column IF_LONG_CYCLE_ORDER.file_key
  is '????
????
????';
comment on column IF_LONG_CYCLE_ORDER.factory_code
  is '??
??
';
create index IDX_MM_LONG_CYCLE_ORDER on IF_LONG_CYCLE_ORDER (DEAL_FLAG)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table IF_LONG_CYCLE_ORDER_DETAIL
prompt =========================================
prompt
create table IF_LONG_CYCLE_ORDER_DETAIL
(
  id            NUMBER(19),
  sale_no       VARCHAR2(50),
  sale_row_no   NUMBER(10),
  part_no       VARCHAR2(30),
  feature       VARCHAR2(10),
  feature_type  VARCHAR2(2),
  feature_value VARCHAR2(500),
  sort_no       NUMBER(5),
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column IF_LONG_CYCLE_ORDER_DETAIL.uda1
  is '????1
????1
';
comment on column IF_LONG_CYCLE_ORDER_DETAIL.uda2
  is '????2
????2
';
comment on column IF_LONG_CYCLE_ORDER_DETAIL.uda3
  is '????3
????3
';
comment on column IF_LONG_CYCLE_ORDER_DETAIL.uda4
  is '????4
????4
';
comment on column IF_LONG_CYCLE_ORDER_DETAIL.uda5
  is '????5
????5
';

prompt
prompt Creating table IF_MM_INV_PART_LOCATION
prompt ======================================
prompt
create table IF_MM_INV_PART_LOCATION
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  part_no            VARCHAR2(20),
  supplier_no        VARCHAR2(20),
  ware_code          VARCHAR2(20),
  station_code       VARCHAR2(20),
  unload_port        VARCHAR2(20),
  dep_no             VARCHAR2(20),
  prepare_person     VARCHAR2(20),
  carpool            VARCHAR2(20),
  distri_person      VARCHAR2(100),
  location           VARCHAR2(50),
  shelf_no           VARCHAR2(20),
  location_num       NUMBER(10),
  model_code         VARCHAR2(10),
  storage            VARCHAR2(100),
  eff_start          DATE,
  eff_end            DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default SYSDATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE default SYSDATE,
  workcenter         VARCHAR2(20),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  guid               VARCHAR2(50),
  uda1               VARCHAR2(50),
  uda2               VARCHAR2(50),
  uda3               VARCHAR2(50),
  uda4               VARCHAR2(50),
  uda5               VARCHAR2(50),
  do_flag            VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_MM_INV_PART_LOCATION
  is 'IF_MM_INV_PART_LOCATION??????
IF_MM_INV_PART_LOCATION??????
';
comment on column IF_MM_INV_PART_LOCATION.id
  is 'ID
ID
';
comment on column IF_MM_INV_PART_LOCATION.factory_code
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.part_no
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.supplier_no
  is '?????
?????
';
comment on column IF_MM_INV_PART_LOCATION.ware_code
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.station_code
  is '???
???
';
comment on column IF_MM_INV_PART_LOCATION.unload_port
  is '???
???
';
comment on column IF_MM_INV_PART_LOCATION.dep_no
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.prepare_person
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.carpool
  is '???
???
';
comment on column IF_MM_INV_PART_LOCATION.distri_person
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.location
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.shelf_no
  is '???
???
';
comment on column IF_MM_INV_PART_LOCATION.location_num
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.model_code
  is '??
??
';
comment on column IF_MM_INV_PART_LOCATION.storage
  is '?????
?????
';
comment on column IF_MM_INV_PART_LOCATION.eff_start
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.eff_end
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.creation_user
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.creation_time
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.last_modified_user
  is '??????
??????
';
comment on column IF_MM_INV_PART_LOCATION.last_modified_time
  is '??????
??????
';
comment on column IF_MM_INV_PART_LOCATION.workcenter
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_MM_INV_PART_LOCATION.deal_time
  is '????
????
';
comment on column IF_MM_INV_PART_LOCATION.guid
  is 'GUID
GUID
GUID';
comment on column IF_MM_INV_PART_LOCATION.uda1
  is '????1
????1
';
comment on column IF_MM_INV_PART_LOCATION.uda2
  is '????2
????2
';
comment on column IF_MM_INV_PART_LOCATION.uda3
  is '????3
????3
';
comment on column IF_MM_INV_PART_LOCATION.uda4
  is '????4
????4
';
comment on column IF_MM_INV_PART_LOCATION.uda5
  is '????5
????5
';
comment on column IF_MM_INV_PART_LOCATION.do_flag
  is '????
????
I-???U-???D-??';

prompt
prompt Creating table IF_MM_JISO_INS
prompt =============================
prompt
create table IF_MM_JISO_INS
(
  ins_no                 VARCHAR2(50) not null,
  plan_code              VARCHAR2(20) not null,
  partgroup_no           VARCHAR2(20) not null,
  arr_depot              VARCHAR2(20) not null,
  sup_factory            VARCHAR2(20) not null,
  ins_partgroup_seqno    VARCHAR2(30),
  ins_supfactory_seqno   VARCHAR2(30),
  partgroup_name         VARCHAR2(100),
  order_flg              NUMBER(1),
  gen_ins_way            NUMBER(1),
  supplier_no            VARCHAR2(20),
  supplier_name          VARCHAR2(150),
  route_code             VARCHAR2(20),
  route_desc             VARCHAR2(100),
  car_batch              NUMBER(5),
  car_batch_seqno        NUMBER(19),
  location               VARCHAR2(20),
  distri_person          VARCHAR2(30),
  prepare_product_seqno  NUMBER(19),
  dispatch_product_seqno NUMBER(19),
  delivery_product_seqno NUMBER(19),
  arrive_product_seqno   NUMBER(19),
  distri_product_seqno   NUMBER(19),
  prepare_time           DATE,
  dispatch_time          DATE,
  delivery_time          DATE,
  arrive_time            DATE,
  distri_time            DATE,
  use_location_num       VARCHAR2(10),
  arrive_batch_no        NUMBER(5),
  is_manu_deal           NUMBER(1) default 0,
  manu_req_time          DATE,
  manu_req_user          VARCHAR2(30),
  manu_req_ip            VARCHAR2(30),
  print_status           NUMBER(1) default 0,
  print_time             DATE,
  print_user             VARCHAR2(30),
  print_user_ip          VARCHAR2(30),
  creation_time          DATE default SYSDATE,
  order_no               VARCHAR2(50),
  order_deal_flag        NUMBER(1) default 0,
  order_deal_time        DATE,
  deal_flag              NUMBER(1) default 0,
  deal_time              DATE,
  if_code                VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table IF_MM_JISO_INS_DETAIL
prompt ====================================
prompt
create table IF_MM_JISO_INS_DETAIL
(
  ins_no             VARCHAR2(50),
  order_no           VARCHAR2(50),
  sale_no            VARCHAR2(50),
  sale_rowno         NUMBER(10),
  part_no            VARCHAR2(40),
  require_num        NUMBER(10),
  part_short_no      VARCHAR2(10),
  part_name          VARCHAR2(150),
  part_mark          VARCHAR2(20),
  remark_flag        VARCHAR2(2),
  vin                VARCHAR2(20),
  model_code         VARCHAR2(20),
  phase              VARCHAR2(20),
  pass_time          DATE,
  wc_seqno           VARCHAR2(10),
  pl_seqno           VARCHAR2(20),
  kb_product_seqno   NUMBER(19),
  kb_time            DATE,
  creation_time      DATE default SYSDATE,
  last_modified_time DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 8K
    minextents 1
    maxextents unlimited
  );
comment on table IF_MM_JISO_INS_DETAIL
  is '同步指示票明细';
comment on column IF_MM_JISO_INS_DETAIL.remark_flag
  is '"0：未切换
1：已切换"';

prompt
prompt Creating table IF_MM_PKG_BOX
prompt ============================
prompt
create table IF_MM_PKG_BOX
(
  id                 NUMBER(19) not null,
  box_code           VARCHAR2(30),
  box_type           NUMBER(2),
  pack_length        NUMBER(19,3),
  pack_width         NUMBER(19,3),
  pack_height        NUMBER(19,3),
  status             NUMBER(2) default 0,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  factory_code       VARCHAR2(10),
  do_flag            VARCHAR2(10),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_MM_PKG_BOX
  is 'IF_MM_PKG_BOX?????
IF_MM_PKG_BOX?????
';
comment on column IF_MM_PKG_BOX.id
  is 'ID
ID
';
comment on column IF_MM_PKG_BOX.box_code
  is '????
????
?code';
comment on column IF_MM_PKG_BOX.box_type
  is '????
????
1-??
2-EU?
3-???
4-??';
comment on column IF_MM_PKG_BOX.pack_length
  is '???
???
???';
comment on column IF_MM_PKG_BOX.pack_width
  is '???
???
???';
comment on column IF_MM_PKG_BOX.pack_height
  is '???
???
???';
comment on column IF_MM_PKG_BOX.status
  is '??
??
0-??
1-??';
comment on column IF_MM_PKG_BOX.creation_user
  is '???
???
';
comment on column IF_MM_PKG_BOX.creation_time
  is '????
????
';
comment on column IF_MM_PKG_BOX.last_modified_user
  is '??????
??????
';
comment on column IF_MM_PKG_BOX.last_modified_time
  is '??????
??????
';
comment on column IF_MM_PKG_BOX.factory_code
  is '????
????
';
comment on column IF_MM_PKG_BOX.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_MM_PKG_BOX.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_MM_PKG_BOX.deal_time
  is '????
????
';
create index IDX_IF_MM_PKG_BOX1 on IF_MM_PKG_BOX (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_MM_PKG_BOX
  add constraint PK_IF_MM_PKG_BOX primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_MM_PKG_BOX_QTY
prompt ================================
prompt
create table IF_MM_PKG_BOX_QTY
(
  id                 NUMBER(19) not null,
  proposal_id        NUMBER(19),
  provide_qty        NUMBER(10),
  box_require_qty    NUMBER(10),
  hair_note_model    VARCHAR2(50),
  plan_date          DATE,
  delay_reason       VARCHAR2(300),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  factory_code       VARCHAR2(10),
  do_flag            VARCHAR2(10),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_MM_PKG_BOX_QTY
  is 'IF_MM_PKG_BOX_QTY?????????
IF_MM_PKG_BOX_QTY?????????
';
comment on column IF_MM_PKG_BOX_QTY.id
  is 'ID
ID
';
comment on column IF_MM_PKG_BOX_QTY.proposal_id
  is '????ID
????ID
';
comment on column IF_MM_PKG_BOX_QTY.provide_qty
  is '????
????
????';
comment on column IF_MM_PKG_BOX_QTY.box_require_qty
  is '?????
?????
?????';
comment on column IF_MM_PKG_BOX_QTY.hair_note_model
  is '????
????
????';
comment on column IF_MM_PKG_BOX_QTY.plan_date
  is '??????
??????
??????';
comment on column IF_MM_PKG_BOX_QTY.delay_reason
  is '????
????
????';
comment on column IF_MM_PKG_BOX_QTY.creation_user
  is '???
???
';
comment on column IF_MM_PKG_BOX_QTY.creation_time
  is '????
????
';
comment on column IF_MM_PKG_BOX_QTY.last_modified_user
  is '??????
??????
';
comment on column IF_MM_PKG_BOX_QTY.last_modified_time
  is '??????
??????
';
comment on column IF_MM_PKG_BOX_QTY.factory_code
  is '????
????
';
comment on column IF_MM_PKG_BOX_QTY.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_MM_PKG_BOX_QTY.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_MM_PKG_BOX_QTY.deal_time
  is '????
????
';
create index IDX_IF_MM_PKG_BOX_QTY1 on IF_MM_PKG_BOX_QTY (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_MM_PKG_BOX_QTY
  add constraint PK_IF_MM_PKG_BOX_QTY primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_MM_PKG_PART
prompt =============================
prompt
create table IF_MM_PKG_PART
(
  id                 NUMBER(19) not null,
  car_type           VARCHAR2(20),
  project            VARCHAR2(50),
  part_no            VARCHAR2(20),
  part_resp_user     VARCHAR2(30),
  supplier_no        VARCHAR2(20),
  status             NUMBER(1),
  creation_user      VARCHAR2(30),
  creation_time      DATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  factory_code       VARCHAR2(10),
  purchase_type      VARCHAR2(10),
  email_flag         NUMBER(1),
  do_flag            VARCHAR2(10),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_MM_PKG_PART
  is 'IF_MM_PKG_PART?????????
IF_MM_PKG_PART?????????
';
comment on column IF_MM_PKG_PART.id
  is 'ID
ID
';
comment on column IF_MM_PKG_PART.car_type
  is '??
??
';
comment on column IF_MM_PKG_PART.project
  is '??
??
';
comment on column IF_MM_PKG_PART.part_no
  is '????
????
';
comment on column IF_MM_PKG_PART.part_resp_user
  is '????
????
';
comment on column IF_MM_PKG_PART.supplier_no
  is '?????
?????
';
comment on column IF_MM_PKG_PART.status
  is '??????
??????
0??? 1???';
comment on column IF_MM_PKG_PART.creation_user
  is '???
???
';
comment on column IF_MM_PKG_PART.creation_time
  is '????
????
';
comment on column IF_MM_PKG_PART.last_modified_user
  is '?????
?????
';
comment on column IF_MM_PKG_PART.last_modified_time
  is '??????
??????
';
comment on column IF_MM_PKG_PART.factory_code
  is '??
??
';
comment on column IF_MM_PKG_PART.purchase_type
  is '????
????
';
comment on column IF_MM_PKG_PART.email_flag
  is '???????
???????
';
comment on column IF_MM_PKG_PART.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_MM_PKG_PART.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_MM_PKG_PART.deal_time
  is '????
????
';
create index IDX_IF_MM_PKG_PART1 on IF_MM_PKG_PART (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_MM_PKG_PART
  add constraint PK_IF_MM_PKG_PART primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_MM_PKG_PROPOSAL
prompt =================================
prompt
create table IF_MM_PKG_PROPOSAL
(
  id                 NUMBER(19) not null,
  car_type           VARCHAR2(20),
  supplier_no        VARCHAR2(20),
  part_no            VARCHAR2(20),
  proposal_status    NUMBER(1) default 0,
  pack_type          NUMBER(1),
  box_type           NUMBER(2),
  reply_limit_date   DATE,
  is_com_pack        NUMBER(1),
  status             NUMBER(1),
  sign_pro_file      NUMBER(19),
  eff_start          DATE,
  eff_end            DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  factory_code       VARCHAR2(10),
  part_resp_user     VARCHAR2(30),
  project            VARCHAR2(50),
  purchase_type      VARCHAR2(10),
  is_show_change     NUMBER(1),
  com_pack_remark    VARCHAR2(100),
  do_flag            VARCHAR2(10),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_MM_PKG_PROPOSAL
  is 'IF_MM_PKG_PROPOSAL?????
IF_MM_PKG_PROPOSAL?????
';
comment on column IF_MM_PKG_PROPOSAL.id
  is 'ID
ID
';
comment on column IF_MM_PKG_PROPOSAL.car_type
  is '??
??
??';
comment on column IF_MM_PKG_PROPOSAL.supplier_no
  is '?????
?????
?????';
comment on column IF_MM_PKG_PROPOSAL.part_no
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL.proposal_status
  is '????
????
0-???
1-????
2-???
3-????
4-?????
5-????
6-?????
7-??';
comment on column IF_MM_PKG_PROPOSAL.pack_type
  is '????
????
0-???
1-??';
comment on column IF_MM_PKG_PROPOSAL.box_type
  is '????
????
0??? 1??? 2?EU? 3???';
comment on column IF_MM_PKG_PROPOSAL.reply_limit_date
  is '??????
??????
????';
comment on column IF_MM_PKG_PROPOSAL.is_com_pack
  is '??????
??????
0-?
1-?';
comment on column IF_MM_PKG_PROPOSAL.status
  is '??????
??????
1-??
2-??';
comment on column IF_MM_PKG_PROPOSAL.sign_pro_file
  is '??????(FTP??ID)
??????(FTP??ID)
';
comment on column IF_MM_PKG_PROPOSAL.eff_start
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL.eff_end
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL.creation_user
  is '???
???
';
comment on column IF_MM_PKG_PROPOSAL.creation_time
  is '????
????
';
comment on column IF_MM_PKG_PROPOSAL.last_modified_user
  is '??????
??????
';
comment on column IF_MM_PKG_PROPOSAL.last_modified_time
  is '??????
??????
';
comment on column IF_MM_PKG_PROPOSAL.factory_code
  is '????
????
';
comment on column IF_MM_PKG_PROPOSAL.part_resp_user
  is '????
????
';
comment on column IF_MM_PKG_PROPOSAL.project
  is '??
??
';
comment on column IF_MM_PKG_PROPOSAL.purchase_type
  is '????
????
';
comment on column IF_MM_PKG_PROPOSAL.is_show_change
  is '?????????
?????????
';
comment on column IF_MM_PKG_PROPOSAL.com_pack_remark
  is '??????
??????
';
comment on column IF_MM_PKG_PROPOSAL.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_MM_PKG_PROPOSAL.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_MM_PKG_PROPOSAL.deal_time
  is '????
????
';
create index IDX_IF_MM_PKG_PROPOSAL1 on IF_MM_PKG_PROPOSAL (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_MM_PKG_PROPOSAL
  add constraint PK_IF_MM_PKG_PROPOSAL primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_MM_PKG_PROPOSAL_DETAIL
prompt ========================================
prompt
create table IF_MM_PKG_PROPOSAL_DETAIL
(
  id                    NUMBER(19) not null,
  proposal_id           NUMBER(19),
  group_no              VARCHAR2(30),
  max_package_num       NUMBER(10),
  standard_package      NUMBER(10),
  part_weight           NUMBER(10,3),
  part_total_weight     NUMBER(10,3),
  pack_weight           NUMBER(10,3),
  part_length           NUMBER(10,3),
  part_width            NUMBER(10,3),
  part_height           NUMBER(10,3),
  empty_trolley_length  NUMBER(10,3),
  empty_trolley_width   NUMBER(10,3),
  empty_trolley_height  NUMBER(10,3),
  real_trolley_length   NUMBER(10,3),
  real_trolley_width    NUMBER(10,3),
  real_trolley_height   NUMBER(10,3),
  trolley_weight        NUMBER(10,3),
  total_weight          NUMBER(10,3),
  is_trolley_code       NUMBER(1),
  is_positioner         NUMBER(1),
  dust_cover            NUMBER(1),
  one_by_package        NUMBER(1),
  board_location        VARCHAR2(10),
  wheel_diameter        NUMBER(10,3),
  word_desc             VARCHAR2(600),
  traction_rod_height   NUMBER(10,3),
  important_postion_pic NUMBER(19),
  empty_tro_front_pic   VARCHAR2(50),
  empty_tro_side_pic    VARCHAR2(50),
  real_tro_pic          VARCHAR2(50),
  box_code              VARCHAR2(20),
  pack_length           NUMBER(10,3),
  pack_width            NUMBER(10,3),
  pack_height           NUMBER(10,3),
  tray_length           NUMBER(10,3),
  tray_width            NUMBER(10,3),
  tray_height           NUMBER(10,3),
  work_require          VARCHAR2(500),
  single_part_pic       NUMBER(19),
  single_part_put_pic   NUMBER(19),
  pack_over_look_pic    NUMBER(19),
  pack_side_look_pic    NUMBER(19),
  creation_user         VARCHAR2(30),
  creation_time         DATE default sysdate,
  last_modified_user    VARCHAR2(30),
  last_modified_time    DATE,
  factory_code          VARCHAR2(10),
  sup_name              VARCHAR2(30),
  mobile                VARCHAR2(30),
  mail                  VARCHAR2(30),
  do_flag               VARCHAR2(10),
  deal_flag             NUMBER(1) default 0,
  deal_time             DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_MM_PKG_PROPOSAL_DETAIL
  is 'IF_MM_PKG_PROPOSAL_DETAIL???????
IF_MM_PKG_PROPOSAL_DETAIL???????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.id
  is 'ID
ID
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.proposal_id
  is '????ID
????ID
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.group_no
  is '??
??
??';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.max_package_num
  is '?????
?????
?????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.standard_package
  is '?????
?????
?????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.part_weight
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.part_total_weight
  is '?????
?????
?????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.pack_weight
  is '????
????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.part_length
  is '???
???
???';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.part_width
  is '???
???
???';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.part_height
  is '???
???
???';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.empty_trolley_length
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.empty_trolley_width
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.empty_trolley_height
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.real_trolley_length
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.real_trolley_width
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.real_trolley_height
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.trolley_weight
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.total_weight
  is '???
???
???';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.is_trolley_code
  is '??????
??????
0-?
1-?';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.is_positioner
  is '?????
?????
0-?
1-?';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.dust_cover
  is '?????
?????
0-?
1-?';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.one_by_package
  is '??????
??????
0-?
1-?';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.board_location
  is '????
????
L  / W';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.wheel_diameter
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.word_desc
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.traction_rod_height
  is '??????
??????
??????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.important_postion_pic
  is '?????(FTP??ID)
?????(FTP??ID)
?????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.empty_tro_front_pic
  is '??????
??????
??????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.empty_tro_side_pic
  is '??????
??????
??????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.real_tro_pic
  is '????
????
????';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.box_code
  is '????
????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.pack_length
  is '???
???
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.pack_width
  is '???
???
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.pack_height
  is '???
???
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.tray_length
  is '?????
?????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.tray_width
  is '?????
?????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.tray_height
  is '?????
?????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.work_require
  is '????
????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.single_part_pic
  is '?????(FTP??ID)
?????(FTP??ID)
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.single_part_put_pic
  is '???????
???????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.pack_over_look_pic
  is '?????
?????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.pack_side_look_pic
  is '?????
?????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.creation_user
  is '???
???
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.creation_time
  is '????
????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.last_modified_user
  is '??????
??????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.last_modified_time
  is '??????
??????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.factory_code
  is '????
????
';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_MM_PKG_PROPOSAL_DETAIL.deal_time
  is '????
????
';
create index IDX_IF_MM_PKG_PROPOSAL_DETAIL1 on IF_MM_PKG_PROPOSAL_DETAIL (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_MM_PKG_PROPOSAL_DETAIL
  add constraint PK_IF_MM_PKG_PROPOSAL_DETAIL primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_MM_PKG_TRAY_QTY
prompt =================================
prompt
create table IF_MM_PKG_TRAY_QTY
(
  id                 NUMBER(19) not null,
  car_type           VARCHAR2(20),
  supplier_no        VARCHAR2(20),
  provide_qty        NUMBER(10),
  tray_require_qty   NUMBER(10),
  plan_date          DATE,
  delay_reason       VARCHAR2(300),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  factory_code       VARCHAR2(10),
  do_flag            VARCHAR2(10),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_MM_PKG_TRAY_QTY
  is 'IF_MM_PKG_TRAY_QTY?????????
IF_MM_PKG_TRAY_QTY?????????
';
comment on column IF_MM_PKG_TRAY_QTY.id
  is 'ID
ID
';
comment on column IF_MM_PKG_TRAY_QTY.car_type
  is '??
??
??';
comment on column IF_MM_PKG_TRAY_QTY.supplier_no
  is '?????
?????
?????';
comment on column IF_MM_PKG_TRAY_QTY.provide_qty
  is '????
????
????';
comment on column IF_MM_PKG_TRAY_QTY.tray_require_qty
  is '?????
?????
?????';
comment on column IF_MM_PKG_TRAY_QTY.plan_date
  is '??????
??????
??????';
comment on column IF_MM_PKG_TRAY_QTY.delay_reason
  is '????
????
????';
comment on column IF_MM_PKG_TRAY_QTY.creation_user
  is '???
???
';
comment on column IF_MM_PKG_TRAY_QTY.creation_time
  is '????
????
';
comment on column IF_MM_PKG_TRAY_QTY.last_modified_user
  is '??????
??????
';
comment on column IF_MM_PKG_TRAY_QTY.last_modified_time
  is '??????
??????
';
comment on column IF_MM_PKG_TRAY_QTY.factory_code
  is '????
????
';
comment on column IF_MM_PKG_TRAY_QTY.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_MM_PKG_TRAY_QTY.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_MM_PKG_TRAY_QTY.deal_time
  is '????
????
';
create index IDX_IF_MM_PKG_TRAY_QTY1 on IF_MM_PKG_TRAY_QTY (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_MM_PKG_TRAY_QTY
  add constraint PK_IF_MM_PKG_TRAY_QTY primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_MM_PUB_PART_UDA
prompt =================================
prompt
create table IF_MM_PUB_PART_UDA
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  part_no            VARCHAR2(30),
  supplier_no        VARCHAR2(10),
  sup_factory        VARCHAR2(10),
  part_short_no      VARCHAR2(10),
  part_name_cn       VARCHAR2(100),
  supplier_name      VARCHAR2(100),
  standard_package   NUMBER(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  guid               VARCHAR2(50),
  uda1               VARCHAR2(50),
  uda2               VARCHAR2(50),
  uda3               VARCHAR2(50),
  uda4               VARCHAR2(50),
  uda5               VARCHAR2(50),
  do_flag            VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_MM_PUB_PART_UDA
  is 'IF_MM_PUB_PART_UDA ??????
IF_MM_PUB_PART_UDA ??????
';
comment on column IF_MM_PUB_PART_UDA.id
  is 'ID
ID
';
comment on column IF_MM_PUB_PART_UDA.factory_code
  is '??
??
';
comment on column IF_MM_PUB_PART_UDA.part_no
  is '????
????
';
comment on column IF_MM_PUB_PART_UDA.supplier_no
  is '?????
?????
';
comment on column IF_MM_PUB_PART_UDA.sup_factory
  is '??????
??????
';
comment on column IF_MM_PUB_PART_UDA.part_short_no
  is '????
????
';
comment on column IF_MM_PUB_PART_UDA.part_name_cn
  is '????
????
';
comment on column IF_MM_PUB_PART_UDA.supplier_name
  is '?????
?????
';
comment on column IF_MM_PUB_PART_UDA.standard_package
  is '?????
?????
';
comment on column IF_MM_PUB_PART_UDA.creation_user
  is '???
???
';
comment on column IF_MM_PUB_PART_UDA.creation_time
  is '????
????
';
comment on column IF_MM_PUB_PART_UDA.last_modified_user
  is '??????
??????
';
comment on column IF_MM_PUB_PART_UDA.last_modified_time
  is '??????
??????
';
comment on column IF_MM_PUB_PART_UDA.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_MM_PUB_PART_UDA.deal_time
  is '????
????
';
comment on column IF_MM_PUB_PART_UDA.guid
  is 'GUID
GUID
GUID';
comment on column IF_MM_PUB_PART_UDA.uda1
  is '????1
????1
';
comment on column IF_MM_PUB_PART_UDA.uda2
  is '????2
????2
';
comment on column IF_MM_PUB_PART_UDA.uda3
  is '????3
????3
';
comment on column IF_MM_PUB_PART_UDA.uda4
  is '????4
????4
';
comment on column IF_MM_PUB_PART_UDA.uda5
  is '????5
????5
';
comment on column IF_MM_PUB_PART_UDA.do_flag
  is '????
????
I-???U-???D-??';
create index IDX_IF_MM_PUB_PART_UDA on IF_MM_PUB_PART_UDA (FACTORY_CODE, PART_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_IF_MM_PUB_PART_UDA_1 on IF_MM_PUB_PART_UDA (DO_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_MM_PUB_PART_UDA
  add constraint PK_IF_MM_PUB_PART_UDA primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_MM_PUB_SUPPLIER
prompt =================================
prompt
create table IF_MM_PUB_SUPPLIER
(
  id                        NUMBER(19) not null,
  sup_factory               VARCHAR2(10) not null,
  supplier_no               VARCHAR2(10),
  supplier_name             VARCHAR2(150),
  sup_factory_addr          VARCHAR2(200),
  detail_addr               VARCHAR2(200),
  sup_status                VARCHAR2(10),
  email                     VARCHAR2(50),
  contact                   VARCHAR2(30),
  mobile_no                 VARCHAR2(30),
  tel_no                    VARCHAR2(30),
  creation_time             DATE default sysdate,
  last_modified_time        DATE,
  blong_area                VARCHAR2(50),
  sup_leader_name           VARCHAR2(30),
  sup_leader_tel            VARCHAR2(30),
  sup_leader_mail           VARCHAR2(100),
  order_contact             VARCHAR2(30),
  order_tel                 VARCHAR2(30),
  order_mail                VARCHAR2(100),
  deliv_contact             VARCHAR2(30),
  delivery_tel              VARCHAR2(30),
  delivery_mail             VARCHAR2(100),
  excep_contact             VARCHAR2(30),
  excep_tel                 VARCHAR2(30),
  excep_mail                VARCHAR2(100),
  pack_dept_name            VARCHAR2(60),
  pack_dept_tel             VARCHAR2(30),
  pack_dept_mail            VARCHAR2(100),
  pack_dept_contact         VARCHAR2(30),
  pack_dept_chief           VARCHAR2(30),
  pack_dept_minister        VARCHAR2(30),
  import_dep                VARCHAR2(60),
  import_position           VARCHAR2(50),
  import_name               VARCHAR2(30),
  import_mobile             VARCHAR2(30),
  import_tel                VARCHAR2(30),
  import_mail               VARCHAR2(50),
  pt_dep                    VARCHAR2(60),
  pt_position               VARCHAR2(50),
  pt_name                   VARCHAR2(30),
  pt_mobile                 VARCHAR2(30),
  pt_tel                    VARCHAR2(30),
  pt_mail                   VARCHAR2(50),
  mass_dep                  VARCHAR2(60),
  mass_position             VARCHAR2(50),
  mass_name                 VARCHAR2(30),
  mass_mobile               VARCHAR2(30),
  mass_tel                  VARCHAR2(30),
  mass_mail                 VARCHAR2(50),
  excep_dep_a               VARCHAR2(60),
  excep_dep_b               VARCHAR2(50),
  excep_position_a          VARCHAR2(50),
  excep_position_b          VARCHAR2(50),
  excep_name_a              VARCHAR2(30),
  excep_name_b              VARCHAR2(30),
  excep_mobile_a            VARCHAR2(30),
  excep_mobile_b            VARCHAR2(30),
  excep_tel_a               VARCHAR2(30),
  excep_tel_b               VARCHAR2(30),
  excep_mail_a              VARCHAR2(50),
  excep_mail_b              VARCHAR2(50),
  device_dep                VARCHAR2(60),
  device_position           VARCHAR2(30),
  device_name               VARCHAR2(30),
  device_mobile             VARCHAR2(30),
  device_tel                VARCHAR2(30),
  device_mail               VARCHAR2(50),
  import_dep_a              VARCHAR2(50),
  import_position_a         VARCHAR2(30),
  import_name_a             VARCHAR2(30),
  import_mobile_a           VARCHAR2(30),
  import_tel_a              VARCHAR2(30),
  import_mail_a             VARCHAR2(50),
  pt_dep_a                  VARCHAR2(60),
  pt_position_a             VARCHAR2(30),
  pt_name_a                 VARCHAR2(30),
  pt_mobil_a                VARCHAR2(30),
  pt_tel_a                  VARCHAR2(30),
  pt_mail_a                 VARCHAR2(50),
  mass_dep_a                VARCHAR2(60),
  mass_position_a           VARCHAR2(30),
  mass_name_a               VARCHAR2(30),
  mass_mobile_a             VARCHAR2(30),
  mass_tel_a                VARCHAR2(30),
  mass_mail_a               VARCHAR2(50),
  device_dep_a              VARCHAR2(60),
  device_position_a         VARCHAR2(30),
  device_name_a             VARCHAR2(30),
  device_mobile_a           VARCHAR2(30),
  device_tel_a              VARCHAR2(30),
  device_mail_a             VARCHAR2(50),
  pack_dep_a                VARCHAR2(60),
  pack_position_a           VARCHAR2(30),
  pack_name_a               VARCHAR2(30),
  pack_mobile_a             VARCHAR2(30),
  pack_tel_a                VARCHAR2(30),
  pack_mail_a               VARCHAR2(50),
  pack_dep_b                VARCHAR2(60),
  pack_position_b           VARCHAR2(30),
  pack_name_b               VARCHAR2(30),
  pack_mobile_b             VARCHAR2(30),
  pack_tel_b                VARCHAR2(30),
  pack_mail_b               VARCHAR2(50),
  pt_logistics_dep          VARCHAR2(60),
  pt_logistics_name         VARCHAR2(30),
  pt_logistics_position     VARCHAR2(30),
  pt_logistics_mobile       VARCHAR2(30),
  pt_logistics_tel          VARCHAR2(30),
  pt_logistics_mail         VARCHAR2(50),
  pt_logistics_dep_a        VARCHAR2(60),
  pt_logistics_name_a       VARCHAR2(30),
  pt_logistics_position_a   VARCHAR2(30),
  pt_logistics_mobile_a     VARCHAR2(30),
  pt_logistics_tel_a        VARCHAR2(30),
  pt_logistics_mail_a       VARCHAR2(50),
  mass_logistics_dep        VARCHAR2(60),
  mass_logistics_position   VARCHAR2(30),
  mass_logistics_name       VARCHAR2(30),
  mass_logistics_mobile     VARCHAR2(30),
  mass_logistics_tel        VARCHAR2(30),
  mass_logistics_mail       VARCHAR2(50),
  mass_logistics_dep_a      VARCHAR2(60),
  mass_logistics_position_a VARCHAR2(30),
  mass_logistics_name_a     VARCHAR2(30),
  mass_logistics_mobile_a   VARCHAR2(30),
  mass_logistics_tel_a      VARCHAR2(30),
  mass_logistics_mail_a     VARCHAR2(50),
  deal_flag                 NUMBER(1) default 0,
  deal_time                 DATE,
  do_flag                   VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_MM_PUB_SUPPLIER
  is 'IF_MM_PUB_SUPPLIER?????????
IF_MM_PUB_SUPPLIER?????????
';
comment on column IF_MM_PUB_SUPPLIER.id
  is 'ID
ID
';
comment on column IF_MM_PUB_SUPPLIER.sup_factory
  is '??????
??????
???????';
comment on column IF_MM_PUB_SUPPLIER.supplier_no
  is '?????
?????
';
comment on column IF_MM_PUB_SUPPLIER.supplier_name
  is '??????
??????
';
comment on column IF_MM_PUB_SUPPLIER.sup_factory_addr
  is '?????
?????
';
comment on column IF_MM_PUB_SUPPLIER.detail_addr
  is '???????
???????
';
comment on column IF_MM_PUB_SUPPLIER.sup_status
  is '?????
?????
1????2????3???';
comment on column IF_MM_PUB_SUPPLIER.email
  is '????
????
';
comment on column IF_MM_PUB_SUPPLIER.contact
  is '???
???
';
comment on column IF_MM_PUB_SUPPLIER.mobile_no
  is '???????
???????
';
comment on column IF_MM_PUB_SUPPLIER.tel_no
  is '?????
?????
';
comment on column IF_MM_PUB_SUPPLIER.creation_time
  is '????
????
';
comment on column IF_MM_PUB_SUPPLIER.last_modified_time
  is '??????
??????
';
comment on column IF_MM_PUB_SUPPLIER.blong_area
  is '????
????
????';
comment on column IF_MM_PUB_SUPPLIER.sup_leader_name
  is '????????
????????
????????';
comment on column IF_MM_PUB_SUPPLIER.sup_leader_tel
  is '???????
???????
???????';
comment on column IF_MM_PUB_SUPPLIER.sup_leader_mail
  is '???????
???????
???????';
comment on column IF_MM_PUB_SUPPLIER.order_contact
  is '?????
?????
?????';
comment on column IF_MM_PUB_SUPPLIER.order_tel
  is '??????
??????
??????';
comment on column IF_MM_PUB_SUPPLIER.order_mail
  is '??????
??????
??????';
comment on column IF_MM_PUB_SUPPLIER.deliv_contact
  is '?????
?????
?????';
comment on column IF_MM_PUB_SUPPLIER.delivery_tel
  is '???????
???????
???????';
comment on column IF_MM_PUB_SUPPLIER.delivery_mail
  is '???????
???????
???????';
comment on column IF_MM_PUB_SUPPLIER.excep_contact
  is '???????
???????
???????';
comment on column IF_MM_PUB_SUPPLIER.excep_tel
  is '????????
????????
????????';
comment on column IF_MM_PUB_SUPPLIER.excep_mail
  is '????????
????????
????????';
comment on column IF_MM_PUB_SUPPLIER.pack_dept_name
  is '??????
??????
??????';
comment on column IF_MM_PUB_SUPPLIER.pack_dept_tel
  is '??????
??????
??????';
comment on column IF_MM_PUB_SUPPLIER.pack_dept_mail
  is '??????
??????
??????';
comment on column IF_MM_PUB_SUPPLIER.pack_dept_contact
  is '????????
????????
????????';
comment on column IF_MM_PUB_SUPPLIER.pack_dept_chief
  is '????????
????????
????????';
comment on column IF_MM_PUB_SUPPLIER.pack_dept_minister
  is '????????
????????
????????';
comment on column IF_MM_PUB_SUPPLIER.import_dep
  is '???????
???????
';
comment on column IF_MM_PUB_SUPPLIER.import_position
  is '???????
???????
';
comment on column IF_MM_PUB_SUPPLIER.import_name
  is '???????
???????
';
comment on column IF_MM_PUB_SUPPLIER.import_mobile
  is '?????????
?????????
';
comment on column IF_MM_PUB_SUPPLIER.import_tel
  is '?????????
?????????
';
comment on column IF_MM_PUB_SUPPLIER.import_mail
  is '?????????
?????????
';
comment on column IF_MM_PUB_SUPPLIER.pt_dep
  is 'PT???????
PT???????
';
comment on column IF_MM_PUB_SUPPLIER.pt_position
  is 'PT???????
PT???????
';
comment on column IF_MM_PUB_SUPPLIER.pt_name
  is 'PT???????
PT???????
';
comment on column IF_MM_PUB_SUPPLIER.pt_mobile
  is 'PT?????????
PT?????????
';
comment on column IF_MM_PUB_SUPPLIER.pt_tel
  is 'PT?????????
PT?????????
';
comment on column IF_MM_PUB_SUPPLIER.pt_mail
  is 'PT?????????
PT?????????
';
comment on column IF_MM_PUB_SUPPLIER.mass_dep
  is '?????????
?????????
';
comment on column IF_MM_PUB_SUPPLIER.mass_position
  is '?????????
?????????
';
comment on column IF_MM_PUB_SUPPLIER.mass_name
  is '?????????
?????????
';
comment on column IF_MM_PUB_SUPPLIER.mass_mobile
  is '???????????
???????????
';
comment on column IF_MM_PUB_SUPPLIER.mass_tel
  is '???????????
???????????
';
comment on column IF_MM_PUB_SUPPLIER.mass_mail
  is '???????????
???????????
';
comment on column IF_MM_PUB_SUPPLIER.excep_dep_a
  is '???????A
???????A
';
comment on column IF_MM_PUB_SUPPLIER.excep_dep_b
  is '???????B
???????B
';
comment on column IF_MM_PUB_SUPPLIER.excep_position_a
  is '???????A
???????A
';
comment on column IF_MM_PUB_SUPPLIER.excep_position_b
  is '???????B
???????B
';
comment on column IF_MM_PUB_SUPPLIER.excep_name_a
  is '???????A
???????A
';
comment on column IF_MM_PUB_SUPPLIER.excep_name_b
  is '???????B
???????B
';
comment on column IF_MM_PUB_SUPPLIER.excep_mobile_a
  is '?????????A
?????????A
';
comment on column IF_MM_PUB_SUPPLIER.excep_mobile_b
  is '?????????B
?????????B
';
comment on column IF_MM_PUB_SUPPLIER.excep_tel_a
  is '?????????A
?????????A
';
comment on column IF_MM_PUB_SUPPLIER.excep_tel_b
  is '?????????B
?????????B
';
comment on column IF_MM_PUB_SUPPLIER.excep_mail_a
  is '?????????A
?????????A
';
comment on column IF_MM_PUB_SUPPLIER.excep_mail_b
  is '?????????B
?????????B
';
comment on column IF_MM_PUB_SUPPLIER.device_dep
  is '???????
???????
';
comment on column IF_MM_PUB_SUPPLIER.device_position
  is '???????
???????
';
comment on column IF_MM_PUB_SUPPLIER.device_name
  is '???????
???????
';
comment on column IF_MM_PUB_SUPPLIER.device_mobile
  is '?????????
?????????
';
comment on column IF_MM_PUB_SUPPLIER.device_tel
  is '?????????
?????????
';
comment on column IF_MM_PUB_SUPPLIER.device_mail
  is '?????????
?????????
';
comment on column IF_MM_PUB_SUPPLIER.import_dep_a
  is '???????1
???????1
';
comment on column IF_MM_PUB_SUPPLIER.import_position_a
  is '???????1
???????1
';
comment on column IF_MM_PUB_SUPPLIER.import_name_a
  is '???????1
???????1
';
comment on column IF_MM_PUB_SUPPLIER.import_mobile_a
  is '?????????1
?????????1
';
comment on column IF_MM_PUB_SUPPLIER.import_tel_a
  is '?????????1
?????????1
';
comment on column IF_MM_PUB_SUPPLIER.import_mail_a
  is '?????????1
?????????1
';
comment on column IF_MM_PUB_SUPPLIER.pt_dep_a
  is 'PT???????1
PT???????1
';
comment on column IF_MM_PUB_SUPPLIER.pt_position_a
  is 'PT???????1
PT???????1
';
comment on column IF_MM_PUB_SUPPLIER.pt_name_a
  is 'PT???????1
PT???????1
';
comment on column IF_MM_PUB_SUPPLIER.pt_mobil_a
  is 'PT?????????1
PT?????????1
';
comment on column IF_MM_PUB_SUPPLIER.pt_tel_a
  is 'PT?????????1
PT?????????1
';
comment on column IF_MM_PUB_SUPPLIER.pt_mail_a
  is 'PT?????????1
PT?????????1
';
comment on column IF_MM_PUB_SUPPLIER.mass_dep_a
  is '?????????1
?????????1
';
comment on column IF_MM_PUB_SUPPLIER.mass_position_a
  is '?????????1
?????????1
';
comment on column IF_MM_PUB_SUPPLIER.mass_name_a
  is '?????????1
?????????1
';
comment on column IF_MM_PUB_SUPPLIER.mass_mobile_a
  is '???????????1
???????????1
';
comment on column IF_MM_PUB_SUPPLIER.mass_tel_a
  is '???????????1
???????????1
';
comment on column IF_MM_PUB_SUPPLIER.mass_mail_a
  is '???????????1
???????????1
';
comment on column IF_MM_PUB_SUPPLIER.device_dep_a
  is '???????1
???????1
';
comment on column IF_MM_PUB_SUPPLIER.device_position_a
  is '???????1
???????1
';
comment on column IF_MM_PUB_SUPPLIER.device_name_a
  is '???????1
???????1
';
comment on column IF_MM_PUB_SUPPLIER.device_mobile_a
  is '?????????1
?????????1
';
comment on column IF_MM_PUB_SUPPLIER.device_tel_a
  is '?????????1
?????????1
';
comment on column IF_MM_PUB_SUPPLIER.device_mail_a
  is '?????????1
?????????1
';
comment on column IF_MM_PUB_SUPPLIER.pack_dep_a
  is '???????1
???????1
';
comment on column IF_MM_PUB_SUPPLIER.pack_position_a
  is '???????1
???????1
';
comment on column IF_MM_PUB_SUPPLIER.pack_name_a
  is '???????1
???????1
';
comment on column IF_MM_PUB_SUPPLIER.pack_mobile_a
  is '?????????1
?????????1
';
comment on column IF_MM_PUB_SUPPLIER.pack_tel_a
  is '?????????1
?????????1
';
comment on column IF_MM_PUB_SUPPLIER.pack_mail_a
  is '?????????1
?????????1
';
comment on column IF_MM_PUB_SUPPLIER.pack_dep_b
  is '???????2
???????2
';
comment on column IF_MM_PUB_SUPPLIER.pack_position_b
  is '???????2
???????2
';
comment on column IF_MM_PUB_SUPPLIER.pack_name_b
  is '???????2
???????2
';
comment on column IF_MM_PUB_SUPPLIER.pack_mobile_b
  is '?????????2
?????????2
';
comment on column IF_MM_PUB_SUPPLIER.pack_tel_b
  is '?????????2
?????????2
';
comment on column IF_MM_PUB_SUPPLIER.pack_mail_b
  is '?????????2
?????????2
';
comment on column IF_MM_PUB_SUPPLIER.pt_logistics_dep
  is 'PT?????????
PT?????????
';
comment on column IF_MM_PUB_SUPPLIER.pt_logistics_name
  is 'PT?????????
PT?????????
';
comment on column IF_MM_PUB_SUPPLIER.pt_logistics_position
  is 'PT?????????
PT?????????
';
comment on column IF_MM_PUB_SUPPLIER.pt_logistics_mobile
  is 'PT???????????
PT???????????
';
comment on column IF_MM_PUB_SUPPLIER.pt_logistics_tel
  is 'PT???????????
PT???????????
';
comment on column IF_MM_PUB_SUPPLIER.pt_logistics_mail
  is 'PT???????????
PT???????????
';
comment on column IF_MM_PUB_SUPPLIER.pt_logistics_dep_a
  is 'PT?????????1
PT?????????1
';
comment on column IF_MM_PUB_SUPPLIER.pt_logistics_name_a
  is 'PT?????????1
PT?????????1
';
comment on column IF_MM_PUB_SUPPLIER.pt_logistics_position_a
  is 'PT?????????1
PT?????????1
';
comment on column IF_MM_PUB_SUPPLIER.pt_logistics_mobile_a
  is 'PT???????????1
PT???????????1
';
comment on column IF_MM_PUB_SUPPLIER.pt_logistics_tel_a
  is 'PT???????????1
PT???????????1
';
comment on column IF_MM_PUB_SUPPLIER.pt_logistics_mail_a
  is 'PT???????????1
PT???????????1
';
comment on column IF_MM_PUB_SUPPLIER.mass_logistics_dep
  is '???????????
???????????
';
comment on column IF_MM_PUB_SUPPLIER.mass_logistics_position
  is '???????????
???????????
';
comment on column IF_MM_PUB_SUPPLIER.mass_logistics_name
  is '???????????
???????????
';
comment on column IF_MM_PUB_SUPPLIER.mass_logistics_mobile
  is '?????????????
?????????????
';
comment on column IF_MM_PUB_SUPPLIER.mass_logistics_tel
  is '?????????????
?????????????
';
comment on column IF_MM_PUB_SUPPLIER.mass_logistics_mail
  is '?????????????
?????????????
';
comment on column IF_MM_PUB_SUPPLIER.mass_logistics_dep_a
  is '???????????1
???????????1
';
comment on column IF_MM_PUB_SUPPLIER.mass_logistics_position_a
  is '???????????1
???????????1
';
comment on column IF_MM_PUB_SUPPLIER.mass_logistics_name_a
  is '???????????1
???????????1
';
comment on column IF_MM_PUB_SUPPLIER.mass_logistics_mobile_a
  is '?????????????1
?????????????1
';
comment on column IF_MM_PUB_SUPPLIER.mass_logistics_tel_a
  is '?????????????1
?????????????1
';
comment on column IF_MM_PUB_SUPPLIER.mass_logistics_mail_a
  is '?????????????1
?????????????1
';
comment on column IF_MM_PUB_SUPPLIER.deal_flag
  is '??????
??????
';
comment on column IF_MM_PUB_SUPPLIER.deal_time
  is '????
????
';
comment on column IF_MM_PUB_SUPPLIER.do_flag
  is '????
????
';
create index IDX_IF_PUB_SUPPLIER on IF_MM_PUB_SUPPLIER (DEAL_FLAG)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_MM_PUB_SUPPLIER
  add constraint PK_IF_MM_PUB_SUPPLIER primary key (ID, SUP_FACTORY)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_MM_PUB_SUPPLIER_DETAIL
prompt ========================================
prompt
create table IF_MM_PUB_SUPPLIER_DETAIL
(
  id                        NUMBER(19) not null,
  sup_factory               VARCHAR2(10) not null,
  supplier_no               VARCHAR2(10),
  sup_factory_addr          VARCHAR2(200),
  email                     VARCHAR2(50),
  contact                   VARCHAR2(30),
  mobile_no                 VARCHAR2(30),
  tel_no                    VARCHAR2(30),
  creation_time             DATE default sysdate,
  last_modified_time        DATE,
  blong_area                VARCHAR2(50),
  sup_leader_name           VARCHAR2(30),
  sup_leader_tel            VARCHAR2(30),
  sup_leader_mail           VARCHAR2(100),
  order_contact             VARCHAR2(30),
  order_tel                 VARCHAR2(30),
  order_mail                VARCHAR2(100),
  deliv_contact             VARCHAR2(30),
  delivery_tel              VARCHAR2(30),
  delivery_mail             VARCHAR2(100),
  excep_contact             VARCHAR2(30),
  excep_tel                 VARCHAR2(30),
  excep_mail                VARCHAR2(100),
  pack_dept_name            VARCHAR2(60),
  pack_dept_tel             VARCHAR2(30),
  pack_dept_mail            VARCHAR2(100),
  pack_dept_contact         VARCHAR2(30),
  pack_dept_chief           VARCHAR2(30),
  pack_dept_minister        VARCHAR2(30),
  import_dep                VARCHAR2(60),
  import_position           VARCHAR2(50),
  import_name               VARCHAR2(30),
  import_mobile             VARCHAR2(30),
  import_tel                VARCHAR2(30),
  import_mail               VARCHAR2(50),
  pt_dep                    VARCHAR2(60),
  pt_position               VARCHAR2(50),
  pt_name                   VARCHAR2(30),
  pt_mobile                 VARCHAR2(30),
  pt_tel                    VARCHAR2(30),
  pt_mail                   VARCHAR2(50),
  mass_dep                  VARCHAR2(60),
  mass_position             VARCHAR2(50),
  mass_name                 VARCHAR2(30),
  mass_mobile               VARCHAR2(30),
  mass_tel                  VARCHAR2(30),
  mass_mail                 VARCHAR2(50),
  excep_dep_a               VARCHAR2(60),
  excep_dep_b               VARCHAR2(50),
  excep_position_a          VARCHAR2(50),
  excep_position_b          VARCHAR2(50),
  excep_name_a              VARCHAR2(30),
  excep_name_b              VARCHAR2(30),
  excep_mobile_a            VARCHAR2(30),
  excep_mobile_b            VARCHAR2(30),
  excep_tel_a               VARCHAR2(30),
  excep_tel_b               VARCHAR2(30),
  excep_mail_a              VARCHAR2(50),
  excep_mail_b              VARCHAR2(50),
  device_dep                VARCHAR2(60),
  device_position           VARCHAR2(30),
  device_name               VARCHAR2(30),
  device_mobile             VARCHAR2(30),
  device_tel                VARCHAR2(30),
  device_mail               VARCHAR2(50),
  import_dep_a              VARCHAR2(50),
  import_position_a         VARCHAR2(30),
  import_name_a             VARCHAR2(30),
  import_mobile_a           VARCHAR2(30),
  import_tel_a              VARCHAR2(30),
  import_mail_a             VARCHAR2(50),
  pt_dep_a                  VARCHAR2(60),
  pt_position_a             VARCHAR2(30),
  pt_name_a                 VARCHAR2(30),
  pt_mobile_a               VARCHAR2(30),
  pt_tel_a                  VARCHAR2(30),
  pt_mail_a                 VARCHAR2(50),
  mass_dep_a                VARCHAR2(60),
  mass_position_a           VARCHAR2(30),
  mass_name_a               VARCHAR2(30),
  mass_mobile_a             VARCHAR2(30),
  mass_tel_a                VARCHAR2(30),
  mass_mail_a               VARCHAR2(50),
  device_dep_a              VARCHAR2(60),
  device_position_a         VARCHAR2(30),
  device_name_a             VARCHAR2(30),
  device_mobile_a           VARCHAR2(30),
  device_tel_a              VARCHAR2(30),
  device_mail_a             VARCHAR2(50),
  pack_dep_a                VARCHAR2(60),
  pack_position_a           VARCHAR2(30),
  pack_name_a               VARCHAR2(30),
  pack_mobile_a             VARCHAR2(30),
  pack_tel_a                VARCHAR2(30),
  pack_mail_a               VARCHAR2(50),
  pack_dep_b                VARCHAR2(60),
  pack_position_b           VARCHAR2(30),
  pack_name_b               VARCHAR2(30),
  pack_mobile_b             VARCHAR2(30),
  pack_tel_b                VARCHAR2(30),
  pack_mail_b               VARCHAR2(50),
  pt_logistics_dep          VARCHAR2(60),
  pt_logistics_name         VARCHAR2(30),
  pt_logistics_position     VARCHAR2(30),
  pt_logistics_mobile       VARCHAR2(30),
  pt_logistics_tel          VARCHAR2(30),
  pt_logistics_mail         VARCHAR2(50),
  pt_logistics_dep_a        VARCHAR2(60),
  pt_logistics_name_a       VARCHAR2(30),
  pt_logistics_position_a   VARCHAR2(30),
  pt_logistics_mobile_a     VARCHAR2(30),
  pt_logistics_tel_a        VARCHAR2(30),
  pt_logistics_mail_a       VARCHAR2(50),
  mass_logistics_dep        VARCHAR2(60),
  mass_logistics_position   VARCHAR2(30),
  mass_logistics_name       VARCHAR2(30),
  mass_logistics_mobile     VARCHAR2(30),
  mass_logistics_tel        VARCHAR2(30),
  mass_logistics_mail       VARCHAR2(50),
  mass_logistics_dep_a      VARCHAR2(60),
  mass_logistics_position_a VARCHAR2(30),
  mass_logistics_name_a     VARCHAR2(30),
  mass_logistics_mobile_a   VARCHAR2(30),
  mass_logistics_tel_a      VARCHAR2(30),
  mass_logistics_mail_a     VARCHAR2(50),
  deal_flag                 NUMBER(1) default 0,
  deal_time                 DATE,
  do_flag                   VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column IF_MM_PUB_SUPPLIER_DETAIL.sup_factory
  is '???????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.blong_area
  is '????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.sup_leader_name
  is '????????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.sup_leader_tel
  is '???????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.sup_leader_mail
  is '???????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.order_contact
  is '?????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.order_tel
  is '??????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.order_mail
  is '??????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.deliv_contact
  is '?????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.delivery_tel
  is '???????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.delivery_mail
  is '???????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.excep_contact
  is '???????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.excep_tel
  is '????????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.excep_mail
  is '????????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.pack_dept_name
  is '??????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.pack_dept_tel
  is '??????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.pack_dept_mail
  is '??????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.pack_dept_contact
  is '????????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.pack_dept_chief
  is '????????';
comment on column IF_MM_PUB_SUPPLIER_DETAIL.pack_dept_minister
  is '????????';
alter table IF_MM_PUB_SUPPLIER_DETAIL
  add constraint PK_IF_MM_PUB_SUPPLIER_DETAIL primary key (ID, SUP_FACTORY)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_MM_SW_ACCOUNT_BILL
prompt ====================================
prompt
create table IF_MM_SW_ACCOUNT_BILL
(
  id                 NUMBER(19),
  bill_no            VARCHAR2(30) not null,
  factory_code       VARCHAR2(10),
  supplier_no        VARCHAR2(20),
  tax_excluded       NUMBER(19,3),
  tax_inclusive      NUMBER(19,3),
  total_tax          NUMBER(19,3),
  make_date          DATE,
  currency_type      VARCHAR2(20),
  rebate             NUMBER(19,3),
  rebate_desc        VARCHAR2(300),
  deduct_money       NUMBER(19,3),
  deduct_money_desc  VARCHAR2(300),
  year_adjust        NUMBER(19,3),
  year_adjust_desc   VARCHAR2(300),
  mould_amount       NUMBER(19,3),
  mould_amount_desc  VARCHAR2(300),
  pay_term           VARCHAR2(100),
  invoice_status     NUMBER(1) default 0,
  invoice_entry_time DATE,
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  remark             VARCHAR2(300),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  submit_status      NUMBER(1) default 0,
  do_flag            VARCHAR2(10),
  deal_flag2         NUMBER(1) default 0,
  deal_time2         DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column IF_MM_SW_ACCOUNT_BILL.bill_no
  is '开票对账单号
';
comment on column IF_MM_SW_ACCOUNT_BILL.factory_code
  is '工厂
';
comment on column IF_MM_SW_ACCOUNT_BILL.supplier_no
  is '供应商代码
';
comment on column IF_MM_SW_ACCOUNT_BILL.tax_excluded
  is '对账单不含税合计
';
comment on column IF_MM_SW_ACCOUNT_BILL.tax_inclusive
  is '对账单含税合计
';
comment on column IF_MM_SW_ACCOUNT_BILL.total_tax
  is '对账单税额合计
';
comment on column IF_MM_SW_ACCOUNT_BILL.make_date
  is '制单日期
';
comment on column IF_MM_SW_ACCOUNT_BILL.currency_type
  is '货币类型
';
comment on column IF_MM_SW_ACCOUNT_BILL.rebate
  is '供应商返利值
';
comment on column IF_MM_SW_ACCOUNT_BILL.rebate_desc
  is '供应商返利描述
';
comment on column IF_MM_SW_ACCOUNT_BILL.deduct_money
  is '特殊扣款值
';
comment on column IF_MM_SW_ACCOUNT_BILL.deduct_money_desc
  is '特殊扣款描述
';
comment on column IF_MM_SW_ACCOUNT_BILL.year_adjust
  is '年底调差值
';
comment on column IF_MM_SW_ACCOUNT_BILL.year_adjust_desc
  is '年底调差描述
';
comment on column IF_MM_SW_ACCOUNT_BILL.mould_amount
  is '模具分摊值
';
comment on column IF_MM_SW_ACCOUNT_BILL.mould_amount_desc
  is '模具分摊描述
';
comment on column IF_MM_SW_ACCOUNT_BILL.pay_term
  is '付款条件
';
comment on column IF_MM_SW_ACCOUNT_BILL.invoice_status
  is '发票反馈状态
0-未反馈
1-已反馈
';
comment on column IF_MM_SW_ACCOUNT_BILL.invoice_entry_time
  is '发票反馈时间
';
comment on column IF_MM_SW_ACCOUNT_BILL.deal_flag
  is '接口处理标志
0-未处理
1-已处理';
comment on column IF_MM_SW_ACCOUNT_BILL.deal_time
  is '接口处理时间
';
comment on column IF_MM_SW_ACCOUNT_BILL.remark
  is '备注
';
comment on column IF_MM_SW_ACCOUNT_BILL.creation_user
  is '创建人
';
comment on column IF_MM_SW_ACCOUNT_BILL.creation_time
  is '创建时间
';
comment on column IF_MM_SW_ACCOUNT_BILL.last_modified_user
  is '最后修改用户
';
comment on column IF_MM_SW_ACCOUNT_BILL.last_modified_time
  is '最后修改时间
';
comment on column IF_MM_SW_ACCOUNT_BILL.submit_status
  is '提交标识
';
comment on column IF_MM_SW_ACCOUNT_BILL.do_flag
  is '处理类型
处理类型
I-新增；U-修改；D-删除';
comment on column IF_MM_SW_ACCOUNT_BILL.deal_flag2
  is '处理标识
处理标识
0 未处理 1已处理';
comment on column IF_MM_SW_ACCOUNT_BILL.deal_time2
  is '处理时间
处理时间
';

prompt
prompt Creating table IF_MM_SW_ACCOUNT_BILL_DETAIL
prompt ===========================================
prompt
create table IF_MM_SW_ACCOUNT_BILL_DETAIL
(
  id                    NUMBER(19),
  bill_no               VARCHAR2(30) not null,
  bill_row_no           NUMBER(10) not null,
  purchase_no           VARCHAR2(50),
  purchase_row_no       NUMBER(10),
  rec_voucher_year      VARCHAR2(20),
  rec_voucher_billno    VARCHAR2(50),
  rec_voucher_rowno     NUMBER(10),
  ref_rec_voucher_bill  VARCHAR2(50),
  ref_rec_voucher_rowno NUMBER(10),
  rec_date              DATE,
  loan_flag             VARCHAR2(10),
  price_status          NUMBER(1),
  eva_price             NUMBER(19,3),
  official_price        NUMBER(19,3),
  adjust_diff_price     NUMBER(19,3),
  eva_price_percent     NUMBER(19,3),
  eva_settle_price      NUMBER(19,3),
  erp_factory_code      VARCHAR2(10),
  part_no               VARCHAR2(20),
  supplier_no           VARCHAR2(20),
  rec_num               NUMBER(19,3),
  pay_amount            NUMBER(19,3),
  tax_rate              NUMBER(19,3),
  tax_amount            NUMBER(19,3),
  currency_type         VARCHAR2(20),
  part_unit             VARCHAR2(20),
  do_flag               VARCHAR2(10),
  deal_flag             NUMBER(1) default 0,
  deal_time             DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.bill_no
  is '开票对账单号
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.bill_row_no
  is '对账单行号
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.purchase_no
  is '采购订单号
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.purchase_row_no
  is '采购单行号
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.rec_voucher_year
  is '收货凭证年度
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.rec_voucher_billno
  is '物料凭证
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.rec_voucher_rowno
  is '物料凭证行项目
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.ref_rec_voucher_bill
  is '参考物料凭证
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.ref_rec_voucher_rowno
  is '参考物料凭证行项目
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.rec_date
  is '收货凭证日期
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.loan_flag
  is '借贷标识
S-正数
H-负数';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.price_status
  is '价格状态
1-暂估价；
2-正式价；
3-调差价';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.eva_price
  is '暂估价(不含税)
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.official_price
  is '正式价(不含税)
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.adjust_diff_price
  is '调差价格(不含税)
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.eva_price_percent
  is '定价(暂估价)百分比
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.eva_settle_price
  is '暂估结算单价
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.erp_factory_code
  is 'ERP工厂代码
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.part_no
  is '零件号
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.supplier_no
  is '供应商代码
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.rec_num
  is '已收货数量
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.pay_amount
  is '应付(不含税)金额
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.tax_rate
  is '税率
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.tax_amount
  is '税额
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.currency_type
  is '货币类型
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.part_unit
  is '物料基本单位
';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.do_flag
  is '处理类型
处理类型
I-新增；U-修改；D-删除';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.deal_flag
  is '处理标识
处理标识
0 未处理 1已处理';
comment on column IF_MM_SW_ACCOUNT_BILL_DETAIL.deal_time
  is '处理时间
处理时间
';

prompt
prompt Creating table IF_MM_SW_DEMAND_FORECAST
prompt =======================================
prompt
create table IF_MM_SW_DEMAND_FORECAST
(
  id                 NUMBER(10) not null,
  factory_code       VARCHAR2(20),
  fore_type          NUMBER(1),
  version            VARCHAR2(20),
  plan_delivery      DATE,
  start_date         DATE,
  end_date           DATE,
  phase              VARCHAR2(20),
  unload_port        VARCHAR2(20),
  part_no            VARCHAR2(20),
  part_unit          VARCHAR2(20),
  order_qty          NUMBER(10),
  supplier_no        VARCHAR2(20),
  supplier_name      VARCHAR2(100),
  sup_factory_addr   VARCHAR2(100),
  sup_factory        VARCHAR2(20),
  model_code         VARCHAR2(20),
  logistics_mode     VARCHAR2(50),
  download_status    NUMBER(1) default 0,
  download_time      DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  release_status     NUMBER(1) default 1,
  feedback_status    NUMBER(1),
  feedback_remark    VARCHAR2(300),
  publish_month      VARCHAR2(30),
  obj_month          VARCHAR2(30),
  do_flag            VARCHAR2(10),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column IF_MM_SW_DEMAND_FORECAST.id
  is 'ID
';
comment on column IF_MM_SW_DEMAND_FORECAST.factory_code
  is '工厂
';
comment on column IF_MM_SW_DEMAND_FORECAST.fore_type
  is '预测类型
1-月预测
2-日预测';
comment on column IF_MM_SW_DEMAND_FORECAST.version
  is '发布版本
';
comment on column IF_MM_SW_DEMAND_FORECAST.plan_delivery
  is '需求到货日期
';
comment on column IF_MM_SW_DEMAND_FORECAST.start_date
  is '开始日期
';
comment on column IF_MM_SW_DEMAND_FORECAST.end_date
  is '结束日期
';
comment on column IF_MM_SW_DEMAND_FORECAST.phase
  is '生产阶段
0-试制
1-量产';
comment on column IF_MM_SW_DEMAND_FORECAST.unload_port
  is '卸货口
';
comment on column IF_MM_SW_DEMAND_FORECAST.part_no
  is '零件编号
';
comment on column IF_MM_SW_DEMAND_FORECAST.part_unit
  is '零件单位
';
comment on column IF_MM_SW_DEMAND_FORECAST.order_qty
  is '需求数量
';
comment on column IF_MM_SW_DEMAND_FORECAST.supplier_no
  is '供应商代码
';
comment on column IF_MM_SW_DEMAND_FORECAST.supplier_name
  is '供应商名称
';
comment on column IF_MM_SW_DEMAND_FORECAST.sup_factory_addr
  is '出货地地址
';
comment on column IF_MM_SW_DEMAND_FORECAST.sup_factory
  is '出货地代码
';
comment on column IF_MM_SW_DEMAND_FORECAST.model_code
  is '车型
';
comment on column IF_MM_SW_DEMAND_FORECAST.logistics_mode
  is '订单物流模式
';
comment on column IF_MM_SW_DEMAND_FORECAST.download_status
  is '下载状态
0-未下载
1-已下载';
comment on column IF_MM_SW_DEMAND_FORECAST.download_time
  is '下载日期
';
comment on column IF_MM_SW_DEMAND_FORECAST.creation_user
  is '创建人
';
comment on column IF_MM_SW_DEMAND_FORECAST.creation_time
  is '创建时间
';
comment on column IF_MM_SW_DEMAND_FORECAST.last_modified_user
  is '最后修改用户
';
comment on column IF_MM_SW_DEMAND_FORECAST.last_modified_time
  is '最后修改时间
';
comment on column IF_MM_SW_DEMAND_FORECAST.release_status
  is '发布状态
';
comment on column IF_MM_SW_DEMAND_FORECAST.feedback_status
  is '反馈状态
';
comment on column IF_MM_SW_DEMAND_FORECAST.feedback_remark
  is '反馈备注
';
comment on column IF_MM_SW_DEMAND_FORECAST.publish_month
  is '发布月份
';
comment on column IF_MM_SW_DEMAND_FORECAST.obj_month
  is '对象月份
';
comment on column IF_MM_SW_DEMAND_FORECAST.do_flag
  is '处理类型
处理类型
I-新增；U-修改；D-删除';
comment on column IF_MM_SW_DEMAND_FORECAST.deal_flag
  is '处理标识
处理标识
0 未处理 1已处理';
comment on column IF_MM_SW_DEMAND_FORECAST.deal_time
  is '处理时间
处理时间
';

prompt
prompt Creating table IF_MM_SW_PICKUP_PLAN
prompt ===================================
prompt
create table IF_MM_SW_PICKUP_PLAN
(
  id                  NUMBER(19),
  order_no            VARCHAR2(50) not null,
  purchase_no         VARCHAR2(50) not null,
  confirm_days        NUMBER(10),
  inter_logis_manager VARCHAR2(30),
  order_use           VARCHAR2(100),
  plan_assemble_time  DATE,
  plan_arr_time       DATE,
  plan_pickup_time    DATE,
  today_car_batch     NUMBER(10),
  feedback_status     NUMBER(1) default 0,
  logistics_mode      VARCHAR2(50),
  area                VARCHAR2(50),
  car_type            VARCHAR2(30),
  route_code          VARCHAR2(30),
  total_batchs        VARCHAR2(30),
  merge_batchs        NUMBER(10),
  sup_factory         VARCHAR2(20),
  supplier_no         VARCHAR2(20),
  work_date           DATE,
  factory_code        VARCHAR2(10),
  diff_flag           NUMBER(1),
  order_desc          VARCHAR2(200),
  pickup_type         VARCHAR2(30),
  order_arr_date      DATE,
  unload_port         VARCHAR2(20),
  adj_status          NUMBER(1),
  download_status     NUMBER(1) default 0,
  download_time       DATE,
  creation_user       VARCHAR2(30),
  creation_time       DATE default sysdate,
  last_modified_user  VARCHAR2(30),
  last_modified_time  DATE,
  do_flag             VARCHAR2(10),
  deal_flag           NUMBER(1) default 0,
  deal_time           DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column IF_MM_SW_PICKUP_PLAN.feedback_status
  is '0-???
1-NG
2-OK';
comment on column IF_MM_SW_PICKUP_PLAN.diff_flag
  is '0-???  1-???';
comment on column IF_MM_SW_PICKUP_PLAN.pickup_type
  is '????(0:??;1:??;2:??)';
comment on column IF_MM_SW_PICKUP_PLAN.adj_status
  is '0-???  1-??? 2-???';
comment on column IF_MM_SW_PICKUP_PLAN.download_status
  is '0-???
1-???';
comment on column IF_MM_SW_PICKUP_PLAN.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_MM_SW_PICKUP_PLAN.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_MM_SW_PICKUP_PLAN.deal_time
  is '????
????
';

prompt
prompt Creating table IF_MODEL_BOM
prompt ===========================
prompt
create table IF_MODEL_BOM
(
  id             NUMBER(19) not null,
  factory_code   VARCHAR2(10) not null,
  mto            VARCHAR2(10) not null,
  part_id        VARCHAR2(30) not null,
  vehicle_type   VARCHAR2(20),
  line_station   VARCHAR2(30) not null,
  stage          VARCHAR2(30),
  version        VARCHAR2(10),
  purchase_type  VARCHAR2(10),
  feature        VARCHAR2(30),
  num            VARCHAR2(10),
  part_unit      VARCHAR2(20),
  supplier_no    VARCHAR2(20),
  next_placement VARCHAR2(20),
  process        VARCHAR2(20),
  a              VARCHAR2(20),
  b              VARCHAR2(20),
  c              VARCHAR2(20),
  eff_start      VARCHAR2(30),
  eff_end        VARCHAR2(30),
  do_flag        VARCHAR2(10),
  uda1           VARCHAR2(50),
  uda2           VARCHAR2(50),
  uda3           VARCHAR2(50),
  uda4           VARCHAR2(50),
  uda5           VARCHAR2(50),
  deal_flag      NUMBER(1) default 0,
  deal_time      DATE,
  creation_time  DATE default sysdate,
  guid           VARCHAR2(50),
  file_key       VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_MODEL_BOM
  is 'IF_MODEL_BOM??????????
IF_MODEL_BOM??????????
';
comment on column IF_MODEL_BOM.id
  is 'ID
ID
';
comment on column IF_MODEL_BOM.factory_code
  is '??
??
';
comment on column IF_MODEL_BOM.mto
  is 'MTO
MTO
';
comment on column IF_MODEL_BOM.part_id
  is '????
????
';
comment on column IF_MODEL_BOM.vehicle_type
  is '??
??
';
comment on column IF_MODEL_BOM.line_station
  is '?????
?????
';
comment on column IF_MODEL_BOM.stage
  is '??
??
';
comment on column IF_MODEL_BOM.version
  is '??
??
';
comment on column IF_MODEL_BOM.purchase_type
  is '????
????
';
comment on column IF_MODEL_BOM.feature
  is '??
??
';
comment on column IF_MODEL_BOM.num
  is '??
??
';
comment on column IF_MODEL_BOM.part_unit
  is '????
????
';
comment on column IF_MODEL_BOM.supplier_no
  is '???
???
';
comment on column IF_MODEL_BOM.next_placement
  is '????
????
?';
comment on column IF_MODEL_BOM.process
  is '????
????
';
comment on column IF_MODEL_BOM.a
  is '???????
???????
';
comment on column IF_MODEL_BOM.b
  is '???????
???????
';
comment on column IF_MODEL_BOM.c
  is '???????
???????
';
comment on column IF_MODEL_BOM.eff_start
  is '????
????
';
comment on column IF_MODEL_BOM.eff_end
  is '????
????
';
comment on column IF_MODEL_BOM.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_MODEL_BOM.uda1
  is '????1
????1
';
comment on column IF_MODEL_BOM.uda2
  is '????2
????2
';
comment on column IF_MODEL_BOM.uda3
  is '????3
????3
';
comment on column IF_MODEL_BOM.uda4
  is '????4
????4
';
comment on column IF_MODEL_BOM.uda5
  is '????5
????5
';
comment on column IF_MODEL_BOM.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_MODEL_BOM.deal_time
  is '????
????
';
comment on column IF_MODEL_BOM.creation_time
  is '????
????
';
comment on column IF_MODEL_BOM.guid
  is 'GUID
GUID
GUID';
comment on column IF_MODEL_BOM.file_key
  is '????
????
????';
create index IDX_IF_MODEL_BOM1 on IF_MODEL_BOM (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_MODEL_BOM
  add constraint PK_IF_MODEL_BOM primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_MP_ADJUST_BOM
prompt ===============================
prompt
create table IF_MP_ADJUST_BOM
(
  comp              VARCHAR2(10),
  car_type          VARCHAR2(20),
  adj_date          VARCHAR2(30),
  part_row_no       VARCHAR2(10),
  part_id           VARCHAR2(30),
  line_station      VARCHAR2(30),
  num               VARCHAR2(18),
  usage_amount_unit VARCHAR2(20),
  purchase_type     VARCHAR2(10),
  uda1              VARCHAR2(50),
  uda2              VARCHAR2(50),
  uda3              VARCHAR2(50),
  uda4              VARCHAR2(50),
  uda5              VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_MP_ADJUST_BOM
  is 'IF_MP_ADJUST_BOM????BOM
IF_MP_ADJUST_BOM????BOM
';
comment on column IF_MP_ADJUST_BOM.comp
  is '??
??
';
comment on column IF_MP_ADJUST_BOM.car_type
  is '??
??
';
comment on column IF_MP_ADJUST_BOM.adj_date
  is '????
????
';
comment on column IF_MP_ADJUST_BOM.part_row_no
  is '??????
??????
?????';
comment on column IF_MP_ADJUST_BOM.part_id
  is '????
????
???? ';
comment on column IF_MP_ADJUST_BOM.line_station
  is '?????
?????
?????';
comment on column IF_MP_ADJUST_BOM.num
  is '??
??
??';
comment on column IF_MP_ADJUST_BOM.usage_amount_unit
  is '????
????
????';
comment on column IF_MP_ADJUST_BOM.purchase_type
  is '????
????
????';
comment on column IF_MP_ADJUST_BOM.uda1
  is '????1
????1
????1';
comment on column IF_MP_ADJUST_BOM.uda2
  is '????2
????2
????2';
comment on column IF_MP_ADJUST_BOM.uda3
  is '????3
????3
????3';
comment on column IF_MP_ADJUST_BOM.uda4
  is '????4
????4
????4';
comment on column IF_MP_ADJUST_BOM.uda5
  is '????5
????5
????5';

prompt
prompt Creating table IF_MP_ADJUST_PLAN
prompt ================================
prompt
create table IF_MP_ADJUST_PLAN
(
  id            NUMBER(19) not null,
  comp          VARCHAR2(10),
  car_type      VARCHAR2(20),
  adj_num       VARCHAR2(10),
  adj_date      VARCHAR2(30),
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate,
  guid          VARCHAR2(50),
  file_key      VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_MP_ADJUST_PLAN
  is 'IF_MP_ADJUST_PLAN???????
IF_MP_ADJUST_PLAN???????
';
comment on column IF_MP_ADJUST_PLAN.id
  is 'ID
ID
';
comment on column IF_MP_ADJUST_PLAN.comp
  is '??
??
';
comment on column IF_MP_ADJUST_PLAN.car_type
  is '??
??
';
comment on column IF_MP_ADJUST_PLAN.adj_num
  is '????
????
 ';
comment on column IF_MP_ADJUST_PLAN.adj_date
  is '????
????
';
comment on column IF_MP_ADJUST_PLAN.uda1
  is '????1
????1
';
comment on column IF_MP_ADJUST_PLAN.uda2
  is '????2
????2
';
comment on column IF_MP_ADJUST_PLAN.uda3
  is '????3
????3
';
comment on column IF_MP_ADJUST_PLAN.uda4
  is '????4
????4
';
comment on column IF_MP_ADJUST_PLAN.uda5
  is '????5
????5
';
comment on column IF_MP_ADJUST_PLAN.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_MP_ADJUST_PLAN.deal_time
  is '????
????
';
comment on column IF_MP_ADJUST_PLAN.creation_time
  is '????
????
????';
comment on column IF_MP_ADJUST_PLAN.guid
  is 'GUID
GUID
GUID';
comment on column IF_MP_ADJUST_PLAN.file_key
  is '????
????
????';
create index IDX_IF_MP_ADJUST_PLAN1 on IF_MP_ADJUST_PLAN (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_MP_ADJUST_PLAN
  add constraint PK_IF_MP_ADJUST_PLAN primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_ORDER
prompt =======================
prompt
create table IF_ORDER
(
  id        NUMBER(19) not null,
  comp      VARCHAR2(10),
  order_no  VARCHAR2(50),
  do_flag   VARCHAR2(10),
  uda1      VARCHAR2(50),
  uda2      VARCHAR2(50),
  uda3      VARCHAR2(50),
  uda4      VARCHAR2(50),
  uda5      VARCHAR2(50),
  deal_flag NUMBER(1) default 0,
  deal_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_ORDER
  is 'IF_ORDERERP?????
IF_ORDERERP?????
IF_ORDERERP?????';
comment on column IF_ORDER.id
  is 'ID
ID
';
comment on column IF_ORDER.comp
  is '??
??
??';
comment on column IF_ORDER.order_no
  is '?????
?????
?????';
comment on column IF_ORDER.do_flag
  is '????
????
????';
comment on column IF_ORDER.uda1
  is '????1
????1
';
comment on column IF_ORDER.uda2
  is '????2
????2
';
comment on column IF_ORDER.uda3
  is '????3
????3
';
comment on column IF_ORDER.uda4
  is '????4
????4
';
comment on column IF_ORDER.uda5
  is '????5
????5
';
comment on column IF_ORDER.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_ORDER.deal_time
  is '????
????
';
create index IDX_IF_ORDER on IF_ORDER (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_ORDER
  add constraint PK_IF_ORDER primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_ORDER_BOM
prompt ===========================
prompt
create table IF_ORDER_BOM
(
  id            NUMBER(19) not null,
  order_no      VARCHAR2(50),
  comp          VARCHAR2(10) not null,
  model_code    VARCHAR2(10),
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50),
  do_flag       VARCHAR2(2),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate,
  guid          VARCHAR2(50),
  file_key      VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_ORDER_BOM
  is 'IF_ORDER_BOM??BOM???
IF_ORDER_BOM??BOM???
';
comment on column IF_ORDER_BOM.id
  is 'ID
ID
';
comment on column IF_ORDER_BOM.order_no
  is '?????
?????
?????';
comment on column IF_ORDER_BOM.comp
  is '??
??
';
comment on column IF_ORDER_BOM.model_code
  is '?? ';
comment on column IF_ORDER_BOM.uda1
  is '????1
????1
';
comment on column IF_ORDER_BOM.uda2
  is '????2
????2
';
comment on column IF_ORDER_BOM.uda3
  is '????3
????3
';
comment on column IF_ORDER_BOM.uda4
  is '????4
????4
';
comment on column IF_ORDER_BOM.uda5
  is '????5
????5
';
comment on column IF_ORDER_BOM.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_ORDER_BOM.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_ORDER_BOM.deal_time
  is '????
????
';
comment on column IF_ORDER_BOM.creation_time
  is '????
????
????';
comment on column IF_ORDER_BOM.guid
  is 'GUID
GUID
GUID';
comment on column IF_ORDER_BOM.file_key
  is '????
????
????';
create index IDX_IF_ORDER_BOM on IF_ORDER_BOM (ID)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_IF_ORDER_BOM_1 on IF_ORDER_BOM (DEAL_FLAG)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table IF_ORDER_BOM_DETAIL
prompt ==================================
prompt
create table IF_ORDER_BOM_DETAIL
(
  id                NUMBER(19) not null,
  order_no          VARCHAR2(50),
  part_row_no       VARCHAR2(10),
  vehicle_part_no   VARCHAR2(30),
  part_id           VARCHAR2(30),
  work_center       VARCHAR2(20),
  line_station      VARCHAR2(30),
  num               VARCHAR2(20),
  usage_amount_unit VARCHAR2(20),
  purchase_type     VARCHAR2(10),
  uda1              VARCHAR2(50),
  uda2              VARCHAR2(50),
  uda3              VARCHAR2(50),
  uda4              VARCHAR2(50),
  uda5              VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_ORDER_BOM_DETAIL
  is 'IF_ORDER_BOM_DETAIL??BOM???
IF_ORDER_BOM_DETAIL??BOM???
';
comment on column IF_ORDER_BOM_DETAIL.id
  is 'ID
ID
';
comment on column IF_ORDER_BOM_DETAIL.order_no
  is '?????
?????
?????';
comment on column IF_ORDER_BOM_DETAIL.part_row_no
  is '??????
??????
?????';
comment on column IF_ORDER_BOM_DETAIL.vehicle_part_no
  is '?????(?MTOC)
?????(?MTOC)
????';
comment on column IF_ORDER_BOM_DETAIL.part_id
  is '????
????
???';
comment on column IF_ORDER_BOM_DETAIL.work_center
  is '??
??
???????????????????';
comment on column IF_ORDER_BOM_DETAIL.line_station
  is '?????
?????
???';
comment on column IF_ORDER_BOM_DETAIL.num
  is '??
??
?????????????';
comment on column IF_ORDER_BOM_DETAIL.usage_amount_unit
  is '????
????
????';
comment on column IF_ORDER_BOM_DETAIL.purchase_type
  is '????
????
';
comment on column IF_ORDER_BOM_DETAIL.uda1
  is '????1
????1
';
comment on column IF_ORDER_BOM_DETAIL.uda2
  is '????2
????2
';
comment on column IF_ORDER_BOM_DETAIL.uda3
  is '????3
????3
';
comment on column IF_ORDER_BOM_DETAIL.uda4
  is '????4
????4
';
comment on column IF_ORDER_BOM_DETAIL.uda5
  is '????5
????5
';
create index IDX_IF_ORDER_BOM_DETAIL on IF_ORDER_BOM_DETAIL (ID)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_ORDER_FEATURE
prompt ===============================
prompt
create table IF_ORDER_FEATURE
(
  id            NUMBER(19) not null,
  order_no      VARCHAR2(50) not null,
  factory_code  VARCHAR2(10) not null,
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50),
  do_flag       VARCHAR2(2),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate,
  guid          VARCHAR2(50),
  file_key      VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_ORDER_FEATURE
  is 'IF_ORDER_FEATURE???????
IF_ORDER_FEATURE???????
';
comment on column IF_ORDER_FEATURE.id
  is 'ID
ID
';
comment on column IF_ORDER_FEATURE.order_no
  is '?????
?????
';
comment on column IF_ORDER_FEATURE.factory_code
  is '??
??
';
comment on column IF_ORDER_FEATURE.uda1
  is '????1
????1
';
comment on column IF_ORDER_FEATURE.uda2
  is '????2
????2
';
comment on column IF_ORDER_FEATURE.uda3
  is '????3
????3
';
comment on column IF_ORDER_FEATURE.uda4
  is '????4
????4
';
comment on column IF_ORDER_FEATURE.uda5
  is '????5
????5
';
comment on column IF_ORDER_FEATURE.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_ORDER_FEATURE.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_ORDER_FEATURE.deal_time
  is '????
????
';
comment on column IF_ORDER_FEATURE.creation_time
  is '????
????
';
comment on column IF_ORDER_FEATURE.guid
  is 'GUID
GUID
';
comment on column IF_ORDER_FEATURE.file_key
  is '????
????
';
alter table IF_ORDER_FEATURE
  add constraint PK_IF_ORDER_FEATURE primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_ORDER_FEATURE_DETAIL
prompt ======================================
prompt
create table IF_ORDER_FEATURE_DETAIL
(
  id                 NUMBER(19) not null,
  order_no           VARCHAR2(50) not null,
  feature_code       VARCHAR2(20) not null,
  feature_code_desc  VARCHAR2(100),
  feature_value      VARCHAR2(500) not null,
  feature_value_desc VARCHAR2(100),
  uda1               VARCHAR2(50),
  uda2               VARCHAR2(50),
  uda3               VARCHAR2(50),
  uda4               VARCHAR2(50),
  uda5               VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_ORDER_FEATURE_DETAIL
  is 'IF_ORDER_FEATURE_DETAIL?????????
IF_ORDER_FEATURE_DETAIL?????????
';
comment on column IF_ORDER_FEATURE_DETAIL.id
  is 'ID
ID
';
comment on column IF_ORDER_FEATURE_DETAIL.order_no
  is '?????
?????
';
comment on column IF_ORDER_FEATURE_DETAIL.feature_code
  is '???????
???????
';
comment on column IF_ORDER_FEATURE_DETAIL.feature_code_desc
  is '?????
?????
';
comment on column IF_ORDER_FEATURE_DETAIL.feature_value
  is '???
???
';
comment on column IF_ORDER_FEATURE_DETAIL.feature_value_desc
  is '?????
?????
';
comment on column IF_ORDER_FEATURE_DETAIL.uda1
  is '????1
????1
';
comment on column IF_ORDER_FEATURE_DETAIL.uda2
  is '????2
????2
';
comment on column IF_ORDER_FEATURE_DETAIL.uda3
  is '????3
????3
';
comment on column IF_ORDER_FEATURE_DETAIL.uda4
  is '????4
????4
';
comment on column IF_ORDER_FEATURE_DETAIL.uda5
  is '????5
????5
';

prompt
prompt Creating table IF_PART
prompt ======================
prompt
create table IF_PART
(
  id            NUMBER(19) not null,
  comp          VARCHAR2(10) not null,
  part_id       VARCHAR2(30) not null,
  part_short_no VARCHAR2(10),
  part_name_cn  VARCHAR2(150),
  part_name_en  VARCHAR2(150),
  part_spec     VARCHAR2(200),
  purchase_type VARCHAR2(10),
  part_unit     VARCHAR2(20),
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate,
  guid          VARCHAR2(50),
  file_key      VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_PART
  is 'IF_PART物料主数据中间表
IF_PART物料主数据中间表
';
comment on column IF_PART.id
  is 'ID
ID
';
comment on column IF_PART.comp
  is '工厂
工厂
';
comment on column IF_PART.part_id
  is '零件编号
零件编号
';
comment on column IF_PART.part_short_no
  is '???????';
comment on column IF_PART.part_name_cn
  is '零件中文名称
零件中文名称
';
comment on column IF_PART.part_name_en
  is '零件英文名称
零件英文名称
';
comment on column IF_PART.part_spec
  is '?????????';
comment on column IF_PART.purchase_type
  is 'W?Z?AW';
comment on column IF_PART.part_unit
  is '用量单位
用量单位
';
comment on column IF_PART.uda1
  is '预留字段1
预留字段1
';
comment on column IF_PART.uda2
  is '预留字段2
预留字段2
';
comment on column IF_PART.uda3
  is '预留字段3
预留字段3
';
comment on column IF_PART.uda4
  is '预留字段4
预留字段4
';
comment on column IF_PART.uda5
  is '预留字段5
预留字段5
';
comment on column IF_PART.deal_flag
  is '0 ??? 1???';
comment on column IF_PART.deal_time
  is '处理时间
处理时间
';
comment on column IF_PART.creation_time
  is '????';
comment on column IF_PART.guid
  is 'GUID';
comment on column IF_PART.file_key
  is '????';
create index IDX_IF_PART1 on IF_PART (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_PART
  add constraint PK_IF_PART primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_PART_SUPPLIER
prompt ===============================
prompt
create table IF_PART_SUPPLIER
(
  id                   NUMBER(19) not null,
  comp                 VARCHAR2(10) not null,
  supplier_id          VARCHAR2(10) not null,
  factory_id           VARCHAR2(10) not null,
  part_id              VARCHAR2(30) not null,
  min_num              VARCHAR2(10),
  standard_package     VARCHAR2(10),
  in_plan_forward_time VARCHAR2(10),
  eff_start            VARCHAR2(30),
  eff_end              VARCHAR2(30),
  uda1                 VARCHAR2(50),
  uda2                 VARCHAR2(50),
  uda3                 VARCHAR2(50),
  uda4                 VARCHAR2(50),
  uda5                 VARCHAR2(50),
  deal_flag            NUMBER(1) default 0,
  deal_time            DATE,
  creation_time        DATE default sysdate,
  do_flag              VARCHAR2(2),
  guid                 VARCHAR2(50),
  file_key             VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_PART_SUPPLIER
  is 'IF_PART_SUPPLIER物料与供应商关系中间表
IF_PART_SUPPLIER物料与供应商关系中间表
';
comment on column IF_PART_SUPPLIER.id
  is 'ID
ID
';
comment on column IF_PART_SUPPLIER.comp
  is '工厂
工厂
';
comment on column IF_PART_SUPPLIER.supplier_id
  is '供应商编号
供应商编号
';
comment on column IF_PART_SUPPLIER.factory_id
  is '供应商出货地
供应商出货地
';
comment on column IF_PART_SUPPLIER.part_id
  is '零件编号
零件编号
';
comment on column IF_PART_SUPPLIER.min_num
  is '最小采购量
最小采购量
';
comment on column IF_PART_SUPPLIER.standard_package
  is '规格包装数
规格包装数
';
comment on column IF_PART_SUPPLIER.in_plan_forward_time
  is '??(?)';
comment on column IF_PART_SUPPLIER.eff_start
  is '???yyyy-MM-dd HH:mm:ss';
comment on column IF_PART_SUPPLIER.eff_end
  is '???yyyy-MM-dd HH:mm:ss';
comment on column IF_PART_SUPPLIER.uda1
  is '预留字段1
预留字段1
';
comment on column IF_PART_SUPPLIER.uda2
  is '预留字段2
预留字段2
';
comment on column IF_PART_SUPPLIER.uda3
  is '预留字段3
预留字段3
';
comment on column IF_PART_SUPPLIER.uda4
  is '预留字段4
预留字段4
';
comment on column IF_PART_SUPPLIER.uda5
  is '预留字段5
预留字段5
';
comment on column IF_PART_SUPPLIER.deal_flag
  is '0 ??? 1???';
comment on column IF_PART_SUPPLIER.deal_time
  is '处理时间
处理时间
';
comment on column IF_PART_SUPPLIER.creation_time
  is '????';
comment on column IF_PART_SUPPLIER.do_flag
  is 'I-???U-???D-??';
comment on column IF_PART_SUPPLIER.guid
  is 'GUID
GUID
';
comment on column IF_PART_SUPPLIER.file_key
  is '文件标识
文件标识
';
create index IDX_IF_PART_SUPPLIER1 on IF_PART_SUPPLIER (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_PART_SUPPLIER
  add constraint PK_IF_PART_SUPPLIER primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_PRO_ROUTE
prompt ===========================
prompt
create table IF_PRO_ROUTE
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10) not null,
  route_code    VARCHAR2(20) not null,
  route_name    VARCHAR2(100),
  do_flag       VARCHAR2(10),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_PRO_ROUTE
  is 'IF_PRO_ROUTE?????????
IF_PRO_ROUTE?????????
';
comment on column IF_PRO_ROUTE.id
  is 'ID
ID
';
comment on column IF_PRO_ROUTE.factory_code
  is '??
??
';
comment on column IF_PRO_ROUTE.route_code
  is '??????
??????
';
comment on column IF_PRO_ROUTE.route_name
  is '??????
??????
';
comment on column IF_PRO_ROUTE.do_flag
  is '????
????
I-???U-???D-???';
comment on column IF_PRO_ROUTE.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_PRO_ROUTE.deal_time
  is '????
????
';
comment on column IF_PRO_ROUTE.creation_time
  is '????
????
';
create index IDX_IF_PRO_ROUTE1 on IF_PRO_ROUTE (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_PRO_ROUTE
  add constraint PK_IF_PRO_ROUTE primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_PRO_ROUTE_DETAIL
prompt ==================================
prompt
create table IF_PRO_ROUTE_DETAIL
(
  id               NUMBER(19),
  work_center      VARCHAR2(20),
  station_code     VARCHAR2(20),
  station_name     VARCHAR2(100),
  station_order_by VARCHAR2(10),
  creation_time    DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_PRO_ROUTE_DETAIL
  is 'IF_PRO_ROUTE_DETAIL???????????
IF_PRO_ROUTE_DETAIL???????????
';
comment on column IF_PRO_ROUTE_DETAIL.id
  is '??ID
??ID
';
comment on column IF_PRO_ROUTE_DETAIL.work_center
  is '????
????
';
comment on column IF_PRO_ROUTE_DETAIL.station_code
  is '????
????
';
comment on column IF_PRO_ROUTE_DETAIL.station_name
  is '????
????
';
comment on column IF_PRO_ROUTE_DETAIL.station_order_by
  is '??????
??????
I-???U-???D-???';
comment on column IF_PRO_ROUTE_DETAIL.creation_time
  is '????
????
';
create index IDX_IF_PRO_ROUTE_DETAIL1 on IF_PRO_ROUTE_DETAIL (ID)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_RGV_RECEIVE
prompt =============================
prompt
create table IF_RGV_RECEIVE
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10),
  ins_no        VARCHAR2(50),
  vin           VARCHAR2(20),
  part_no       VARCHAR2(30),
  num           VARCHAR2(10),
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate,
  guid          VARCHAR2(50),
  file_key      VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_RGV_RECEIVE
  is 'RGV????';
comment on column IF_RGV_RECEIVE.id
  is 'ID
ID
';
comment on column IF_RGV_RECEIVE.uda1
  is '????1
????1
';
comment on column IF_RGV_RECEIVE.uda2
  is '????2
????2
';
comment on column IF_RGV_RECEIVE.uda3
  is '????3
????3
';
comment on column IF_RGV_RECEIVE.uda4
  is '????4
????4
';
comment on column IF_RGV_RECEIVE.uda5
  is '????5
????5
';
comment on column IF_RGV_RECEIVE.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_RGV_RECEIVE.deal_time
  is '????
????
';
comment on column IF_RGV_RECEIVE.creation_time
  is '????
????
';
comment on column IF_RGV_RECEIVE.guid
  is 'GUID
GUID
GUID';
comment on column IF_RGV_RECEIVE.file_key
  is '????
????
????';

prompt
prompt Creating table IF_SPS_CONFIG
prompt ============================
prompt
create table IF_SPS_CONFIG
(
  id            NUMBER(19) not null,
  config_name   VARCHAR2(64) not null,
  config_desc   VARCHAR2(256),
  feature_group VARCHAR2(64) not null,
  do_flag       VARCHAR2(2),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate,
  guid          VARCHAR2(50),
  file_key      VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_SPS_CONFIG
  is 'IF_SPS_CONFIG???
IF_SPS_CONFIG???
';
comment on column IF_SPS_CONFIG.id
  is 'ID
ID
';
comment on column IF_SPS_CONFIG.config_name
  is '?????
?????
';
comment on column IF_SPS_CONFIG.config_desc
  is '?????
?????
';
comment on column IF_SPS_CONFIG.feature_group
  is '?????
?????
';
comment on column IF_SPS_CONFIG.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_SPS_CONFIG.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_SPS_CONFIG.deal_time
  is '????
????
';
comment on column IF_SPS_CONFIG.creation_time
  is '????
????
';
comment on column IF_SPS_CONFIG.guid
  is 'GUID
GUID
';
comment on column IF_SPS_CONFIG.file_key
  is '????
????
';
alter table IF_SPS_CONFIG
  add constraint PK_IF_SPS_CONFIG primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_SUPER_BOM
prompt ===========================
prompt
create table IF_SUPER_BOM
(
  id                 NUMBER(19),
  model_code         VARCHAR2(40),
  factory_code       VARCHAR2(40),
  part_no            VARCHAR2(40),
  parent_part_code   VARCHAR2(40),
  part_name_cn       VARCHAR2(80),
  part_name_en       VARCHAR2(150),
  part_version       VARCHAR2(8),
  line_no            NUMBER(10),
  uc                 VARCHAR2(2000),
  amount             NUMBER(10,2),
  unit_code          VARCHAR2(8),
  plate_code         VARCHAR2(40),
  purchase_type      VARCHAR2(20),
  next_placement     VARCHAR2(200),
  process_type       VARCHAR2(200),
  plan_eff_start     VARCHAR2(40),
  plan_eff_end       VARCHAR2(40),
  actual_eff_start   VARCHAR2(40),
  actual_eff_end     VARCHAR2(40),
  pco                VARCHAR2(40),
  raw_num            VARCHAR2(256),
  gacne_key_part     VARCHAR2(10),
  inter_change_group VARCHAR2(20),
  after_sale_flag    VARCHAR2(10),
  guid               VARCHAR2(36),
  do_flag            VARCHAR2(30),
  uda1               VARCHAR2(50),
  uda2               VARCHAR2(50),
  uda3               VARCHAR2(50),
  uda4               VARCHAR2(50),
  uda5               VARCHAR2(50),
  file_key           VARCHAR2(50),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  creation_time      DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_SUPER_BOM
  is 'G-BOM???ERP???BOM';
comment on column IF_SUPER_BOM.id
  is 'ID';
comment on column IF_SUPER_BOM.model_code
  is '??';
comment on column IF_SUPER_BOM.factory_code
  is '??';
comment on column IF_SUPER_BOM.part_no
  is '????';
comment on column IF_SUPER_BOM.parent_part_code
  is '??????';
comment on column IF_SUPER_BOM.part_name_cn
  is '??????';
comment on column IF_SUPER_BOM.part_name_en
  is '??????';
comment on column IF_SUPER_BOM.part_version
  is '????';
comment on column IF_SUPER_BOM.line_no
  is '??';
comment on column IF_SUPER_BOM.uc
  is '??';
comment on column IF_SUPER_BOM.amount
  is '??';
comment on column IF_SUPER_BOM.unit_code
  is '??';
comment on column IF_SUPER_BOM.plate_code
  is '????';
comment on column IF_SUPER_BOM.purchase_type
  is 'GACNE????';
comment on column IF_SUPER_BOM.next_placement
  is '????';
comment on column IF_SUPER_BOM.process_type
  is '????';
comment on column IF_SUPER_BOM.plan_eff_start
  is '??????';
comment on column IF_SUPER_BOM.plan_eff_end
  is '??????';
comment on column IF_SUPER_BOM.actual_eff_start
  is '??????';
comment on column IF_SUPER_BOM.actual_eff_end
  is '??????';
comment on column IF_SUPER_BOM.pco
  is 'PCO??';
comment on column IF_SUPER_BOM.raw_num
  is '??';
comment on column IF_SUPER_BOM.gacne_key_part
  is 'GACNE???';
comment on column IF_SUPER_BOM.inter_change_group
  is '????';
comment on column IF_SUPER_BOM.after_sale_flag
  is '????';
comment on column IF_SUPER_BOM.guid
  is 'GUID';
comment on column IF_SUPER_BOM.do_flag
  is '?????';
comment on column IF_SUPER_BOM.uda1
  is '预留字段1
预留字段1
';
comment on column IF_SUPER_BOM.uda2
  is '预留字段2
预留字段2
';
comment on column IF_SUPER_BOM.uda3
  is '预留字段3
预留字段3
';
comment on column IF_SUPER_BOM.uda4
  is '预留字段4
预留字段4
';
comment on column IF_SUPER_BOM.uda5
  is '预留字段5
预留字段5
';
comment on column IF_SUPER_BOM.file_key
  is '????';
comment on column IF_SUPER_BOM.deal_flag
  is '0 ??? 1???';
comment on column IF_SUPER_BOM.deal_time
  is '处理时间
处理时间
';
comment on column IF_SUPER_BOM.creation_time
  is '????';
create index IDX_IF_SUPER_BOM on IF_SUPER_BOM (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_SUPPLIER
prompt ==========================
prompt
create table IF_SUPPLIER
(
  id             NUMBER(19) not null,
  sup_factory_id VARCHAR2(10) not null,
  supplier_no    VARCHAR2(10),
  chinese_name   VARCHAR2(150),
  detail_addr    VARCHAR2(200),
  sup_status     VARCHAR2(10),
  email          VARCHAR2(50),
  contact        VARCHAR2(30),
  mobile_no      VARCHAR2(30),
  tel_no         VARCHAR2(30),
  uda1           VARCHAR2(50),
  uda2           VARCHAR2(50),
  uda3           VARCHAR2(50),
  uda4           VARCHAR2(50),
  uda5           VARCHAR2(50),
  deal_flag      NUMBER(1) default 0,
  deal_time      DATE,
  creation_time  DATE default sysdate,
  guid           VARCHAR2(50),
  file_key       VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_SUPPLIER
  is 'IF_SUPPLIER供应商主数据中间表
IF_SUPPLIER供应商主数据中间表
';
comment on column IF_SUPPLIER.id
  is 'ID
ID
';
comment on column IF_SUPPLIER.sup_factory_id
  is '???????';
comment on column IF_SUPPLIER.supplier_no
  is '供应商代码
供应商代码
';
comment on column IF_SUPPLIER.chinese_name
  is '供应商中文名
供应商中文名
';
comment on column IF_SUPPLIER.detail_addr
  is '供应商详细地址
供应商详细地址
';
comment on column IF_SUPPLIER.sup_status
  is '1????2????3???';
comment on column IF_SUPPLIER.email
  is '联系邮箱
联系邮箱
';
comment on column IF_SUPPLIER.contact
  is '联系人
联系人
';
comment on column IF_SUPPLIER.mobile_no
  is '联系人移动电话
联系人移动电话
';
comment on column IF_SUPPLIER.tel_no
  is '联系人电话
联系人电话
';
comment on column IF_SUPPLIER.uda1
  is '预留字段1
预留字段1
';
comment on column IF_SUPPLIER.uda2
  is '预留字段2
预留字段2
';
comment on column IF_SUPPLIER.uda3
  is '预留字段3
预留字段3
';
comment on column IF_SUPPLIER.uda4
  is '预留字段4
预留字段4
';
comment on column IF_SUPPLIER.uda5
  is '预留字段5
预留字段5
';
comment on column IF_SUPPLIER.deal_flag
  is '0 ??? 1???';
comment on column IF_SUPPLIER.deal_time
  is '处理时间
处理时间
';
comment on column IF_SUPPLIER.creation_time
  is '创建时间
创建时间
';
comment on column IF_SUPPLIER.guid
  is 'GUID';
comment on column IF_SUPPLIER.file_key
  is '????';
create index IDX_IF_SUPPLIER1 on IF_SUPPLIER (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_SUPPLIER
  add constraint PK_IF_SUPPLIER primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_SUPPORTING_PART
prompt =================================
prompt
create table IF_SUPPORTING_PART
(
  partf_id            VARCHAR2(30),
  factory_code        VARCHAR2(10) not null,
  part_row_no         NUMBER(10),
  part_no             VARCHAR2(30),
  num                 NUMBER(18),
  use_age_amount_unit VARCHAR2(20),
  line_station        VARCHAR2(30),
  next_placement      VARCHAR2(30),
  purchase_type       VARCHAR2(10),
  do_flag             VARCHAR2(10),
  id                  NUMBER(19) not null,
  uda1                VARCHAR2(50),
  uda2                VARCHAR2(50),
  uda3                VARCHAR2(50),
  uda4                VARCHAR2(50),
  uda5                VARCHAR2(50),
  deal_flag           NUMBER(1) default 0,
  deal_time           DATE,
  creation_time       DATE default sysdate,
  guid                VARCHAR2(50),
  file_key            VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_SUPPORTING_PART
  is '???';
comment on column IF_SUPPORTING_PART.partf_id
  is '??';
comment on column IF_SUPPORTING_PART.factory_code
  is '??
??
';
comment on column IF_SUPPORTING_PART.part_row_no
  is '??????';
comment on column IF_SUPPORTING_PART.part_no
  is '????';
comment on column IF_SUPPORTING_PART.num
  is '??';
comment on column IF_SUPPORTING_PART.use_age_amount_unit
  is '????';
comment on column IF_SUPPORTING_PART.line_station
  is '?????';
comment on column IF_SUPPORTING_PART.next_placement
  is '????';
comment on column IF_SUPPORTING_PART.purchase_type
  is '????';
comment on column IF_SUPPORTING_PART.do_flag
  is '????';
comment on column IF_SUPPORTING_PART.id
  is 'ID
ID
';
comment on column IF_SUPPORTING_PART.uda1
  is '????1
????1
';
comment on column IF_SUPPORTING_PART.uda2
  is '????2
????2
';
comment on column IF_SUPPORTING_PART.uda3
  is '????3
????3
';
comment on column IF_SUPPORTING_PART.uda4
  is '????4
????4
';
comment on column IF_SUPPORTING_PART.uda5
  is '????5
????5
';
comment on column IF_SUPPORTING_PART.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_SUPPORTING_PART.deal_time
  is '????
????
';
comment on column IF_SUPPORTING_PART.creation_time
  is '????
????
????';
comment on column IF_SUPPORTING_PART.guid
  is 'GUID
GUID
GUID';
comment on column IF_SUPPORTING_PART.file_key
  is '????
????
????';

prompt
prompt Creating table IF_SW_ACCOUNT_BILL
prompt =================================
prompt
create table IF_SW_ACCOUNT_BILL
(
  id                NUMBER(19) not null,
  comp              VARCHAR2(10) not null,
  account_bill_no   VARCHAR2(30) not null,
  supplier_no       VARCHAR2(20),
  free_tax_amount   VARCHAR2(20),
  total_amount      VARCHAR2(20),
  total_tax         VARCHAR2(20),
  account_date      VARCHAR2(30),
  currency_type     VARCHAR2(20),
  rebate            VARCHAR2(20),
  rebate_desc       VARCHAR2(200),
  deduct_money      VARCHAR2(20),
  deduct_money_desc VARCHAR2(200),
  year_adjust       VARCHAR2(20),
  year_adjust_desc  VARCHAR2(200),
  mould_amount      VARCHAR2(20),
  mould_amount_desc VARCHAR2(200),
  pay_term          VARCHAR2(50),
  remark            VARCHAR2(300),
  uda1              VARCHAR2(200),
  uda2              VARCHAR2(200),
  uda3              VARCHAR2(200),
  uda4              VARCHAR2(200),
  uda5              VARCHAR2(200),
  deal_flag         VARCHAR2(10) default '0',
  deal_time         DATE,
  creation_time     DATE default sysdate,
  do_flag           VARCHAR2(10),
  guid              VARCHAR2(50),
  file_key          VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_SW_ACCOUNT_BILL
  is 'IF_SW_ACCOUNT_BILL????????
IF_SW_ACCOUNT_BILL????????
';
comment on column IF_SW_ACCOUNT_BILL.id
  is 'ID
ID
';
comment on column IF_SW_ACCOUNT_BILL.comp
  is '????
????
?????i-LMS???????';
comment on column IF_SW_ACCOUNT_BILL.account_bill_no
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_BILL.supplier_no
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_BILL.free_tax_amount
  is '????????
????????
????????';
comment on column IF_SW_ACCOUNT_BILL.total_amount
  is '???????
???????
????????';
comment on column IF_SW_ACCOUNT_BILL.total_tax
  is '???????
???????
????????';
comment on column IF_SW_ACCOUNT_BILL.account_date
  is '????
????
';
comment on column IF_SW_ACCOUNT_BILL.currency_type
  is '????
????
';
comment on column IF_SW_ACCOUNT_BILL.rebate
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_BILL.rebate_desc
  is '???????
???????
';
comment on column IF_SW_ACCOUNT_BILL.deduct_money
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_BILL.deduct_money_desc
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_BILL.year_adjust
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_BILL.year_adjust_desc
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_BILL.mould_amount
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_BILL.mould_amount_desc
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_BILL.pay_term
  is '????
????
';
comment on column IF_SW_ACCOUNT_BILL.remark
  is '????
????
';
comment on column IF_SW_ACCOUNT_BILL.uda1
  is '????1
????1
';
comment on column IF_SW_ACCOUNT_BILL.uda2
  is '????2
????2
';
comment on column IF_SW_ACCOUNT_BILL.uda3
  is '????3
????3
';
comment on column IF_SW_ACCOUNT_BILL.uda4
  is '????4
????4
';
comment on column IF_SW_ACCOUNT_BILL.uda5
  is '????5
????5
';
comment on column IF_SW_ACCOUNT_BILL.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_SW_ACCOUNT_BILL.deal_time
  is '????
????
';
comment on column IF_SW_ACCOUNT_BILL.creation_time
  is '????
????
????';
comment on column IF_SW_ACCOUNT_BILL.do_flag
  is '????
????
I-???U-???D-??';
comment on column IF_SW_ACCOUNT_BILL.guid
  is 'GUID
GUID
GUID';
comment on column IF_SW_ACCOUNT_BILL.file_key
  is '????
????
????';
create index IDX_IF_SW_ACCOUNT_BILL1 on IF_SW_ACCOUNT_BILL (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_SW_ACCOUNT_BILL
  add constraint PK_IF_SW_ACCOUNT_BILL primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_SW_ACCOUNT_BILL_DETAIL
prompt ========================================
prompt
create table IF_SW_ACCOUNT_BILL_DETAIL
(
  id                        NUMBER(19),
  account_bill_no           VARCHAR2(30) not null,
  account_bill_row_no       VARCHAR2(10) not null,
  purchase_order_no         VARCHAR2(50),
  purchase_row_no           VARCHAR2(10),
  rec_voucher_year          VARCHAR2(20),
  rec_voucher_bill_no       VARCHAR2(50),
  rec_voucher_row_no        VARCHAR2(10),
  ref_rec_voucher_bill      VARCHAR2(50),
  ref_rec_voucher_row_no    VARCHAR2(10),
  rec_date                  VARCHAR2(30),
  loan_flag                 VARCHAR2(10),
  price_status              VARCHAR2(10),
  eva_price                 VARCHAR2(20),
  official_price            VARCHAR2(20),
  adjust_diff_price         VARCHAR2(20),
  eva_price_percent         VARCHAR2(20),
  eva_settle_price          VARCHAR2(20),
  erp_factory_code          VARCHAR2(10),
  part_no                   VARCHAR2(30),
  supplier_no               VARCHAR2(20),
  rec_num                   VARCHAR2(20),
  part_unit                 VARCHAR2(20),
  pay_amount                VARCHAR2(20),
  tax_rate                  VARCHAR2(20),
  tax_amount                VARCHAR2(20),
  currency_type             VARCHAR2(20),
  uda1                      VARCHAR2(50),
  uda2                      VARCHAR2(50),
  uda3                      VARCHAR2(50),
  uda4                      VARCHAR2(50),
  uda5                      VARCHAR2(50),
  eva_price_unit            VARCHAR2(20),
  official_price_unit       VARCHAR2(20),
  ref_year_rec_voucher_bill VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_SW_ACCOUNT_BILL_DETAIL
  is 'IF_SW_ACCOUNT_BILL_DETAIL??????????
IF_SW_ACCOUNT_BILL_DETAIL??????????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.id
  is '??ID
??ID
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.account_bill_no
  is '????
????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.account_bill_row_no
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.purchase_order_no
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.purchase_row_no
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.rec_voucher_year
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.rec_voucher_bill_no
  is '????
????
????????????';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.rec_voucher_row_no
  is '???????
???????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.ref_rec_voucher_bill
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.ref_rec_voucher_row_no
  is '?????????
?????????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.rec_date
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.loan_flag
  is '????
????
S-???H-??';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.price_status
  is '????
????
1-????2-????3-???';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.eva_price
  is '???(???)
???(???)
????????';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.official_price
  is '???(???)
???(???)
????????';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.adjust_diff_price
  is '????(???)
????(???)
????????';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.eva_price_percent
  is '??(???)???
??(???)???
???????????????15????15%??';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.eva_settle_price
  is '??????
??????
????????';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.erp_factory_code
  is '????
????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.part_no
  is '???
???
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.supplier_no
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.rec_num
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.part_unit
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.pay_amount
  is '??(???)??
??(???)??
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.tax_rate
  is '??
??
??????15????15%??';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.tax_amount
  is '??
??
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.currency_type
  is '????
????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.uda1
  is '????1
????1
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.uda2
  is '????2
????2
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.uda3
  is '????3
????3
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.uda4
  is '????4
????4
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.uda5
  is '????5
????5
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.eva_price_unit
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.official_price_unit
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_BILL_DETAIL.ref_year_rec_voucher_bill
  is '??????
??????
';
create index IDX_IF_SW_ACCOU_BILL_DETAIL1 on IF_SW_ACCOUNT_BILL_DETAIL (ID)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_SW_ACCOUNT_INVOICE
prompt ====================================
prompt
create table IF_SW_ACCOUNT_INVOICE
(
  account_bill_no   VARCHAR2(30) not null,
  comp              VARCHAR2(10) not null,
  invoice_date      DATE,
  supplier_no       VARCHAR2(20),
  invoice_amount    NUMBER(19,3),
  tax_amount        NUMBER(19,3),
  rebate            VARCHAR2(20),
  rebate_desc       VARCHAR2(200),
  deduct_money      VARCHAR2(20),
  deduct_money_desc VARCHAR2(200),
  year_adjust       VARCHAR2(20),
  year_adjust_desc  VARCHAR2(200),
  mould_amount      VARCHAR2(20),
  mould_amount_desc VARCHAR2(200),
  currency_type     VARCHAR2(20),
  pay_term          VARCHAR2(50),
  uda1              VARCHAR2(50),
  uda2              VARCHAR2(50),
  uda3              VARCHAR2(50),
  uda4              VARCHAR2(50),
  uda5              VARCHAR2(50),
  deal_flag         NUMBER(1) default 0,
  deal_time         DATE,
  creation_time     DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_SW_ACCOUNT_INVOICE
  is 'IF_SW_ACCOUNT_INVOICE????????????
IF_SW_ACCOUNT_INVOICE????????????
';
comment on column IF_SW_ACCOUNT_INVOICE.account_bill_no
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_INVOICE.comp
  is '????
????
?????i-LMS???????';
comment on column IF_SW_ACCOUNT_INVOICE.invoice_date
  is '????
????
????';
comment on column IF_SW_ACCOUNT_INVOICE.supplier_no
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_INVOICE.invoice_amount
  is '???????
???????
';
comment on column IF_SW_ACCOUNT_INVOICE.tax_amount
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_INVOICE.rebate
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_INVOICE.rebate_desc
  is '???????
???????
';
comment on column IF_SW_ACCOUNT_INVOICE.deduct_money
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_INVOICE.deduct_money_desc
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_INVOICE.year_adjust
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_INVOICE.year_adjust_desc
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_INVOICE.mould_amount
  is '?????
?????
';
comment on column IF_SW_ACCOUNT_INVOICE.mould_amount_desc
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_INVOICE.currency_type
  is '????
????
';
comment on column IF_SW_ACCOUNT_INVOICE.pay_term
  is '????
????
';
comment on column IF_SW_ACCOUNT_INVOICE.uda1
  is '????1
????1
';
comment on column IF_SW_ACCOUNT_INVOICE.uda2
  is '????2
????2
';
comment on column IF_SW_ACCOUNT_INVOICE.uda3
  is '????3
????3
';
comment on column IF_SW_ACCOUNT_INVOICE.uda4
  is '????4
????4
';
comment on column IF_SW_ACCOUNT_INVOICE.uda5
  is '????5
????5
';
comment on column IF_SW_ACCOUNT_INVOICE.deal_flag
  is '????
????
0 ??? 1??? 2??';
comment on column IF_SW_ACCOUNT_INVOICE.deal_time
  is '????
????
';
comment on column IF_SW_ACCOUNT_INVOICE.creation_time
  is '????
????
????';
create index IDX_IF_SW_ACCOUNT_INVOICE1 on IF_SW_ACCOUNT_INVOICE (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_SW_ACCOUNT_INVOICE
  add constraint PK_IF_SW_ACCOUNT_INVOICE primary key (ACCOUNT_BILL_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_SW_ACCOUNT_INVOICE_DETAIL
prompt ===========================================
prompt
create table IF_SW_ACCOUNT_INVOICE_DETAIL
(
  account_bill_no       VARCHAR2(30) not null,
  invoice_no            VARCHAR2(50),
  invoice_code          VARCHAR2(50),
  single_invoice_amount NUMBER(19,3),
  single_tax_amount     NUMBER(19,3),
  invoice_date          DATE,
  check_code            VARCHAR2(30),
  invoice_net_price     NUMBER(19,3),
  uda1                  VARCHAR2(50),
  uda2                  VARCHAR2(50),
  uda3                  VARCHAR2(50),
  uda4                  VARCHAR2(50),
  uda5                  VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_SW_ACCOUNT_INVOICE_DETAIL
  is 'IF_SW_ACCOUNT_INVOICE_DETAIL??????????????
IF_SW_ACCOUNT_INVOICE_DETAIL??????????????
';
comment on column IF_SW_ACCOUNT_INVOICE_DETAIL.account_bill_no
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_INVOICE_DETAIL.invoice_no
  is '?????
?????
?????i-LMS???????';
comment on column IF_SW_ACCOUNT_INVOICE_DETAIL.invoice_code
  is '????
????
';
comment on column IF_SW_ACCOUNT_INVOICE_DETAIL.single_invoice_amount
  is '???????
???????
';
comment on column IF_SW_ACCOUNT_INVOICE_DETAIL.single_tax_amount
  is '????
????
';
comment on column IF_SW_ACCOUNT_INVOICE_DETAIL.invoice_date
  is '??????
??????
';
comment on column IF_SW_ACCOUNT_INVOICE_DETAIL.check_code
  is '???
???
';
comment on column IF_SW_ACCOUNT_INVOICE_DETAIL.invoice_net_price
  is '???????????
???????????
';
comment on column IF_SW_ACCOUNT_INVOICE_DETAIL.uda1
  is '????1
????1
';
comment on column IF_SW_ACCOUNT_INVOICE_DETAIL.uda2
  is '????2
????2
';
comment on column IF_SW_ACCOUNT_INVOICE_DETAIL.uda3
  is '????3
????3
';
comment on column IF_SW_ACCOUNT_INVOICE_DETAIL.uda4
  is '????4
????4
';
comment on column IF_SW_ACCOUNT_INVOICE_DETAIL.uda5
  is '????5
????5
';
create index IDX_IF_SW_AI_DETAIL on IF_SW_ACCOUNT_INVOICE_DETAIL (ACCOUNT_BILL_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_SW_DEMAND_FORECAST
prompt ====================================
prompt
create table IF_SW_DEMAND_FORECAST
(
  id            NUMBER(19) not null,
  comp          VARCHAR2(10),
  version_no    VARCHAR2(20),
  rec_date      VARCHAR2(30),
  phase         VARCHAR2(20),
  supplier_no   VARCHAR2(20),
  part_id       VARCHAR2(30),
  fore_type     VARCHAR2(10),
  end_date      VARCHAR2(30),
  order_num     VARCHAR2(10),
  part_unit     VARCHAR2(20),
  start_date    VARCHAR2(30),
  model_code    VARCHAR2(20),
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate,
  part_short_no VARCHAR2(10),
  part_name_cn  VARCHAR2(150),
  chinese_name  VARCHAR2(150),
  guid          VARCHAR2(50),
  file_key      VARCHAR2(50),
  obj_month     VARCHAR2(30),
  publish_month VARCHAR2(30),
  workcenter    VARCHAR2(10),
  obj_week      VARCHAR2(30),
  publish_week  VARCHAR2(30),
  seq           VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_SW_DEMAND_FORECAST
  is 'IF_SW_DEMAND_FORECAST?????????
IF_SW_DEMAND_FORECAST?????????
';
comment on column IF_SW_DEMAND_FORECAST.id
  is 'ID
ID
';
comment on column IF_SW_DEMAND_FORECAST.comp
  is '??
??
';
comment on column IF_SW_DEMAND_FORECAST.version_no
  is '???
???
';
comment on column IF_SW_DEMAND_FORECAST.rec_date
  is '??????
??????
??????????1?????????2018-08-01?8???????yyyy-MM-dd HH:mm:ss';
comment on column IF_SW_DEMAND_FORECAST.phase
  is '????
????
?????';
comment on column IF_SW_DEMAND_FORECAST.supplier_no
  is '?????
?????
';
comment on column IF_SW_DEMAND_FORECAST.part_id
  is '????
????
';
comment on column IF_SW_DEMAND_FORECAST.fore_type
  is '????
????
???????';
comment on column IF_SW_DEMAND_FORECAST.end_date
  is '????
????
???yyyy-MM-dd HH:mm:ss';
comment on column IF_SW_DEMAND_FORECAST.order_num
  is '????
????
';
comment on column IF_SW_DEMAND_FORECAST.part_unit
  is '????
????
';
comment on column IF_SW_DEMAND_FORECAST.start_date
  is '????
????
???yyyy-MM-dd HH:mm:ss';
comment on column IF_SW_DEMAND_FORECAST.model_code
  is '??
??
??';
comment on column IF_SW_DEMAND_FORECAST.uda1
  is '????1
????1
';
comment on column IF_SW_DEMAND_FORECAST.uda2
  is '????2
????2
';
comment on column IF_SW_DEMAND_FORECAST.uda3
  is '????3
????3
';
comment on column IF_SW_DEMAND_FORECAST.uda4
  is '????4
????4
';
comment on column IF_SW_DEMAND_FORECAST.uda5
  is '????5
????5
';
comment on column IF_SW_DEMAND_FORECAST.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_SW_DEMAND_FORECAST.deal_time
  is '????
????
';
comment on column IF_SW_DEMAND_FORECAST.creation_time
  is '????
????
';
comment on column IF_SW_DEMAND_FORECAST.part_short_no
  is '????
????
???????';
comment on column IF_SW_DEMAND_FORECAST.part_name_cn
  is '??????
??????
';
comment on column IF_SW_DEMAND_FORECAST.chinese_name
  is '??????
??????
';
comment on column IF_SW_DEMAND_FORECAST.guid
  is 'GUID
GUID
GUID';
comment on column IF_SW_DEMAND_FORECAST.file_key
  is '????
????
????';
comment on column IF_SW_DEMAND_FORECAST.obj_month
  is '???
???
???';
comment on column IF_SW_DEMAND_FORECAST.publish_month
  is '???
???
???';
comment on column IF_SW_DEMAND_FORECAST.seq
  is '???????????????????';
create index IDX_IF_SW_DEMAND_FORECAST1 on IF_SW_DEMAND_FORECAST (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_SW_DEMAND_FORECAST
  add constraint PK_IF_SW_DEMAND_FORECAST primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_SW_MATERIAL_ORDER_REPLY
prompt =========================================
prompt
create table IF_SW_MATERIAL_ORDER_REPLY
(
  comp               VARCHAR2(10) not null,
  purchase_order_no  VARCHAR2(50) not null,
  reply_seq_no       VARCHAR2(10) not null,
  purchase_row_no    VARCHAR2(10) not null,
  plan_delivery_date DATE,
  plan_delivery_num  NUMBER(10),
  reply_msg          VARCHAR2(300),
  reply_date         DATE,
  uda1               VARCHAR2(50),
  uda2               VARCHAR2(50),
  uda3               VARCHAR2(50),
  uda4               VARCHAR2(50),
  uda5               VARCHAR2(50),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  creation_time      DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_SW_MATERIAL_ORDER_REPLY
  is 'IF_SW_MATERIAL_ORDER_REPLY???????????
IF_SW_MATERIAL_ORDER_REPLY???????????
';
comment on column IF_SW_MATERIAL_ORDER_REPLY.comp
  is '??
??
';
comment on column IF_SW_MATERIAL_ORDER_REPLY.purchase_order_no
  is '?????
?????
';
comment on column IF_SW_MATERIAL_ORDER_REPLY.reply_seq_no
  is '??????
??????
0:??1:?';
comment on column IF_SW_MATERIAL_ORDER_REPLY.purchase_row_no
  is '??????
??????
';
comment on column IF_SW_MATERIAL_ORDER_REPLY.plan_delivery_date
  is '??????
??????
';
comment on column IF_SW_MATERIAL_ORDER_REPLY.plan_delivery_num
  is '??????
??????
';
comment on column IF_SW_MATERIAL_ORDER_REPLY.reply_msg
  is '??????
??????
';
comment on column IF_SW_MATERIAL_ORDER_REPLY.reply_date
  is '??????
??????
yyyy-MM-dd';
comment on column IF_SW_MATERIAL_ORDER_REPLY.uda1
  is '????1
????1
';
comment on column IF_SW_MATERIAL_ORDER_REPLY.uda2
  is '????2
????2
';
comment on column IF_SW_MATERIAL_ORDER_REPLY.uda3
  is '????3
????3
';
comment on column IF_SW_MATERIAL_ORDER_REPLY.uda4
  is '????4
????4
';
comment on column IF_SW_MATERIAL_ORDER_REPLY.uda5
  is '????5
????5
';
comment on column IF_SW_MATERIAL_ORDER_REPLY.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_SW_MATERIAL_ORDER_REPLY.deal_time
  is '????
????
';
comment on column IF_SW_MATERIAL_ORDER_REPLY.creation_time
  is '????
????
????';
create index IDX_IF_SW_ORDER_REPLY1 on IF_SW_MATERIAL_ORDER_REPLY (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_SW_NON_STANDARD
prompt =================================
prompt
create table IF_SW_NON_STANDARD
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  order_no           VARCHAR2(50),
  sale_no            VARCHAR2(50),
  sale_rowno         NUMBER(10),
  supplier_no        VARCHAR2(20),
  sup_factory        VARCHAR2(10),
  supplier_name      VARCHAR2(150),
  part_no            VARCHAR2(30),
  part_short_no      VARCHAR2(10),
  part_name_cn       VARCHAR2(150),
  order_num          NUMBER(19),
  creation_user      VARCHAR2(30),
  creation_time      DATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  last_check_id      NUMBER(19),
  pic_upload_status  NUMBER(2) default 0,
  deal_flag          NUMBER(2),
  deal_time          DATE,
  do_flag            VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column IF_SW_NON_STANDARD.last_check_id
  is '最后检查ID';
comment on column IF_SW_NON_STANDARD.pic_upload_status
  is '0：未上传 1：已上传';

prompt
prompt Creating table IF_SW_NON_STANDARD_DETAIL
prompt ========================================
prompt
create table IF_SW_NON_STANDARD_DETAIL
(
  sale_no            VARCHAR2(50),
  sale_rowno         NUMBER(10),
  part_no            VARCHAR2(30),
  feature            VARCHAR2(20),
  feature_type       VARCHAR2(2),
  feature_value      VARCHAR2(500),
  sort_no            NUMBER(5),
  creation_time      DATE,
  last_modified_time DATE,
  deal_flag          VARCHAR2(10),
  deal_time          DATE,
  do_flag            VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column IF_SW_NON_STANDARD_DETAIL.sale_no
  is '销售单号';
comment on column IF_SW_NON_STANDARD_DETAIL.sale_rowno
  is '销售单行号';
comment on column IF_SW_NON_STANDARD_DETAIL.part_no
  is '零件号';
comment on column IF_SW_NON_STANDARD_DETAIL.feature
  is '属性名称';
comment on column IF_SW_NON_STANDARD_DETAIL.feature_type
  is '属性类型';
comment on column IF_SW_NON_STANDARD_DETAIL.feature_value
  is '属性值';
comment on column IF_SW_NON_STANDARD_DETAIL.sort_no
  is '排序码';

prompt
prompt Creating table IF_SW_NON_STANDAR_CHECK
prompt ======================================
prompt
create table IF_SW_NON_STANDAR_CHECK
(
  id               NUMBER(19) not null,
  sale_no          VARCHAR2(50),
  sale_rowno       NUMBER(10),
  part_no          VARCHAR2(50),
  remark           VARCHAR2(300),
  check_result     NUMBER(1) default 0,
  checker          VARCHAR2(30),
  check_time       DATE,
  creation_user    VARCHAR2(30),
  creation_user_ip VARCHAR2(30),
  deal_flag        VARCHAR2(10),
  deal_time        DATE,
  do_flag          VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column IF_SW_NON_STANDAR_CHECK.check_result
  is '0：未检查
1：不通过
2：通过';

prompt
prompt Creating table IF_SW_NON_STAND_PIC
prompt ==================================
prompt
create table IF_SW_NON_STAND_PIC
(
  check_id           NUMBER(19),
  sale_no            VARCHAR2(50),
  sale_rowno         NUMBER(10),
  part_no            VARCHAR2(30),
  pic_type           NUMBER(2),
  pic_id             NUMBER(19),
  creation_time      DATE,
  creation_user      VARCHAR2(30),
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  deal_flag          VARCHAR2(10),
  deal_time          DATE,
  do_flag            VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column IF_SW_NON_STAND_PIC.pic_type
  is '0：实物上传的图片  1：反馈的图片';

prompt
prompt Creating table IF_SW_ORDER
prompt ==========================
prompt
create table IF_SW_ORDER
(
  id                    NUMBER(19) not null,
  comp                  VARCHAR2(10) not null,
  purchase_order_no     VARCHAR2(50) not null,
  logistics_orderno     VARCHAR2(50),
  supplier_no           VARCHAR2(20),
  sup_shipment_place_no VARCHAR2(20),
  order_type            VARCHAR2(10),
  order_place           VARCHAR2(30),
  order_issue_date      VARCHAR2(30),
  dao_huo_time          VARCHAR2(30),
  depot_no              VARCHAR2(10),
  sp_type               VARCHAR2(10),
  hms_order_no          VARCHAR2(50),
  rec_address           VARCHAR2(300),
  rec_user              VARCHAR2(30),
  rec_tel               VARCHAR2(30),
  planner               VARCHAR2(30),
  uda1                  VARCHAR2(50),
  uda2                  VARCHAR2(50),
  uda3                  VARCHAR2(50),
  uda4                  VARCHAR2(50),
  uda5                  VARCHAR2(50),
  deal_flag             NUMBER(1) default 0,
  deal_time             DATE,
  creation_time         DATE default sysdate,
  guid                  VARCHAR2(50),
  file_key              VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_SW_ORDER
  is 'IF_SW_ORDER???????
IF_SW_ORDER???????
';
comment on column IF_SW_ORDER.id
  is 'ID
ID
';
comment on column IF_SW_ORDER.comp
  is '??
??
';
comment on column IF_SW_ORDER.purchase_order_no
  is '?????
?????
';
comment on column IF_SW_ORDER.logistics_orderno
  is '????
????
';
comment on column IF_SW_ORDER.supplier_no
  is '?????
?????
';
comment on column IF_SW_ORDER.sup_shipment_place_no
  is '????????
????????
';
comment on column IF_SW_ORDER.order_type
  is '????
????
01:?????02:?????03:????:?04:?????05:??????11:??????12:????(SP)?14??????';
comment on column IF_SW_ORDER.order_place
  is '????
????
??????(??????????????)';
comment on column IF_SW_ORDER.order_issue_date
  is '??????
??????
yyyy-MM-dd HH:mm:ss';
comment on column IF_SW_ORDER.dao_huo_time
  is '??????
??????
yyyy-MM-dd HH:mm:ss??????,????????';
comment on column IF_SW_ORDER.depot_no
  is '????
????
?????????????????';
comment on column IF_SW_ORDER.sp_type
  is 'SP??
SP??
?????(1:????2?????3:????) ???';
comment on column IF_SW_ORDER.hms_order_no
  is 'HMS???
HMS???
??????';
comment on column IF_SW_ORDER.rec_address
  is '??????
??????
????????????????';
comment on column IF_SW_ORDER.rec_user
  is '?????
?????
???????????????';
comment on column IF_SW_ORDER.rec_tel
  is '??????
??????
????????????????';
comment on column IF_SW_ORDER.planner
  is '???/???
???/???
????';
comment on column IF_SW_ORDER.uda1
  is '????1
????1
';
comment on column IF_SW_ORDER.uda2
  is '????2
????2
';
comment on column IF_SW_ORDER.uda3
  is '????3
????3
';
comment on column IF_SW_ORDER.uda4
  is '????4
????4
';
comment on column IF_SW_ORDER.uda5
  is '????5
????5
';
comment on column IF_SW_ORDER.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_SW_ORDER.deal_time
  is '????
????
';
comment on column IF_SW_ORDER.creation_time
  is '????
????
????';
comment on column IF_SW_ORDER.guid
  is 'GUID
GUID
GUID';
comment on column IF_SW_ORDER.file_key
  is '????
????
????';
create index IDX_IF_SW_ORDER1 on IF_SW_ORDER (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_SW_ORDER
  add constraint PK_IF_SW_ORDER primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_SW_ORDER_DETAIL
prompt =================================
prompt
create table IF_SW_ORDER_DETAIL
(
  id                     NUMBER(19) not null,
  purchase_order_no      VARCHAR2(50) not null,
  purchase_row_no        VARCHAR2(10) not null,
  logistics_orderno      VARCHAR2(50),
  logistics_order_row_no VARCHAR2(10),
  zg_flag                VARCHAR2(10),
  part_id                VARCHAR2(30),
  order_num              VARCHAR2(10),
  cancel_num             VARCHAR2(10),
  order_unit             VARCHAR2(20),
  daohuo_time            VARCHAR2(30),
  depot_no               VARCHAR2(20),
  package_num            VARCHAR2(10),
  zk_flag                VARCHAR2(10),
  zbzgg                  VARCHAR2(128),
  zstock                 VARCHAR2(32),
  lgpbe                  VARCHAR2(32),
  zkostl                 VARCHAR2(32),
  ktext                  VARCHAR2(100),
  do_flag                VARCHAR2(2),
  uda1                   VARCHAR2(50),
  uda2                   VARCHAR2(50),
  uda3                   VARCHAR2(50),
  uda4                   VARCHAR2(50),
  uda5                   VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_SW_ORDER_DETAIL
  is 'IF_SW_ORDER_DETAIL?????????
IF_SW_ORDER_DETAIL?????????
';
comment on column IF_SW_ORDER_DETAIL.id
  is '??ID
??ID
';
comment on column IF_SW_ORDER_DETAIL.purchase_order_no
  is '?????
?????
';
comment on column IF_SW_ORDER_DETAIL.purchase_row_no
  is '??????
??????
';
comment on column IF_SW_ORDER_DETAIL.logistics_orderno
  is '????
????
';
comment on column IF_SW_ORDER_DETAIL.logistics_order_row_no
  is '??????
??????
?????????';
comment on column IF_SW_ORDER_DETAIL.zg_flag
  is '?????
?????
0:??1:?';
comment on column IF_SW_ORDER_DETAIL.part_id
  is '????
????
';
comment on column IF_SW_ORDER_DETAIL.order_num
  is '????
????
';
comment on column IF_SW_ORDER_DETAIL.cancel_num
  is '????
????
';
comment on column IF_SW_ORDER_DETAIL.order_unit
  is '?????
?????
';
comment on column IF_SW_ORDER_DETAIL.daohuo_time
  is '??????
??????
yyyy-MM-dd HH:mm:ss';
comment on column IF_SW_ORDER_DETAIL.depot_no
  is '????
????
????????';
comment on column IF_SW_ORDER_DETAIL.package_num
  is '???
???
?????HMS???';
comment on column IF_SW_ORDER_DETAIL.zk_flag
  is '????
????
?????(0???1??)';
comment on column IF_SW_ORDER_DETAIL.zbzgg
  is '????
????
??????';
comment on column IF_SW_ORDER_DETAIL.zstock
  is '????
????
??????';
comment on column IF_SW_ORDER_DETAIL.lgpbe
  is '?????
?????
??????';
comment on column IF_SW_ORDER_DETAIL.zkostl
  is '??????
??????
??????';
comment on column IF_SW_ORDER_DETAIL.ktext
  is '????????/??
????????/??
??????';
comment on column IF_SW_ORDER_DETAIL.do_flag
  is '????
????
I-???U-???D-????????????????????????????????????????';
comment on column IF_SW_ORDER_DETAIL.uda1
  is '????1
????1
';
comment on column IF_SW_ORDER_DETAIL.uda2
  is '????2
????2
';
comment on column IF_SW_ORDER_DETAIL.uda3
  is '????3
????3
';
comment on column IF_SW_ORDER_DETAIL.uda4
  is '????4
????4
';
comment on column IF_SW_ORDER_DETAIL.uda5
  is '????5
????5
';
create index IDX_IF_SW_ORDER_DETAIL1 on IF_SW_ORDER_DETAIL (ID)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_TACT_TIME
prompt ===========================
prompt
create table IF_TACT_TIME
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10) not null,
  work_center   VARCHAR2(20) not null,
  pro_line      VARCHAR2(20) not null,
  eff_date      VARCHAR2(30),
  jph           VARCHAR2(20),
  oee           VARCHAR2(20),
  produce_time  VARCHAR2(20),
  pro_capacity  VARCHAR2(30),
  remark        VARCHAR2(200),
  doflag        VARCHAR2(10),
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate,
  guid          VARCHAR2(50),
  file_key      VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_TACT_TIME
  is 'IF_TACT_TIME???????
IF_TACT_TIME???????
';
comment on column IF_TACT_TIME.id
  is 'ID
ID
';
comment on column IF_TACT_TIME.factory_code
  is '??
??
';
comment on column IF_TACT_TIME.work_center
  is '????
????
';
comment on column IF_TACT_TIME.pro_line
  is '???
???
?????????';
comment on column IF_TACT_TIME.eff_date
  is '????
????
';
comment on column IF_TACT_TIME.jph
  is 'JPH
JPH
';
comment on column IF_TACT_TIME.oee
  is '???
???
';
comment on column IF_TACT_TIME.produce_time
  is '????
????
';
comment on column IF_TACT_TIME.pro_capacity
  is '????
????
';
comment on column IF_TACT_TIME.remark
  is '??
??
';
comment on column IF_TACT_TIME.doflag
  is '????
????
I-???U-???D-??';
comment on column IF_TACT_TIME.uda1
  is '????1
????1
';
comment on column IF_TACT_TIME.uda2
  is '????2
????2
';
comment on column IF_TACT_TIME.uda3
  is '????3
????3
';
comment on column IF_TACT_TIME.uda4
  is '????4
????4
';
comment on column IF_TACT_TIME.uda5
  is '????5
????5
';
comment on column IF_TACT_TIME.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_TACT_TIME.deal_time
  is '????
????
';
comment on column IF_TACT_TIME.creation_time
  is '????
????
';
comment on column IF_TACT_TIME.guid
  is 'GUID
GUID
GUID';
comment on column IF_TACT_TIME.file_key
  is '????
????
????';
alter table IF_TACT_TIME
  add constraint PK_IF_TACT_TIME primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_VEH_CONF_ITEM
prompt ===============================
prompt
create table IF_VEH_CONF_ITEM
(
  id NUMBER(19) not null
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_VEH_CONF_ITEM
  is 'IF_VEH_CONF_ITEM??????????
IF_VEH_CONF_ITEM??????????
';
comment on column IF_VEH_CONF_ITEM.id
  is 'ID
ID
';

prompt
prompt Creating table IF_VEH_LOCK_PLAN
prompt ===============================
prompt
create table IF_VEH_LOCK_PLAN
(
  id                   NUMBER(19) not null,
  factory_code         VARCHAR2(10) not null,
  pro_line             VARCHAR2(20),
  order_no             VARCHAR2(50) not null,
  erp_order_no         VARCHAR2(50),
  sort_id              VARCHAR2(20),
  phase                VARCHAR2(10),
  mtoc                 VARCHAR2(64),
  weon_time            VARCHAR2(30),
  afoff_time           VARCHAR2(30),
  vin                  VARCHAR2(20),
  work_shop_pro_line   VARCHAR2(20),
  model_code           VARCHAR2(20),
  veh_type             VARCHAR2(20),
  route_code           VARCHAR2(20),
  vehicle_level_desc_s VARCHAR2(20),
  material_no_s        VARCHAR2(20),
  sun_roof_s           VARCHAR2(20),
  in_color_desc_s      VARCHAR2(20),
  out_color_desc_s     VARCHAR2(20),
  main_model_code_s    VARCHAR2(20),
  battery_power_s      VARCHAR2(20),
  uda1                 VARCHAR2(50),
  uda2                 VARCHAR2(50),
  uda3                 VARCHAR2(50),
  uda4                 VARCHAR2(50),
  uda5                 VARCHAR2(50),
  order_status         NUMBER(2) default 0,
  deal_flag            NUMBER(1) default 0,
  deal_time            DATE,
  creation_time        DATE default sysdate,
  guid                 VARCHAR2(50),
  file_key             VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_VEH_LOCK_PLAN
  is 'IF_VEH_LOCK_PLAN???????????
IF_VEH_LOCK_PLAN???????????
';
comment on column IF_VEH_LOCK_PLAN.id
  is 'ID
ID
';
comment on column IF_VEH_LOCK_PLAN.factory_code
  is '??
??
';
comment on column IF_VEH_LOCK_PLAN.pro_line
  is '???
???
????????';
comment on column IF_VEH_LOCK_PLAN.order_no
  is '?????
?????
';
comment on column IF_VEH_LOCK_PLAN.erp_order_no
  is 'ERP???
ERP???
ERP???';
comment on column IF_VEH_LOCK_PLAN.sort_id
  is '???
???
';
comment on column IF_VEH_LOCK_PLAN.phase
  is '????
????
';
comment on column IF_VEH_LOCK_PLAN.mtoc
  is 'MTOC
MTOC
';
comment on column IF_VEH_LOCK_PLAN.weon_time
  is '????????????
????????????
??????????????????????';
comment on column IF_VEH_LOCK_PLAN.afoff_time
  is '??????
??????
';
comment on column IF_VEH_LOCK_PLAN.vin
  is 'VIN?
VIN?
';
comment on column IF_VEH_LOCK_PLAN.work_shop_pro_line
  is '??
??
';
comment on column IF_VEH_LOCK_PLAN.model_code
  is '??
??
??';
comment on column IF_VEH_LOCK_PLAN.veh_type
  is '????
????
????????';
comment on column IF_VEH_LOCK_PLAN.route_code
  is '????
????
??????';
comment on column IF_VEH_LOCK_PLAN.vehicle_level_desc_s
  is '????';
comment on column IF_VEH_LOCK_PLAN.material_no_s
  is '?????';
comment on column IF_VEH_LOCK_PLAN.sun_roof_s
  is '??';
comment on column IF_VEH_LOCK_PLAN.in_color_desc_s
  is '????';
comment on column IF_VEH_LOCK_PLAN.out_color_desc_s
  is '????';
comment on column IF_VEH_LOCK_PLAN.main_model_code_s
  is '?????';
comment on column IF_VEH_LOCK_PLAN.battery_power_s
  is '????';
comment on column IF_VEH_LOCK_PLAN.uda1
  is '????1
????1
';
comment on column IF_VEH_LOCK_PLAN.uda2
  is '????2
????2
';
comment on column IF_VEH_LOCK_PLAN.uda3
  is '????3
????3
';
comment on column IF_VEH_LOCK_PLAN.uda4
  is '????4
????4
';
comment on column IF_VEH_LOCK_PLAN.uda5
  is '????5
????5
';
comment on column IF_VEH_LOCK_PLAN.order_status
  is '????
????
0????
10????
15???WE-MB?
20????
30????';
comment on column IF_VEH_LOCK_PLAN.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_VEH_LOCK_PLAN.deal_time
  is '????
????
';
comment on column IF_VEH_LOCK_PLAN.creation_time
  is '????
????
';
comment on column IF_VEH_LOCK_PLAN.guid
  is 'GUID
GUID
GUID';
comment on column IF_VEH_LOCK_PLAN.file_key
  is '????
????
????';
create index IDX_IF_VEH_LOCK_PLAN1 on IF_VEH_LOCK_PLAN (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_IF_VEH_LOCK_PLAN2 on IF_VEH_LOCK_PLAN (ORDER_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_IF_VEH_LOCK_PLAN3 on IF_VEH_LOCK_PLAN (VIN)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_IF_VEH_LOCK_PLAN4 on IF_VEH_LOCK_PLAN (TO_DATE(WEON_TIME,'yyyy-mm-dd hh24:mi:ss'))
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table IF_VEH_LOCK_PLAN
  add constraint PK_IF_VEH_LOCK_PLAN primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_VEH_LOCK_PLAN_HIS
prompt ===================================
prompt
create table IF_VEH_LOCK_PLAN_HIS
(
  id                   NUMBER(19),
  factory_code         VARCHAR2(10),
  pro_line             VARCHAR2(20),
  order_no             VARCHAR2(50),
  erp_order_no         VARCHAR2(50),
  sort_id              VARCHAR2(20),
  phase                VARCHAR2(10),
  mtoc                 VARCHAR2(64),
  weon_time            VARCHAR2(30),
  afoff_time           VARCHAR2(30),
  vin                  VARCHAR2(20),
  work_shop_pro_line   VARCHAR2(20),
  model_code           VARCHAR2(20),
  veh_type             VARCHAR2(20),
  route_code           VARCHAR2(20),
  order_status         NUMBER(2),
  vehicle_level_desc_s VARCHAR2(50),
  material_no_s        VARCHAR2(50),
  sun_roof_s           VARCHAR2(50),
  in_color_desc_s      VARCHAR2(50),
  out_color_desc_s     VARCHAR2(50),
  main_model_code_s    VARCHAR2(50),
  battery_power_s      VARCHAR2(100),
  uda1                 VARCHAR2(50),
  uda2                 VARCHAR2(50),
  uda3                 VARCHAR2(50),
  uda4                 VARCHAR2(50),
  uda5                 VARCHAR2(50),
  deal_flag            NUMBER(1),
  deal_time            DATE,
  creation_time        DATE,
  guid                 VARCHAR2(50),
  file_key             VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table IF_VEH_PASS
prompt ==========================
prompt
create table IF_VEH_PASS
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10) not null,
  order_no      VARCHAR2(50) not null,
  erp_order_no  VARCHAR2(50),
  station_code  VARCHAR2(20) not null,
  pass_time     VARCHAR2(30),
  vin           VARCHAR2(20),
  phase         VARCHAR2(10),
  mtoc          VARCHAR2(64),
  model_code    VARCHAR2(20),
  wc_seqno      VARCHAR2(3),
  pl_seqno      VARCHAR2(6),
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate,
  guid          VARCHAR2(50),
  file_key      VARCHAR2(50),
  inv_flag      NUMBER(1) default 0,
  inv_time      DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_VEH_PASS
  is 'IF_VEH_PASS???????????
IF_VEH_PASS???????????
';
comment on column IF_VEH_PASS.id
  is 'ID
ID
';
comment on column IF_VEH_PASS.factory_code
  is '??
??
';
comment on column IF_VEH_PASS.order_no
  is '?????
?????
?????';
comment on column IF_VEH_PASS.erp_order_no
  is 'ERP???
ERP???
ERP???';
comment on column IF_VEH_PASS.station_code
  is '????
????
';
comment on column IF_VEH_PASS.pass_time
  is '????
????
';
comment on column IF_VEH_PASS.vin
  is 'VIN?
VIN?
';
comment on column IF_VEH_PASS.phase
  is '????
????
';
comment on column IF_VEH_PASS.mtoc
  is 'MTOC
MTOC
';
comment on column IF_VEH_PASS.model_code
  is '??
??
';
comment on column IF_VEH_PASS.wc_seqno
  is '?????
?????
';
comment on column IF_VEH_PASS.pl_seqno
  is '?????
?????
';
comment on column IF_VEH_PASS.uda1
  is '????1
????1
A16?A28';
comment on column IF_VEH_PASS.uda2
  is '????2
????2
';
comment on column IF_VEH_PASS.uda3
  is '????3
????3
I-???U-???D-???';
comment on column IF_VEH_PASS.uda4
  is '????4
????4
';
comment on column IF_VEH_PASS.uda5
  is '????5
????5
';
comment on column IF_VEH_PASS.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_VEH_PASS.deal_time
  is '????
????
';
comment on column IF_VEH_PASS.creation_time
  is '????
????
';
comment on column IF_VEH_PASS.guid
  is 'GUID
GUID
GUID';
comment on column IF_VEH_PASS.file_key
  is '????
????
????';
create index IDX_IF_VEH_PASS1 on IF_VEH_PASS (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_VEH_PASS
  add constraint PK_IF_VEH_PASS primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_VEH_PRO_PLAN
prompt ==============================
prompt
create table IF_VEH_PRO_PLAN
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10) not null,
  order_no      VARCHAR2(50) not null,
  erp_order_no  VARCHAR2(50),
  order_type    VARCHAR2(10),
  weon_time     VARCHAR2(30),
  af_off_time   VARCHAR2(30),
  sort_id       VARCHAR2(20),
  mtoc          VARCHAR2(20),
  car_type      VARCHAR2(64),
  phase         VARCHAR2(10),
  do_flag       VARCHAR2(10),
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate,
  guid          VARCHAR2(50),
  file_key      VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_VEH_PRO_PLAN
  is 'IF_VEH_PRO_PLAN??W+3????????
IF_VEH_PRO_PLAN??W+3????????
';
comment on column IF_VEH_PRO_PLAN.id
  is 'ID
ID
';
comment on column IF_VEH_PRO_PLAN.factory_code
  is '??
??
';
comment on column IF_VEH_PRO_PLAN.order_no
  is '???
???
';
comment on column IF_VEH_PRO_PLAN.erp_order_no
  is 'ERP???
ERP???
';
comment on column IF_VEH_PRO_PLAN.order_type
  is '????
????
';
comment on column IF_VEH_PRO_PLAN.weon_time
  is '??????
??????
';
comment on column IF_VEH_PRO_PLAN.af_off_time
  is '??????
??????
';
comment on column IF_VEH_PRO_PLAN.sort_id
  is '???
???
';
comment on column IF_VEH_PRO_PLAN.mtoc
  is 'MTOC
MTOC
';
comment on column IF_VEH_PRO_PLAN.car_type
  is '??
??
A16?A28';
comment on column IF_VEH_PRO_PLAN.phase
  is '????
????
';
comment on column IF_VEH_PRO_PLAN.do_flag
  is '????
????
I-???U-???D-???';
comment on column IF_VEH_PRO_PLAN.uda1
  is '????1
????1
';
comment on column IF_VEH_PRO_PLAN.uda2
  is '????2
????2
';
comment on column IF_VEH_PRO_PLAN.uda3
  is '????3
????3
';
comment on column IF_VEH_PRO_PLAN.uda4
  is '????4
????4
';
comment on column IF_VEH_PRO_PLAN.uda5
  is '????5
????5
';
comment on column IF_VEH_PRO_PLAN.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_VEH_PRO_PLAN.deal_time
  is '????
????
';
comment on column IF_VEH_PRO_PLAN.creation_time
  is '????
????
';
comment on column IF_VEH_PRO_PLAN.guid
  is 'GUID
GUID
GUID';
comment on column IF_VEH_PRO_PLAN.file_key
  is '????
????
????';
create index IDX_IF_VEH_PRO_PLAN1 on IF_VEH_PRO_PLAN (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_VEH_PRO_PLAN
  add constraint PK_IF_VEH_PRO_PLAN primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_VEH_SCRAP
prompt ===========================
prompt
create table IF_VEH_SCRAP
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  order_no           VARCHAR2(50) not null,
  erp_order_no       VARCHAR2(50) not null,
  vin                VARCHAR2(20),
  scrap_workcenter   VARCHAR2(20),
  scrap_station_code VARCHAR2(20),
  scrap_station_desc VARCHAR2(50),
  scrap_reason       VARCHAR2(600),
  scrap_time         VARCHAR2(30),
  uda1               VARCHAR2(50),
  uda2               VARCHAR2(50),
  uda3               VARCHAR2(50),
  uda4               VARCHAR2(50),
  uda5               VARCHAR2(50),
  creation_time      DATE default SYSDATE,
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  guid               VARCHAR2(50),
  file_key           VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_VEH_SCRAP
  is 'IF_VEH_SCRAP?????????
IF_VEH_SCRAP?????????
';
comment on column IF_VEH_SCRAP.id
  is 'ID
ID
';
comment on column IF_VEH_SCRAP.factory_code
  is '??
??
';
comment on column IF_VEH_SCRAP.order_no
  is '???
???
';
comment on column IF_VEH_SCRAP.erp_order_no
  is 'ERP???
ERP???
ERP???';
comment on column IF_VEH_SCRAP.vin
  is 'VIN
VIN
';
comment on column IF_VEH_SCRAP.scrap_workcenter
  is '????
????
';
comment on column IF_VEH_SCRAP.scrap_station_code
  is '??????
??????
';
comment on column IF_VEH_SCRAP.scrap_station_desc
  is '????????
????????
';
comment on column IF_VEH_SCRAP.scrap_reason
  is '????
????
';
comment on column IF_VEH_SCRAP.scrap_time
  is '????
????
';
comment on column IF_VEH_SCRAP.uda1
  is '????1
????1
';
comment on column IF_VEH_SCRAP.uda2
  is '????2
????2
????????';
comment on column IF_VEH_SCRAP.uda3
  is '????3
????3
????????';
comment on column IF_VEH_SCRAP.uda4
  is '????4
????4
??????';
comment on column IF_VEH_SCRAP.uda5
  is '????5
????5
';
comment on column IF_VEH_SCRAP.creation_time
  is '????
????
';
comment on column IF_VEH_SCRAP.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_VEH_SCRAP.deal_time
  is '????
????
';
comment on column IF_VEH_SCRAP.guid
  is 'GUID
GUID
GUID';
comment on column IF_VEH_SCRAP.file_key
  is '????
????
????';
create index IDX_IF_VEH_SCRAP1 on IF_VEH_SCRAP (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_VEH_SCRAP
  add constraint PK_IF_VEH_SCRAP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_WORK_CALENDAR
prompt ===============================
prompt
create table IF_WORK_CALENDAR
(
  id              NUMBER(19) not null,
  id_calendar     VARCHAR2(20) not null,
  factory_code    VARCHAR2(10) not null,
  work_center     VARCHAR2(20) not null,
  shift_code      VARCHAR2(20) not null,
  work_date       VARCHAR2(30) not null,
  work_start_time VARCHAR2(30),
  work_end_time   VARCHAR2(30),
  do_flag         VARCHAR2(10),
  uda1            VARCHAR2(50),
  uda2            VARCHAR2(50),
  uda3            VARCHAR2(50),
  uda4            VARCHAR2(50),
  uda5            VARCHAR2(50),
  deal_flag       NUMBER(1) default 0,
  deal_time       DATE,
  creation_time   DATE default sysdate,
  guid            VARCHAR2(50),
  file_key        VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_WORK_CALENDAR
  is 'IF_WORK_CALENDAR?????????
IF_WORK_CALENDAR?????????
';
comment on column IF_WORK_CALENDAR.id
  is 'ID
ID
';
comment on column IF_WORK_CALENDAR.id_calendar
  is '????????
????????
';
comment on column IF_WORK_CALENDAR.factory_code
  is '??
??
';
comment on column IF_WORK_CALENDAR.work_center
  is '????
????
';
comment on column IF_WORK_CALENDAR.shift_code
  is '??
??
';
comment on column IF_WORK_CALENDAR.work_date
  is '???
???
';
comment on column IF_WORK_CALENDAR.work_start_time
  is '??????
??????
';
comment on column IF_WORK_CALENDAR.work_end_time
  is '??????
??????
';
comment on column IF_WORK_CALENDAR.do_flag
  is '????
????
D-??????D??????????';
comment on column IF_WORK_CALENDAR.uda1
  is '????1
????1
';
comment on column IF_WORK_CALENDAR.uda2
  is '????2
????2
';
comment on column IF_WORK_CALENDAR.uda3
  is '????3
????3
';
comment on column IF_WORK_CALENDAR.uda4
  is '????4
????4
';
comment on column IF_WORK_CALENDAR.uda5
  is '????5
????5
';
comment on column IF_WORK_CALENDAR.deal_flag
  is '????
????
0 ??? 1???';
comment on column IF_WORK_CALENDAR.deal_time
  is '????
????
';
comment on column IF_WORK_CALENDAR.creation_time
  is '????
????
';
comment on column IF_WORK_CALENDAR.guid
  is 'GUID
GUID
GUID';
comment on column IF_WORK_CALENDAR.file_key
  is '????
????
????';
create index IDX_IF_WORK_CALENDAR1 on IF_WORK_CALENDAR (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table IF_WORK_CALENDAR
  add constraint PK_IF_WORK_CALENDAR primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table IF_WORK_CALENDAR_DETAIL
prompt ======================================
prompt
create table IF_WORK_CALENDAR_DETAIL
(
  id            NUMBER(19),
  id_calendar   VARCHAR2(20),
  start_time    VARCHAR2(30),
  end_time      VARCHAR2(30),
  time_type     VARCHAR2(10),
  uda1          VARCHAR2(50),
  uda2          VARCHAR2(50),
  uda3          VARCHAR2(50),
  uda4          VARCHAR2(50),
  uda5          VARCHAR2(50),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table IF_WORK_CALENDAR_DETAIL
  is 'IF_WORK_CALENDAR_DETAIL???????????
IF_WORK_CALENDAR_DETAIL???????????
';
comment on column IF_WORK_CALENDAR_DETAIL.id
  is '??ID
??ID
';
comment on column IF_WORK_CALENDAR_DETAIL.id_calendar
  is '????????
????????
';
comment on column IF_WORK_CALENDAR_DETAIL.start_time
  is '????
????
';
comment on column IF_WORK_CALENDAR_DETAIL.end_time
  is '????
????
';
comment on column IF_WORK_CALENDAR_DETAIL.time_type
  is '?????
?????
1-?????2-????';
comment on column IF_WORK_CALENDAR_DETAIL.uda1
  is '????1
????1
';
comment on column IF_WORK_CALENDAR_DETAIL.uda2
  is '????2
????2
';
comment on column IF_WORK_CALENDAR_DETAIL.uda3
  is '????3
????3
';
comment on column IF_WORK_CALENDAR_DETAIL.uda4
  is '????4
????4
';
comment on column IF_WORK_CALENDAR_DETAIL.uda5
  is '????5
????5
';
comment on column IF_WORK_CALENDAR_DETAIL.creation_time
  is '????
????
';
create index IDX_IF_WORK_CALENDAR_DETAIL1 on IF_WORK_CALENDAR_DETAIL (ID)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_BASE_REL_RESOURCES
prompt ====================================
prompt
create table MM_BASE_REL_RESOURCES
(
  id         NUMBER(19) not null,
  trx_time   DATE,
  user_id    VARCHAR2(64),
  table_name VARCHAR2(64),
  form_name  VARCHAR2(256),
  trx_type   VARCHAR2(1),
  columns    VARCHAR2(2000),
  old_value  VARCHAR2(3000),
  local_ip   VARCHAR2(30),
  record_key VARCHAR2(100),
  id_column  VARCHAR2(100),
  table_type VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_BASE_REL_RESOURCES
  is '????';
comment on column MM_BASE_REL_RESOURCES.id
  is '????';
comment on column MM_BASE_REL_RESOURCES.trx_time
  is '?????????';
comment on column MM_BASE_REL_RESOURCES.user_id
  is '????';
comment on column MM_BASE_REL_RESOURCES.table_name
  is '?????Key';
comment on column MM_BASE_REL_RESOURCES.form_name
  is 'flat ???tree ??';
comment on column MM_BASE_REL_RESOURCES.trx_type
  is '???';
comment on column MM_BASE_REL_RESOURCES.columns
  is '??';
comment on column MM_BASE_REL_RESOURCES.old_value
  is '??';
comment on column MM_BASE_REL_RESOURCES.local_ip
  is 'Y=??N=?';
comment on column MM_BASE_REL_RESOURCES.record_key
  is '??key';
comment on column MM_BASE_REL_RESOURCES.id_column
  is '??';
comment on column MM_BASE_REL_RESOURCES.table_type
  is '???';

prompt
prompt Creating table MM_BASE_RES_ROLE
prompt ===============================
prompt
create table MM_BASE_RES_ROLE
(
  id        VARCHAR2(50) not null,
  system_id VARCHAR2(50) not null,
  res_id    VARCHAR2(50) not null,
  role_id   VARCHAR2(50) not null
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_BASE_RES_ROLE
  is '??????';
comment on column MM_BASE_RES_ROLE.id
  is '????';
comment on column MM_BASE_RES_ROLE.system_id
  is '??ID';
comment on column MM_BASE_RES_ROLE.res_id
  is '??ID';
comment on column MM_BASE_RES_ROLE.role_id
  is '??ID';

prompt
prompt Creating table MM_BASE_SYS_RESOURCE
prompt ===================================
prompt
create table MM_BASE_SYS_RESOURCE
(
  id           VARCHAR2(50) not null,
  system_id    VARCHAR2(50),
  alias        VARCHAR2(50),
  name         VARCHAR2(100),
  default_url  VARCHAR2(100),
  enable_menu  NUMBER,
  has_children NUMBER,
  opened       NUMBER,
  icon         VARCHAR2(100),
  new_window   NUMBER,
  sn           NUMBER,
  parent_id    VARCHAR2(50),
  create_time  TIMESTAMP(6)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_BASE_SYS_RESOURCE
  is '??????';
comment on column MM_BASE_SYS_RESOURCE.id
  is '????';
comment on column MM_BASE_SYS_RESOURCE.system_id
  is '???ID';
comment on column MM_BASE_SYS_RESOURCE.alias
  is '????';
comment on column MM_BASE_SYS_RESOURCE.name
  is '???';
comment on column MM_BASE_SYS_RESOURCE.default_url
  is '??URL';
comment on column MM_BASE_SYS_RESOURCE.enable_menu
  is '?????(1,??,0 ,???)';
comment on column MM_BASE_SYS_RESOURCE.has_children
  is '??????';
comment on column MM_BASE_SYS_RESOURCE.opened
  is '????';
comment on column MM_BASE_SYS_RESOURCE.icon
  is '??';
comment on column MM_BASE_SYS_RESOURCE.new_window
  is '?????';
comment on column MM_BASE_SYS_RESOURCE.sn
  is '??';
comment on column MM_BASE_SYS_RESOURCE.parent_id
  is '???ID';
comment on column MM_BASE_SYS_RESOURCE.create_time
  is '????';

prompt
prompt Creating table MM_DPM_AREA
prompt ==========================
prompt
create table MM_DPM_AREA
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  workcenter         VARCHAR2(10) not null,
  area_code          VARCHAR2(30) not null,
  area_name          VARCHAR2(100),
  area_desc          VARCHAR2(300),
  ware_code          VARCHAR2(30),
  is_line_area       NUMBER(1),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_DPM_AREA
  is '???????';
comment on column MM_DPM_AREA.workcenter
  is '???AF????PA????WE????';
comment on column MM_DPM_AREA.area_code
  is '??????';
comment on column MM_DPM_AREA.area_name
  is '??????';
comment on column MM_DPM_AREA.area_desc
  is '??????';
comment on column MM_DPM_AREA.ware_code
  is '????';
comment on column MM_DPM_AREA.is_line_area
  is '0-?????
1-????';
alter table MM_DPM_AREA
  add constraint PK_MM_DPM_AREA primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_DPM_AREA
  add constraint AK_MM_DPM_AREA unique (AREA_CODE, WORKCENTER, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_DPM_CONFIRM_DEP
prompt =================================
prompt
create table MM_DPM_CONFIRM_DEP
(
  apply_no           VARCHAR2(50) not null,
  resp_dep           VARCHAR2(20) not null,
  resp_flag          NUMBER(1),
  confirm_date       DATE,
  confirm_user       VARCHAR2(30),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_DPM_CONFIRM_DEP.resp_dep
  is '??????';
comment on column MM_DPM_CONFIRM_DEP.resp_flag
  is '0-???
1-???';
comment on column MM_DPM_CONFIRM_DEP.confirm_date
  is '????';
comment on column MM_DPM_CONFIRM_DEP.confirm_user
  is '??ID';
alter table MM_DPM_CONFIRM_DEP
  add constraint PK_MM_DPM_CONFIRM_DEP primary key (APPLY_NO, RESP_DEP)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_DPM_DEPARTMENT
prompt ================================
prompt
create table MM_DPM_DEPARTMENT
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  dep_code           VARCHAR2(20),
  dep_name           VARCHAR2(60),
  belong_dep         VARCHAR2(20),
  dep_checker        VARCHAR2(30),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_DPM_DEPARTMENT
  is '???????';
comment on column MM_DPM_DEPARTMENT.dep_code
  is '?????????????????0';
comment on column MM_DPM_DEPARTMENT.dep_name
  is '?????';
comment on column MM_DPM_DEPARTMENT.belong_dep
  is '????';
comment on column MM_DPM_DEPARTMENT.dep_checker
  is '?????';
alter table MM_DPM_DEPARTMENT
  add constraint PK_MM_DPM_DEPARTMENT primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_DPM_DEPARTMENT
  add constraint AK_MM_DPM_DEP unique (DEP_CODE, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_DPM_DEP_PERSON
prompt ================================
prompt
create table MM_DPM_DEP_PERSON
(
  id                 NUMBER(19) not null,
  user_id            VARCHAR2(30),
  dep_code           VARCHAR2(30),
  default_disco_area VARCHAR2(30),
  factory_code       VARCHAR2(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_DPM_DEP_PERSON.default_disco_area
  is '??????';
comment on column MM_DPM_DEP_PERSON.last_modified_time
  is '??';
alter table MM_DPM_DEP_PERSON
  add constraint PK_MM_DPM_DEP_PERSON primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_DPM_DEP_PERSON
  add constraint AK_MM_DPM_DEP_PERSON unique (USER_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_DPM_INS
prompt =========================
prompt
create table MM_DPM_INS
(
  apply_no           VARCHAR2(50) not null,
  factory_code       VARCHAR2(10),
  dpm_type           NUMBER(1),
  model_code         VARCHAR2(20),
  apply_dep          VARCHAR2(30),
  ins_date           DATE,
  part_no            VARCHAR2(20),
  part_short_no      VARCHAR2(10),
  supplier_no        VARCHAR2(20),
  disco_area         VARCHAR2(20),
  dpm_code           VARCHAR2(20),
  dpm_desc           VARCHAR2(100),
  dpm_num            NUMBER(10),
  resp_dep           VARCHAR2(20),
  deal_result        NUMBER(1),
  ins_status         NUMBER(1) default 0,
  print_status       NUMBER(1) default 0,
  order_status       NUMBER(1) default 0,
  cal_order_no       VARCHAR2(50),
  excep_status       NUMBER(1) default 0,
  excep_order_no     VARCHAR2(50),
  send_status        NUMBER(1) default 0,
  delivery_status    NUMBER(1),
  delivery_order_no  VARCHAR2(100),
  check_date         DATE,
  check_user         VARCHAR2(30),
  remark             VARCHAR2(200),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  use_flag           NUMBER(1),
  print_user         VARCHAR2(30),
  print_time         DATE,
  contact            VARCHAR2(30),
  tel_no             VARCHAR2(30),
  check_remark       VARCHAR2(900)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_DPM_INS
  is '??????';
comment on column MM_DPM_INS.apply_no
  is '????';
comment on column MM_DPM_INS.dpm_type
  is '1-?????2-????';
comment on column MM_DPM_INS.model_code
  is '??';
comment on column MM_DPM_INS.apply_dep
  is '????';
comment on column MM_DPM_INS.ins_date
  is '???(??????????';
comment on column MM_DPM_INS.part_no
  is '?????';
comment on column MM_DPM_INS.part_short_no
  is '????';
comment on column MM_DPM_INS.supplier_no
  is '?????';
comment on column MM_DPM_INS.disco_area
  is '??????';
comment on column MM_DPM_INS.dpm_code
  is '??????';
comment on column MM_DPM_INS.dpm_desc
  is '????';
comment on column MM_DPM_INS.dpm_num
  is '?????';
comment on column MM_DPM_INS.resp_dep
  is '??????';
comment on column MM_DPM_INS.deal_result
  is '1-?? ?2-??';
comment on column MM_DPM_INS.ins_status
  is '0????
1????
2?????
3???';
comment on column MM_DPM_INS.print_status
  is '0????
1????';
comment on column MM_DPM_INS.order_status
  is '0????
1????';
comment on column MM_DPM_INS.excep_status
  is '0????
1????';
comment on column MM_DPM_INS.send_status
  is '0????
1????';
comment on column MM_DPM_INS.check_date
  is '????(????)';
comment on column MM_DPM_INS.check_user
  is '???';
comment on column MM_DPM_INS.remark
  is '??';
comment on column MM_DPM_INS.use_flag
  is '0-??? 1-???';
create index IDX_MM_DPM_INS1 on MM_DPM_INS (INS_DATE)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_DPM_INS2 on MM_DPM_INS (INS_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_DPM_INS3 on MM_DPM_INS (SEND_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_DPM_INS4 on MM_DPM_INS (ORDER_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_DPM_INS
  add constraint PK_MM_DPM_INS primary key (APPLY_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_DPM_ITEM
prompt ==========================
prompt
create table MM_DPM_ITEM
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  item_code          VARCHAR2(20),
  item_name          VARCHAR2(50),
  item_desc          VARCHAR2(150),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_DPM_ITEM
  is '???????';
comment on column MM_DPM_ITEM.item_code
  is '???????';
comment on column MM_DPM_ITEM.item_name
  is '???????';
comment on column MM_DPM_ITEM.item_desc
  is '???????';
alter table MM_DPM_ITEM
  add constraint PK_MM_DPM_ITEM primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_DPM_ITEM
  add constraint AK_MM_DPM_ITEM unique (ITEM_CODE, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_IF_CONFIG
prompt ===========================
prompt
create table MM_IF_CONFIG
(
  id                 VARCHAR2(50) not null,
  supplier_no        VARCHAR2(20),
  sup_factory        VARCHAR2(20),
  route_code         VARCHAR2(20),
  if_code            VARCHAR2(20),
  creation_time      DATE default SYSDATE,
  last_modified_time DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 8K
    minextents 1
    maxextents unlimited
  );
comment on table MM_IF_CONFIG
  is '接口配置表';
alter table MM_IF_CONFIG
  add constraint PK_MM_IF_CONFIG primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_BENCHMARK
prompt ===============================
prompt
create table MM_INV_BENCHMARK
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  ware_code          VARCHAR2(20),
  part_no            VARCHAR2(20),
  stock              NUMBER(10),
  flag               NUMBER(1),
  cal_user           VARCHAR2(30),
  cal_time           DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_INV_BENCHMARK
  is '????';
comment on column MM_INV_BENCHMARK.factory_code
  is '????';
comment on column MM_INV_BENCHMARK.ware_code
  is '????';
comment on column MM_INV_BENCHMARK.part_no
  is '????';
comment on column MM_INV_BENCHMARK.stock
  is '????';
create unique index IDX_MM_INV_BENCHMARK_1 on MM_INV_BENCHMARK (FACTORY_CODE, WARE_CODE, PART_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_INV_BENCHMARK_2 on MM_INV_BENCHMARK (FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_INV_BENCHMARK
  add constraint PK_MM_INV_BENCHMARK primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_INV_CONFIRM
prompt =============================
prompt
create table MM_INV_CONFIRM
(
  confirm_no         VARCHAR2(50),
  work_center        VARCHAR2(20),
  factory_code       VARCHAR2(10),
  inv_flag           NUMBER(1) default 0,
  inv_time           DATE,
  virtual_inv_flag   NUMBER(1) default 0,
  virtual_inv_time   DATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  type               NUMBER(1),
  distri_person      VARCHAR2(100),
  batch_seq          VARCHAR2(30),
  reason             VARCHAR2(30),
  shelve_id          VARCHAR2(32),
  ins_no             VARCHAR2(30),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_CONFIRM.confirm_no
  is '确认单号';
comment on column MM_INV_CONFIRM.work_center
  is '车间';
comment on column MM_INV_CONFIRM.factory_code
  is '工厂代码';
comment on column MM_INV_CONFIRM.inv_flag
  is '库存处理标识 0 未处理 1已处理';
comment on column MM_INV_CONFIRM.inv_time
  is '库存处理时间';
comment on column MM_INV_CONFIRM.virtual_inv_flag
  is '虚拟仓库存处理标识 0 未处理 1已处理';
comment on column MM_INV_CONFIRM.virtual_inv_time
  is '虚拟仓库存处理时间';
comment on column MM_INV_CONFIRM.creation_user
  is '创建人';
comment on column MM_INV_CONFIRM.creation_time
  is '创建时间';
comment on column MM_INV_CONFIRM.type
  is '类型 0 SPS上架 1 线边扫描上架';
comment on column MM_INV_CONFIRM.reason
  is '未配齐原因';
comment on column MM_INV_CONFIRM.shelve_id
  is '用于SPS上架记录货架信息';
comment on column MM_INV_CONFIRM.ins_no
  is '配送单号';
comment on column MM_INV_CONFIRM.deal_flag
  is '处理标识';
comment on column MM_INV_CONFIRM.deal_time
  is '处理时间';
alter table MM_INV_CONFIRM
  add constraint AK_MM_INV_CONFIRM unique (CONFIRM_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_CONFIRM_DETAIL
prompt ====================================
prompt
create table MM_INV_CONFIRM_DETAIL
(
  confirm_no VARCHAR2(50),
  part_no    VARCHAR2(20),
  rec_qty    NUMBER(10),
  location   VARCHAR2(50),
  shelve_id  VARCHAR2(32),
  ins_no     VARCHAR2(100)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_CONFIRM_DETAIL.confirm_no
  is '????';
comment on column MM_INV_CONFIRM_DETAIL.part_no
  is '????';
comment on column MM_INV_CONFIRM_DETAIL.rec_qty
  is '????';
comment on column MM_INV_CONFIRM_DETAIL.shelve_id
  is '??SPS????????';
comment on column MM_INV_CONFIRM_DETAIL.ins_no
  is '配送单号';

prompt
prompt Creating table MM_INV_DEVELOP
prompt =============================
prompt
create table MM_INV_DEVELOP
(
  id            NUMBER(19) not null,
  work_center   VARCHAR2(20),
  factory_code  VARCHAR2(10),
  part_no       VARCHAR2(20),
  stock         NUMBER(10),
  plan_qty      NUMBER(10),
  pro_qty       NUMBER(10),
  car_type      VARCHAR2(20),
  cal_point     DATE,
  creation_time DATE default sysdate,
  creation_user VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_DEVELOP.work_center
  is '??';
comment on column MM_INV_DEVELOP.factory_code
  is '????';
comment on column MM_INV_DEVELOP.part_no
  is '????';
comment on column MM_INV_DEVELOP.stock
  is '????';
comment on column MM_INV_DEVELOP.plan_qty
  is '????';
comment on column MM_INV_DEVELOP.pro_qty
  is '????';
comment on column MM_INV_DEVELOP.car_type
  is '??';
comment on column MM_INV_DEVELOP.cal_point
  is '?????';
comment on column MM_INV_DEVELOP.creation_time
  is '????';
comment on column MM_INV_DEVELOP.creation_user
  is '???';
alter table MM_INV_DEVELOP
  add constraint PK_MM_INV_DEVELOP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_INV_DEVELOP
  add constraint AK_MM_INV_DEVELOP unique (WORK_CENTER, FACTORY_CODE, PART_NO, CAR_TYPE, CAL_POINT)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_DEV_BASE
prompt ==============================
prompt
create table MM_INV_DEV_BASE
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10),
  part_no       VARCHAR2(20),
  stock         NUMBER(10),
  adj_stock     NUMBER(10),
  creation_time DATE default sysdate,
  creation_user VARCHAR2(30),
  work_center   VARCHAR2(10),
  ware_code     VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_DEV_BASE.factory_code
  is '????';
comment on column MM_INV_DEV_BASE.part_no
  is '????';
comment on column MM_INV_DEV_BASE.stock
  is '????';
comment on column MM_INV_DEV_BASE.adj_stock
  is '????';
comment on column MM_INV_DEV_BASE.creation_time
  is '????';
comment on column MM_INV_DEV_BASE.creation_user
  is '???';
comment on column MM_INV_DEV_BASE.work_center
  is '''?????(PUB_WORKCENTER):
A1-??
T1-??
W1-??';
comment on column MM_INV_DEV_BASE.ware_code
  is '????';
alter table MM_INV_DEV_BASE
  add constraint PK_MM_INV_DEV_BASE primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_INV_DEV_BASE
  add constraint AK_MM_INV_DEV_BASE unique (FACTORY_CODE, PART_NO, WORK_CENTER)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_INV_DEV_BASE_IMP
prompt ==================================
prompt
create table MM_INV_DEV_BASE_IMP
(
  imp_uuid      VARCHAR2(50),
  work_center   VARCHAR2(10),
  ware_code     VARCHAR2(20),
  part_no       VARCHAR2(20),
  stock         NUMBER(10),
  adj_stock     NUMBER(10),
  check_result  NUMBER(1),
  check_info    VARCHAR2(300),
  import_status NUMBER(1),
  ope_type      VARCHAR2(8),
  factory_code  VARCHAR2(10),
  creation_user VARCHAR2(30),
  creation_time DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_INV_DEV_BASE_IMP
  is '?????????';
comment on column MM_INV_DEV_BASE_IMP.work_center
  is '????';
comment on column MM_INV_DEV_BASE_IMP.ware_code
  is '????';
comment on column MM_INV_DEV_BASE_IMP.part_no
  is '????';
comment on column MM_INV_DEV_BASE_IMP.stock
  is '??';
comment on column MM_INV_DEV_BASE_IMP.adj_stock
  is '?????';
comment on column MM_INV_DEV_BASE_IMP.check_result
  is '???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_INV_DEV_BASE_IMP.check_info
  is '????';
comment on column MM_INV_DEV_BASE_IMP.import_status
  is '0-???
1-???';
comment on column MM_INV_DEV_BASE_IMP.ope_type
  is 'I ?? U??';
comment on column MM_INV_DEV_BASE_IMP.factory_code
  is '??';
comment on column MM_INV_DEV_BASE_IMP.creation_user
  is '???';
comment on column MM_INV_DEV_BASE_IMP.creation_time
  is '????';

prompt
prompt Creating table MM_INV_DEV_BASE_TEMP
prompt ===================================
prompt
create table MM_INV_DEV_BASE_TEMP
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10),
  part_no       VARCHAR2(20),
  stock         NUMBER(10),
  adj_stock     NUMBER(10),
  creation_time DATE default sysdate,
  creation_user VARCHAR2(30),
  work_center   VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_DEV_BASE_TEMP.factory_code
  is '????';
comment on column MM_INV_DEV_BASE_TEMP.part_no
  is '????';
comment on column MM_INV_DEV_BASE_TEMP.stock
  is '????';
comment on column MM_INV_DEV_BASE_TEMP.adj_stock
  is '????';
comment on column MM_INV_DEV_BASE_TEMP.creation_time
  is '????';
comment on column MM_INV_DEV_BASE_TEMP.creation_user
  is '???';
comment on column MM_INV_DEV_BASE_TEMP.work_center
  is '''?????(PUB_WORKCENTER):
A1-??
T1-??
W1-??';
alter table MM_INV_DEV_BASE_TEMP
  add constraint PK_MM_INV_DEV_BASE_TEMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_INV_DEV_BASE_TEMP
  add constraint AK_MM_INV_DEV_BASE_TEMP unique (FACTORY_CODE, PART_NO, WORK_CENTER)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_DIFFERENCE
prompt ================================
prompt
create table MM_INV_DIFFERENCE
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  part_no            VARCHAR2(20),
  ware_code          VARCHAR2(20),
  use_num            NUMBER(10),
  af_date            DATE,
  creation_time      DATE,
  creation_user      VARCHAR2(50),
  last_modified_time DATE,
  last_modified_user VARCHAR2(50),
  base_num           NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
alter table MM_INV_DIFFERENCE
  add constraint PK_MM_INV_DIFFERENCE primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_EC
prompt ========================
prompt
create table MM_INV_EC
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  supplier_no        VARCHAR2(20),
  box_type           VARCHAR2(10),
  box_qty            NUMBER(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  work_center        VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_INV_EC
  is '??????';
comment on column MM_INV_EC.factory_code
  is '??';
comment on column MM_INV_EC.supplier_no
  is '???';
comment on column MM_INV_EC.box_type
  is '1 ??
2 ??';
comment on column MM_INV_EC.box_qty
  is '??????';
comment on column MM_INV_EC.work_center
  is '??';
alter table MM_INV_EC
  add constraint PK_MM_INV_EC primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_INV_EC
  add constraint AK_MM_INV_EC unique (SUPPLIER_NO, BOX_TYPE, FACTORY_CODE, WORK_CENTER)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_INV_EC_IMP
prompt ============================
prompt
create table MM_INV_EC_IMP
(
  busi_id       NUMBER(19),
  factory_code  VARCHAR2(10),
  supplier_no   VARCHAR2(64),
  box_type      NUMBER(1),
  box_qty       NUMBER(10),
  creation_user VARCHAR2(30),
  creation_time DATE,
  imp_uuid      VARCHAR2(50),
  check_result  NUMBER(1),
  check_info    VARCHAR2(300),
  import_status NUMBER(1),
  ope_type      VARCHAR2(8),
  pk_id         NUMBER(19),
  work_center   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_INV_EC_IMP
  is ' ???????';
comment on column MM_INV_EC_IMP.busi_id
  is 'ID';
comment on column MM_INV_EC_IMP.factory_code
  is '??';
comment on column MM_INV_EC_IMP.supplier_no
  is '???';
comment on column MM_INV_EC_IMP.box_type
  is '??';
comment on column MM_INV_EC_IMP.box_qty
  is '??';
comment on column MM_INV_EC_IMP.creation_user
  is '???';
comment on column MM_INV_EC_IMP.creation_time
  is '????';
comment on column MM_INV_EC_IMP.imp_uuid
  is 'UUID';
comment on column MM_INV_EC_IMP.check_result
  is '????';
comment on column MM_INV_EC_IMP.check_info
  is '????';
comment on column MM_INV_EC_IMP.import_status
  is '????';
comment on column MM_INV_EC_IMP.ope_type
  is '????';
comment on column MM_INV_EC_IMP.pk_id
  is 'PK_ID';
comment on column MM_INV_EC_IMP.work_center
  is '??';

prompt
prompt Creating table MM_INV_EC_IN
prompt ===========================
prompt
create table MM_INV_EC_IN
(
  id            NUMBER(19) not null,
  id_ec         NUMBER(19),
  factory_code  VARCHAR2(10),
  supplier_no   VARCHAR2(20),
  box_type      NUMBER(1),
  in_qty        NUMBER(10),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate,
  work_center   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_INV_EC_IN
  is '???????';
comment on column MM_INV_EC_IN.box_type
  is '1 ??
2 ??';
comment on column MM_INV_EC_IN.deal_flag
  is '0-???
1-???';
comment on column MM_INV_EC_IN.work_center
  is '车间';
create index IDX_MM_INV_EC_IN1 on MM_INV_EC_IN (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_INV_EC_IN
  add constraint PK_MM_INV_EC_IN primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_EC_OUT
prompt ============================
prompt
create table MM_INV_EC_OUT
(
  id            NUMBER(19) not null,
  id_ec         NUMBER(19),
  factory_code  VARCHAR2(10),
  supplier_no   VARCHAR2(20),
  box_type      NUMBER(1),
  out_qty       NUMBER(10),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_INV_EC_OUT
  is '???????';
comment on column MM_INV_EC_OUT.box_type
  is '1 ??
2 ??';
comment on column MM_INV_EC_OUT.deal_flag
  is '0-???
1-???';
create index IDX_MM_INV_EC_OUT1 on MM_INV_EC_OUT (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_INV_EC_OUT
  add constraint PK_MM_INV_EC_OUT primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_EC_OUT_INS
prompt ================================
prompt
create table MM_INV_EC_OUT_INS
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10),
  supplier_no   VARCHAR2(20),
  car_type      VARCHAR2(20),
  route_code    VARCHAR2(20),
  total_car_no  VARCHAR2(30),
  box_type      NUMBER(1),
  out_qty       NUMBER(10),
  pickup_time   DATE,
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_INV_EC_OUT_INS
  is '???????';
comment on column MM_INV_EC_OUT_INS.supplier_no
  is '???';
comment on column MM_INV_EC_OUT_INS.car_type
  is '??';
comment on column MM_INV_EC_OUT_INS.route_code
  is '????';
comment on column MM_INV_EC_OUT_INS.total_car_no
  is '????';
comment on column MM_INV_EC_OUT_INS.box_type
  is '1 ??
2 ??';
comment on column MM_INV_EC_OUT_INS.out_qty
  is '????';
comment on column MM_INV_EC_OUT_INS.pickup_time
  is '????';
create index IDX_MM_INV_EC_OUT_INS1 on MM_INV_EC_OUT_INS (PICKUP_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_INV_EC_OUT_INS
  add constraint PK_MM_INV_EC_OUT_INS primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_IN
prompt ========================
prompt
create table MM_INV_IN
(
  rec_no               VARCHAR2(50) not null,
  factory_code         VARCHAR2(10),
  order_no             VARCHAR2(50),
  rec_times            NUMBER(2),
  depot_no             VARCHAR2(20),
  ope_ip               VARCHAR2(50),
  rec_client           NUMBER(1),
  order_type           VARCHAR2(10),
  actual_arr_pro_seqno NUMBER(19),
  inv_flag             NUMBER(1) default 0,
  inv_time             DATE,
  deal_flag            NUMBER(1) default 0,
  deal_time            DATE,
  creation_user        VARCHAR2(30),
  creation_time        DATE default sysdate,
  note                 VARCHAR2(100),
  p_deal_flag          NUMBER(1) default 0,
  p_deal_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_IN.rec_no
  is '????';
comment on column MM_INV_IN.factory_code
  is '????';
comment on column MM_INV_IN.order_no
  is '???';
comment on column MM_INV_IN.rec_times
  is '??';
comment on column MM_INV_IN.depot_no
  is '????';
comment on column MM_INV_IN.ope_ip
  is 'IP';
comment on column MM_INV_IN.rec_client
  is '1-PC
2-PDA';
comment on column MM_INV_IN.order_type
  is 'JIS-??
JIT-??
SW-??';
comment on column MM_INV_IN.inv_flag
  is '0 ???
1???';
comment on column MM_INV_IN.inv_time
  is '??????';
comment on column MM_INV_IN.deal_flag
  is '0 ???
1???';
comment on column MM_INV_IN.deal_time
  is '????';
comment on column MM_INV_IN.creation_user
  is '???';
comment on column MM_INV_IN.creation_time
  is '????';
comment on column MM_INV_IN.note
  is '??';
comment on column MM_INV_IN.p_deal_flag
  is '0 ??? 1???';
create index IDX_MM_INV_IN1 on MM_INV_IN (INV_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_INV_IN2 on MM_INV_IN (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_INV_IN
  add constraint PK_MM_INV_IN primary key (REC_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_INV_IN_DETAIL
prompt ===============================
prompt
create table MM_INV_IN_DETAIL
(
  rec_no        VARCHAR2(50),
  row_no        NUMBER(5),
  rec_times     NUMBER(2),
  part_no       VARCHAR2(20),
  order_qty     NUMBER(10,2),
  rec_qty       NUMBER(10,2),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_IN_DETAIL.rec_no
  is '????';
comment on column MM_INV_IN_DETAIL.row_no
  is '????';
comment on column MM_INV_IN_DETAIL.part_no
  is '????';
comment on column MM_INV_IN_DETAIL.order_qty
  is '????';
comment on column MM_INV_IN_DETAIL.rec_qty
  is '????';
comment on column MM_INV_IN_DETAIL.creation_time
  is '????';
create index IDX_MM_INV_IN_DETAIL1 on MM_INV_IN_DETAIL (REC_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_INV_LOCK
prompt ==========================
prompt
create table MM_INV_LOCK
(
  type_value NUMBER(1),
  begin_date DATE,
  end_date   DATE,
  factory    VARCHAR2(10),
  type_name  VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )
nologging;
comment on table MM_INV_LOCK
  is '???????';
comment on column MM_INV_LOCK.type_value
  is '0-???1-??';
comment on column MM_INV_LOCK.begin_date
  is '????';
comment on column MM_INV_LOCK.end_date
  is '????';
comment on column MM_INV_LOCK.factory
  is '??';
comment on column MM_INV_LOCK.type_name
  is '????';

prompt
prompt Creating table MM_INV_ORDER_BOM
prompt ===============================
prompt
create table MM_INV_ORDER_BOM
(
  factory_code       VARCHAR2(10) not null,
  order_no           VARCHAR2(50) not null,
  part_rowno         NUMBER(10) not null,
  vehicle_part_no    VARCHAR2(30),
  part_no            VARCHAR2(30),
  workcenter         VARCHAR2(20),
  station_code       VARCHAR2(30),
  num                NUMBER(18,3),
  usage_amount_unit  VARCHAR2(20),
  purchase_type      VARCHAR2(10),
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_ORDER_BOM.order_no
  is '?????';
comment on column MM_INV_ORDER_BOM.part_rowno
  is '?????';
comment on column MM_INV_ORDER_BOM.vehicle_part_no
  is '????';
comment on column MM_INV_ORDER_BOM.part_no
  is '???';
comment on column MM_INV_ORDER_BOM.workcenter
  is '???????????????????';
comment on column MM_INV_ORDER_BOM.station_code
  is '???';
comment on column MM_INV_ORDER_BOM.num
  is '?????????????';
comment on column MM_INV_ORDER_BOM.usage_amount_unit
  is '????';

prompt
prompt Creating table MM_INV_OUT
prompt =========================
prompt
create table MM_INV_OUT
(
  inv_out_no    VARCHAR2(50) not null,
  factory_code  VARCHAR2(10),
  ins_no        VARCHAR2(50),
  out_times     NUMBER(20),
  ins_type      VARCHAR2(10),
  from_depot_no VARCHAR2(20),
  to_depot_no   VARCHAR2(20),
  inv_flag      NUMBER(1) default 0,
  inv_time      DATE,
  pc_inv_flag   NUMBER(1) default 0,
  pc_inv_time   DATE,
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate,
  out_type      NUMBER(1),
  note          VARCHAR2(100)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_OUT.inv_out_no
  is '????';
comment on column MM_INV_OUT.factory_code
  is '????';
comment on column MM_INV_OUT.ins_no
  is '???';
comment on column MM_INV_OUT.out_times
  is '??';
comment on column MM_INV_OUT.ins_type
  is 'JIS-??
JIT-??
SW-??';
comment on column MM_INV_OUT.from_depot_no
  is '????';
comment on column MM_INV_OUT.to_depot_no
  is '????';
comment on column MM_INV_OUT.inv_flag
  is '0 ???
1???';
comment on column MM_INV_OUT.inv_time
  is '??????';
comment on column MM_INV_OUT.pc_inv_flag
  is '?????????';
comment on column MM_INV_OUT.pc_inv_time
  is '?????????';
comment on column MM_INV_OUT.deal_flag
  is '0 ???
1???';
comment on column MM_INV_OUT.deal_time
  is '????';
comment on column MM_INV_OUT.creation_user
  is '???';
comment on column MM_INV_OUT.creation_time
  is '????';
comment on column MM_INV_OUT.out_type
  is '1-?PC???????
2-??????????';
comment on column MM_INV_OUT.note
  is '??';
create index IDX_MM_INV_OUT1 on MM_INV_OUT (INV_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_INV_OUT2 on MM_INV_OUT (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_INV_OUT
  add constraint PK_MM_INV_OUT primary key (INV_OUT_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_OUT_DETAIL
prompt ================================
prompt
create table MM_INV_OUT_DETAIL
(
  inv_out_no    VARCHAR2(50),
  location      VARCHAR2(50),
  out_times     NUMBER(20),
  part_no       VARCHAR2(20),
  order_qty     NUMBER(10),
  rec_qty       NUMBER(10),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_OUT_DETAIL.inv_out_no
  is '????';
comment on column MM_INV_OUT_DETAIL.location
  is '????';
comment on column MM_INV_OUT_DETAIL.out_times
  is '????';
comment on column MM_INV_OUT_DETAIL.part_no
  is '????';
comment on column MM_INV_OUT_DETAIL.order_qty
  is '????';
comment on column MM_INV_OUT_DETAIL.rec_qty
  is '????';
comment on column MM_INV_OUT_DETAIL.creation_time
  is '????';
create index IDX_MM_INV_OUT_DETAIL1 on MM_INV_OUT_DETAIL (INV_OUT_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_PART_DEVLOP
prompt =================================
prompt
create table MM_INV_PART_DEVLOP
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  ware_code          VARCHAR2(20),
  part_no            VARCHAR2(20),
  develop_weeks      NUMBER(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_INV_PART_DEVLOP
  is '零件推移基准表';
comment on column MM_INV_PART_DEVLOP.factory_code
  is '工厂代码';
comment on column MM_INV_PART_DEVLOP.ware_code
  is '仓库代码';
comment on column MM_INV_PART_DEVLOP.part_no
  is '零件编号';
create unique index IDX_MM_INV_PART_DEVLOP1 on MM_INV_PART_DEVLOP (FACTORY_CODE, WARE_CODE, PART_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_INV_PART_DEVLOP
  add constraint PK_MM_INV_PART_DEVLOP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_PART_LOCATION
prompt ===================================
prompt
create table MM_INV_PART_LOCATION
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  part_no            VARCHAR2(64),
  supplier_no        VARCHAR2(20),
  ware_code          VARCHAR2(20),
  station_code       VARCHAR2(20),
  unload_port        VARCHAR2(20),
  dep_no             VARCHAR2(20),
  prepare_person     VARCHAR2(20),
  carpool            VARCHAR2(20),
  distri_person      VARCHAR2(100),
  location           VARCHAR2(50),
  shelf_no           VARCHAR2(20),
  location_num       NUMBER(10),
  model_code         VARCHAR2(10),
  storage            VARCHAR2(100),
  eff_start          DATE,
  eff_end            DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default SYSDATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE default SYSDATE,
  workcenter         VARCHAR2(20),
  last_modified_ip   VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_INV_PART_LOCATION
  is 'MM_INV_PART_LOCATION??????
';
comment on column MM_INV_PART_LOCATION.id
  is 'ID
';
comment on column MM_INV_PART_LOCATION.factory_code
  is '????
';
comment on column MM_INV_PART_LOCATION.part_no
  is '????
';
comment on column MM_INV_PART_LOCATION.supplier_no
  is '?????
';
comment on column MM_INV_PART_LOCATION.ware_code
  is '????
';
comment on column MM_INV_PART_LOCATION.station_code
  is '???
';
comment on column MM_INV_PART_LOCATION.unload_port
  is '???
';
comment on column MM_INV_PART_LOCATION.dep_no
  is '????
';
comment on column MM_INV_PART_LOCATION.prepare_person
  is '????
';
comment on column MM_INV_PART_LOCATION.carpool
  is '???
';
comment on column MM_INV_PART_LOCATION.distri_person
  is '????
';
comment on column MM_INV_PART_LOCATION.location
  is '????
';
comment on column MM_INV_PART_LOCATION.shelf_no
  is '???
';
comment on column MM_INV_PART_LOCATION.location_num
  is '????
';
comment on column MM_INV_PART_LOCATION.model_code
  is '??
';
comment on column MM_INV_PART_LOCATION.storage
  is '?????
';
comment on column MM_INV_PART_LOCATION.eff_start
  is '????
';
comment on column MM_INV_PART_LOCATION.eff_end
  is '????
';
comment on column MM_INV_PART_LOCATION.creation_user
  is '????
';
comment on column MM_INV_PART_LOCATION.creation_time
  is '????
';
comment on column MM_INV_PART_LOCATION.last_modified_user
  is '??????
';
comment on column MM_INV_PART_LOCATION.last_modified_time
  is '??????
';
comment on column MM_INV_PART_LOCATION.workcenter
  is '????
';
comment on column MM_INV_PART_LOCATION.last_modified_ip
  is '????IP
';
alter table MM_INV_PART_LOCATION
  add constraint PK_MM_INV_PART_LOCATION primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_INV_PART_LOCATION_TEMP
prompt ========================================
prompt
create table MM_INV_PART_LOCATION_TEMP
(
  id                NUMBER(10) not null,
  new_part_no       VARCHAR2(20),
  new_supplier_no   VARCHAR2(20),
  new_unload_port   VARCHAR2(20),
  new_repare_person VARCHAR2(20),
  new_carpool       VARCHAR2(30),
  new_distri_person VARCHAR2(100),
  new_location      VARCHAR2(50),
  new_station_code  VARCHAR2(10),
  new_shelf_no      VARCHAR2(20),
  new_location_num  NUMBER(10),
  new_storage       VARCHAR2(100),
  old_part_no       VARCHAR2(20),
  old_supplier_no   VARCHAR2(20),
  old_unload_port   VARCHAR2(20),
  old_repare_person VARCHAR2(20),
  old_carpool       VARCHAR2(30),
  old_distri_person VARCHAR2(30),
  old_location      VARCHAR2(50),
  old_station_code  VARCHAR2(10),
  old_shelf_no      VARCHAR2(20),
  old_location_num  NUMBER(10),
  old_storage       VARCHAR2(100),
  model_code        VARCHAR2(10),
  eff_start         DATE,
  eff_end           DATE,
  deal_flag         VARCHAR2(10),
  check_flag        VARCHAR2(10),
  operation_type    VARCHAR2(10),
  old_ware_code     VARCHAR2(20),
  check_result      VARCHAR2(3000),
  factory_code      VARCHAR2(20),
  new_work_center   VARCHAR2(20),
  old_work_center   VARCHAR2(20),
  new_ware_code     VARCHAR2(20),
  new_dept_no       VARCHAR2(20),
  old_dept_no       VARCHAR2(20),
  import_status     NUMBER(1),
  imp_uuid          VARCHAR2(50),
  check_info        VARCHAR2(3000),
  busi_id           NUMBER(19),
  creation_user     VARCHAR2(20),
  creation_time     DATE,
  last_modified_ip  VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_INV_PART_LOCATION_TEMP
  is 'MM_INV_PART_LOCATION_TEMP?????????
';
comment on column MM_INV_PART_LOCATION_TEMP.id
  is 'ID
';
comment on column MM_INV_PART_LOCATION_TEMP.new_part_no
  is '????(?)
????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.new_supplier_no
  is '?????(?)
?????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.new_unload_port
  is '???(?)
???(?)';
comment on column MM_INV_PART_LOCATION_TEMP.new_repare_person
  is '????(?)
????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.new_carpool
  is '???(?)
???(?)';
comment on column MM_INV_PART_LOCATION_TEMP.new_distri_person
  is '????(?)
????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.new_location
  is '????(?)
????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.new_station_code
  is '??(?)
??(?)';
comment on column MM_INV_PART_LOCATION_TEMP.new_shelf_no
  is '???(?)
???(?)';
comment on column MM_INV_PART_LOCATION_TEMP.new_location_num
  is '????(?)
????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.new_storage
  is '?????(?)
?????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.old_part_no
  is '????(?)
????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.old_supplier_no
  is '?????(?)
?????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.old_unload_port
  is '???(?)
???(?)';
comment on column MM_INV_PART_LOCATION_TEMP.old_repare_person
  is '????(?)
????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.old_carpool
  is '???(?)
???(?)';
comment on column MM_INV_PART_LOCATION_TEMP.old_distri_person
  is '????(?)
????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.old_location
  is '????(?)
????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.old_station_code
  is '???(?)
???(?)';
comment on column MM_INV_PART_LOCATION_TEMP.old_shelf_no
  is '???(?)
???(?)';
comment on column MM_INV_PART_LOCATION_TEMP.old_location_num
  is '????(?)
????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.old_storage
  is '?????(?)
?????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.model_code
  is '??
??';
comment on column MM_INV_PART_LOCATION_TEMP.eff_start
  is '????
????';
comment on column MM_INV_PART_LOCATION_TEMP.eff_end
  is '????
????';
comment on column MM_INV_PART_LOCATION_TEMP.deal_flag
  is '????
????';
comment on column MM_INV_PART_LOCATION_TEMP.check_flag
  is '????
????';
comment on column MM_INV_PART_LOCATION_TEMP.operation_type
  is '?????????????
?????????????';
comment on column MM_INV_PART_LOCATION_TEMP.old_ware_code
  is '????
????';
comment on column MM_INV_PART_LOCATION_TEMP.check_result
  is '????
????';
comment on column MM_INV_PART_LOCATION_TEMP.factory_code
  is '??
??';
comment on column MM_INV_PART_LOCATION_TEMP.new_work_center
  is '??(?)
??(?)';
comment on column MM_INV_PART_LOCATION_TEMP.old_work_center
  is '??(?)
??(?)';
comment on column MM_INV_PART_LOCATION_TEMP.new_ware_code
  is '????(?)
????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.new_dept_no
  is '????(?)
????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.old_dept_no
  is '????(?)
????(?)';
comment on column MM_INV_PART_LOCATION_TEMP.import_status
  is '????';
comment on column MM_INV_PART_LOCATION_TEMP.imp_uuid
  is '??uuid';
comment on column MM_INV_PART_LOCATION_TEMP.check_info
  is '????';
comment on column MM_INV_PART_LOCATION_TEMP.busi_id
  is 'BUSI_ID';
comment on column MM_INV_PART_LOCATION_TEMP.creation_user
  is '???';
comment on column MM_INV_PART_LOCATION_TEMP.creation_time
  is '????';
comment on column MM_INV_PART_LOCATION_TEMP.last_modified_ip
  is '????IP';
alter table MM_INV_PART_LOCATION_TEMP
  add constraint PK_MM_INV_PART_LOCATION_TEMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_PRO_PLAN
prompt ==============================
prompt
create table MM_INV_PRO_PLAN
(
  factory_code       VARCHAR2(10) not null,
  order_no           VARCHAR2(50) not null,
  order_type         VARCHAR2(10),
  weon_time          DATE,
  afoff_time         DATE,
  sort_id            NUMBER(19),
  mtoc               VARCHAR2(20),
  model_code         VARCHAR2(10),
  phase              VARCHAR2(10),
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_PRO_PLAN.model_code
  is 'A16?A28';

prompt
prompt Creating table MM_INV_REC_TEMP
prompt ==============================
prompt
create table MM_INV_REC_TEMP
(
  factory_code  VARCHAR2(10),
  order_no      VARCHAR2(50) not null,
  row_no        NUMBER(10) not null,
  this_sh_num   NUMBER(10),
  ope_user      VARCHAR2(50),
  uuid          VARCHAR2(60),
  creation_time DATE default sysdate,
  partlabel     VARCHAR2(300),
  id            NUMBER(19),
  ip            VARCHAR2(40),
  check_code    NUMBER(1),
  kb_seq_no     NUMBER(10),
  order_seq     NUMBER(10),
  detail_seq    NUMBER(10),
  depot_no      VARCHAR2(20),
  part_no       VARCHAR2(20),
  order_type    VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_REC_TEMP.factory_code
  is '????';
comment on column MM_INV_REC_TEMP.order_no
  is '???';
comment on column MM_INV_REC_TEMP.row_no
  is '????';
comment on column MM_INV_REC_TEMP.this_sh_num
  is '??????';
comment on column MM_INV_REC_TEMP.ope_user
  is '???';
comment on column MM_INV_REC_TEMP.uuid
  is 'UUID';
comment on column MM_INV_REC_TEMP.creation_time
  is '????';
comment on column MM_INV_REC_TEMP.partlabel
  is '??';
comment on column MM_INV_REC_TEMP.ip
  is '??IP';
comment on column MM_INV_REC_TEMP.check_code
  is '????';
comment on column MM_INV_REC_TEMP.kb_seq_no
  is '??????';
comment on column MM_INV_REC_TEMP.order_seq
  is '???????';
comment on column MM_INV_REC_TEMP.detail_seq
  is '????????';
comment on column MM_INV_REC_TEMP.depot_no
  is '????';
comment on column MM_INV_REC_TEMP.part_no
  is '???';
comment on column MM_INV_REC_TEMP.order_type
  is '????';

prompt
prompt Creating table MM_INV_SHELVES_LABEL
prompt ===================================
prompt
create table MM_INV_SHELVES_LABEL
(
  id                 NUMBER(10) not null,
  shelves_addr       VARCHAR2(150),
  factory_code       VARCHAR2(20),
  part_no            VARCHAR2(64),
  supplier_no        VARCHAR2(20),
  standard_pack      NUMBER(10),
  safe_stock         NUMBER(10),
  car_type           VARCHAR2(20),
  stack_layers       NUMBER(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
alter table MM_INV_SHELVES_LABEL
  add constraint PK_MM_INV_SHELVES_LABEL primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_SHELVES_LABEL_TEMP
prompt ========================================
prompt
create table MM_INV_SHELVES_LABEL_TEMP
(
  shelves_addr  VARCHAR2(150),
  factory_code  VARCHAR2(20),
  part_no       VARCHAR2(64),
  supplier_no   VARCHAR2(20),
  standard_pack NUMBER,
  safe_stock    NUMBER,
  car_type      VARCHAR2(20),
  stack_layers  NUMBER,
  id            NUMBER not null,
  deal_flag     CHAR(10),
  check_flag    VARCHAR2(2),
  check_result  VARCHAR2(2),
  part_short_no VARCHAR2(150),
  part_name     VARCHAR2(20),
  supplier_name VARCHAR2(150),
  "Column_16"   VARCHAR2(150)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
alter table MM_INV_SHELVES_LABEL_TEMP
  add constraint PK_MM_INV_SHELVES_LABEL_TEMP primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_STOCK
prompt ===========================
prompt
create table MM_INV_STOCK
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  ware_code          VARCHAR2(20),
  part_no            VARCHAR2(64),
  max_stock          NUMBER(10),
  safe_stock         NUMBER(10),
  stock              NUMBER(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  adj_remark         VARCHAR2(300)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_STOCK.factory_code
  is '????';
comment on column MM_INV_STOCK.ware_code
  is '????';
comment on column MM_INV_STOCK.part_no
  is '????';
comment on column MM_INV_STOCK.max_stock
  is '????';
comment on column MM_INV_STOCK.safe_stock
  is '????';
comment on column MM_INV_STOCK.stock
  is '????';
comment on column MM_INV_STOCK.adj_remark
  is '??????';
alter table MM_INV_STOCK
  add constraint PK_MM_INV_STOCK primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_INV_STOCK
  add constraint AK_MM_INV_STOCK unique (PART_NO, WARE_CODE, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_INV_STOCK_IMP
prompt ===============================
prompt
create table MM_INV_STOCK_IMP
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10),
  ware_code     VARCHAR2(20),
  part_no       VARCHAR2(20),
  max_stock     VARCHAR2(10),
  safe_stock    VARCHAR2(10),
  stock         VARCHAR2(10),
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate,
  imp_uuid      VARCHAR2(32),
  import_status NUMBER(1),
  ope_type      VARCHAR2(8),
  check_result  NUMBER(1),
  check_info    VARCHAR2(300),
  adj_remark    VARCHAR2(300),
  from_depot_no VARCHAR2(20),
  to_depot_no   VARCHAR2(20),
  inv_out_no    VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_STOCK_IMP.factory_code
  is '工厂代码';
comment on column MM_INV_STOCK_IMP.ware_code
  is '仓库代码';
comment on column MM_INV_STOCK_IMP.part_no
  is '零件编号';
comment on column MM_INV_STOCK_IMP.max_stock
  is '最大在库';
comment on column MM_INV_STOCK_IMP.safe_stock
  is '最小在库';
comment on column MM_INV_STOCK_IMP.stock
  is '库存数量';
alter table MM_INV_STOCK_IMP
  add constraint PK_MM_INV_STOCK_IMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_STOCK_TAKE
prompt ================================
prompt
create table MM_INV_STOCK_TAKE
(
  ins_no        VARCHAR2(30) not null,
  factoy_code   VARCHAR2(10),
  deal_flag     NUMBER(1),
  deal_time     DATE,
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_INV_STOCK_TAKE
  is '???ERP???????';
comment on column MM_INV_STOCK_TAKE.factoy_code
  is '??';
comment on column MM_INV_STOCK_TAKE.deal_flag
  is '0-???
1-???';
comment on column MM_INV_STOCK_TAKE.deal_time
  is '????';
create index IDX_MM_INV_STOCK_TAKE1 on MM_INV_STOCK_TAKE (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_INV_STOCK_TAKE
  add constraint PK_MM_INV_STOCK_TAKE primary key (INS_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_STOCK_TAKE_DETAIL
prompt =======================================
prompt
create table MM_INV_STOCK_TAKE_DETAIL
(
  ins_no     VARCHAR2(30),
  ware_code  VARCHAR2(20),
  part_no    VARCHAR2(20),
  sys_stock  NUMBER(10),
  take_stock NUMBER(10),
  diff_stock NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_STOCK_TAKE_DETAIL.ware_code
  is '??';
comment on column MM_INV_STOCK_TAKE_DETAIL.part_no
  is '???';
comment on column MM_INV_STOCK_TAKE_DETAIL.sys_stock
  is '????';
create index IDX_MM_INV_TAKE_DETAIL1 on MM_INV_STOCK_TAKE_DETAIL (INS_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_STOCK_TAKE_IMP
prompt ====================================
prompt
create table MM_INV_STOCK_TAKE_IMP
(
  factory_code     VARCHAR2(10),
  ware_code        VARCHAR2(20),
  part_no          VARCHAR2(20),
  part_short_no    VARCHAR2(10),
  take_stock       NUMBER(10),
  diff_stock       NUMBER(10),
  note             VARCHAR2(300),
  imp_uuid         VARCHAR2(32),
  import_status    NUMBER(1),
  ope_type         VARCHAR2(8),
  check_result     NUMBER(1),
  check_info       VARCHAR2(300),
  creation_user    VARCHAR2(30),
  creation_time    DATE default SYSDATE,
  standard_package NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_INV_STOCK_TAKE_IMP
  is '???????????';
comment on column MM_INV_STOCK_TAKE_IMP.standard_package
  is '??????????';

prompt
prompt Creating table MM_INV_SUPP_ORDER_BOM
prompt ====================================
prompt
create table MM_INV_SUPP_ORDER_BOM
(
  factory_code       VARCHAR2(10),
  order_no           VARCHAR2(50),
  part_rowno         NUMBER(10),
  part_no            VARCHAR2(30),
  workcenter         VARCHAR2(20),
  num                NUMBER(18,3),
  usage_amount_unit  VARCHAR2(20),
  purchase_type      VARCHAR2(10),
  creation_time      DATE default sysdate,
  last_modified_time DATE,
  creation_user      VARCHAR2(30),
  last_modified_user VARCHAR2(30),
  afoff_time         DATE,
  ware_code          VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_INV_SUPP_ORDER_BOM
  is 'MM_SUPP_ORDER_BOM支给件清单
';
comment on column MM_INV_SUPP_ORDER_BOM.factory_code
  is '工厂
工厂
';
comment on column MM_INV_SUPP_ORDER_BOM.order_no
  is '生产订单号
生产订单号
生产订单号';
comment on column MM_INV_SUPP_ORDER_BOM.part_rowno
  is '组件物料行号
组件物料行号
子件行项目';
comment on column MM_INV_SUPP_ORDER_BOM.part_no
  is '组件物料
组件物料
子件号';
comment on column MM_INV_SUPP_ORDER_BOM.workcenter
  is '车间
车间
车间，需根据装配工位和车间对应关系关联';
comment on column MM_INV_SUPP_ORDER_BOM.num
  is '用量
用量
组件物料在该总成件下的用量';
comment on column MM_INV_SUPP_ORDER_BOM.usage_amount_unit
  is '用量单位
用量单位
子件单位';
comment on column MM_INV_SUPP_ORDER_BOM.purchase_type
  is '采购类型
采购类型
';
comment on column MM_INV_SUPP_ORDER_BOM.creation_time
  is '创建时间
创建时间
';
comment on column MM_INV_SUPP_ORDER_BOM.last_modified_time
  is '最后修改时间
最后修改时间
';
comment on column MM_INV_SUPP_ORDER_BOM.creation_user
  is '创建人
';
comment on column MM_INV_SUPP_ORDER_BOM.last_modified_user
  is '最后修改用户
';
create index IDX_MM_SUPP_ORDER_BOM on MM_INV_SUPP_ORDER_BOM (ORDER_NO)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_SW_REC
prompt ============================
prompt
create table MM_INV_SW_REC
(
  rec_no       VARCHAR2(50) not null,
  purchase_no  VARCHAR2(50),
  factory_code VARCHAR2(10),
  rec_user     VARCHAR2(30),
  rec_time     DATE default sysdate,
  rec_ip       VARCHAR2(50),
  deal_flag    NUMBER(1) default 0,
  deal_time    DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on column MM_INV_SW_REC.deal_flag
  is '0-???
1-???';
create index IDX_MM_INV_SW_REC1 on MM_INV_SW_REC (REC_TIME)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_INV_SW_REC2 on MM_INV_SW_REC (DEAL_FLAG)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_INV_SW_REC3 on MM_INV_SW_REC (PURCHASE_NO)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_INV_SW_REC
  add constraint PK_MM_INV_SW_REC primary key (REC_NO)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_SW_REC_DETAIL
prompt ===================================
prompt
create table MM_INV_SW_REC_DETAIL
(
  rec_no        VARCHAR2(50),
  rec_rowno     NUMBER(10),
  part_no       VARCHAR2(64),
  rec_qty       NUMBER(10),
  rec_nums      NUMBER(10),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
create index IDX_MM_INV_SW_REC_DETAIL1 on MM_INV_SW_REC_DETAIL (REC_NO)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_INV_SW_REC_DETAIL2 on MM_INV_SW_REC_DETAIL (REC_ROWNO)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_INV_SW_REC_DETAIL
  add constraint AK_KEY_1_MM_INV_S unique (REC_NO, REC_ROWNO)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_UNLOAD
prompt ============================
prompt
create table MM_INV_UNLOAD
(
  id                    NUMBER(19) not null,
  factory_code          VARCHAR2(10) not null,
  work_center           VARCHAR2(20),
  ware_code             VARCHAR2(20),
  unload_port           VARCHAR2(20) not null,
  is_pl                 VARCHAR2(20),
  logistics_mode        VARCHAR2(30),
  logic_unload_port     VARCHAR2(200),
  inner_logistics_model VARCHAR2(20),
  unload_port_type      VARCHAR2(200),
  note                  VARCHAR2(100),
  creation_user         VARCHAR2(30),
  creation_time         DATE default sysdate,
  last_modified_user    VARCHAR2(30),
  last_modified_time    DATE,
  empty_plateform       VARCHAR2(200)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_UNLOAD.factory_code
  is '????';
comment on column MM_INV_UNLOAD.work_center
  is '??';
comment on column MM_INV_UNLOAD.ware_code
  is '????';
comment on column MM_INV_UNLOAD.unload_port
  is '???';
comment on column MM_INV_UNLOAD.is_pl
  is '???P?(????PUB_IS_EXISTS)
0-?
1-?';
comment on column MM_INV_UNLOAD.logistics_mode
  is '????(????PUB_MM_MODEL)
SW-????
JIT-????
JISO-????';
comment on column MM_INV_UNLOAD.logic_unload_port
  is '?????';
comment on column MM_INV_UNLOAD.inner_logistics_model
  is '??????';
comment on column MM_INV_UNLOAD.unload_port_type
  is '?????';
comment on column MM_INV_UNLOAD.note
  is '??';
comment on column MM_INV_UNLOAD.creation_user
  is '???';
comment on column MM_INV_UNLOAD.creation_time
  is '????';
comment on column MM_INV_UNLOAD.last_modified_user
  is '?????';
comment on column MM_INV_UNLOAD.last_modified_time
  is '??????';
comment on column MM_INV_UNLOAD.empty_plateform
  is '????';
create index IDX_MM_INV_UNLOAD_ITEM1 on MM_INV_UNLOAD (WORK_CENTER, UNLOAD_PORT, LOGISTICS_MODE)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_INV_UNLOAD
  add constraint PK_MM_INV_UNLOAD primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_INV_UNLOAD
  add constraint AK_MM_INV_UNLOAD unique (FACTORY_CODE, UNLOAD_PORT)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_INV_WAREHOUSE
prompt ===============================
prompt
create table MM_INV_WAREHOUSE
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  ware_code          VARCHAR2(20),
  erp_ware_code      VARCHAR2(20),
  ware_addr          VARCHAR2(100),
  ware_name          VARCHAR2(50),
  ware_type          NUMBER(1),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_INV_WAREHOUSE.factory_code
  is '????';
comment on column MM_INV_WAREHOUSE.ware_code
  is '????';
comment on column MM_INV_WAREHOUSE.erp_ware_code
  is 'SAP????';
comment on column MM_INV_WAREHOUSE.ware_addr
  is '????';
comment on column MM_INV_WAREHOUSE.ware_name
  is '????';
comment on column MM_INV_WAREHOUSE.ware_type
  is '0 ????  1 PC?? 2 ???? 3???';
comment on column MM_INV_WAREHOUSE.creation_user
  is '???';
comment on column MM_INV_WAREHOUSE.creation_time
  is '????';
comment on column MM_INV_WAREHOUSE.last_modified_user
  is '?????';
comment on column MM_INV_WAREHOUSE.last_modified_time
  is '??????';
alter table MM_INV_WAREHOUSE
  add constraint PK_MM_INV_WAREHOUSE primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_INV_WAREHOUSE
  add constraint AK_KEY_2_MM_INV_W unique (WARE_CODE, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_INV_WEEK_CAL
prompt ==============================
prompt
create table MM_INV_WEEK_CAL
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  ware_code          VARCHAR2(20),
  part_no            VARCHAR2(20),
  cal_week           NUMBER(10),
  creation_time      DATE,
  creation_user      VARCHAR2(50),
  last_modified_time DATE,
  last_modified_user VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
alter table MM_INV_WEEK_CAL
  add constraint PK_MM_INV_WEEK_CAL primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_INV_WEEK_CAL_IMP
prompt ==================================
prompt
create table MM_INV_WEEK_CAL_IMP
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  ware_code          VARCHAR2(20),
  part_no            VARCHAR2(20),
  cal_week           NUMBER(10),
  creation_time      DATE,
  creation_user      VARCHAR2(50),
  last_modified_time DATE,
  last_modified_user VARCHAR2(50),
  check_result       NUMBER(1) default 0,
  check_info         VARCHAR2(300),
  import_status      NUMBER(1),
  ope_type           VARCHAR2(8),
  imp_uuid           VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on column MM_INV_WEEK_CAL_IMP.check_result
  is '数据字典类型“IMP_CHECK_RESULT”
0-不通过
1-通过';
comment on column MM_INV_WEEK_CAL_IMP.check_info
  is '校验信息';
comment on column MM_INV_WEEK_CAL_IMP.import_status
  is '0-未导入
1-已导入';
comment on column MM_INV_WEEK_CAL_IMP.ope_type
  is 'I 新增 U更新';
alter table MM_INV_WEEK_CAL_IMP
  add constraint PK_MM_INV_WEEK_CAL_IMP primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISI_INS
prompt ==========================
prompt
create table MM_JISI_INS
(
  ins_no           VARCHAR2(50) not null,
  plan_code        VARCHAR2(20) not null,
  order_no         VARCHAR2(50) not null,
  printer_id       NUMBER(19) not null,
  vin              VARCHAR2(20),
  model_code       VARCHAR2(20),
  phase            VARCHAR2(20),
  wc_seqno         VARCHAR2(10),
  pl_seqno         VARCHAR2(20),
  kb_product_seqno NUMBER(19),
  kb_time          DATE,
  pass_time        DATE,
  print_status     NUMBER(1) default 0,
  print_time       DATE,
  print_user       VARCHAR2(30),
  print_user_ip    VARCHAR2(30),
  creation_time    DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISI_INS.print_status
  is '???????PRINT_STATUS?
';
create index IDX_MM_JISI_INS1 on MM_JISI_INS (PRINT_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_JISI_INS2 on MM_JISI_INS (PASS_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_JISI_INS3 on MM_JISI_INS (PRINTER_ID)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JISI_INS
  add constraint PK_MM_JISI_INS primary key (INS_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISI_INS_DETAIL
prompt =================================
prompt
create table MM_JISI_INS_DETAIL
(
  ins_no             VARCHAR2(50),
  print_location     VARCHAR2(20),
  part_no            VARCHAR2(40),
  require_num        NUMBER(10),
  partgroup_no       VARCHAR2(20),
  partgroup_name     VARCHAR2(150),
  part_short_no      VARCHAR2(10),
  part_name          VARCHAR2(150),
  part_mark          VARCHAR2(20),
  location           VARCHAR2(20),
  creation_time      DATE default SYSDATE,
  last_modified_time DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_JISI_INS_DETAIL
  is '????????????????';
create index IDX_MM_JISI_INS_DETAIL1 on MM_JISI_INS_DETAIL (INS_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISI_INS_SN
prompt =============================
prompt
create table MM_JISI_INS_SN
(
  plan_code  VARCHAR2(20) not null,
  printer_id NUMBER(19) not null,
  use_date   DATE not null,
  seq_no     NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_JISI_INS_SN
  add constraint PK_MM_JISI_INS_SN primary key (USE_DATE, PRINTER_ID, PLAN_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISI_PART
prompt ===========================
prompt
create table MM_JISI_PART
(
  id                 NUMBER(19) not null,
  partgroup_id       NUMBER(19),
  part_no            VARCHAR2(40),
  part_mark          VARCHAR2(20),
  eff_start          DATE,
  eff_end            DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default SYSDATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE default SYSDATE,
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_JISI_PART
  add constraint PK_MM_JISI_PART primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JISI_PART
  add constraint AK_MM_JISI_PART unique (PART_NO, PARTGROUP_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISI_PARTGROUP
prompt ================================
prompt
create table MM_JISI_PARTGROUP
(
  id                 NUMBER(19) not null,
  plan_code          VARCHAR2(20) not null,
  partgroup_no       VARCHAR2(20) not null,
  partgroup_name     VARCHAR2(150),
  printer_id         NUMBER(19),
  print_location     VARCHAR2(20),
  is_auto_print      NUMBER(1) default 0,
  eff_start          DATE,
  eff_end            DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default SYSDATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE default SYSDATE,
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISI_PARTGROUP.is_auto_print
  is '0 ??
1??';
alter table MM_JISI_PARTGROUP
  add constraint PK_MM_JISI_PARTGROUP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JISI_PARTGROUP
  add constraint AK_MM_JISI_PARTGROUP unique (PLAN_CODE, PARTGROUP_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISI_PARTGROUP_IMP
prompt ====================================
prompt
create table MM_JISI_PARTGROUP_IMP
(
  id             NUMBER(19) not null,
  plan_code      VARCHAR2(20),
  partgroup_no   VARCHAR2(20),
  partgroup_name VARCHAR2(150),
  printer_id     NUMBER(19),
  print_location VARCHAR2(20),
  is_auto_print  NUMBER(1) default 0,
  eff_start      DATE,
  eff_end        DATE,
  imp_uuid       VARCHAR2(50),
  check_result   NUMBER(1) default 0,
  check_info     VARCHAR2(512),
  import_status  NUMBER(1) default 0,
  continue_check NUMBER(1) default 1,
  ope_type       VARCHAR2(8) default 'I',
  busi_id        NUMBER(19),
  creation_time  DATE,
  creation_user  VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISI_PARTGROUP_IMP.is_auto_print
  is '0 ??
1??';
comment on column MM_JISI_PARTGROUP_IMP.check_result
  is '??????"PUB_IMP_CK_RESULT"';
comment on column MM_JISI_PARTGROUP_IMP.import_status
  is '???????PUB_IMP_STATUS?';
comment on column MM_JISI_PARTGROUP_IMP.continue_check
  is '0:?
1:?';
comment on column MM_JISI_PARTGROUP_IMP.ope_type
  is 'I:??
U:??';

prompt
prompt Creating table MM_JISI_PART_IMP
prompt ===============================
prompt
create table MM_JISI_PART_IMP
(
  id             NUMBER(19) not null,
  plan_code      VARCHAR2(20),
  partgroup_no   VARCHAR2(20),
  part_no        VARCHAR2(40),
  part_mark      VARCHAR2(20),
  eff_start      DATE,
  eff_end        DATE,
  imp_uuid       VARCHAR2(50),
  check_result   NUMBER(1) default 0,
  check_info     VARCHAR2(512),
  import_status  NUMBER(1) default 0,
  continue_check NUMBER(1) default 1,
  ope_type       VARCHAR2(8) default 'I',
  busi_id        NUMBER(19),
  creation_time  DATE,
  creation_user  VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISI_PART_IMP.check_result
  is '??????"PUB_IMP_CK_RESULT"';
comment on column MM_JISI_PART_IMP.import_status
  is '???????PUB_IMP_STATUS?';
comment on column MM_JISI_PART_IMP.continue_check
  is '0:?
1:?';
comment on column MM_JISI_PART_IMP.ope_type
  is 'I:??
U:??';

prompt
prompt Creating table MM_JISI_QUEUE_CONFIG
prompt ===================================
prompt
create table MM_JISI_QUEUE_CONFIG
(
  plan_code        VARCHAR2(20) not null,
  max_pass_time    DATE,
  work_date        DATE,
  wc_seqno         VARCHAR2(10),
  kb_product_seqno NUMBER(19),
  kb_time          DATE,
  creation_time    DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_JISI_QUEUE_CONFIG
  add constraint PK_MM_JISI_QUEUE_CONFIG primary key (PLAN_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISI_VEH_QUEUE
prompt ================================
prompt
create table MM_JISI_VEH_QUEUE
(
  plan_code         VARCHAR2(20) not null,
  order_no          VARCHAR2(50) not null,
  erp_order_no      VARCHAR2(50) not null,
  vin               VARCHAR2(20),
  model_code        VARCHAR2(20),
  phase             VARCHAR2(20),
  pass_time         DATE,
  wc_seqno          VARCHAR2(10),
  pl_seqno          VARCHAR2(20),
  kb_product_seqno  NUMBER(19),
  kb_time           DATE,
  exec_status       NUMBER(1) default 0,
  exec_time         DATE,
  partgroup_num     NUMBER(5) default 0,
  partgroup_ins_num NUMBER(5) default 0,
  creation_time     DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISI_VEH_QUEUE.exec_status
  is '???????EXEC_STATE?';
create index IDX_MM_JISI_VEH_QUEUE1 on MM_JISI_VEH_QUEUE (EXEC_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_JISI_VEH_QUEUE2 on MM_JISI_VEH_QUEUE (PASS_TIME DESC)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JISI_VEH_QUEUE
  add constraint PK_MM_JISI_VEH_QUEUE primary key (PLAN_CODE, ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_CAR_BATCH
prompt ================================
prompt
create table MM_JISO_CAR_BATCH
(
  plan_code       VARCHAR2(20) not null,
  partgroup_no    VARCHAR2(20) not null,
  route_code      VARCHAR2(20) not null,
  car_batch_seqno NUMBER(19),
  end_flag        NUMBER(1) default 0,
  ins_num         NUMBER(10),
  use_flag        NUMBER(1) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISO_CAR_BATCH.end_flag
  is '0????
1????';
comment on column MM_JISO_CAR_BATCH.use_flag
  is '0????
1????';
alter table MM_JISO_CAR_BATCH
  add constraint PK_MM_JISO_CAR_BATCH primary key (PLAN_CODE, PARTGROUP_NO, ROUTE_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_INS
prompt ==========================
prompt
create table MM_JISO_INS
(
  ins_no                 VARCHAR2(50) not null,
  plan_code              VARCHAR2(20) not null,
  partgroup_no           VARCHAR2(20) not null,
  arr_depot              VARCHAR2(20) not null,
  sup_factory            VARCHAR2(20) not null,
  ins_partgroup_seqno    VARCHAR2(30),
  ins_supfactory_seqno   VARCHAR2(30),
  partgroup_name         VARCHAR2(100),
  order_flg              NUMBER(1),
  gen_ins_way            NUMBER(1),
  supplier_no            VARCHAR2(20),
  supplier_name          VARCHAR2(150),
  route_code             VARCHAR2(20),
  route_desc             VARCHAR2(100),
  car_batch              NUMBER(5),
  car_batch_seqno        NUMBER(19),
  location               VARCHAR2(20),
  distri_person          VARCHAR2(30),
  prepare_product_seqno  NUMBER(19),
  dispatch_product_seqno NUMBER(19),
  delivery_product_seqno NUMBER(19),
  arrive_product_seqno   NUMBER(19),
  distri_product_seqno   NUMBER(19),
  prepare_time           DATE,
  dispatch_time          DATE,
  delivery_time          DATE,
  arrive_time            DATE,
  distri_time            DATE,
  use_location_num       VARCHAR2(10),
  arrive_batch_no        NUMBER(5),
  is_manu_deal           NUMBER(1) default 0,
  manu_req_time          DATE,
  manu_req_user          VARCHAR2(30),
  manu_req_ip            VARCHAR2(30),
  print_status           NUMBER(1) default 0,
  print_time             DATE,
  print_user             VARCHAR2(30),
  print_user_ip          VARCHAR2(30),
  creation_time          DATE default SYSDATE,
  order_no               VARCHAR2(50),
  order_deal_flag        NUMBER(1) default 0,
  order_deal_time        DATE,
  deal_flag              NUMBER(1) default 0,
  deal_time              DATE,
  deal_flag_in           NUMBER(1) default 0,
  deal_time_in           DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISO_INS.order_flg
  is '???????TRUE_FALSE"
';
comment on column MM_JISO_INS.gen_ins_way
  is '0?????????
1????????
';
comment on column MM_JISO_INS.supplier_name
  is '???????';
comment on column MM_JISO_INS.car_batch
  is '??:1-999??';
comment on column MM_JISO_INS.car_batch_seqno
  is '??????';
comment on column MM_JISO_INS.use_location_num
  is 'SYS?????
WC???
LOC???';
comment on column MM_JISO_INS.is_manu_deal
  is '???????TRUE_FALSE"';
comment on column MM_JISO_INS.print_status
  is '???????PRINT_STATUS?
';
comment on column MM_JISO_INS.order_deal_flag
  is '??????: ?JIT_GEN_ORDER_STATUS?';
comment on column MM_JISO_INS.deal_flag
  is '0????
1????';
comment on column MM_JISO_INS.deal_flag_in
  is '0????
1????';
create index IDX_MM_JISO_INS1 on MM_JISO_INS (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JISO_INS2 on MM_JISO_INS (PRINT_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JISO_INS3 on MM_JISO_INS (CREATION_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JISO_INS4 on MM_JISO_INS (ORDER_DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JISO_INS5 on MM_JISO_INS (DEAL_FLAG_IN)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_JISO_INS
  add constraint PK_MM_JISO_INS_HEAD primary key (INS_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JISO_INS_DETAIL
prompt =================================
prompt
create table MM_JISO_INS_DETAIL
(
  ins_no             VARCHAR2(50),
  order_no           VARCHAR2(50),
  part_no            VARCHAR2(64),
  require_num        NUMBER(10),
  part_short_no      VARCHAR2(10),
  part_name          VARCHAR2(150),
  part_mark          VARCHAR2(20),
  remark_flag        VARCHAR2(2),
  vin                VARCHAR2(20),
  model_code         VARCHAR2(20),
  phase              VARCHAR2(20),
  pass_time          DATE,
  wc_seqno           VARCHAR2(10),
  pl_seqno           VARCHAR2(20),
  kb_product_seqno   NUMBER(19),
  kb_time            DATE,
  creation_time      DATE default SYSDATE,
  last_modified_time DATE default SYSDATE,
  rgv_deal_flag      NUMBER(1) default 0,
  rgv_deal_time      DATE,
  sale_no            VARCHAR2(50),
  sale_rowno         NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 8K
    minextents 1
    maxextents unlimited
  );
comment on table MM_JISO_INS_DETAIL
  is '?????????????????';
comment on column MM_JISO_INS_DETAIL.remark_flag
  is '0????
1????';
comment on column MM_JISO_INS_DETAIL.rgv_deal_flag
  is 'RGV?????? ';
comment on column MM_JISO_INS_DETAIL.rgv_deal_time
  is 'RGV?????? ';
comment on column MM_JISO_INS_DETAIL.sale_no
  is '????
  ';
comment on column MM_JISO_INS_DETAIL.sale_rowno
  is '?????
  ';
create index IDX_MM_JISO_INS_DETAIL1 on MM_JISO_INS_DETAIL (INS_NO)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JISO_INS_DETAIL_RECEIVE
prompt =========================================
prompt
create table MM_JISO_INS_DETAIL_RECEIVE
(
  factory_code  VARCHAR2(10) not null,
  ins_no        VARCHAR2(50) not null,
  vin           VARCHAR2(20) not null,
  part_no       VARCHAR2(30) not null,
  part_short_no VARCHAR2(10),
  pass_time     VARCHAR2(50),
  num           VARCHAR2(10),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_JISO_INS_DETAIL_RECEIVE
  is 'RGV??';
comment on column MM_JISO_INS_DETAIL_RECEIVE.deal_flag
  is '????
????
0 ??? 1???';
comment on column MM_JISO_INS_DETAIL_RECEIVE.deal_time
  is '????
????
';
comment on column MM_JISO_INS_DETAIL_RECEIVE.creation_time
  is '????
????
';
alter table MM_JISO_INS_DETAIL_RECEIVE
  add constraint PK_MM_JISO_INS_DETAIL_RECEIVE primary key (FACTORY_CODE, INS_NO, VIN, PART_NO)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JISO_INS_DETAIL_T
prompt ===================================
prompt
create table MM_JISO_INS_DETAIL_T
(
  ins_no             VARCHAR2(50),
  order_no           VARCHAR2(50),
  part_no            VARCHAR2(64),
  require_num        NUMBER(10),
  part_short_no      VARCHAR2(10),
  part_name          VARCHAR2(150),
  part_mark          VARCHAR2(20),
  remark_flag        VARCHAR2(2),
  vin                VARCHAR2(20),
  model_code         VARCHAR2(20),
  phase              VARCHAR2(20),
  pass_time          DATE,
  wc_seqno           VARCHAR2(10),
  pl_seqno           VARCHAR2(20),
  kb_product_seqno   NUMBER(19),
  kb_time            DATE,
  creation_time      DATE default SYSDATE,
  last_modified_time DATE default SYSDATE,
  rgv_deal_flag      NUMBER(1) default 0,
  rgv_deal_time      DATE,
  sale_no            VARCHAR2(50),
  sale_rowno         NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JISO_INS_MANU_DEAL
prompt ====================================
prompt
create table MM_JISO_INS_MANU_DEAL
(
  plan_code     VARCHAR2(20) not null,
  partgroup_no  VARCHAR2(20) not null,
  manu_req_user VARCHAR2(30),
  manu_req_time DATE default SYSDATE,
  manu_req_ip   VARCHAR2(30),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISO_INS_MANU_DEAL.deal_flag
  is '0????
1????';
create index IDX_MM_JISO_INS_MANU_DEAL1 on MM_JISO_INS_MANU_DEAL (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_INS_SN
prompt =============================
prompt
create table MM_JISO_INS_SN
(
  plan_code    VARCHAR2(20) not null,
  partgroup_no VARCHAR2(20) not null,
  use_date     DATE not null,
  seq_no       NUMBER(10),
  use_flag     NUMBER(1) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISO_INS_SN.use_flag
  is '0：未使用
1：使用中';
create index IDX_MM_JISO_INS_SN1 on MM_JISO_INS_SN (USE_FLAG DESC)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JISO_INS_SN
  add constraint PK_MM_JISO_INS_SN primary key (USE_DATE, PARTGROUP_NO, PLAN_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_INS_SN_SUP
prompt =================================
prompt
create table MM_JISO_INS_SN_SUP
(
  plan_code    VARCHAR2(20) not null,
  partgroup_no VARCHAR2(20) not null,
  supplier_no  VARCHAR2(20) not null,
  sup_factory  VARCHAR2(20) not null,
  use_date     DATE not null,
  seq_no       NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_JISO_INS_SN_SUP
  add constraint PK_MM_JISO_INS_SN_SUP primary key (USE_DATE, PARTGROUP_NO, SUPPLIER_NO, SUP_FACTORY, PLAN_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_NET_REQ
prompt ==============================
prompt
create table MM_JISO_NET_REQ
(
  plan_code        VARCHAR2(20) not null,
  partgroup_no     VARCHAR2(20) not null,
  order_no         VARCHAR2(50) not null,
  sale_no          VARCHAR2(50),
  sale_rowno       NUMBER(10),
  supplier_no      VARCHAR2(20) not null,
  sup_factory      VARCHAR2(20) not null,
  route_code       VARCHAR2(20) not null,
  supplier_name    VARCHAR2(100),
  route_desc       VARCHAR2(100),
  part_no          VARCHAR2(40),
  part_short_no    VARCHAR2(10),
  part_name        VARCHAR2(120),
  require_num      NUMBER(10),
  part_mark        VARCHAR2(20),
  vin              VARCHAR2(20),
  model_code       VARCHAR2(20),
  phase            VARCHAR2(20),
  pass_time        DATE,
  wc_seqno         VARCHAR2(10),
  pl_seqno         VARCHAR2(20),
  kb_product_seqno NUMBER(19),
  kb_time          DATE,
  creation_time    DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISO_NET_REQ.sale_no
  is '????
  ';
comment on column MM_JISO_NET_REQ.sale_rowno
  is '?????
  ';
create index IDX_MM_JISO_NET_REQ1 on MM_JISO_NET_REQ (PARTGROUP_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_NET_REQ_T
prompt ================================
prompt
create table MM_JISO_NET_REQ_T
(
  plan_code        VARCHAR2(20) not null,
  partgroup_no     VARCHAR2(20) not null,
  order_no         VARCHAR2(50) not null,
  supplier_no      VARCHAR2(20) not null,
  sup_factory      VARCHAR2(20) not null,
  route_code       VARCHAR2(20) not null,
  supplier_name    VARCHAR2(100),
  route_desc       VARCHAR2(100),
  part_no          VARCHAR2(64),
  part_short_no    VARCHAR2(10),
  part_name        VARCHAR2(120),
  require_num      NUMBER(10),
  part_mark        VARCHAR2(20),
  vin              VARCHAR2(20),
  model_code       VARCHAR2(20),
  phase            VARCHAR2(20),
  pass_time        DATE,
  wc_seqno         VARCHAR2(10),
  pl_seqno         VARCHAR2(20),
  kb_product_seqno NUMBER(19),
  kb_time          DATE,
  creation_time    DATE default SYSDATE,
  sale_no          VARCHAR2(50),
  sale_rowno       NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JISO_ORDER
prompt ============================
prompt
create table MM_JISO_ORDER
(
  order_no                 VARCHAR2(30) not null,
  plan_code                VARCHAR2(20) not null,
  arr_depot                VARCHAR2(20) not null,
  sup_factory              VARCHAR2(20) not null,
  route_code               VARCHAR2(20) not null,
  car_batch_seqno          NUMBER(19),
  supplier_no              VARCHAR2(20),
  supplier_name            VARCHAR2(100),
  route_desc               VARCHAR2(100),
  car_batch                NUMBER(5),
  prepare_product_seqno    NUMBER(19),
  dispatch_product_seqno   NUMBER(19),
  delivery_product_seqno   NUMBER(19),
  arrive_product_seqno     NUMBER(19),
  distri_product_seqno     NUMBER(19),
  prepare_time             DATE,
  dispatch_time            DATE,
  delivery_time            DATE,
  arrive_time              DATE,
  distri_time              DATE,
  arrive_batch_no          NUMBER(5),
  is_manu_deal             NUMBER(1) default 0,
  manu_req_time            DATE,
  manu_req_user            VARCHAR2(30),
  manu_req_ip              VARCHAR2(30),
  print_status             NUMBER(1) default 0,
  print_time               DATE,
  print_user               VARCHAR2(30),
  print_user_ip            VARCHAR2(30),
  purchase_orderno         VARCHAR2(50),
  creation_time            DATE default SYSDATE,
  arrive_status            NUMBER(1) default 0,
  arrive_count             NUMBER(5) default 0,
  actual_arr_product_seqno NUMBER(19),
  deal_flag                NUMBER(1) default 0,
  deal_time                DATE,
  deal_flag_in             NUMBER(1) default 0,
  deal_time_in             DATE,
  receive_date             DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISO_ORDER.car_batch_seqno
  is '??????';
comment on column MM_JISO_ORDER.supplier_name
  is '???????';
comment on column MM_JISO_ORDER.car_batch
  is '??:1-999??';
comment on column MM_JISO_ORDER.is_manu_deal
  is '???????TRUE_FALSE"';
comment on column MM_JISO_ORDER.print_status
  is '???????PRINT_STATUS?
';
comment on column MM_JISO_ORDER.arrive_status
  is '???????ARRIVE_STATUS?';
comment on column MM_JISO_ORDER.deal_flag
  is '0????
1????';
comment on column MM_JISO_ORDER.deal_flag_in
  is '0????
1????';
comment on column MM_JISO_ORDER.receive_date
  is '????';
create index IDX_MM_JISO_ORDER1 on MM_JISO_ORDER (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JISO_ORDER2 on MM_JISO_ORDER (PRINT_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JISO_ORDER3 on MM_JISO_ORDER (CREATION_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JISO_ORDER4 on MM_JISO_ORDER (DEAL_FLAG_IN)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_JISO_ORDER
  add constraint PK_MM_JISO_ORDER primary key (ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JISO_ORDER_DETAIL
prompt ===================================
prompt
create table MM_JISO_ORDER_DETAIL
(
  order_no                 VARCHAR2(50) not null,
  order_rowno              NUMBER(10) not null,
  part_no                  VARCHAR2(40),
  require_num              NUMBER(10),
  part_short_no            VARCHAR2(10),
  part_name                VARCHAR2(150),
  standard_package         NUMBER(10),
  creation_time            DATE default SYSDATE,
  last_modified_time       DATE default SYSDATE,
  arrive_status            NUMBER(1) default 0,
  arrive_count             NUMBER(5) default 0,
  actual_arr_product_seqno NUMBER(19),
  arrive_num               NUMBER(19),
  receive_date             DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISO_ORDER_DETAIL.arrive_status
  is '???????ARRIVE_STATUS?';
comment on column MM_JISO_ORDER_DETAIL.receive_date
  is '收货时间';
create index IDX_MM_JISO_ORDER_DETAIL1 on MM_JISO_ORDER_DETAIL (ORDER_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_JISO_ORDER_DETAIL
  add constraint PK_MM_JISO_ORDER_DETAIL primary key (ORDER_NO, ORDER_ROWNO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JISO_ORDER_MANU_DEAL
prompt ======================================
prompt
create table MM_JISO_ORDER_MANU_DEAL
(
  plan_code       VARCHAR2(20) not null,
  supplier_no     VARCHAR2(20) not null,
  sup_factory     VARCHAR2(20) not null,
  route_code      VARCHAR2(20) not null,
  car_batch_seqno NUMBER(19) not null,
  car_batch       NUMBER(5),
  manu_req_user   VARCHAR2(30),
  manu_req_time   DATE default SYSDATE,
  manu_req_ip     VARCHAR2(30),
  deal_flag       NUMBER(1) default 0,
  deal_time       DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISO_ORDER_MANU_DEAL.car_batch
  is '??:1-999??';
comment on column MM_JISO_ORDER_MANU_DEAL.deal_flag
  is '0????
1????';
create index IDX_MM_JISO_ORDER_MANU_DEAL1 on MM_JISO_ORDER_MANU_DEAL (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JISO_ORDER_MANU_DEAL
  add constraint PK_MM_JISO_INS_MANU_DEAL primary key (PLAN_CODE, SUPPLIER_NO, SUP_FACTORY, ROUTE_CODE, CAR_BATCH_SEQNO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_ORDER_SUP_KB
prompt ===================================
prompt
create table MM_JISO_ORDER_SUP_KB
(
  plan_code    VARCHAR2(20) not null,
  partgroup_no VARCHAR2(20) not null,
  order_no     VARCHAR2(50) not null,
  supplier_no  VARCHAR2(20),
  sup_factory  VARCHAR2(20),
  route_code   VARCHAR2(20),
  order_seqno  NUMBER(19),
  deal_flag    NUMBER(1) default 0,
  deal_time    DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_JISO_ORDER_SUP_KB
  is '??????????';
comment on column MM_JISO_ORDER_SUP_KB.deal_flag
  is '0????
1????';
alter table MM_JISO_ORDER_SUP_KB
  add constraint PK_MM_JISO_ORDER_SUP_KB primary key (PARTGROUP_NO, PLAN_CODE, ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_ORDER_SUP_KB_DEAL
prompt ========================================
prompt
create table MM_JISO_ORDER_SUP_KB_DEAL
(
  plan_code         VARCHAR2(20) not null,
  partgroup_no      VARCHAR2(20) not null,
  order_no          VARCHAR2(50) not null,
  creation_time     DATE default SYSDATE,
  license_plate_num VARCHAR2(50),
  deal_flag         NUMBER(1) default 0,
  deal_time         DATE,
  deal_user         VARCHAR2(30),
  deal_ip           VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_JISO_ORDER_SUP_KB_DEAL
  is '??????????????';
comment on column MM_JISO_ORDER_SUP_KB_DEAL.deal_flag
  is '0????
1????';
alter table MM_JISO_ORDER_SUP_KB_DEAL
  add constraint PK_MM_JISO_ORDER_SUP_KB_DEAL primary key (ORDER_NO, PARTGROUP_NO, PLAN_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_PART
prompt ===========================
prompt
create table MM_JISO_PART
(
  id                 NUMBER(19) not null,
  model_code         VARCHAR2(20) not null,
  partgroup_id       NUMBER(19) not null,
  part_no            VARCHAR2(40) not null,
  part_mark          VARCHAR2(20),
  eff_start          DATE,
  eff_end            DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_JISO_PART
  add constraint PK_MM_JISO_PART primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JISO_PART
  add constraint AK_MM_JISO_PART unique (PART_NO, PARTGROUP_ID, MODEL_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_PARTGROUP
prompt ================================
prompt
create table MM_JISO_PARTGROUP
(
  id                 NUMBER(19) not null,
  plan_code          VARCHAR2(20),
  partgroup_no       VARCHAR2(20),
  partgroup_name     VARCHAR2(100),
  arr_depot          VARCHAR2(20),
  ins_product_num    NUMBER(10),
  order_ins_num      NUMBER(10),
  prepare_num        NUMBER(10),
  dispatch_num       NUMBER(10),
  delivery_num       NUMBER(10),
  arrive_num         NUMBER(10),
  distribution_num   NUMBER(10),
  gen_ins_way        NUMBER(1),
  order_flg          NUMBER(1),
  eff_start          DATE,
  eff_end            DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISO_PARTGROUP.gen_ins_way
  is '0?????????
1????????
';
comment on column MM_JISO_PARTGROUP.order_flg
  is '???????TRUE_FALSE"
';
alter table MM_JISO_PARTGROUP
  add constraint PK_MM_JISO_PARTGROUP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JISO_PARTGROUP
  add constraint AK_MM_JISO_PARTGROUP unique (PLAN_CODE, PARTGROUP_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_PARTGROUP_ROUTE
prompt ======================================
prompt
create table MM_JISO_PARTGROUP_ROUTE
(
  id                 NUMBER(19) not null,
  partgroup_id       NUMBER(19),
  sup_factory        VARCHAR2(20),
  supplier_no        VARCHAR2(20),
  route_code         VARCHAR2(20),
  route_desc         VARCHAR2(100),
  eff_start          DATE,
  eff_end            DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_JISO_PARTGROUP_ROUTE
  add constraint PK_MM_JISO_PARTGROUP_ROUTE primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JISO_PARTGROUP_ROUTE
  add constraint AK_MM_JISO_PARTGROUP_ROUTE unique (PARTGROUP_ID, SUPPLIER_NO, SUP_FACTORY)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_PART_PLAN
prompt ================================
prompt
create table MM_JISO_PART_PLAN
(
  id                 NUMBER(19) not null,
  model_code         VARCHAR2(10),
  supplier_no        VARCHAR2(30),
  arr_depot          VARCHAR2(20),
  partgroup_no       VARCHAR2(20),
  part_no            VARCHAR2(50),
  require_num        NUMBER(10),
  offline_time       DATE,
  creation_time      DATE,
  creation_user      VARCHAR2(50),
  last_modified_time DATE,
  last_modified_user VARCHAR2(50),
  deal_flag_in       NUMBER(2) default 0,
  deal_time_in       DATE,
  do_flag_in         VARCHAR2(10),
  factory_code       VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISO_PART_PLAN.deal_flag_in
  is '0????  1????';
alter table MM_JISO_PART_PLAN
  add constraint PK_MM_JISO_PART_PLAN primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_QUEUE_CONFIG
prompt ===================================
prompt
create table MM_JISO_QUEUE_CONFIG
(
  plan_code        VARCHAR2(20) not null,
  max_pass_time    DATE,
  work_date        DATE,
  wc_seqno         VARCHAR2(10),
  kb_product_seqno NUMBER(19),
  kb_time          DATE,
  creation_time    DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_JISO_QUEUE_CONFIG
  add constraint PK_MM_JISO_QUEUE_CONFIG primary key (PLAN_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JISO_VEH_QUEUE
prompt ================================
prompt
create table MM_JISO_VEH_QUEUE
(
  plan_code           VARCHAR2(20) not null,
  order_no            VARCHAR2(50) not null,
  erp_order_no        VARCHAR2(50) not null,
  sale_no             VARCHAR2(50),
  sale_rowno          NUMBER(10),
  vin                 VARCHAR2(20),
  model_code          VARCHAR2(20),
  phase               VARCHAR2(20),
  pass_time           DATE,
  wc_seqno            VARCHAR2(10),
  pl_seqno            VARCHAR2(20),
  kb_product_seqno    NUMBER(19),
  kb_time             DATE,
  exec_status         NUMBER(1) default 0,
  exec_time           DATE,
  partgroup_num       NUMBER(5) default 0,
  partgroup_ins_num   NUMBER(5) default 0,
  partgroup_order_num NUMBER(5) default 0,
  creation_time       DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JISO_VEH_QUEUE.sale_no
  is '????
  ';
comment on column MM_JISO_VEH_QUEUE.sale_rowno
  is '?????
  ';
comment on column MM_JISO_VEH_QUEUE.exec_status
  is '???????EXEC_STATE?';
create index IDX_MM_JISO_VEH_QUEUE1 on MM_JISO_VEH_QUEUE (EXEC_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_JISO_VEH_QUEUE2 on MM_JISO_VEH_QUEUE (PASS_TIME DESC)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JISO_VEH_QUEUE
  add constraint PK_MM_JISO_VEH_QUEUE primary key (PLAN_CODE, ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_ACCOUNT_FILTER
prompt ====================================
prompt
create table MM_JIT_ACCOUNT_FILTER
(
  id                 NUMBER(19) not null,
  plan_code          VARCHAR2(20) not null,
  order_type         VARCHAR2(10) not null,
  filter_by          VARCHAR2(10) not null,
  filter_data        VARCHAR2(30) not null,
  creation_user      VARCHAR2(30),
  creation_time      DATE default SYSDATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE default SYSDATE,
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JIT_ACCOUNT_FILTER.order_type
  is '??????? JIT_ORDER_TYPE?';
comment on column MM_JIT_ACCOUNT_FILTER.filter_by
  is '??????? JIT_ACCOUNT_FILTER?';
alter table MM_JIT_ACCOUNT_FILTER
  add constraint PK_MM_JIT_ACCOUNT_FILTER primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JIT_ACCOUNT_FILTER
  add constraint AK_MM_JIT_ACCOUNT_FILTER unique (PLAN_CODE, ORDER_TYPE, FILTER_BY, FILTER_DATA)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_INS
prompt =========================
prompt
create table MM_JIT_INS
(
  ins_no                   VARCHAR2(100) not null,
  plan_code                VARCHAR2(20),
  ship_depot               VARCHAR2(20),
  arr_depot                VARCHAR2(20),
  prepare_person           VARCHAR2(30),
  distri_person            VARCHAR2(30),
  carpool                  VARCHAR2(30),
  gen_ins_way              VARCHAR2(2),
  prepare_product_seqno    NUMBER(19),
  delivery_product_seqno   NUMBER(19),
  arrive_product_seqno     NUMBER(19),
  distri_product_seqno     NUMBER(19),
  prepare_time             DATE,
  delivery_time            DATE,
  arrive_time              DATE,
  distri_time              DATE,
  ins_no_batch             VARCHAR2(100),
  ins_no_diffseq           NUMBER(3) default 0,
  order_no                 VARCHAR2(50),
  print_status             NUMBER(1) default 0,
  print_time               DATE,
  print_user               VARCHAR2(30),
  print_user_ip            VARCHAR2(30),
  prepare_batch_no         NUMBER(5),
  creation_time            DATE default SYSDATE,
  prepare_status           NUMBER(1) default 0,
  prepare_count            NUMBER(5),
  actual_pre_product_seqno NUMBER(19),
  f_distri_status          NUMBER(2) default 0,
  f_distri_count           NUMBER(5),
  t_distri_status          NUMBER(2) default 0,
  t_distri_count           NUMBER(5),
  is_load                  NUMBER(1) default 0,
  load_time                DATE,
  is_jump                  NUMBER(1) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_JIT_INS.gen_ins_way
  is '???????JITI_GEN_INS_WAY?';
comment on column MM_JIT_INS.print_status
  is '0????
1????';
comment on column MM_JIT_INS.prepare_status
  is '0-???
1-????
2-????';
comment on column MM_JIT_INS.prepare_count
  is '
1-????
2-????';
comment on column MM_JIT_INS.f_distri_status
  is '0????
1?????
2?????';
comment on column MM_JIT_INS.f_distri_count
  is '
1-????
2-????';
comment on column MM_JIT_INS.t_distri_status
  is '0-???
1-????
2-????';
comment on column MM_JIT_INS.t_distri_count
  is '0????
1?????
2?????';
comment on column MM_JIT_INS.is_jump
  is '0??? 1???';
create index IDX_MM_JIT_INS1 on MM_JIT_INS (PRINT_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_INS2 on MM_JIT_INS (INS_NO_BATCH)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_INS3 on MM_JIT_INS (IS_LOAD)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_INS4 on MM_JIT_INS (ORDER_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_JIT_INS
  add constraint PK_MM_JIT_INS primary key (INS_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JIT_INS_DETAIL
prompt ================================
prompt
create table MM_JIT_INS_DETAIL
(
  ins_no             VARCHAR2(100) not null,
  part_no            VARCHAR2(40) not null,
  location           VARCHAR2(20) not null,
  distri_person      VARCHAR2(30),
  carpool            VARCHAR2(30),
  require_num        NUMBER(10),
  prepare_count      NUMBER(5) default 0,
  prepare_num        NUMBER(10) default 0,
  part_short_no      VARCHAR2(10),
  part_name          VARCHAR2(150),
  supplier_no        VARCHAR2(20),
  supplier_name      VARCHAR2(150),
  standard_package   NUMBER(10),
  storage            VARCHAR2(30),
  creation_time      DATE default SYSDATE,
  last_modified_time DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_INS_DETAIL1 on MM_JIT_INS_DETAIL (INS_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JIT_INS_IN_ORDER
prompt ==================================
prompt
create table MM_JIT_INS_IN_ORDER
(
  order_no         VARCHAR2(50) not null,
  order_no_batch   VARCHAR2(50),
  order_no_diffseq NUMBER(10),
  creation_time    DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_INS_IN_ORDER1 on MM_JIT_INS_IN_ORDER (ORDER_NO_BATCH)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JIT_INS_IN_ORDER
  add constraint PK_MM_JIT_INS_IN_ORDER primary key (ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_INS_PRINTER_CONFIG
prompt ========================================
prompt
create table MM_JIT_INS_PRINTER_CONFIG
(
  id                 NUMBER(19) not null,
  plan_code          VARCHAR2(20) not null,
  prepare_person     VARCHAR2(30) not null,
  is_auto_print      NUMBER(1),
  printer_id         NUMBER(5),
  creation_user      VARCHAR2(30),
  creation_time      DATE default SYSDATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE default SYSDATE,
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JIT_INS_PRINTER_CONFIG.is_auto_print
  is '???????TRUE_FALSE"';
alter table MM_JIT_INS_PRINTER_CONFIG
  add constraint PK_MM_JIT_INS_PRINTER_CONFIG primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JIT_INS_PRINTER_CONFIG
  add constraint AK_MM_JIT_INS_PRINTER_CONFIG unique (PLAN_CODE, PREPARE_PERSON)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_INS_SORT
prompt ==============================
prompt
create table MM_JIT_INS_SORT
(
  id      NUMBER(10) not null,
  storage VARCHAR2(30),
  sort_id NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_JIT_INS_SORT
  is '???????';
comment on column MM_JIT_INS_SORT.id
  is 'ID';
comment on column MM_JIT_INS_SORT.storage
  is '????';
comment on column MM_JIT_INS_SORT.sort_id
  is '???';

prompt
prompt Creating table MM_JIT_INVEN_COMP
prompt ================================
prompt
create table MM_JIT_INVEN_COMP
(
  id                      NUMBER(19) not null,
  plan_code               VARCHAR2(20),
  part_no                 VARCHAR2(40),
  vin                     VARCHAR2(20),
  arr_batch_no            NUMBER(5),
  arr_process_no          NUMBER(5),
  curr_inventory          NUMBER(10),
  safety_inventory        NUMBER(10),
  check_part_short_no     VARCHAR2(10),
  check_part_name         VARCHAR2(150),
  check_arr_pro_seqno     NUMBER(19),
  check_cal_vin           VARCHAR2(20),
  check_cal_kb_pro_seqno  NUMBER(19),
  check_plan_qty          NUMBER(10) default 0,
  check_assembly_qty      NUMBER(10) default 0,
  check_part_remain       NUMBER(10) default 0,
  check_inventory_diffqty NUMBER(10),
  check_sort_no           NUMBER(10),
  creation_time           DATE default sysdate,
  imp_uuid                VARCHAR2(50),
  check_result            NUMBER(1),
  check_info              VARCHAR2(512),
  import_status           NUMBER(1),
  continue_check          NUMBER(1),
  ope_type                VARCHAR2(8),
  busi_id                 NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JIT_INVEN_COMP.check_result
  is '0:???
1:??';
comment on column MM_JIT_INVEN_COMP.import_status
  is '0:???
1:???';
comment on column MM_JIT_INVEN_COMP.continue_check
  is '0:?
1:?';
comment on column MM_JIT_INVEN_COMP.ope_type
  is 'I:??
U:??';
alter table MM_JIT_INVEN_COMP
  add constraint PK_MM_JIT_INVEN_COMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_LABEL
prompt ===========================
prompt
create table MM_JIT_LABEL
(
  order_no                    VARCHAR2(50) not null,
  label_rowno                 NUMBER(19) not null,
  plan_code                   VARCHAR2(20),
  part_no                     VARCHAR2(40),
  location                    VARCHAR2(20),
  require_num                 NUMBER(10),
  part_short_no               VARCHAR2(10),
  part_name                   VARCHAR2(150),
  supplier_no                 VARCHAR2(20),
  supplier_name               VARCHAR2(150),
  ship_depot                  VARCHAR2(20),
  arr_depot                   VARCHAR2(20),
  standard_package            NUMBER(10),
  distri_package              NUMBER(10),
  unload_port                 VARCHAR2(20),
  prepare_person              VARCHAR2(30),
  storage                     VARCHAR2(30),
  distri_person               VARCHAR2(30),
  kb_product_seqno            NUMBER(19),
  prepare_product_seqno       NUMBER(19),
  dispatch_product_seqno      NUMBER(19),
  delivery_product_seqno      NUMBER(19),
  arrive_product_seqno        NUMBER(19),
  distri_product_seqno        NUMBER(19),
  assemble_product_seqno      NUMBER(19),
  kb_time                     DATE,
  prepare_time                DATE,
  dispatch_time               DATE,
  delivery_time               DATE,
  arrive_time                 DATE,
  distri_time                 DATE,
  assemble_time               DATE,
  prepare_batch_no            NUMBER(5),
  kb_batch_no                 NUMBER(5),
  label_part_rowno            NUMBER(10),
  print_status                NUMBER(1) default 0,
  print_time                  DATE,
  print_user                  VARCHAR2(30),
  print_user_ip               VARCHAR2(30),
  creation_time               DATE default SYSDATE,
  deal_flag                   NUMBER(1) default 0,
  deal_time                   DATE,
  deal_flag_in                NUMBER(1) default 0,
  deal_time_in                DATE,
  bar_uuid                    VARCHAR2(50),
  actual_distri_product_seqno NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_JIT_LABEL.print_status
  is '数据字典类型“PRINT_STATUS"';
comment on column MM_JIT_LABEL.deal_flag
  is '"0：未处理
1：已处理"';
comment on column MM_JIT_LABEL.deal_flag_in
  is '"0：未处理
1：已处理"';
comment on column MM_JIT_LABEL.bar_uuid
  is 'UUID';
create index IDX_MM_JIT_LABEL1 on MM_JIT_LABEL (PRINT_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_LABEL2 on MM_JIT_LABEL (CREATION_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_LABEL3 on MM_JIT_LABEL (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_LABEL4 on MM_JIT_LABEL (ORDER_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_LABEL5 on MM_JIT_LABEL (DEAL_FLAG_IN)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_JIT_LABEL
  add constraint AK_KEY_1_MM_JIT_L unique (ORDER_NO, LABEL_ROWNO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JIT_NET_REQ
prompt =============================
prompt
create table MM_JIT_NET_REQ
(
  plan_code        VARCHAR2(20) not null,
  order_no         VARCHAR2(50) not null,
  part_no          VARCHAR2(40) not null,
  location         VARCHAR2(20),
  require_num      NUMBER(10),
  model_code       VARCHAR2(20),
  pass_time        DATE,
  kb_product_seqno NUMBER(19),
  kb_time          DATE,
  deal_state       NUMBER(1) default 0,
  creation_time    DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_NET_REQ1 on MM_JIT_NET_REQ (PART_NO, PLAN_CODE, LOCATION)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_ORDER
prompt ===========================
prompt
create table MM_JIT_ORDER
(
  order_no                  VARCHAR2(50) not null,
  plan_code                 VARCHAR2(20),
  ship_depot                VARCHAR2(20),
  arr_depot                 VARCHAR2(20),
  ship_depot_type           VARCHAR2(10),
  sup_factory               VARCHAR2(30),
  supplier_no               VARCHAR2(30),
  supplier_name             VARCHAR2(100),
  s_prepare_product_seqno   NUMBER(19),
  e_prepare_product_seqno   NUMBER(19),
  dispatch_product_seqno    NUMBER(19),
  delivery_product_seqno    NUMBER(19),
  arrive_product_seqno      NUMBER(19),
  prepare_time              DATE,
  dispatch_time             DATE,
  delivery_time             DATE,
  arrive_time               DATE,
  s_prepare_batch_no        NUMBER(5),
  e_prepare_batch_no        NUMBER(5),
  delivery_batch_no         NUMBER(5),
  print_status              NUMBER(2) default 0,
  print_time                DATE,
  print_user                VARCHAR2(30),
  print_user_ip             VARCHAR2(30),
  order_no_batch            VARCHAR2(50),
  order_no_diffseq          NUMBER(3) default 0,
  purchase_orderno          VARCHAR2(50),
  creation_time             DATE default SYSDATE,
  prepare_status            NUMBER(1) default 0,
  prepare_count             NUMBER(5) default 0,
  actual_pre_product_seqno  NUMBER(19),
  delivery_status           NUMBER(1) default 0,
  delivery_count            NUMBER(5) default 0,
  actual_deli_product_seqno NUMBER(19),
  arrive_status             NUMBER(1) default 0,
  arrive_count              NUMBER(5) default 0,
  actual_arr_product_seqno  NUMBER(19),
  deal_flag                 NUMBER(1) default 0,
  deal_time                 DATE,
  deal_flag_in              NUMBER(1) default 0,
  deal_time_in              DATE,
  receive_date              DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_JIT_ORDER.ship_depot_type
  is '???????PUB_SHIP_DEPOT_TYPE?';
comment on column MM_JIT_ORDER.sup_factory
  is '???????';
comment on column MM_JIT_ORDER.supplier_no
  is '???????';
comment on column MM_JIT_ORDER.supplier_name
  is '???????';
comment on column MM_JIT_ORDER.print_status
  is '???????PRINT_STATUS?';
comment on column MM_JIT_ORDER.order_no_diffseq
  is '>0????';
comment on column MM_JIT_ORDER.prepare_status
  is '???????PREPARE_STATUS?';
comment on column MM_JIT_ORDER.delivery_status
  is '???????DELIVERY_STATUS?';
comment on column MM_JIT_ORDER.arrive_status
  is '???????ARRIVE_STATUS?';
comment on column MM_JIT_ORDER.deal_flag
  is '0????
1????';
comment on column MM_JIT_ORDER.deal_flag_in
  is '0????
1????';
comment on column MM_JIT_ORDER.receive_date
  is '????';
create index IDX_MM_JIT_ORDER1 on MM_JIT_ORDER (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_ORDER2 on MM_JIT_ORDER (CREATION_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_ORDER3 on MM_JIT_ORDER (S_PREPARE_PRODUCT_SEQNO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_ORDER4 on MM_JIT_ORDER (DEAL_FLAG_IN)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_JIT_ORDER
  add constraint PK_MM_JIT_ORDER primary key (ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JIT_ORDER_CONFIG
prompt ==================================
prompt
create table MM_JIT_ORDER_CONFIG
(
  id                      NUMBER(19) not null,
  plan_code               VARCHAR2(20) not null,
  ship_depot              VARCHAR2(30) not null,
  arr_depot               VARCHAR2(30) not null,
  ship_depot_type         VARCHAR2(10),
  sup_factory             VARCHAR2(20),
  supplier_no             VARCHAR2(20),
  order_product_num       NUMBER(10),
  ahead_product_num       NUMBER(10),
  s_prepare_product_seqno NUMBER(19),
  e_prepare_product_seqno NUMBER(19),
  eff_start               DATE,
  eff_end                 DATE,
  creation_user           VARCHAR2(30),
  creation_time           DATE default SYSDATE,
  last_modified_user      VARCHAR2(30),
  last_modified_time      DATE default SYSDATE,
  last_modified_ip        VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_JIT_ORDER_CONFIG
  add constraint PK_MM_JIT_ORDER_CONFIG primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JIT_ORDER_CONFIG
  add constraint AK_MM_JIT_ORDER_CONFIG unique (PLAN_CODE, SHIP_DEPOT, ARR_DEPOT)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_ORDER_DETAIL
prompt ==================================
prompt
create table MM_JIT_ORDER_DETAIL
(
  order_no                  VARCHAR2(50),
  order_rowno               NUMBER(10),
  part_no                   VARCHAR2(40),
  location                  VARCHAR2(20),
  require_num               NUMBER(10),
  part_short_no             VARCHAR2(10),
  part_name                 VARCHAR2(150),
  standard_package          NUMBER(10),
  box_num                   NUMBER(5),
  supplier_no               VARCHAR2(20),
  supplier_name             VARCHAR2(150),
  purchase_orderno          VARCHAR2(50),
  prepare_status            NUMBER(1) default 0,
  prepare_count             NUMBER(5) default 0,
  actual_pre_product_seqno  NUMBER(19),
  prepare_num               NUMBER(10) default 0,
  delivery_status           NUMBER(1) default 0,
  delivery_count            NUMBER(5) default 0,
  actual_deli_product_seqno NUMBER(19),
  delivery_num              NUMBER(10) default 0,
  arrive_status             NUMBER(1) default 0,
  arrive_count              NUMBER(5) default 0,
  actual_arr_product_seqno  NUMBER(19),
  arrive_num                NUMBER(10) default 0,
  creation_time             DATE default SYSDATE,
  last_modified_time        DATE default SYSDATE,
  receive_date              DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_JIT_ORDER_DETAIL.prepare_status
  is '???????PREPARE_STATUS?';
comment on column MM_JIT_ORDER_DETAIL.delivery_status
  is '???????DELIVERY_STATUS?';
comment on column MM_JIT_ORDER_DETAIL.arrive_status
  is '???????ARRIVE_STATUS?';
comment on column MM_JIT_ORDER_DETAIL.receive_date
  is '收货时间';
create index IDX_JIT_ORDER_DETAIL1 on MM_JIT_ORDER_DETAIL (ORDER_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_JIT_ORDER_DETAIL
  add constraint AK_KEY_1_MM_JIT_O unique (ORDER_NO, ORDER_ROWNO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JIT_PART
prompt ==========================
prompt
create table MM_JIT_PART
(
  id                 NUMBER(19) not null,
  model_code         VARCHAR2(20) not null,
  plan_code          VARCHAR2(20) not null,
  part_no            VARCHAR2(40) not null,
  ship_depot         VARCHAR2(20),
  arr_depot          VARCHAR2(20),
  prepare_num        NUMBER(10),
  dispatch_num       NUMBER(10),
  delivery_num       NUMBER(10),
  arrive_num         NUMBER(10),
  distribution_num   NUMBER(10),
  distri_package     NUMBER(10),
  standard_package   NUMBER(10),
  eff_start          DATE,
  eff_end            DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default SYSDATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE default SYSDATE,
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_JIT_PART
  add constraint PK_MM_JIT_PART primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JIT_PART
  add constraint AK_MM_JIT_PART unique (PART_NO, PLAN_CODE, MODEL_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_PART_LACK
prompt ===============================
prompt
create table MM_JIT_PART_LACK
(
  id                      NUMBER(19) not null,
  plan_code               VARCHAR2(20),
  part_no                 VARCHAR2(40),
  s_prepare_product_seqno NUMBER(19),
  e_prepare_product_seqno NUMBER(19),
  s_distri_product_seqno  NUMBER(19),
  e_distri_product_seqno  NUMBER(19),
  location                VARCHAR2(20),
  lack_num                NUMBER(10),
  distri_num              NUMBER(10) default 0,
  deal_status             NUMBER(1) default 0,
  creation_time           DATE default SYSDATE,
  deal_flag               NUMBER(1) default 0,
  deal_time               DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_JIT_PART_LACK
  add constraint PK_MM_JIT_PART_LACK primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_PART_LACK_DEAL
prompt ====================================
prompt
create table MM_JIT_PART_LACK_DEAL
(
  id                   NUMBER(19) not null,
  lack_id              NUMBER(19),
  order_no             VARCHAR2(50),
  label_rowno          NUMBER(19),
  distri_product_seqno NUMBER(19),
  distri_num           NUMBER(10),
  deal_user            VARCHAR2(30),
  deal_ip              VARCHAR2(30),
  deal_time            DATE,
  creation_time        DATE default SYSDATE,
  deal_method          NUMBER(1)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_JIT_PART_LACK_DEAL
  add constraint PK_MM_JIT_PART_LACK_DEAL primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_PART_LACK_IMP
prompt ===================================
prompt
create table MM_JIT_PART_LACK_IMP
(
  id                      NUMBER(19) not null,
  plan_code               VARCHAR2(20),
  part_no                 VARCHAR2(40),
  location                VARCHAR2(20),
  part_short_no           VARCHAR2(10),
  part_name               VARCHAR2(150),
  s_prepare_product_seqno NUMBER(19),
  e_prepare_product_seqno NUMBER(19),
  s_distri_product_seqno  NUMBER(19),
  e_distri_product_seqno  NUMBER(19),
  require_num             NUMBER(10),
  imp_uuid                VARCHAR2(50),
  check_result            NUMBER(1),
  check_info              VARCHAR2(512),
  import_status           NUMBER(1),
  continue_check          NUMBER(1),
  ope_type                VARCHAR2(8),
  busi_id                 NUMBER(19),
  box_num                 NUMBER(5),
  creation_time           DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JIT_PART_REMAIN
prompt =================================
prompt
create table MM_JIT_PART_REMAIN
(
  id                 NUMBER(19) not null,
  part_no            VARCHAR2(40) not null,
  plan_code          VARCHAR2(20) not null,
  location           VARCHAR2(20),
  part_remain        NUMBER(10) default 0,
  safety_inventory   NUMBER(10) default 0,
  end_require_date   DATE,
  end_require_num    NUMBER(10),
  start_remain       NUMBER(10),
  end_remain         NUMBER(10) default 0,
  creation_user      VARCHAR2(30),
  creation_time      DATE default SYSDATE,
  last_modified_user VARCHAR2(30),
  last_modified_ip   VARCHAR2(30),
  last_modified_time DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_JIT_PART_REMAIN
  add constraint PK_MM_JIT_PART_REMAIN primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JIT_PART_REMAIN
  add constraint AK_MM_JIT_PART_REMAIN unique (PART_NO, PLAN_CODE, LOCATION)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_PART_REMAIN_IMP
prompt =====================================
prompt
create table MM_JIT_PART_REMAIN_IMP
(
  id               NUMBER(19) not null,
  plan_code        VARCHAR2(20),
  part_no          VARCHAR2(40),
  location         VARCHAR2(20),
  part_remain      NUMBER(10) default 0,
  safety_inventory NUMBER(10) default 0,
  end_require_date DATE,
  end_require_num  NUMBER(10),
  imp_uuid         VARCHAR2(50),
  check_result     NUMBER(1) default 0,
  check_info       VARCHAR2(512),
  import_status    NUMBER(1) default 0,
  continue_check   NUMBER(1) default 1,
  ope_type         VARCHAR2(8) default 'I',
  busi_id          NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JIT_PART_REMAIN_IMP.check_result
  is '??????"PUB_IMP_CK_RESULT"';
comment on column MM_JIT_PART_REMAIN_IMP.import_status
  is '???????PUB_IMP_STATUS?';
comment on column MM_JIT_PART_REMAIN_IMP.continue_check
  is '0:?
1:?';
comment on column MM_JIT_PART_REMAIN_IMP.ope_type
  is 'I:??
U:??';
alter table MM_JIT_PART_REMAIN_IMP
  add constraint PK_MM_JIT_PART_REMAIN_IMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_PART_REMAIN_LOG
prompt =====================================
prompt
create table MM_JIT_PART_REMAIN_LOG
(
  id               NUMBER(19) not null,
  plan_code        VARCHAR2(20),
  part_no          VARCHAR2(40),
  location         VARCHAR2(20),
  part_remain_old  NUMBER(10),
  part_remain_new  NUMBER(10),
  safety_inventory NUMBER(10),
  end_require_date DATE,
  end_require_num  NUMBER(10),
  kb_product_seqno NUMBER(19),
  ope_user         VARCHAR2(30),
  ope_ip           VARCHAR2(80),
  ope_time         DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index IDX_JIT_PART_REMAIN_LOG1 on MM_JIT_PART_REMAIN_LOG (OPE_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_JIT_PART_REMAIN_LOG2 on MM_JIT_PART_REMAIN_LOG (PART_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JIT_PART_REMAIN_LOG
  add constraint PK_MM_JIT_PART_REMAIN_LOG primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_PART_REMAIN_PROD
prompt ======================================
prompt
create table MM_JIT_PART_REMAIN_PROD
(
  id                 NUMBER(19) not null,
  part_no            VARCHAR2(40) not null,
  plan_code          VARCHAR2(20) not null,
  location           VARCHAR2(20),
  s_kb_product_seqno NUMBER(19),
  e_kb_product_seqno NUMBER(19),
  start_remain       NUMBER(10),
  end_remain         NUMBER(10) default 0,
  require_num        NUMBER(10),
  distri_package     NUMBER(10),
  safety_inventory   NUMBER(10) default 0,
  dpm_num            NUMBER(10) default 0,
  end_require_num    NUMBER(10) default 0,
  is_finish          NUMBER(1) default 0,
  creation_time      DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JIT_PART_REMAIN_PROD.is_finish
  is '0????
1????';
create index IDX_MM_JIT_PART_REMAIN_PROD1 on MM_JIT_PART_REMAIN_PROD (IS_FINISH)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JIT_PART_REMAIN_PROD
  add constraint PK_MM_JIT_PART_REMAIN_PROD primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JIT_PART_REMAIN_PROD
  add constraint AK_MM_JIT_PART_REMAIN_PROD unique (S_KB_PRODUCT_SEQNO, PART_NO, PLAN_CODE, LOCATION)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_PKG_REQ
prompt =============================
prompt
create table MM_JIT_PKG_REQ
(
  id                     NUMBER(19) not null,
  plan_code              VARCHAR2(20),
  part_no                VARCHAR2(40),
  location               VARCHAR2(20),
  s_product_seqno        NUMBER(19),
  e_product_seqno        NUMBER(19),
  require_num            NUMBER(10),
  part_short_no          VARCHAR2(10),
  part_name              VARCHAR2(120),
  sup_factory            VARCHAR2(20),
  supplier_no            VARCHAR2(20),
  supplier_name          VARCHAR2(100),
  ship_depot             VARCHAR2(20),
  arr_depot              VARCHAR2(20),
  distri_package         NUMBER(10),
  standard_package       NUMBER(10),
  unload_port            VARCHAR2(20),
  storage                VARCHAR2(30),
  prepare_person         VARCHAR2(30),
  carpool                VARCHAR2(30),
  distri_person          VARCHAR2(30),
  kb_product_seqno       NUMBER(19),
  prepare_product_seqno  NUMBER(19),
  dispatch_product_seqno NUMBER(19),
  delivery_product_seqno NUMBER(19),
  arrive_product_seqno   NUMBER(19),
  distri_product_seqno   NUMBER(19),
  assemble_product_seqno NUMBER(19),
  kb_time                DATE,
  prepare_time           DATE,
  dispatch_time          DATE,
  delivery_time          DATE,
  arrive_time            DATE,
  distri_time            DATE,
  assemble_time          DATE,
  prepare_batch_seqno    NUMBER(19),
  use_location_num       VARCHAR2(10),
  creation_time          DATE default SYSDATE,
  order_no               VARCHAR2(50),
  order_deal_flag        NUMBER(1) default 0,
  order_deal_time        DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_JIT_PKG_REQ.use_location_num
  is 'SYS?????
WC???
LOC???';
comment on column MM_JIT_PKG_REQ.order_deal_flag
  is '??????: ?JIT_GEN_ORDER_STATUS?';
create index IDX_MM_JIT_PKG_REQ1 on MM_JIT_PKG_REQ (ORDER_DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_PKG_REQ2 on MM_JIT_PKG_REQ (ORDER_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_PKG_REQ3 on MM_JIT_PKG_REQ (CREATION_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_PKG_REQ4 on MM_JIT_PKG_REQ (KB_PRODUCT_SEQNO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_JIT_PKG_REQ
  add constraint PK_MM_JIT_PKG_REQ primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_JIT_PKG_REQ_DPM
prompt =================================
prompt
create table MM_JIT_PKG_REQ_DPM
(
  dpm_apply_no  VARCHAR2(50) not null,
  plan_code     VARCHAR2(20) not null,
  part_no       VARCHAR2(40) not null,
  location      VARCHAR2(20) not null,
  dpm_num       NUMBER(10),
  pkg_req_id    NUMBER(19),
  pkg_deal_flag NUMBER(1) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JIT_PKG_REQ_DPM.pkg_deal_flag
  is '0??
1??';
create index IDX_MM_JIT_PKG_REQ_DPM1 on MM_JIT_PKG_REQ_DPM (PKG_REQ_ID)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JIT_PKG_REQ_DPM
  add constraint PK_MM_JIT_PKG_REQ_DPM primary key (PART_NO, PLAN_CODE, LOCATION, DPM_APPLY_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_QUEUE_CONFIG
prompt ==================================
prompt
create table MM_JIT_QUEUE_CONFIG
(
  plan_code        VARCHAR2(20) not null,
  is_plan          NUMBER(1),
  max_pass_time    DATE,
  max_sortid       NUMBER(19),
  kb_product_seqno NUMBER(19),
  kb_time          DATE,
  creation_time    DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JIT_QUEUE_CONFIG.is_plan
  is '0??
1??';
alter table MM_JIT_QUEUE_CONFIG
  add constraint PK_MM_JIT_QUEUE_CONFIG primary key (PLAN_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_REAL_KB_BATCH
prompt ===================================
prompt
create table MM_JIT_REAL_KB_BATCH
(
  plan_code             VARCHAR2(20) not null,
  order_no              VARCHAR2(50) not null,
  real_kb_time          DATE,
  real_kb_product_seqno NUMBER(19),
  creation_time         DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_JIT_REAL_KB_BATCH1 on MM_JIT_REAL_KB_BATCH (REAL_KB_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JIT_REAL_KB_BATCH
  add constraint PK_MM_JIT_REAL_KB_BATCH primary key (PLAN_CODE, ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_VEH_FILTER
prompt ================================
prompt
create table MM_JIT_VEH_FILTER
(
  plan_code     VARCHAR2(20),
  order_no      VARCHAR2(50),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;

prompt
prompt Creating table MM_JIT_VEH_QUEUE
prompt ===============================
prompt
create table MM_JIT_VEH_QUEUE
(
  plan_code          VARCHAR2(20) not null,
  order_no           VARCHAR2(50) not null,
  erp_order_no       VARCHAR2(50) not null,
  vin                VARCHAR2(20),
  model_code         VARCHAR2(20),
  phase              VARCHAR2(20),
  sortid             NUMBER(19),
  pass_time          DATE,
  kb_product_seqno   NUMBER(19),
  kb_time            DATE,
  exec_status        NUMBER(1) default 0,
  exec_time          DATE,
  creation_time      DATE default SYSDATE,
  last_modified_user VARCHAR2(30),
  last_modified_ip   VARCHAR2(30),
  last_modified_time DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_JIT_VEH_QUEUE.exec_status
  is '???????EXEC_STATE?';
create index IDX_MM_JIT_VEH_QUEUE1 on MM_JIT_VEH_QUEUE (EXEC_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_JIT_VEH_QUEUE2 on MM_JIT_VEH_QUEUE (PASS_TIME DESC)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JIT_VEH_QUEUE
  add constraint PK_MM_JIT_VEH_QUEUE primary key (ORDER_NO, PLAN_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_JIT_VEH_SCRAP
prompt ===============================
prompt
create table MM_JIT_VEH_SCRAP
(
  factory_code       VARCHAR2(10) not null,
  order_no           VARCHAR2(50) not null,
  erp_order_no       VARCHAR2(50) not null,
  vin                VARCHAR2(20),
  scrap_workcenter   VARCHAR2(20),
  scrap_station_code VARCHAR2(20),
  scrap_station_desc VARCHAR2(50),
  scrap_reason       VARCHAR2(600),
  scrap_time         DATE,
  adjust_kb_state    NUMBER(1),
  adjust_user        VARCHAR2(30),
  adjust_time        DATE,
  adjust_ip          VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_JIT_VEH_SCRAP
  is 'MM_JIT_VEH_SCRAP?????????
MM_JIT_VEH_SCRAP?????????
';
comment on column MM_JIT_VEH_SCRAP.factory_code
  is '??
??
';
comment on column MM_JIT_VEH_SCRAP.order_no
  is '???
???
';
comment on column MM_JIT_VEH_SCRAP.erp_order_no
  is 'ERP???
ERP???
ERP???';
comment on column MM_JIT_VEH_SCRAP.vin
  is 'VIN
VIN
';
comment on column MM_JIT_VEH_SCRAP.scrap_workcenter
  is '????
????
';
comment on column MM_JIT_VEH_SCRAP.scrap_station_code
  is '??????
??????
';
comment on column MM_JIT_VEH_SCRAP.scrap_station_desc
  is '????????
????????
';
comment on column MM_JIT_VEH_SCRAP.scrap_reason
  is '????
????
';
comment on column MM_JIT_VEH_SCRAP.scrap_time
  is '????
????
';
comment on column MM_JIT_VEH_SCRAP.adjust_kb_state
  is '??????
??????
???????JIT_ADJUST_KB?';
comment on column MM_JIT_VEH_SCRAP.adjust_user
  is '?????
?????
';
comment on column MM_JIT_VEH_SCRAP.adjust_time
  is '?????
?????
';
comment on column MM_JIT_VEH_SCRAP.adjust_ip
  is '???IP
???IP
';
comment on column MM_JIT_VEH_SCRAP.creation_time
  is '????
????
';
comment on column MM_JIT_VEH_SCRAP.last_modified_time
  is '??????
??????
';
create index IDX_MM_JIT_VEH_SCRAP1 on MM_JIT_VEH_SCRAP (ADJUST_KB_STATE)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_JIT_VEH_SCRAP2 on MM_JIT_VEH_SCRAP (SCRAP_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_JIT_VEH_SCRAP
  add constraint PK_MM_JIT_VEH_SCRAP primary key (FACTORY_CODE, ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_KB_IP_CONFIG
prompt ==============================
prompt
create table MM_KB_IP_CONFIG
(
  id                 NUMBER(19) not null,
  kb_id              NUMBER(19),
  factory_code       VARCHAR2(10) not null,
  kb_type            VARCHAR2(10),
  kb_ip              VARCHAR2(30) not null,
  distri_person      VARCHAR2(30),
  run_process_no     NUMBER(5),
  limit_delay        NUMBER(5),
  mbps_comb          VARCHAR2(30),
  station_code       NUMBER(5),
  shit_schedule      NUMBER(5),
  is_edit            NUMBER(1),
  creation_user      VARCHAR2(30),
  creation_time      DATE,
  last_modified_time DATE,
  last_modified_user VARCHAR2(30),
  last_modified_ip   VARCHAR2(30),
  work_center        VARCHAR2(5),
  addr_binding       VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_KB_IP_CONFIG
  is 'MM_KB_IP_CONFIG??-IP???
??IP???????';
comment on column MM_KB_IP_CONFIG.id
  is 'ID
';
comment on column MM_KB_IP_CONFIG.factory_code
  is '??
??';
comment on column MM_KB_IP_CONFIG.kb_type
  is '????
JIT: ????
JISO: ????
SPARE: ??????
STATION: ????';
comment on column MM_KB_IP_CONFIG.kb_ip
  is '??IP??
??IP??';
comment on column MM_KB_IP_CONFIG.mbps_comb
  is '???????
???????';
comment on column MM_KB_IP_CONFIG.is_edit
  is '?????
?????';
comment on column MM_KB_IP_CONFIG.creation_user
  is '????
????';
comment on column MM_KB_IP_CONFIG.creation_time
  is '????
????';
comment on column MM_KB_IP_CONFIG.last_modified_time
  is '??????
??????';
comment on column MM_KB_IP_CONFIG.last_modified_user
  is '?????
?????';
comment on column MM_KB_IP_CONFIG.last_modified_ip
  is '????IP
????IP';
comment on column MM_KB_IP_CONFIG.work_center
  is '??';
comment on column MM_KB_IP_CONFIG.addr_binding
  is '????';
alter table MM_KB_IP_CONFIG
  add constraint PK_MM_KB_IP_CONFIG primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_KB_IP_CONFIG
  add constraint AK_KEY_MM_KB_IP unique (FACTORY_CODE, KB_IP)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_KB_IP_CONFIG_DETAIL
prompt =====================================
prompt
create table MM_KB_IP_CONFIG_DETAIL
(
  id                 NUMBER(19) not null,
  buss_id            NUMBER(19),
  req_parameter      VARCHAR2(200),
  is_edit            NUMBER(1),
  creation_user      VARCHAR2(30),
  creation_time      DATE,
  last_modified_time DATE,
  last_modified_user VARCHAR2(30),
  last_modified_ip   VARCHAR2(30),
  delay_warn_voice   VARCHAR2(200)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_KB_IP_CONFIG_DETAIL
  is 'MM_KB_IP_CONFIG_DETAIL  ??-IP?????
??-IP?????';
comment on column MM_KB_IP_CONFIG_DETAIL.id
  is 'ID
';
comment on column MM_KB_IP_CONFIG_DETAIL.buss_id
  is '??ID
??ID';
comment on column MM_KB_IP_CONFIG_DETAIL.req_parameter
  is '????
????';
comment on column MM_KB_IP_CONFIG_DETAIL.is_edit
  is '?????
?????';
comment on column MM_KB_IP_CONFIG_DETAIL.creation_user
  is '????
????';
comment on column MM_KB_IP_CONFIG_DETAIL.creation_time
  is '????
????';
comment on column MM_KB_IP_CONFIG_DETAIL.last_modified_time
  is '??????
??????';
comment on column MM_KB_IP_CONFIG_DETAIL.last_modified_user
  is '?????
?????';
comment on column MM_KB_IP_CONFIG_DETAIL.last_modified_ip
  is '????IP
????IP';
alter table MM_KB_IP_CONFIG_DETAIL
  add constraint PK_MM_KB_IP_CONFIG_DETAIL primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_KB_IP_CONFIG_DETAIL
  add constraint AK_KEY_MM_KB_IP_DETAIL unique (BUSS_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_KB_IP_CONFIG_IMP
prompt ==================================
prompt
create table MM_KB_IP_CONFIG_IMP
(
  factory_code  VARCHAR2(10) not null,
  kb_type       VARCHAR2(10),
  kb_ip         VARCHAR2(30) not null,
  page_url      VARCHAR2(200),
  buss_id       NUMBER(19),
  req_parameter VARCHAR2(200),
  is_edit       NUMBER(1),
  imp_uuid      VARCHAR2(50),
  check_result  NUMBER(1),
  check_info    VARCHAR2(300),
  import_status NUMBER(1),
  ope_type      VARCHAR2(8) default 'I'
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_KB_IP_CONFIG_IMP
  is 'MM_KB_IP_CONFIG_IMP??-IP???
??IP???????';
comment on column MM_KB_IP_CONFIG_IMP.factory_code
  is '??
??';
comment on column MM_KB_IP_CONFIG_IMP.kb_type
  is '????
JIT: ????
JISO: ????
SPARE: ??????
STATION: ????';
comment on column MM_KB_IP_CONFIG_IMP.kb_ip
  is '??IP??
??IP??';
comment on column MM_KB_IP_CONFIG_IMP.page_url
  is '??URL
??URL';
comment on column MM_KB_IP_CONFIG_IMP.buss_id
  is '??ID
??ID';
comment on column MM_KB_IP_CONFIG_IMP.req_parameter
  is '????
????';
comment on column MM_KB_IP_CONFIG_IMP.is_edit
  is '?????
?????';
comment on column MM_KB_IP_CONFIG_IMP.imp_uuid
  is 'IMP_UUID
';
comment on column MM_KB_IP_CONFIG_IMP.check_result
  is '????
???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_KB_IP_CONFIG_IMP.check_info
  is '????
';
comment on column MM_KB_IP_CONFIG_IMP.import_status
  is '????
0-???
1-???';
comment on column MM_KB_IP_CONFIG_IMP.ope_type
  is '????
I ??
U??';

prompt
prompt Creating table MM_MON_ALLOW_DEVIATION
prompt =====================================
prompt
create table MM_MON_ALLOW_DEVIATION
(
  id           NUMBER(10) not null,
  route_code   VARCHAR2(20),
  error_date   NUMBER(10),
  factory_code VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MON_ALLOW_DEVIATION
  is 'MM_MON_ALLOW_DEVIATION物流允许误差维护
';
comment on column MM_MON_ALLOW_DEVIATION.id
  is 'ID
';
comment on column MM_MON_ALLOW_DEVIATION.route_code
  is '集货线路
';
comment on column MM_MON_ALLOW_DEVIATION.error_date
  is '允许误差
';
comment on column MM_MON_ALLOW_DEVIATION.factory_code
  is '工厂代码
';
alter table MM_MON_ALLOW_DEVIATION
  add constraint PK_MM_MON_ALLOW_DEVIATION primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MON_ALLOW_DEVIATION_IMP
prompt =========================================
prompt
create table MM_MON_ALLOW_DEVIATION_IMP
(
  id            NUMBER,
  factory_code  NVARCHAR2(10),
  route_code    NVARCHAR2(50),
  error_date    NUMBER(5),
  imp_uuid      NVARCHAR2(50),
  check_result  NVARCHAR2(50),
  check_info    NVARCHAR2(50),
  import_status NVARCHAR2(5),
  pk_id         NVARCHAR2(50),
  ope_type      NVARCHAR2(10) default 'I',
  busi_id       NVARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_MON_ALLOW_DEVIATION_IMP.factory_code
  is '????';
comment on column MM_MON_ALLOW_DEVIATION_IMP.route_code
  is '????';
comment on column MM_MON_ALLOW_DEVIATION_IMP.error_date
  is '????(?)';
comment on column MM_MON_ALLOW_DEVIATION_IMP.imp_uuid
  is '??uuidd';
comment on column MM_MON_ALLOW_DEVIATION_IMP.check_result
  is '????';
comment on column MM_MON_ALLOW_DEVIATION_IMP.check_info
  is '????';
comment on column MM_MON_ALLOW_DEVIATION_IMP.import_status
  is '????';
comment on column MM_MON_ALLOW_DEVIATION_IMP.ope_type
  is '????';
create index IDX1 on MM_MON_ALLOW_DEVIATION_IMP (IMP_UUID)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MON_BATTERY_KB
prompt ================================
prompt
create table MM_MON_BATTERY_KB
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  battery_code       VARCHAR2(50) not null,
  station_code       VARCHAR2(20) not null,
  pass_time          DATE not null,
  uda1               VARCHAR2(50),
  uda2               VARCHAR2(50),
  uda3               VARCHAR2(50),
  uda4               VARCHAR2(50),
  uda5               VARCHAR2(50),
  creation_time      DATE default SYSDATE,
  creation_user      VARCHAR2(30),
  last_modified_time DATE,
  last_modified_user VARCHAR2(30),
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_MON_BATTERY_KB
  add constraint PK_MM_MON_BATTERY_KB primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MON_DISTRIBUTION_LOG
prompt ======================================
prompt
create table MM_MON_DISTRIBUTION_LOG
(
  id                   NUMBER(19) not null,
  kb_detail_id         NUMBER(19),
  distri_product_seqno NUMBER(19),
  limit_delay          NUMBER(5),
  status               NUMBER(1) default 0,
  request_run_time     DATE,
  get_run_time         DATE,
  creation_time        DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_MON_DISTRIBUTION_LOG.status
  is '0???
1???????
2?????';
alter table MM_MON_DISTRIBUTION_LOG
  add constraint PK_MM_MON_DISTRIBUTION_LOG primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MON_KB
prompt ========================
prompt
create table MM_MON_KB
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  kb_code            VARCHAR2(20) not null,
  production_line    VARCHAR2(20),
  workcenter         VARCHAR2(20),
  station_code       VARCHAR2(20),
  kb_name            VARCHAR2(200),
  kb_type            VARCHAR2(10),
  batch_cycle_num    NUMBER(5),
  process_cycle_num  NUMBER(5),
  curr_batch_no      NUMBER(5),
  curr_process_no    NUMBER(5),
  curr_batch_seqno   NUMBER(19),
  product_seqno      NUMBER(19),
  is_edit            NUMBER(1) default 1,
  remark             VARCHAR2(256),
  max_pass_time      DATE default SYSDATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  last_modified_ip   VARCHAR2(30),
  kb_ip              VARCHAR2(200)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_MON_KB.station_code
  is '???????MON_KB_STATION?';
comment on column MM_MON_KB.kb_type
  is '???????MON_KB_TYPE?';
comment on column MM_MON_KB.is_edit
  is '???????TRUE_FALSE"';
alter table MM_MON_KB
  add constraint PK_MM_MON_KB primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_MON_KB
  add constraint AK_MM_MON_KB unique (KB_CODE, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_MON_KB_DETAIL
prompt ===============================
prompt
create table MM_MON_KB_DETAIL
(
  id                 NUMBER(19) not null,
  kb_id              NUMBER(19) not null,
  distri_person      VARCHAR2(30) not null,
  run_process_no     NUMBER(5),
  lamp_id            VARCHAR2(30),
  limit_delay        NUMBER(5),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
  );
alter table MM_MON_KB_DETAIL
  add constraint PK_MM_MON_KB_DETAIL primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
  );
alter table MM_MON_KB_DETAIL
  add constraint AK_MM_MON_KB_DETAIL unique (KB_ID, DISTRI_PERSON)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
  );

prompt
prompt Creating table MM_MON_KB_FILTER
prompt ===============================
prompt
create table MM_MON_KB_FILTER
(
  factory_code VARCHAR2(10) not null,
  order_no     VARCHAR2(50) not null
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_MON_LAMP
prompt ==========================
prompt
create table MM_MON_LAMP
(
  id        NUMBER(19) not null,
  lamp_code VARCHAR2(50),
  lamp_desc VARCHAR2(120)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
alter table MM_MON_LAMP
  add constraint PK_MM_MON_LAMP primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_ADJ_BOM
prompt ============================
prompt
create table MM_MP_ADJ_BOM
(
  id                 NUMBER(19),
  comp               VARCHAR2(10),
  car_type           VARCHAR2(20),
  adj_date           DATE,
  part_row_no        VARCHAR2(10),
  part_id            VARCHAR2(30),
  line_station       VARCHAR2(30),
  num                VARCHAR2(18),
  usage_amount_unit  VARCHAR2(20),
  purchase_type      VARCHAR2(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_ADJ_BOM
  is 'MM_MP_ADJ_BOM????BOM
';
comment on column MM_MP_ADJ_BOM.id
  is 'ID
??ID';
comment on column MM_MP_ADJ_BOM.comp
  is '??
';
comment on column MM_MP_ADJ_BOM.car_type
  is '??
';
comment on column MM_MP_ADJ_BOM.adj_date
  is '????
';
comment on column MM_MP_ADJ_BOM.part_row_no
  is '??????
?????';
comment on column MM_MP_ADJ_BOM.part_id
  is '????
???? ';
comment on column MM_MP_ADJ_BOM.line_station
  is '?????
?????';
comment on column MM_MP_ADJ_BOM.num
  is '??
??';
comment on column MM_MP_ADJ_BOM.usage_amount_unit
  is '????
????';
comment on column MM_MP_ADJ_BOM.purchase_type
  is '????
????';
comment on column MM_MP_ADJ_BOM.creation_user
  is '???
???';
comment on column MM_MP_ADJ_BOM.creation_time
  is '????
????';
comment on column MM_MP_ADJ_BOM.last_modified_user
  is '??????
??????';
comment on column MM_MP_ADJ_BOM.last_modified_time
  is '??????
??????';

prompt
prompt Creating table MM_MP_ADJ_ORDER_DIFF
prompt ===================================
prompt
create table MM_MP_ADJ_ORDER_DIFF
(
  id            NUMBER(19) not null,
  supplier_no   VARCHAR2(20),
  part_no       VARCHAR2(20),
  adj_date      DATE,
  cal_diff_num  NUMBER(10),
  adj_diff_num  NUMBER(10),
  factory_code  VARCHAR2(10),
  send_flag     NUMBER(1) default 0,
  send_time     DATE,
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_ADJ_ORDER_DIFF
  is 'MM_MP_ADJ_ORDER_DIFF ???????
???????';
comment on column MM_MP_ADJ_ORDER_DIFF.id
  is 'ID
';
comment on column MM_MP_ADJ_ORDER_DIFF.supplier_no
  is '???
???';
comment on column MM_MP_ADJ_ORDER_DIFF.part_no
  is '???
???';
comment on column MM_MP_ADJ_ORDER_DIFF.adj_date
  is '????
????';
comment on column MM_MP_ADJ_ORDER_DIFF.cal_diff_num
  is '??????
????';
comment on column MM_MP_ADJ_ORDER_DIFF.adj_diff_num
  is '??????
??????';
comment on column MM_MP_ADJ_ORDER_DIFF.factory_code
  is '??
??';
comment on column MM_MP_ADJ_ORDER_DIFF.send_flag
  is '???????
0 ? 1?';
comment on column MM_MP_ADJ_ORDER_DIFF.send_time
  is '??????
';
comment on column MM_MP_ADJ_ORDER_DIFF.creation_user
  is '???
';
comment on column MM_MP_ADJ_ORDER_DIFF.creation_time
  is '????
';
alter table MM_MP_ADJ_ORDER_DIFF
  add constraint PK_MM_MP_ADJ_ORDER_DIFF primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_ADJ_ORDER_DIFF_TEMP
prompt ========================================
prompt
create table MM_MP_ADJ_ORDER_DIFF_TEMP
(
  part_no       VARCHAR2(20),
  adj_date      DATE,
  cal_diff_num  NUMBER(10),
  factory_code  VARCHAR2(10),
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_ADJ_ORDER_DIFF_TEMP
  is 'MM_MP_ADJ_ORDER_DIFF_TEMP ?????????
?????????';
comment on column MM_MP_ADJ_ORDER_DIFF_TEMP.part_no
  is '???
???';
comment on column MM_MP_ADJ_ORDER_DIFF_TEMP.adj_date
  is '????
????';
comment on column MM_MP_ADJ_ORDER_DIFF_TEMP.cal_diff_num
  is '??????
????';
comment on column MM_MP_ADJ_ORDER_DIFF_TEMP.factory_code
  is '??
??';
comment on column MM_MP_ADJ_ORDER_DIFF_TEMP.creation_user
  is '???
';
comment on column MM_MP_ADJ_ORDER_DIFF_TEMP.creation_time
  is '????
';

prompt
prompt Creating table MM_MP_ADJ_PLAN
prompt =============================
prompt
create table MM_MP_ADJ_PLAN
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  car_type           VARCHAR2(20),
  diff_num           NUMBER(10),
  adj_date           DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_ADJ_PLAN
  is 'MM_MP_ADJ_PLAN ????
????';
comment on column MM_MP_ADJ_PLAN.id
  is '??ID
??ID';
comment on column MM_MP_ADJ_PLAN.factory_code
  is '??
??';
comment on column MM_MP_ADJ_PLAN.car_type
  is '??
??';
comment on column MM_MP_ADJ_PLAN.diff_num
  is '????
??';
comment on column MM_MP_ADJ_PLAN.adj_date
  is '????
????';
comment on column MM_MP_ADJ_PLAN.creation_user
  is '???
';
comment on column MM_MP_ADJ_PLAN.creation_time
  is '????
';
comment on column MM_MP_ADJ_PLAN.last_modified_user
  is '??????
';
comment on column MM_MP_ADJ_PLAN.last_modified_time
  is '??????
';
alter table MM_MP_ADJ_PLAN
  add constraint PK_MM_MP_ADJ_PLAN primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_MP_ADJ_PLAN
  add constraint AK_MM_MP_ADJ_PLAN unique (FACTORY_CODE, CAR_TYPE, ADJ_DATE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_ADJ_PLAN_HIS
prompt =================================
prompt
create table MM_MP_ADJ_PLAN_HIS
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  car_type           VARCHAR2(20),
  diff_num           NUMBER(10),
  adj_date           DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_ADJ_PLAN_HIS
  is 'MM_MP_ADJ_PLAN_HIS ?????
?????';
comment on column MM_MP_ADJ_PLAN_HIS.id
  is '??ID
??ID';
comment on column MM_MP_ADJ_PLAN_HIS.factory_code
  is '??
??';
comment on column MM_MP_ADJ_PLAN_HIS.car_type
  is '??
??';
comment on column MM_MP_ADJ_PLAN_HIS.diff_num
  is '????
??';
comment on column MM_MP_ADJ_PLAN_HIS.adj_date
  is '????
????';
comment on column MM_MP_ADJ_PLAN_HIS.creation_user
  is '???
';
comment on column MM_MP_ADJ_PLAN_HIS.creation_time
  is '????
';
comment on column MM_MP_ADJ_PLAN_HIS.last_modified_user
  is '??????
';
comment on column MM_MP_ADJ_PLAN_HIS.last_modified_time
  is '??????
';
alter table MM_MP_ADJ_PLAN_HIS
  add constraint PK_MM_MP_ADJ_PLAN_HIS primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_ADJ_SUP_FEEDBACK
prompt =====================================
prompt
create table MM_MP_ADJ_SUP_FEEDBACK
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10),
  part_no       VARCHAR2(20),
  supplier_no   VARCHAR2(20),
  sup_factory   VARCHAR2(20),
  diff_num      NUMBER(10),
  supply_date   DATE,
  is_supply     NUMBER(1),
  supply_reason VARCHAR2(200),
  feedback_time DATE default SYSDATE,
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_ADJ_SUP_FEEDBACK
  is 'MM_MP_ADJ_SUP_FEEDBACK ??????????
??????????';
comment on column MM_MP_ADJ_SUP_FEEDBACK.id
  is 'ID
';
comment on column MM_MP_ADJ_SUP_FEEDBACK.factory_code
  is '??
??';
comment on column MM_MP_ADJ_SUP_FEEDBACK.part_no
  is '????
????';
comment on column MM_MP_ADJ_SUP_FEEDBACK.supplier_no
  is '?????
?????';
comment on column MM_MP_ADJ_SUP_FEEDBACK.sup_factory
  is '??????
???';
comment on column MM_MP_ADJ_SUP_FEEDBACK.diff_num
  is '??????
????';
comment on column MM_MP_ADJ_SUP_FEEDBACK.supply_date
  is '????
????';
comment on column MM_MP_ADJ_SUP_FEEDBACK.is_supply
  is '?????
0-????
1-???';
comment on column MM_MP_ADJ_SUP_FEEDBACK.supply_reason
  is '??
??';
comment on column MM_MP_ADJ_SUP_FEEDBACK.feedback_time
  is '????
????';
comment on column MM_MP_ADJ_SUP_FEEDBACK.creation_user
  is '???
';
comment on column MM_MP_ADJ_SUP_FEEDBACK.creation_time
  is '????
';
alter table MM_MP_ADJ_SUP_FEEDBACK
  add constraint PK_MM_MP_ADJ_SUP_FEEDBACK primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_MP_ADJ_SUP_FEEDBACK
  add constraint AK_KEY_2_MM_MP_AD unique (SUPPLY_DATE, PART_NO, SUPPLIER_NO, SUP_FACTORY, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_AUTO_LOG
prompt =============================
prompt
create table MM_MP_AUTO_LOG
(
  factory_code  VARCHAR2(10),
  reason        VARCHAR2(200),
  ope_user      VARCHAR2(20),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_AUTO_LOG
  is 'MM_MP_AUTO_LOG??????
??????';
comment on column MM_MP_AUTO_LOG.factory_code
  is '??
';
comment on column MM_MP_AUTO_LOG.reason
  is '??
??';
comment on column MM_MP_AUTO_LOG.ope_user
  is '???
???';
comment on column MM_MP_AUTO_LOG.creation_time
  is '????
';

prompt
prompt Creating table MM_MP_CAL_END_LOG
prompt ================================
prompt
create table MM_MP_CAL_END_LOG
(
  cal_point   NUMBER,
  car_type    VARCHAR2(20),
  create_time DATE default SYSDATE,
  sort_id     NUMBER
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_CAL_END_LOG
  is 'MM_MP_CAL_END_LOG
';
comment on column MM_MP_CAL_END_LOG.cal_point
  is 'CAL_POINT
';
comment on column MM_MP_CAL_END_LOG.car_type
  is 'CAR_TYPE
';
comment on column MM_MP_CAL_END_LOG.create_time
  is 'CREATE_TIME
';
comment on column MM_MP_CAL_END_LOG.sort_id
  is 'SORT_ID
';

prompt
prompt Creating table MM_MP_CAL_LOCK
prompt =============================
prompt
create table MM_MP_CAL_LOCK
(
  factory_code       VARCHAR2(10) not null,
  cal_type           NUMBER(1) not null,
  is_lock            NUMBER(1) not null,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_CAL_LOCK
  is 'MM_MP_CAL_LOCK ?????
?????';
comment on column MM_MP_CAL_LOCK.factory_code
  is '??
????';
comment on column MM_MP_CAL_LOCK.cal_type
  is '????
1??????
2???????';
comment on column MM_MP_CAL_LOCK.is_lock
  is '????
0????
1????';
comment on column MM_MP_CAL_LOCK.creation_user
  is '???
';
comment on column MM_MP_CAL_LOCK.creation_time
  is '????
';
comment on column MM_MP_CAL_LOCK.last_modified_user
  is '??????
';
comment on column MM_MP_CAL_LOCK.last_modified_time
  is '??????
';
alter table MM_MP_CAL_LOCK
  add constraint PK_MM_MP_CAL_LOCK primary key (FACTORY_CODE, CAL_TYPE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_CAL_LOG
prompt ============================
prompt
create table MM_MP_CAL_LOG
(
  factory_code       VARCHAR2(10),
  cal_type           NUMBER(1) not null,
  is_lock            NUMBER(1),
  cal_start_time     DATE,
  cal_end_time       DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  uuid               VARCHAR2(100)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_CAL_LOG
  is 'MM_MP_CAL_LOG ??????
??????';
comment on column MM_MP_CAL_LOG.factory_code
  is '??
????';
comment on column MM_MP_CAL_LOG.cal_type
  is '????
1??????
2???????';
comment on column MM_MP_CAL_LOG.is_lock
  is 'IS_LOCK
';
comment on column MM_MP_CAL_LOG.cal_start_time
  is '??????
??????';
comment on column MM_MP_CAL_LOG.cal_end_time
  is '??????
??????';
comment on column MM_MP_CAL_LOG.creation_user
  is '???
';
comment on column MM_MP_CAL_LOG.creation_time
  is '????
';
comment on column MM_MP_CAL_LOG.last_modified_user
  is '??????
';
comment on column MM_MP_CAL_LOG.last_modified_time
  is '??????
';
comment on column MM_MP_CAL_LOG.uuid
  is 'UUID
';

prompt
prompt Creating table MM_MP_CAR_TYPE_NODE
prompt ==================================
prompt
create table MM_MP_CAR_TYPE_NODE
(
  factory_code       VARCHAR2(10),
  sort_id            NUMBER(12),
  multi_car_type     VARCHAR2(100),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_CAR_TYPE_NODE
  is 'MM_MP_CAR_TYPE_NODE ?????
?????';
comment on column MM_MP_CAR_TYPE_NODE.factory_code
  is '??
';
comment on column MM_MP_CAR_TYPE_NODE.sort_id
  is '???????
';
comment on column MM_MP_CAR_TYPE_NODE.multi_car_type
  is '????
';
comment on column MM_MP_CAR_TYPE_NODE.last_modified_time
  is '??????
';

prompt
prompt Creating table MM_MP_CAR_TYPE_QUEUE
prompt ===================================
prompt
create table MM_MP_CAR_TYPE_QUEUE
(
  factory_code       VARCHAR2(10) not null,
  car_type_sort_id   NUMBER(10) not null,
  multi_car_type     VARCHAR2(100) not null,
  sort_id            NUMBER(12) not null,
  order_no           VARCHAR2(50),
  plan_num           NUMBER(5),
  afoff_time         DATE,
  car_type           VARCHAR2(20),
  creation_user      VARCHAR2(30),
  creation_time      DATE default SYSDATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  adj_afoff_time     DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )
nologging;
comment on table MM_MP_CAR_TYPE_QUEUE
  is 'MM_MP_CAR_TYPE_QUEUE????
?????????';
comment on column MM_MP_CAR_TYPE_QUEUE.factory_code
  is 'FACTORY_CODE
????';
comment on column MM_MP_CAR_TYPE_QUEUE.car_type_sort_id
  is 'CAR_TYPE_SORT_ID
';
comment on column MM_MP_CAR_TYPE_QUEUE.multi_car_type
  is 'MULTI_CAR_TYPE
';
comment on column MM_MP_CAR_TYPE_QUEUE.sort_id
  is 'SORT_ID
';
comment on column MM_MP_CAR_TYPE_QUEUE.order_no
  is 'ORDER_NO
';
comment on column MM_MP_CAR_TYPE_QUEUE.plan_num
  is 'PLAN_NUM
????';
comment on column MM_MP_CAR_TYPE_QUEUE.afoff_time
  is 'AFOFF_TIME
????????';
comment on column MM_MP_CAR_TYPE_QUEUE.car_type
  is 'CAR_TYPE
??';
comment on column MM_MP_CAR_TYPE_QUEUE.creation_user
  is 'CREATION_USER
';
comment on column MM_MP_CAR_TYPE_QUEUE.creation_time
  is 'CREATION_TIME
';
comment on column MM_MP_CAR_TYPE_QUEUE.last_modified_user
  is 'LAST_MODIFIED_USER
';
comment on column MM_MP_CAR_TYPE_QUEUE.last_modified_time
  is 'LAST_MODIFIED_TIME
';
comment on column MM_MP_CAR_TYPE_QUEUE.adj_afoff_time
  is 'ADJ_AFOFF_TIME
';
create index IDX_MP_CAR_TYPE_QUEUE on MM_MP_CAR_TYPE_QUEUE (AFOFF_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_MP_CAR_TYPE_QUEUE
  add constraint PK_MM_MP_CAR_TYPE_QUEUE primary key (CAR_TYPE_SORT_ID, MULTI_CAR_TYPE, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter index PK_MM_MP_CAR_TYPE_QUEUE nologging;

prompt
prompt Creating table MM_MP_COMPARE_PLAN_TEMP
prompt ======================================
prompt
create table MM_MP_COMPARE_PLAN_TEMP
(
  factory_code       VARCHAR2(10) not null,
  order_no           VARCHAR2(50) not null,
  order_type         VARCHAR2(10),
  weon_time          DATE,
  afoff_time         DATE,
  sort_id            NUMBER(19),
  model_code         VARCHAR2(10),
  phase              VARCHAR2(10),
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_COMPARE_PLAN_TEMP
  is 'MM_MP_COMPARE_PLAN_TEMP????W+1 W+2?????
';
comment on column MM_MP_COMPARE_PLAN_TEMP.factory_code
  is '??
';
comment on column MM_MP_COMPARE_PLAN_TEMP.order_no
  is '???
';
comment on column MM_MP_COMPARE_PLAN_TEMP.order_type
  is '????
';
comment on column MM_MP_COMPARE_PLAN_TEMP.weon_time
  is '??????
';
comment on column MM_MP_COMPARE_PLAN_TEMP.afoff_time
  is '??????
';
comment on column MM_MP_COMPARE_PLAN_TEMP.sort_id
  is '???
';
comment on column MM_MP_COMPARE_PLAN_TEMP.model_code
  is '??
A16?A28';
comment on column MM_MP_COMPARE_PLAN_TEMP.phase
  is '????
';
comment on column MM_MP_COMPARE_PLAN_TEMP.creation_time
  is '????
';
comment on column MM_MP_COMPARE_PLAN_TEMP.last_modified_time
  is '??????
';

prompt
prompt Creating table MM_MP_DIFF_NUM_TEMP
prompt ==================================
prompt
create table MM_MP_DIFF_NUM_TEMP
(
  order_no      VARCHAR2(50),
  num           NUMBER(10),
  type          CHAR(1),
  creation_time DATE default sysdate,
  model_code    VARCHAR2(10),
  factory_code  VARCHAR2(10),
  flag          VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_DIFF_NUM_TEMP
  is 'MM_MP_DIFF_NUM_TEMP????????
';
comment on column MM_MP_DIFF_NUM_TEMP.order_no
  is '???
???';
comment on column MM_MP_DIFF_NUM_TEMP.num
  is '??
??';
comment on column MM_MP_DIFF_NUM_TEMP.type
  is '??
O ???????W+1 W+2 1????????W+1 W+2';
comment on column MM_MP_DIFF_NUM_TEMP.creation_time
  is '????
';
comment on column MM_MP_DIFF_NUM_TEMP.model_code
  is '??
??';
comment on column MM_MP_DIFF_NUM_TEMP.factory_code
  is '??
';
comment on column MM_MP_DIFF_NUM_TEMP.flag
  is '??
W+1   W+2';

prompt
prompt Creating table MM_MP_EXCEP_ORDER
prompt ================================
prompt
create table MM_MP_EXCEP_ORDER
(
  order_no           VARCHAR2(50) not null,
  purchase_no        VARCHAR2(50) not null,
  supplier_no        VARCHAR2(20) not null,
  sup_factory        VARCHAR2(20) not null,
  arrive_date        DATE not null,
  factory_code       VARCHAR2(10),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default SYSDATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  flag               NUMBER(1),
  p_deal_flag        NUMBER(1),
  p_deal_time        DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_EXCEP_ORDER
  is 'MM_MP_EXCEP_ORDER?????????
????';
comment on column MM_MP_EXCEP_ORDER.order_no
  is '????
????';
comment on column MM_MP_EXCEP_ORDER.purchase_no
  is '????
????';
comment on column MM_MP_EXCEP_ORDER.supplier_no
  is '???
???';
comment on column MM_MP_EXCEP_ORDER.sup_factory
  is '???
???';
comment on column MM_MP_EXCEP_ORDER.arrive_date
  is '????
????';
comment on column MM_MP_EXCEP_ORDER.factory_code
  is '??
??';
comment on column MM_MP_EXCEP_ORDER.deal_flag
  is 'DEAL_FLAG
0 ??? 1???';
comment on column MM_MP_EXCEP_ORDER.deal_time
  is 'DEAL_TIME
????';
comment on column MM_MP_EXCEP_ORDER.creation_user
  is 'CREATION_USER
???';
comment on column MM_MP_EXCEP_ORDER.creation_time
  is 'CREATION_TIME
????';
comment on column MM_MP_EXCEP_ORDER.last_modified_user
  is 'LAST_MODIFIED_USER
?????';
comment on column MM_MP_EXCEP_ORDER.last_modified_time
  is 'LAST_MODIFIED_TIME
??????';
comment on column MM_MP_EXCEP_ORDER.flag
  is '0 ?? 1???
0 ?? 1???';
comment on column MM_MP_EXCEP_ORDER.p_deal_flag
  is '????????
0 ??? 1???';
comment on column MM_MP_EXCEP_ORDER.p_deal_time
  is '??????
';
create index IDX_MM_MP_EXCEP_ORDER1 on MM_MP_EXCEP_ORDER (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_MP_EXCEP_ORDER
  add constraint PK_MM_MP_EXCEP_ORDER primary key (ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_EXCEP_ORDER_DEMAND
prompt =======================================
prompt
create table MM_MP_EXCEP_ORDER_DEMAND
(
  id                NUMBER(19) not null,
  supplier_no       VARCHAR2(20),
  sup_factory       VARCHAR2(20),
  part_no           VARCHAR2(20),
  order_num         NUMBER(10),
  arrive_date       DATE,
  factory_code      VARCHAR2(10),
  creation_user     VARCHAR2(30),
  creation_time     DATE default SYSDATE,
  use_flag          NUMBER(1) default 0,
  storage           VARCHAR2(30),
  use               VARCHAR2(300),
  demand_department VARCHAR2(30),
  demander          VARCHAR2(30),
  con_number        VARCHAR2(30),
  opt_user          VARCHAR2(30),
  opt_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_EXCEP_ORDER_DEMAND
  is 'MM_MP_EXCEP_ORDER_DEMAND??????
??????';
comment on column MM_MP_EXCEP_ORDER_DEMAND.id
  is 'ID
??ID';
comment on column MM_MP_EXCEP_ORDER_DEMAND.supplier_no
  is '???
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND.sup_factory
  is '???
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND.part_no
  is '???
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND.order_num
  is '???
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND.arrive_date
  is '????
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND.factory_code
  is '??
??';
comment on column MM_MP_EXCEP_ORDER_DEMAND.creation_user
  is '???
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND.creation_time
  is '????
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND.use_flag
  is '????
???? 0 ??????? 1?????????';
comment on column MM_MP_EXCEP_ORDER_DEMAND.storage
  is '????
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND.use
  is '??
??';
comment on column MM_MP_EXCEP_ORDER_DEMAND.demand_department
  is '????
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND.demander
  is '???
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND.con_number
  is '????
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND.opt_user
  is '???
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND.opt_time
  is '????
????';
alter table MM_MP_EXCEP_ORDER_DEMAND
  add constraint PK_MM_MP_EXCEP_ORDER_DEMAND primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_EXCEP_ORDER_DEMAND_HIS
prompt ===========================================
prompt
create table MM_MP_EXCEP_ORDER_DEMAND_HIS
(
  id                NUMBER(19) not null,
  supplier_no       VARCHAR2(20),
  sup_factory       VARCHAR2(20),
  part_no           VARCHAR2(20),
  order_num         NUMBER(10),
  arrive_date       DATE,
  factory_code      VARCHAR2(10),
  creation_user     VARCHAR2(30),
  creation_time     DATE default SYSDATE,
  cal_status        NUMBER(1) default 0,
  cal_time          DATE,
  storage           VARCHAR2(30),
  use               VARCHAR2(300),
  demand_department VARCHAR2(30),
  demander          VARCHAR2(30),
  con_number        VARCHAR2(30),
  opt_user          VARCHAR2(30),
  opt_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_EXCEP_ORDER_DEMAND_HIS
  is 'MM_MP_EXCEP_ORDER_DEMAND_HIS?????????
?????????';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.id
  is 'ID
??ID';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.supplier_no
  is 'SUPPLIER_NO
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.sup_factory
  is 'SUP_FACTORY
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.part_no
  is 'PART_NO
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.order_num
  is 'ORDER_NUM
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.arrive_date
  is 'ARRIVE_DATE
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.factory_code
  is 'FACTORY_CODE
??';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.creation_user
  is 'CREATION_USER
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.creation_time
  is 'CREATION_TIME
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.cal_status
  is 'CAL_STATUS
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.cal_time
  is 'CAL_TIME
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.storage
  is '????
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.use
  is '??
??';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.demand_department
  is '????
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.demander
  is '???
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.con_number
  is '????
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.opt_user
  is '???
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_HIS.opt_time
  is '????
????';
alter table MM_MP_EXCEP_ORDER_DEMAND_HIS
  add constraint PK_MM_MP_EXCEP_ORDER_DEMAND_HI primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_EXCEP_ORDER_DEMAND_IMP
prompt ===========================================
prompt
create table MM_MP_EXCEP_ORDER_DEMAND_IMP
(
  id                NUMBER(19),
  supplier_no       VARCHAR2(20),
  sup_factory       VARCHAR2(20),
  part_no           VARCHAR2(20),
  order_num         NUMBER(10),
  arrive_date       DATE,
  factory_code      VARCHAR2(10),
  creation_user     VARCHAR2(30),
  creation_time     DATE default SYSDATE,
  imp_uuid          VARCHAR2(50),
  check_result      NUMBER(1),
  check_info        VARCHAR2(300),
  import_status     NUMBER(1),
  ope_type          VARCHAR2(8) default 'I',
  storage           VARCHAR2(30),
  workcenter        VARCHAR2(10),
  use               VARCHAR2(300),
  demand_department VARCHAR2(30),
  demander          VARCHAR2(30),
  con_number        VARCHAR2(30),
  opt_user          VARCHAR2(30),
  opt_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_EXCEP_ORDER_DEMAND_IMP
  is 'MM_MP_EXCEP_ORDER_DEMAND_IMP???????????
???????????';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.id
  is 'ID
';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.supplier_no
  is '???
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.sup_factory
  is 'SUP_FACTORY
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.part_no
  is 'PART_NO
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.order_num
  is 'ORDER_NUM
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.arrive_date
  is 'ARRIVE_DATE
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.factory_code
  is 'FACTORY_CODE
??';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.creation_user
  is 'CREATION_USER
';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.creation_time
  is 'CREATION_TIME
';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.imp_uuid
  is 'IMP_UUID
';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.check_result
  is 'CHECK_RESULT
???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.check_info
  is 'CHECK_INFO
';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.import_status
  is '0-???
1-???
0-???
1-???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.ope_type
  is 'I ?? U??
I ?? U??';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.storage
  is '????
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.workcenter
  is '??
??';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.use
  is '??
??';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.demand_department
  is '????
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.demander
  is '???
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.con_number
  is '????
????';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.opt_user
  is '???
???';
comment on column MM_MP_EXCEP_ORDER_DEMAND_IMP.opt_time
  is '????
????';

prompt
prompt Creating table MM_MP_EXCEP_ORDER_DETAIL
prompt =======================================
prompt
create table MM_MP_EXCEP_ORDER_DETAIL
(
  order_no          VARCHAR2(50) not null,
  row_no            NUMBER(10),
  part_no           VARCHAR2(20),
  order_num         NUMBER(10),
  order_depot       VARCHAR2(20),
  use               VARCHAR2(300),
  demand_department VARCHAR2(30),
  demander          VARCHAR2(30),
  con_number        VARCHAR2(30),
  opt_user          VARCHAR2(30),
  opt_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_EXCEP_ORDER_DETAIL
  is 'MM_MP_EXCEP_ORDER_DETAIL????????
????????';
comment on column MM_MP_EXCEP_ORDER_DETAIL.order_no
  is 'ORDER_NO
????';
comment on column MM_MP_EXCEP_ORDER_DETAIL.row_no
  is 'ROW_NO
??';
comment on column MM_MP_EXCEP_ORDER_DETAIL.part_no
  is 'PART_NO
???';
comment on column MM_MP_EXCEP_ORDER_DETAIL.order_num
  is 'ORDER_NUM
???';
comment on column MM_MP_EXCEP_ORDER_DETAIL.order_depot
  is 'ORDER_DEPOT
????';
comment on column MM_MP_EXCEP_ORDER_DETAIL.use
  is '"??
??"';
comment on column MM_MP_EXCEP_ORDER_DETAIL.demand_department
  is '"????
????"';
comment on column MM_MP_EXCEP_ORDER_DETAIL.demander
  is '"???
???"';
comment on column MM_MP_EXCEP_ORDER_DETAIL.con_number
  is '"????
????"';
comment on column MM_MP_EXCEP_ORDER_DETAIL.opt_user
  is '"???
???"';
comment on column MM_MP_EXCEP_ORDER_DETAIL.opt_time
  is '"????
????"';
create index IDX_MP_EXC_ORDER_DETAIL1 on MM_MP_EXCEP_ORDER_DETAIL (ORDER_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_EXC_OD_RELATION
prompt ====================================
prompt
create table MM_MP_EXC_OD_RELATION
(
  demand_id     NUMBER(19),
  order_no      VARCHAR2(50) not null,
  creation_user VARCHAR2(30),
  creation_time DATE default SYSDATE,
  factory_code  VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_EXC_OD_RELATION
  is 'MM_MP_EXC_OD_RELATION???????
???????';
comment on column MM_MP_EXC_OD_RELATION.demand_id
  is 'DEMAND_ID
??ID';
comment on column MM_MP_EXC_OD_RELATION.order_no
  is 'ORDER_NO
???';
comment on column MM_MP_EXC_OD_RELATION.creation_user
  is 'CREATION_USER
???';
comment on column MM_MP_EXC_OD_RELATION.creation_time
  is 'CREATION_TIME
????';
comment on column MM_MP_EXC_OD_RELATION.factory_code
  is 'FACTORY_CODE
??';

prompt
prompt Creating table MM_MP_GAM_PUR_ORDER
prompt ==================================
prompt
create table MM_MP_GAM_PUR_ORDER
(
  plan_order_id      VARCHAR2(13) not null,
  supplier_no        VARCHAR2(20),
  sup_factory        VARCHAR2(20),
  unload_port        VARCHAR2(10),
  factory_code       VARCHAR2(10) not null,
  part_no            VARCHAR2(20),
  part_unit          VARCHAR2(20),
  order_num          NUMBER(10),
  total_order_box    NUMBER(10),
  logistics_flag     VARCHAR2(10),
  logistics_order    VARCHAR2(30),
  order_status       NUMBER(1),
  order_issue_date   DATE,
  shipment_date      DATE,
  group_id           NUMBER(10),
  purchase_type      VARCHAR2(10),
  arrive_time        DATE,
  prepare_time       DATE,
  order_depot        VARCHAR2(20),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  seqid              NUMBER,
  order_package      NUMBER(10),
  standard_package   NUMBER(12,4)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_GAM_PUR_ORDER
  is 'MM_MP_GAM_PUR_ORDER
';
comment on column MM_MP_GAM_PUR_ORDER.plan_order_id
  is '?????
????? ???';
comment on column MM_MP_GAM_PUR_ORDER.supplier_no
  is '?????
?????';
comment on column MM_MP_GAM_PUR_ORDER.sup_factory
  is '??????
???';
comment on column MM_MP_GAM_PUR_ORDER.unload_port
  is '????
????';
comment on column MM_MP_GAM_PUR_ORDER.factory_code
  is '??
??';
comment on column MM_MP_GAM_PUR_ORDER.part_no
  is '????
????';
comment on column MM_MP_GAM_PUR_ORDER.part_unit
  is '????
????';
comment on column MM_MP_GAM_PUR_ORDER.order_num
  is '?????
????';
comment on column MM_MP_GAM_PUR_ORDER.total_order_box
  is '????
????';
comment on column MM_MP_GAM_PUR_ORDER.logistics_flag
  is '????
????';
comment on column MM_MP_GAM_PUR_ORDER.logistics_order
  is '??????
??????';
comment on column MM_MP_GAM_PUR_ORDER.order_status
  is '????
????';
comment on column MM_MP_GAM_PUR_ORDER.order_issue_date
  is '?????
????? ';
comment on column MM_MP_GAM_PUR_ORDER.shipment_date
  is '??????
?????? ';
comment on column MM_MP_GAM_PUR_ORDER.group_id
  is '??????
???';
comment on column MM_MP_GAM_PUR_ORDER.purchase_type
  is '????
????';
comment on column MM_MP_GAM_PUR_ORDER.arrive_time
  is '??????
??????';
comment on column MM_MP_GAM_PUR_ORDER.prepare_time
  is '??????
?????';
comment on column MM_MP_GAM_PUR_ORDER.order_depot
  is '????
????';
comment on column MM_MP_GAM_PUR_ORDER.creation_user
  is '???
';
comment on column MM_MP_GAM_PUR_ORDER.creation_time
  is '????
';
comment on column MM_MP_GAM_PUR_ORDER.last_modified_user
  is '??????
';
comment on column MM_MP_GAM_PUR_ORDER.last_modified_time
  is '??????
';
comment on column MM_MP_GAM_PUR_ORDER.seqid
  is 'SEQID
??';
comment on column MM_MP_GAM_PUR_ORDER.order_package
  is '????
????';
comment on column MM_MP_GAM_PUR_ORDER.standard_package
  is '???
?????';

prompt
prompt Creating table MM_MP_MATERIEL_LIST_B
prompt ====================================
prompt
create table MM_MP_MATERIEL_LIST_B
(
  order_no          VARCHAR2(50),
  part_no           VARCHAR2(64),
  num               NUMBER(18,3),
  work_center       VARCHAR2(10),
  usage_amount_unit VARCHAR2(20),
  factory_code      VARCHAR2(10),
  purchase_type     VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_MP_MATERIEL_LIST_B
  is 'MM_MP_MATERIEL_LIST_B????
';
comment on column MM_MP_MATERIEL_LIST_B.order_no
  is 'ORDER_NO
???';
comment on column MM_MP_MATERIEL_LIST_B.part_no
  is 'PART_NO
???';
comment on column MM_MP_MATERIEL_LIST_B.num
  is 'NUM
??????????';
comment on column MM_MP_MATERIEL_LIST_B.work_center
  is 'WORK_CENTER
????';
comment on column MM_MP_MATERIEL_LIST_B.usage_amount_unit
  is 'USAGE_AMOUNT_UNIT
????';
comment on column MM_MP_MATERIEL_LIST_B.factory_code
  is 'FACTORY_CODE
??';
comment on column MM_MP_MATERIEL_LIST_B.purchase_type
  is 'PURCHASE_TYPE
????';

prompt
prompt Creating table MM_MP_OPE_LOG
prompt ============================
prompt
create table MM_MP_OPE_LOG
(
  ope_type      NUMBER(1),
  ope_user      VARCHAR2(20),
  ope_time      DATE,
  creation_user VARCHAR2(30),
  creation_time DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_OPE_LOG
  is 'MM_MP_OPE_LOG????
';
comment on column MM_MP_OPE_LOG.ope_type
  is 'OPE_TYPE
0 ????????';
comment on column MM_MP_OPE_LOG.ope_user
  is 'OPE_USER
???';
comment on column MM_MP_OPE_LOG.ope_time
  is 'OPE_TIME
????';
comment on column MM_MP_OPE_LOG.creation_user
  is 'CREATION_USER
';
comment on column MM_MP_OPE_LOG.creation_time
  is 'CREATION_TIME
';

prompt
prompt Creating table MM_MP_ORDER_BOM
prompt ==============================
prompt
create table MM_MP_ORDER_BOM
(
  factory_code       VARCHAR2(10),
  order_no           VARCHAR2(50),
  model_code         VARCHAR2(10),
  part_rowno         NUMBER(10),
  vehicle_part_no    VARCHAR2(30),
  part_no            VARCHAR2(30),
  workcenter         VARCHAR2(20),
  station_code       VARCHAR2(30),
  num                NUMBER(18,3),
  usage_amount_unit  VARCHAR2(20),
  purchase_type      VARCHAR2(10),
  creation_time      DATE default sysdate,
  last_modified_time DATE,
  creation_user      VARCHAR2(30),
  last_modified_user VARCHAR2(30),
  partf_id           VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_ORDER_BOM
  is 'MM_MP_ORDER_BOM????
';
comment on column MM_MP_ORDER_BOM.factory_code
  is '??
??
';
comment on column MM_MP_ORDER_BOM.order_no
  is '?????
?????
?????';
comment on column MM_MP_ORDER_BOM.part_rowno
  is '??????
??????
?????';
comment on column MM_MP_ORDER_BOM.vehicle_part_no
  is '?????(?MTOC)
?????(?MTOC)
????';
comment on column MM_MP_ORDER_BOM.part_no
  is '????
????
???';
comment on column MM_MP_ORDER_BOM.workcenter
  is '??
??
???????????????????';
comment on column MM_MP_ORDER_BOM.station_code
  is '?????
?????
???';
comment on column MM_MP_ORDER_BOM.num
  is '??
??
?????????????';
comment on column MM_MP_ORDER_BOM.usage_amount_unit
  is '????
????
????';
comment on column MM_MP_ORDER_BOM.purchase_type
  is '????
????
';
comment on column MM_MP_ORDER_BOM.creation_time
  is '????
????
';
comment on column MM_MP_ORDER_BOM.last_modified_time
  is '??????
??????
';
comment on column MM_MP_ORDER_BOM.creation_user
  is '???
';
comment on column MM_MP_ORDER_BOM.last_modified_user
  is '??????
';
create index IDX_MM_MP_ORDER_BOM on MM_MP_ORDER_BOM (ORDER_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_ORDER_RECORD
prompt =================================
prompt
create table MM_MP_ORDER_RECORD
(
  plan_order_id               VARCHAR2(13) not null,
  order_no                    VARCHAR2(50),
  factory_code                VARCHAR2(10),
  supplier_no                 VARCHAR2(20),
  sup_factory                 VARCHAR2(20),
  unload_port                 VARCHAR2(10),
  part_no                     VARCHAR2(20),
  logistics_flag              VARCHAR2(10),
  group_id                    NUMBER(10),
  logistics_order             VARCHAR2(30),
  dr_sort_id_start            NUMBER(10),
  dr_sort_id_end              NUMBER(10),
  lr_sort_id_start            NUMBER(10),
  lr_sort_id_end              NUMBER(10),
  defect_num                  NUMBER(10),
  safe_num                    NUMBER(10),
  adj_diff_num                NUMBER(10),
  necessary_net_num           NUMBER(10),
  necessary_order_residual    NUMBER(10),
  necessary_real_order_num    NUMBER(10),
  necessary_plan_num          NUMBER(10),
  necessary_real_residual_num NUMBER(10),
  standard_package            NUMBER(12,4),
  order_num                   NUMBER(10),
  total_order_num             NUMBER(10),
  order_package               NUMBER(10),
  total_order_box             NUMBER(10),
  adj_box                     NUMBER(10),
  adj_order_num               NUMBER(10),
  arrive_time                 DATE,
  prepare_time                DATE,
  order_status                NUMBER(1),
  order_issue_date            DATE,
  shipment_date               DATE,
  purchase_type               VARCHAR2(10),
  purchase_dept               VARCHAR2(20),
  order_depot                 VARCHAR2(20),
  calculate_num               NUMBER(10),
  creation_time               DATE default sysdate,
  creation_user               VARCHAR2(30),
  part_unit                   VARCHAR2(20),
  part_group_id               NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_ORDER_RECORD
  is 'MM_MP_ORDER_RECORD ???????
???????';
comment on column MM_MP_ORDER_RECORD.plan_order_id
  is '?????
????? ???';
comment on column MM_MP_ORDER_RECORD.order_no
  is '?????
????? ';
comment on column MM_MP_ORDER_RECORD.factory_code
  is '??
??';
comment on column MM_MP_ORDER_RECORD.supplier_no
  is '?????
?????';
comment on column MM_MP_ORDER_RECORD.sup_factory
  is '??????
???';
comment on column MM_MP_ORDER_RECORD.unload_port
  is '????
????';
comment on column MM_MP_ORDER_RECORD.part_no
  is '????
????';
comment on column MM_MP_ORDER_RECORD.logistics_flag
  is '????
????';
comment on column MM_MP_ORDER_RECORD.group_id
  is '??????
???';
comment on column MM_MP_ORDER_RECORD.logistics_order
  is '??????
????';
comment on column MM_MP_ORDER_RECORD.dr_sort_id_start
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_ORDER_RECORD.dr_sort_id_end
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_ORDER_RECORD.lr_sort_id_start
  is 'LINE_SIDE_RANGE????
linesiderange??';
comment on column MM_MP_ORDER_RECORD.lr_sort_id_end
  is 'LINE_SIDE_RANGE????
linesiderange??';
comment on column MM_MP_ORDER_RECORD.defect_num
  is '????
????';
comment on column MM_MP_ORDER_RECORD.safe_num
  is '????
????';
comment on column MM_MP_ORDER_RECORD.adj_diff_num
  is '??????
??????';
comment on column MM_MP_ORDER_RECORD.necessary_net_num
  is '??????
???';
comment on column MM_MP_ORDER_RECORD.necessary_order_residual
  is '?????????
????????';
comment on column MM_MP_ORDER_RECORD.necessary_real_order_num
  is '?????????
????????? ';
comment on column MM_MP_ORDER_RECORD.necessary_plan_num
  is '???????
??????? ';
comment on column MM_MP_ORDER_RECORD.necessary_real_residual_num
  is '????????
????????';
comment on column MM_MP_ORDER_RECORD.standard_package
  is '???
?????';
comment on column MM_MP_ORDER_RECORD.order_num
  is '????
????';
comment on column MM_MP_ORDER_RECORD.total_order_num
  is '?????
?????';
comment on column MM_MP_ORDER_RECORD.order_package
  is '????
????';
comment on column MM_MP_ORDER_RECORD.total_order_box
  is '????
????';
comment on column MM_MP_ORDER_RECORD.adj_box
  is '????
????';
comment on column MM_MP_ORDER_RECORD.adj_order_num
  is '??????
??????';
comment on column MM_MP_ORDER_RECORD.arrive_time
  is '????
????';
comment on column MM_MP_ORDER_RECORD.prepare_time
  is '??????
?????';
comment on column MM_MP_ORDER_RECORD.order_status
  is '????
????';
comment on column MM_MP_ORDER_RECORD.order_issue_date
  is '?????
????? ';
comment on column MM_MP_ORDER_RECORD.shipment_date
  is '??????
?????? ';
comment on column MM_MP_ORDER_RECORD.purchase_type
  is '????
????';
comment on column MM_MP_ORDER_RECORD.purchase_dept
  is '????
???? ';
comment on column MM_MP_ORDER_RECORD.order_depot
  is '????
???? ';
comment on column MM_MP_ORDER_RECORD.calculate_num
  is '????????
???';
comment on column MM_MP_ORDER_RECORD.creation_time
  is '????
';
comment on column MM_MP_ORDER_RECORD.creation_user
  is '???
';
comment on column MM_MP_ORDER_RECORD.part_unit
  is '????
';
comment on column MM_MP_ORDER_RECORD.part_group_id
  is '????????
';
alter table MM_MP_ORDER_RECORD
  add constraint PK_MM_MP_ORDER_RECORD primary key (PLAN_ORDER_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_ORDER_RECORD_HIS
prompt =====================================
prompt
create table MM_MP_ORDER_RECORD_HIS
(
  plan_order_id               VARCHAR2(13) not null,
  factory_code                VARCHAR2(10),
  part_no                     VARCHAR2(20),
  supplier_no                 VARCHAR2(20),
  sup_factory                 VARCHAR2(20),
  unload_port                 VARCHAR2(10),
  logistics_order             VARCHAR2(30),
  order_no                    VARCHAR2(50),
  logistics_flag              VARCHAR2(10),
  group_id                    NUMBER(10),
  dr_sort_id_start            NUMBER(10),
  dr_sort_id_end              NUMBER(10),
  lr_sort_id_start            NUMBER(10),
  lr_sort_id_end              NUMBER(10),
  defect_num                  NUMBER(10),
  safe_num                    NUMBER(10),
  adj_diff_num                NUMBER(10),
  necessary_net_num           NUMBER(10),
  necessary_order_residual    NUMBER(10),
  necessary_real_order_num    NUMBER(10),
  necessary_plan_num          NUMBER(10),
  necessary_real_residual_num NUMBER(10),
  order_num                   NUMBER(10),
  standard_package            NUMBER(12,4),
  order_package               NUMBER(10),
  total_order_num             NUMBER(10),
  total_order_box             NUMBER(10),
  adj_box                     NUMBER(10),
  adj_order_num               NUMBER(10),
  arrive_time                 DATE,
  prepare_time                DATE,
  order_status                NUMBER(1),
  order_issue_date            DATE,
  shipment_date               DATE,
  purchase_type               VARCHAR2(10),
  purchase_dept               VARCHAR2(20),
  order_depot                 VARCHAR2(20),
  calculate_num               NUMBER(10),
  creation_time               DATE default sysdate,
  creation_user               VARCHAR2(30),
  part_unit                   VARCHAR2(20),
  part_group_id               NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_ORDER_RECORD_HIS
  is 'MM_MP_ORDER_RECORD_HIS ???????
???????';
comment on column MM_MP_ORDER_RECORD_HIS.plan_order_id
  is '?????
????? ???';
comment on column MM_MP_ORDER_RECORD_HIS.factory_code
  is '??
??';
comment on column MM_MP_ORDER_RECORD_HIS.part_no
  is '????
????';
comment on column MM_MP_ORDER_RECORD_HIS.supplier_no
  is '?????
?????';
comment on column MM_MP_ORDER_RECORD_HIS.sup_factory
  is '??????
???';
comment on column MM_MP_ORDER_RECORD_HIS.unload_port
  is '????
????';
comment on column MM_MP_ORDER_RECORD_HIS.logistics_order
  is '??????
????';
comment on column MM_MP_ORDER_RECORD_HIS.order_no
  is '?????
????? ';
comment on column MM_MP_ORDER_RECORD_HIS.logistics_flag
  is '????
????';
comment on column MM_MP_ORDER_RECORD_HIS.group_id
  is '??????
???';
comment on column MM_MP_ORDER_RECORD_HIS.dr_sort_id_start
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_ORDER_RECORD_HIS.dr_sort_id_end
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_ORDER_RECORD_HIS.lr_sort_id_start
  is 'LINE_SIDE_RANGE????
linesiderange??';
comment on column MM_MP_ORDER_RECORD_HIS.lr_sort_id_end
  is 'LINE_SIDE_RANGE????
linesiderange??';
comment on column MM_MP_ORDER_RECORD_HIS.defect_num
  is '????
????';
comment on column MM_MP_ORDER_RECORD_HIS.safe_num
  is '????
????';
comment on column MM_MP_ORDER_RECORD_HIS.adj_diff_num
  is '??????
??????';
comment on column MM_MP_ORDER_RECORD_HIS.necessary_net_num
  is '??????
???';
comment on column MM_MP_ORDER_RECORD_HIS.necessary_order_residual
  is '?????????
????????';
comment on column MM_MP_ORDER_RECORD_HIS.necessary_real_order_num
  is '?????????
????????? ';
comment on column MM_MP_ORDER_RECORD_HIS.necessary_plan_num
  is '???????
??????? ';
comment on column MM_MP_ORDER_RECORD_HIS.necessary_real_residual_num
  is '????????
????????';
comment on column MM_MP_ORDER_RECORD_HIS.order_num
  is '????
????';
comment on column MM_MP_ORDER_RECORD_HIS.standard_package
  is '???
?????';
comment on column MM_MP_ORDER_RECORD_HIS.order_package
  is '????
????';
comment on column MM_MP_ORDER_RECORD_HIS.total_order_num
  is '?????
?????';
comment on column MM_MP_ORDER_RECORD_HIS.total_order_box
  is '????
????';
comment on column MM_MP_ORDER_RECORD_HIS.adj_box
  is '????
????';
comment on column MM_MP_ORDER_RECORD_HIS.adj_order_num
  is '??????
??????';
comment on column MM_MP_ORDER_RECORD_HIS.arrive_time
  is '????
????';
comment on column MM_MP_ORDER_RECORD_HIS.prepare_time
  is '??????
?????';
comment on column MM_MP_ORDER_RECORD_HIS.order_status
  is '????
????';
comment on column MM_MP_ORDER_RECORD_HIS.order_issue_date
  is '?????
????? ';
comment on column MM_MP_ORDER_RECORD_HIS.shipment_date
  is '??????
?????? ';
comment on column MM_MP_ORDER_RECORD_HIS.purchase_type
  is '????
????';
comment on column MM_MP_ORDER_RECORD_HIS.purchase_dept
  is '????
???? ';
comment on column MM_MP_ORDER_RECORD_HIS.order_depot
  is '????
???? ';
comment on column MM_MP_ORDER_RECORD_HIS.calculate_num
  is '????????
???';
comment on column MM_MP_ORDER_RECORD_HIS.creation_time
  is '????
';
comment on column MM_MP_ORDER_RECORD_HIS.creation_user
  is '???
';
comment on column MM_MP_ORDER_RECORD_HIS.part_unit
  is '????
';
comment on column MM_MP_ORDER_RECORD_HIS.part_group_id
  is '????????
';
create index IDX_MM_MP_ORDER_REC_HIS1 on MM_MP_ORDER_RECORD_HIS (CREATION_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_MP_ORDER_RECORD_HIS
  add constraint PK_MM_MP_ORDER_RECORD_HIS primary key (PLAN_ORDER_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_ORDER_RECORD_IMP
prompt =====================================
prompt
create table MM_MP_ORDER_RECORD_IMP
(
  plan_order_id               VARCHAR2(13),
  order_no                    VARCHAR2(50),
  factory_code                VARCHAR2(10),
  supplier_no                 VARCHAR2(20),
  sup_factory                 VARCHAR2(20),
  unload_port                 VARCHAR2(10),
  part_no                     VARCHAR2(20),
  logistics_flag              VARCHAR2(10),
  group_id                    NUMBER(10),
  logistics_order             VARCHAR2(30),
  dr_sort_id_start            NUMBER(10),
  dr_sort_id_end              NUMBER(10),
  lr_sort_id_start            NUMBER(10),
  lr_sort_id_end              NUMBER(10),
  defect_num                  NUMBER(10),
  safe_num                    NUMBER(10),
  adj_diff_num                NUMBER(10),
  necessary_net_num           NUMBER(10),
  necessary_order_residual    NUMBER(10),
  necessary_real_order_num    NUMBER(10),
  necessary_plan_num          NUMBER(10),
  necessary_real_residual_num NUMBER(10),
  standard_package            NUMBER(12,4),
  order_num                   NUMBER(10),
  total_order_num             NUMBER(10),
  order_package               NUMBER(10),
  total_order_box             NUMBER(10),
  adj_box                     NUMBER(10),
  adj_order_num               NUMBER(10),
  arrive_time                 DATE,
  prepare_time                DATE,
  order_status                NUMBER(1),
  order_issue_date            DATE,
  shipment_date               DATE,
  purchase_type               VARCHAR2(10),
  purchase_dept               VARCHAR2(20),
  order_depot                 VARCHAR2(20),
  calculate_num               NUMBER(10),
  creation_time               DATE default sysdate,
  creation_user               VARCHAR2(30),
  part_unit                   VARCHAR2(20),
  part_group_id               NUMBER(19),
  imp_uuid                    VARCHAR2(50),
  check_result                NUMBER(1),
  check_info                  VARCHAR2(300),
  import_status               NUMBER(1),
  ope_type                    VARCHAR2(8) default 'U'
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_ORDER_RECORD_IMP
  is 'MM_MP_ORDER_RECORD_IMP ?????????
?????????';
comment on column MM_MP_ORDER_RECORD_IMP.plan_order_id
  is '?????
????? ???';
comment on column MM_MP_ORDER_RECORD_IMP.order_no
  is '?????
????? ';
comment on column MM_MP_ORDER_RECORD_IMP.factory_code
  is '??
??';
comment on column MM_MP_ORDER_RECORD_IMP.supplier_no
  is '?????
?????';
comment on column MM_MP_ORDER_RECORD_IMP.sup_factory
  is '??????
???';
comment on column MM_MP_ORDER_RECORD_IMP.unload_port
  is '????
????';
comment on column MM_MP_ORDER_RECORD_IMP.part_no
  is '????
????';
comment on column MM_MP_ORDER_RECORD_IMP.logistics_flag
  is '????
????';
comment on column MM_MP_ORDER_RECORD_IMP.group_id
  is '??????
???';
comment on column MM_MP_ORDER_RECORD_IMP.logistics_order
  is '??????
????';
comment on column MM_MP_ORDER_RECORD_IMP.dr_sort_id_start
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_ORDER_RECORD_IMP.dr_sort_id_end
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_ORDER_RECORD_IMP.lr_sort_id_start
  is 'LINE_SIDE_RANGE????
linesiderange??';
comment on column MM_MP_ORDER_RECORD_IMP.lr_sort_id_end
  is 'LINE_SIDE_RANGE????
linesiderange??';
comment on column MM_MP_ORDER_RECORD_IMP.defect_num
  is '????
????';
comment on column MM_MP_ORDER_RECORD_IMP.safe_num
  is '????
????';
comment on column MM_MP_ORDER_RECORD_IMP.adj_diff_num
  is '??????
??????';
comment on column MM_MP_ORDER_RECORD_IMP.necessary_net_num
  is '??????
???';
comment on column MM_MP_ORDER_RECORD_IMP.necessary_order_residual
  is '?????????
????????';
comment on column MM_MP_ORDER_RECORD_IMP.necessary_real_order_num
  is '?????????
????????? ';
comment on column MM_MP_ORDER_RECORD_IMP.necessary_plan_num
  is '???????
??????? ';
comment on column MM_MP_ORDER_RECORD_IMP.necessary_real_residual_num
  is '????????
????????';
comment on column MM_MP_ORDER_RECORD_IMP.standard_package
  is '???
?????';
comment on column MM_MP_ORDER_RECORD_IMP.order_num
  is '????
????';
comment on column MM_MP_ORDER_RECORD_IMP.total_order_num
  is '?????
?????';
comment on column MM_MP_ORDER_RECORD_IMP.order_package
  is '????
????';
comment on column MM_MP_ORDER_RECORD_IMP.total_order_box
  is '????
????';
comment on column MM_MP_ORDER_RECORD_IMP.adj_box
  is '????
????';
comment on column MM_MP_ORDER_RECORD_IMP.adj_order_num
  is '??????
??????';
comment on column MM_MP_ORDER_RECORD_IMP.arrive_time
  is '????
????';
comment on column MM_MP_ORDER_RECORD_IMP.prepare_time
  is '??????
?????';
comment on column MM_MP_ORDER_RECORD_IMP.order_status
  is '????
????';
comment on column MM_MP_ORDER_RECORD_IMP.order_issue_date
  is '?????
????? ';
comment on column MM_MP_ORDER_RECORD_IMP.shipment_date
  is '??????
?????? ';
comment on column MM_MP_ORDER_RECORD_IMP.purchase_type
  is '????
????';
comment on column MM_MP_ORDER_RECORD_IMP.purchase_dept
  is '????
???? ';
comment on column MM_MP_ORDER_RECORD_IMP.order_depot
  is '????
???? ';
comment on column MM_MP_ORDER_RECORD_IMP.calculate_num
  is '????????
???';
comment on column MM_MP_ORDER_RECORD_IMP.creation_time
  is '????
';
comment on column MM_MP_ORDER_RECORD_IMP.creation_user
  is '???
';
comment on column MM_MP_ORDER_RECORD_IMP.part_unit
  is '????
';
comment on column MM_MP_ORDER_RECORD_IMP.part_group_id
  is '????????
';
comment on column MM_MP_ORDER_RECORD_IMP.imp_uuid
  is 'IMP_UUID
';
comment on column MM_MP_ORDER_RECORD_IMP.check_result
  is '????
???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_MP_ORDER_RECORD_IMP.check_info
  is '????
';
comment on column MM_MP_ORDER_RECORD_IMP.import_status
  is '????
0-???
1-???';
comment on column MM_MP_ORDER_RECORD_IMP.ope_type
  is '????
I ??
U??';

prompt
prompt Creating table MM_MP_PART
prompt =========================
prompt
create table MM_MP_PART
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  supplier_no        VARCHAR2(20),
  sup_factory        VARCHAR2(20),
  unload_port        VARCHAR2(10),
  part_no            VARCHAR2(30),
  part_unit          VARCHAR2(20),
  standard_package   NUMBER(12,4),
  order_package      NUMBER(12,4),
  supply_rate        NUMBER(12,4),
  safe_num           NUMBER(10),
  logistics_flag     VARCHAR2(8),
  eff_start          DATE,
  eff_end            DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  first_sort_id      NUMBER(10),
  workcenter         VARCHAR2(10),
  order_depot        VARCHAR2(20),
  logistics_model    VARCHAR2(10),
  model_code         VARCHAR2(20),
  loc_depth          NUMBER(10),
  delivery_num       NUMBER(10),
  arrive_num         NUMBER(10),
  distribution_num   NUMBER(10),
  order_product_num  NUMBER(10),
  prepare_num        NUMBER(10),
  purchase_type      VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_PART
  is 'MM_MP_PART ???????
???????';
comment on column MM_MP_PART.id
  is 'ID
';
comment on column MM_MP_PART.factory_code
  is '??
';
comment on column MM_MP_PART.supplier_no
  is '?????
?????';
comment on column MM_MP_PART.sup_factory
  is '??????
???';
comment on column MM_MP_PART.unload_port
  is '????
????';
comment on column MM_MP_PART.part_no
  is '????
????';
comment on column MM_MP_PART.part_unit
  is '????
????';
comment on column MM_MP_PART.standard_package
  is '???
?????';
comment on column MM_MP_PART.order_package
  is '?????
?????';
comment on column MM_MP_PART.supply_rate
  is '????
????';
comment on column MM_MP_PART.safe_num
  is '????
';
comment on column MM_MP_PART.logistics_flag
  is '????
????';
comment on column MM_MP_PART.eff_start
  is '????
';
comment on column MM_MP_PART.eff_end
  is '????
';
comment on column MM_MP_PART.creation_user
  is '???
';
comment on column MM_MP_PART.creation_time
  is '????
';
comment on column MM_MP_PART.last_modified_user
  is '??????
';
comment on column MM_MP_PART.last_modified_time
  is '??????
';
comment on column MM_MP_PART.first_sort_id
  is '??????SORTID
??????SORTID';
comment on column MM_MP_PART.workcenter
  is '????
????';
comment on column MM_MP_PART.order_depot
  is '????
???? ';
comment on column MM_MP_PART.logistics_model
  is '????
????, ??, ??';
comment on column MM_MP_PART.model_code
  is '??
??';
comment on column MM_MP_PART.loc_depth
  is '????
????';
comment on column MM_MP_PART.delivery_num
  is '???????
???????';
comment on column MM_MP_PART.arrive_num
  is '???????
???????';
comment on column MM_MP_PART.distribution_num
  is '???????
???????';
comment on column MM_MP_PART.order_product_num
  is '?????
?????';
comment on column MM_MP_PART.prepare_num
  is '???????
???????';
comment on column MM_MP_PART.purchase_type
  is '????';
alter table MM_MP_PART
  add constraint PK_MM_MP_PART primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_MP_PART
  add constraint AK_MM_MP_PART unique (PART_NO, SUPPLIER_NO, SUP_FACTORY, UNLOAD_PORT, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_MP_PART_SORT
prompt ==============================
prompt
create table MM_MP_PART_SORT
(
  id                             NUMBER(19) not null,
  factory_code                   VARCHAR2(10),
  logistics_order                VARCHAR2(30),
  supplier_no                    VARCHAR2(20) not null,
  sup_factory                    VARCHAR2(20) not null,
  unload_port                    VARCHAR2(10),
  part_no                        VARCHAR2(20) not null,
  group_id                       NUMBER(10),
  dr_sort_id_start               NUMBER(10),
  dr_sort_id_end                 NUMBER(10),
  lr_sort_id_start               NUMBER(10),
  lr_sort_id_end                 NUMBER(10),
  real_end_sort_id               NUMBER(10),
  final_underline_time_start     DATE,
  final_underline_time_end       DATE,
  final_underline_time_start_new DATE,
  final_underline_time_end_new   DATE,
  standard_package               NUMBER(12,4),
  order_package                  NUMBER(12,3) not null,
  group_qty                      NUMBER(10) default 0,
  cal_status                     NUMBER(1) default 0,
  group_qty_new                  NUMBER(10) default 0,
  workcenter                     VARCHAR2(10),
  group_qty_diff                 NUMBER(10) default 0,
  item_calculate_num             NUMBER(10),
  arrive_time                    DATE,
  line_side_time                 DATE,
  line_side_sort_id              NUMBER(10),
  use_range_sort_id_start        NUMBER(10),
  use_range_sort_id_end          NUMBER(10),
  creation_time                  DATE default sysdate,
  supply_rate                    NUMBER(12,4),
  in_plan_forward_time           NUMBER(10),
  purchase_type                  VARCHAR2(10),
  car_type                       VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_PART_SORT
  is 'MM_MP_PART_SORT????
';
comment on column MM_MP_PART_SORT.id
  is 'ID
';
comment on column MM_MP_PART_SORT.factory_code
  is '??
????';
comment on column MM_MP_PART_SORT.logistics_order
  is '??????
??????';
comment on column MM_MP_PART_SORT.supplier_no
  is '?????
?????';
comment on column MM_MP_PART_SORT.sup_factory
  is '?????
?????';
comment on column MM_MP_PART_SORT.unload_port
  is '????
????';
comment on column MM_MP_PART_SORT.part_no
  is '???
???';
comment on column MM_MP_PART_SORT.group_id
  is '??????
???';
comment on column MM_MP_PART_SORT.dr_sort_id_start
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_PART_SORT.dr_sort_id_end
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_PART_SORT.lr_sort_id_start
  is 'LINE_SIDE_RANGE????
linesiderange??';
comment on column MM_MP_PART_SORT.lr_sort_id_end
  is 'LINE_SIDE_RANGE????
linesiderange??';
comment on column MM_MP_PART_SORT.real_end_sort_id
  is '????SORTID
????SortId';
comment on column MM_MP_PART_SORT.final_underline_time_start
  is 'FINAL_UNDERLINE_TIME_START
';
comment on column MM_MP_PART_SORT.final_underline_time_end
  is 'FINAL_UNDERLINE_TIME_END
';
comment on column MM_MP_PART_SORT.final_underline_time_start_new
  is 'FINAL_UNDERLINE_TIME_START_NEW
';
comment on column MM_MP_PART_SORT.final_underline_time_end_new
  is 'FINAL_UNDERLINE_TIME_END_NEW
';
comment on column MM_MP_PART_SORT.standard_package
  is '???
?????';
comment on column MM_MP_PART_SORT.order_package
  is '????
????';
comment on column MM_MP_PART_SORT.group_qty
  is '????
????';
comment on column MM_MP_PART_SORT.cal_status
  is '????
????';
comment on column MM_MP_PART_SORT.group_qty_new
  is 'GROUP_QTY_NEW
';
comment on column MM_MP_PART_SORT.workcenter
  is '????
????';
comment on column MM_MP_PART_SORT.group_qty_diff
  is 'GROUP_QTY_DIFF
';
comment on column MM_MP_PART_SORT.item_calculate_num
  is 'ITEM_CALCULATE_NUM
????????';
comment on column MM_MP_PART_SORT.arrive_time
  is '????
????';
comment on column MM_MP_PART_SORT.line_side_time
  is '????
????';
comment on column MM_MP_PART_SORT.line_side_sort_id
  is '????(????)
????(????)';
comment on column MM_MP_PART_SORT.use_range_sort_id_start
  is '????(???)??
????(???)';
comment on column MM_MP_PART_SORT.use_range_sort_id_end
  is '????(???)??
????(???)';
comment on column MM_MP_PART_SORT.creation_time
  is '????
';
comment on column MM_MP_PART_SORT.supply_rate
  is '????
????';
comment on column MM_MP_PART_SORT.in_plan_forward_time
  is '???????
???????';
comment on column MM_MP_PART_SORT.purchase_type
  is '????
????';
comment on column MM_MP_PART_SORT.car_type
  is '??
??';
alter table MM_MP_PART_SORT
  add constraint PK_MM_MP_PART_SORT primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_MP_PART_SORT
  add constraint AK_MM_MP_PART_SORT unique (LOGISTICS_ORDER, PART_NO, SUPPLIER_NO, SUP_FACTORY, UNLOAD_PORT, FACTORY_CODE, GROUP_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_PART_SORT_MAX
prompt ==================================
prompt
create table MM_MP_PART_SORT_MAX
(
  part_no            VARCHAR2(20) not null,
  supplier_no        VARCHAR2(20) not null,
  sup_factory        VARCHAR2(20) not null,
  factory_code       VARCHAR2(10),
  unload_port        VARCHAR2(10),
  work_center        VARCHAR2(10),
  group_id           NUMBER(10),
  dr_sort_id_start   NUMBER(10),
  dr_sort_id_end     NUMBER(10),
  line_side_sort_id  NUMBER(10),
  lr_sort_id_end     NUMBER(10),
  real_end_sort_id   NUMBER(10),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_PART_SORT_MAX
  is 'MM_MP_PART_SORT_MAX???????
????????';
comment on column MM_MP_PART_SORT_MAX.part_no
  is '???
???';
comment on column MM_MP_PART_SORT_MAX.supplier_no
  is '?????
?????';
comment on column MM_MP_PART_SORT_MAX.sup_factory
  is '?????
?????';
comment on column MM_MP_PART_SORT_MAX.factory_code
  is '??
????';
comment on column MM_MP_PART_SORT_MAX.unload_port
  is '????
????';
comment on column MM_MP_PART_SORT_MAX.work_center
  is '??
????';
comment on column MM_MP_PART_SORT_MAX.group_id
  is '??????
???';
comment on column MM_MP_PART_SORT_MAX.dr_sort_id_start
  is '???????SORT_ID
???????SORT_ID';
comment on column MM_MP_PART_SORT_MAX.dr_sort_id_end
  is '???????SORT_ID
???????SORT_ID';
comment on column MM_MP_PART_SORT_MAX.line_side_sort_id
  is '??SORT_ID
??SORT_ID';
comment on column MM_MP_PART_SORT_MAX.lr_sort_id_end
  is '????SORT_ID
????SORT_ID';
comment on column MM_MP_PART_SORT_MAX.real_end_sort_id
  is '????SORT_ID
????SORT_ID';
comment on column MM_MP_PART_SORT_MAX.last_modified_time
  is '??????
';

prompt
prompt Creating table MM_MP_PART_SORT_TEMP
prompt ===================================
prompt
create table MM_MP_PART_SORT_TEMP
(
  id                             NUMBER(19),
  factory_code                   VARCHAR2(10),
  supplier_no                    VARCHAR2(20) not null,
  sup_factory                    VARCHAR2(20) not null,
  unload_port                    VARCHAR2(10),
  part_no                        VARCHAR2(20) not null,
  group_id                       NUMBER(10),
  dr_sort_id_start               NUMBER(10),
  dr_sort_id_end                 NUMBER(10),
  lr_sort_id_start               NUMBER(10),
  lr_sort_id_end                 NUMBER(10),
  real_end_sort_id               NUMBER(10),
  final_underline_time_start     DATE,
  final_underline_time_end       DATE,
  final_underline_time_start_new DATE,
  final_underline_time_end_new   DATE,
  standard_package               NUMBER(12,4),
  order_package                  NUMBER(12,3) not null,
  group_qty                      NUMBER(10) default 0,
  cal_status                     NUMBER(1) default 0,
  logistics_order                VARCHAR2(30),
  group_qty_new                  NUMBER(10) default 0,
  workcenter                     VARCHAR2(10),
  group_qty_diff                 NUMBER(10) default 0,
  item_calculate_num             NUMBER(10),
  arrive_time                    DATE,
  line_side_time                 DATE,
  line_side_sort_id              NUMBER(10),
  use_range_sort_id_start        NUMBER(10),
  use_range_sort_id_end          NUMBER(10),
  creation_time                  DATE default sysdate,
  supply_rate                    NUMBER(12,4),
  in_plan_forward_time           NUMBER(10),
  purchase_type                  VARCHAR2(10),
  car_type                       VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_PART_SORT_TEMP
  is 'MM_MP_PART_SORT_TEMP???????
???????';
comment on column MM_MP_PART_SORT_TEMP.id
  is 'ID
';
comment on column MM_MP_PART_SORT_TEMP.factory_code
  is '??
????';
comment on column MM_MP_PART_SORT_TEMP.supplier_no
  is '?????
?????';
comment on column MM_MP_PART_SORT_TEMP.sup_factory
  is '?????
?????';
comment on column MM_MP_PART_SORT_TEMP.unload_port
  is '????
????';
comment on column MM_MP_PART_SORT_TEMP.part_no
  is '???
???';
comment on column MM_MP_PART_SORT_TEMP.group_id
  is '??????
???';
comment on column MM_MP_PART_SORT_TEMP.dr_sort_id_start
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_PART_SORT_TEMP.dr_sort_id_end
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_PART_SORT_TEMP.lr_sort_id_start
  is 'LINE_SIDE_RANGE????
linesiderange??';
comment on column MM_MP_PART_SORT_TEMP.lr_sort_id_end
  is 'LINE_SIDE_RANGE????
linesiderange??';
comment on column MM_MP_PART_SORT_TEMP.real_end_sort_id
  is '????SORTID
????SortId';
comment on column MM_MP_PART_SORT_TEMP.final_underline_time_start
  is 'FINAL_UNDERLINE_TIME_START
';
comment on column MM_MP_PART_SORT_TEMP.final_underline_time_end
  is 'FINAL_UNDERLINE_TIME_END
';
comment on column MM_MP_PART_SORT_TEMP.final_underline_time_start_new
  is 'FINAL_UNDERLINE_TIME_START_NEW
';
comment on column MM_MP_PART_SORT_TEMP.final_underline_time_end_new
  is 'FINAL_UNDERLINE_TIME_END_NEW
';
comment on column MM_MP_PART_SORT_TEMP.standard_package
  is '???
?????';
comment on column MM_MP_PART_SORT_TEMP.order_package
  is '????
????';
comment on column MM_MP_PART_SORT_TEMP.group_qty
  is '????
????';
comment on column MM_MP_PART_SORT_TEMP.cal_status
  is '????
????';
comment on column MM_MP_PART_SORT_TEMP.logistics_order
  is '??????
??????';
comment on column MM_MP_PART_SORT_TEMP.group_qty_new
  is 'GROUP_QTY_NEW
';
comment on column MM_MP_PART_SORT_TEMP.workcenter
  is '????
????';
comment on column MM_MP_PART_SORT_TEMP.group_qty_diff
  is 'GROUP_QTY_DIFF
';
comment on column MM_MP_PART_SORT_TEMP.item_calculate_num
  is 'ITEM_CALCULATE_NUM
????????';
comment on column MM_MP_PART_SORT_TEMP.arrive_time
  is '????
????';
comment on column MM_MP_PART_SORT_TEMP.line_side_time
  is '????
????';
comment on column MM_MP_PART_SORT_TEMP.line_side_sort_id
  is '????(????)
????(????)';
comment on column MM_MP_PART_SORT_TEMP.use_range_sort_id_start
  is '????(???)??
????(???)';
comment on column MM_MP_PART_SORT_TEMP.use_range_sort_id_end
  is '????(???)??
????(???)';
comment on column MM_MP_PART_SORT_TEMP.creation_time
  is '????
';
comment on column MM_MP_PART_SORT_TEMP.supply_rate
  is '????
????';
comment on column MM_MP_PART_SORT_TEMP.in_plan_forward_time
  is '???????
???????';
comment on column MM_MP_PART_SORT_TEMP.purchase_type
  is '????
????';
comment on column MM_MP_PART_SORT_TEMP.car_type
  is '??
??';

prompt
prompt Creating table MM_MP_PLAN_DIFF_TEMP
prompt ===================================
prompt
create table MM_MP_PLAN_DIFF_TEMP
(
  factory_code  VARCHAR2(10),
  supplier_no   VARCHAR2(20),
  sup_factory   VARCHAR2(20),
  unload_port   VARCHAR2(10),
  part_no       VARCHAR2(20),
  adj_diff_num  NUMBER(10),
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate,
  model_code    VARCHAR2(20),
  workcenter    VARCHAR2(10),
  manu_num      NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_PLAN_DIFF_TEMP
  is 'MM_MP_PLAN_DIFF_TEMP????????
W+1 W+2?????';
comment on column MM_MP_PLAN_DIFF_TEMP.factory_code
  is '??
';
comment on column MM_MP_PLAN_DIFF_TEMP.supplier_no
  is '?????
?????';
comment on column MM_MP_PLAN_DIFF_TEMP.sup_factory
  is '??????
???';
comment on column MM_MP_PLAN_DIFF_TEMP.unload_port
  is '????
????';
comment on column MM_MP_PLAN_DIFF_TEMP.part_no
  is '????
????';
comment on column MM_MP_PLAN_DIFF_TEMP.adj_diff_num
  is '????
????';
comment on column MM_MP_PLAN_DIFF_TEMP.creation_user
  is '???
';
comment on column MM_MP_PLAN_DIFF_TEMP.creation_time
  is '????
';
comment on column MM_MP_PLAN_DIFF_TEMP.model_code
  is '??
??';
comment on column MM_MP_PLAN_DIFF_TEMP.workcenter
  is '????
????';
comment on column MM_MP_PLAN_DIFF_TEMP.manu_num
  is '??????
??????';
create unique index AK_MM_MP_PLAN_DIFF_TEMP on MM_MP_PLAN_DIFF_TEMP (FACTORY_CODE, SUPPLIER_NO, SUP_FACTORY, UNLOAD_PORT, PART_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_PLAN_DIFF_TEMP_IMP
prompt =======================================
prompt
create table MM_MP_PLAN_DIFF_TEMP_IMP
(
  id            NUMBER(19),
  factory_code  VARCHAR2(10),
  supplier_no   VARCHAR2(20),
  sup_factory   VARCHAR2(20),
  unload_port   VARCHAR2(10),
  part_no       VARCHAR2(20),
  adj_diff_num  NUMBER(10),
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate,
  model_code    VARCHAR2(20),
  workcenter    VARCHAR2(10),
  manu_num      NUMBER(10),
  imp_uuid      VARCHAR2(50),
  check_result  NUMBER(1),
  check_info    VARCHAR2(300),
  import_status NUMBER(1),
  ope_type      VARCHAR2(8) default 'I'
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_PLAN_DIFF_TEMP_IMP
  is 'MM_MP_PLAN_DIFF_TEMP_IMP?????????????
?????????????';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.id
  is 'ID
';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.factory_code
  is '??
';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.supplier_no
  is '?????
?????';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.sup_factory
  is '??????
???';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.unload_port
  is '????
????';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.part_no
  is '????
????';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.adj_diff_num
  is '????
????';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.creation_user
  is '???
';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.creation_time
  is '????
';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.model_code
  is '??
??';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.workcenter
  is '????
????';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.manu_num
  is '??????
??????';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.imp_uuid
  is 'IMP_UUID
';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.check_result
  is '????
???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.check_info
  is '????
';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.import_status
  is '????
0-???
1-???';
comment on column MM_MP_PLAN_DIFF_TEMP_IMP.ope_type
  is '????
I ??
U??';

prompt
prompt Creating table MM_MP_PRO_PLAN_HIS
prompt =================================
prompt
create table MM_MP_PRO_PLAN_HIS
(
  sort_id            NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  car_type           VARCHAR2(10),
  order_no           VARCHAR2(50),
  car_type_sort_id   NUMBER(10),
  mtoc               VARCHAR2(20),
  weon_time          DATE,
  afoff_time         DATE,
  pro_phase          VARCHAR2(10),
  cal_status         NUMBER(1),
  cal_time           DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  is_autoed          NUMBER(1) default 0,
  version            NUMBER(10),
  write_time         DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_PRO_PLAN_HIS
  is 'MM_MP_PRO_PLAN_HISW+1W+2????
W+1W+2????';
comment on column MM_MP_PRO_PLAN_HIS.sort_id
  is '??????
SORT_ID';
comment on column MM_MP_PRO_PLAN_HIS.factory_code
  is '????
';
comment on column MM_MP_PRO_PLAN_HIS.car_type
  is '??
??';
comment on column MM_MP_PRO_PLAN_HIS.order_no
  is '?????
???';
comment on column MM_MP_PRO_PLAN_HIS.car_type_sort_id
  is '?????
?????';
comment on column MM_MP_PRO_PLAN_HIS.mtoc
  is 'MTOC
';
comment on column MM_MP_PRO_PLAN_HIS.weon_time
  is '??????
??????';
comment on column MM_MP_PRO_PLAN_HIS.afoff_time
  is '??????
';
comment on column MM_MP_PRO_PLAN_HIS.pro_phase
  is '????
????';
comment on column MM_MP_PRO_PLAN_HIS.cal_status
  is '????
0-???
1-???';
comment on column MM_MP_PRO_PLAN_HIS.cal_time
  is '????
';
comment on column MM_MP_PRO_PLAN_HIS.creation_user
  is '???
';
comment on column MM_MP_PRO_PLAN_HIS.creation_time
  is '????
';
comment on column MM_MP_PRO_PLAN_HIS.last_modified_user
  is '??????
';
comment on column MM_MP_PRO_PLAN_HIS.last_modified_time
  is '??????
';
comment on column MM_MP_PRO_PLAN_HIS.is_autoed
  is '?????????
?????? 0?????, 1??????';
comment on column MM_MP_PRO_PLAN_HIS.version
  is '??
??';
comment on column MM_MP_PRO_PLAN_HIS.write_time
  is '????
????';
create index IDX_MM_MP_VEH_PLAN4 on MM_MP_PRO_PLAN_HIS (AFOFF_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_PRO_PLAN_TEMP
prompt ==================================
prompt
create table MM_MP_PRO_PLAN_TEMP
(
  sort_id            NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  car_type           VARCHAR2(10),
  order_no           VARCHAR2(50),
  car_type_sort_id   NUMBER(10),
  mtoc               VARCHAR2(20),
  weon_time          DATE,
  afoff_time         DATE,
  pro_phase          VARCHAR2(10),
  cal_status         NUMBER(1),
  cal_time           DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  is_autoed          NUMBER(1) default 0,
  version            NUMBER(10),
  write_time         DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_PRO_PLAN_TEMP
  is 'MM_MP_PRO_PLAN_TEMPW+1W+2????
W+1W+2????';
comment on column MM_MP_PRO_PLAN_TEMP.sort_id
  is '??????
SORT_ID';
comment on column MM_MP_PRO_PLAN_TEMP.factory_code
  is '????
';
comment on column MM_MP_PRO_PLAN_TEMP.car_type
  is '??
??';
comment on column MM_MP_PRO_PLAN_TEMP.order_no
  is '?????
???';
comment on column MM_MP_PRO_PLAN_TEMP.car_type_sort_id
  is '?????
?????';
comment on column MM_MP_PRO_PLAN_TEMP.mtoc
  is 'MTOC
';
comment on column MM_MP_PRO_PLAN_TEMP.weon_time
  is '??????
??????';
comment on column MM_MP_PRO_PLAN_TEMP.afoff_time
  is '??????
';
comment on column MM_MP_PRO_PLAN_TEMP.pro_phase
  is '????
????';
comment on column MM_MP_PRO_PLAN_TEMP.cal_status
  is '????
0-???
1-???';
comment on column MM_MP_PRO_PLAN_TEMP.cal_time
  is '????
';
comment on column MM_MP_PRO_PLAN_TEMP.creation_user
  is '???
';
comment on column MM_MP_PRO_PLAN_TEMP.creation_time
  is '????
';
comment on column MM_MP_PRO_PLAN_TEMP.last_modified_user
  is '??????
';
comment on column MM_MP_PRO_PLAN_TEMP.last_modified_time
  is '??????
';
comment on column MM_MP_PRO_PLAN_TEMP.is_autoed
  is '?????????
?????? 0?????, 1??????';
comment on column MM_MP_PRO_PLAN_TEMP.version
  is '??
??';
comment on column MM_MP_PRO_PLAN_TEMP.write_time
  is '????
????';
create index IDX_MM_MP_VEH_PLAN3 on MM_MP_PRO_PLAN_TEMP (AFOFF_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_MP_PRO_PLAN_TEMP
  add constraint PK_MM_MP_PRO_PLAN_TEMP primary key (SORT_ID, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_PUR_ORDER
prompt ==============================
prompt
create table MM_MP_PUR_ORDER
(
  order_no      VARCHAR2(50) not null,
  purchase_no   VARCHAR2(50),
  factory_code  VARCHAR2(10),
  sup_factory   VARCHAR2(20),
  supplier_no   VARCHAR2(20),
  issue_date    DATE,
  arrive_date   DATE,
  prepare_time  DATE,
  plan_order_id VARCHAR2(30),
  order_type    VARCHAR2(20),
  purchase_dept VARCHAR2(20),
  buyer         VARCHAR2(20),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate,
  p_deal_flag   NUMBER(1),
  p_deal_time   DATE,
  status        NUMBER(1) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_PUR_ORDER
  is 'MM_MP_PUR_ORDER?????
?????';
comment on column MM_MP_PUR_ORDER.order_no
  is '?????
???';
comment on column MM_MP_PUR_ORDER.purchase_no
  is '?????
';
comment on column MM_MP_PUR_ORDER.factory_code
  is '??
??';
comment on column MM_MP_PUR_ORDER.sup_factory
  is '??????
???';
comment on column MM_MP_PUR_ORDER.supplier_no
  is '?????
?????';
comment on column MM_MP_PUR_ORDER.issue_date
  is '??????
??????';
comment on column MM_MP_PUR_ORDER.arrive_date
  is '??????
??????';
comment on column MM_MP_PUR_ORDER.prepare_time
  is '??????
?????';
comment on column MM_MP_PUR_ORDER.plan_order_id
  is '???????
????????';
comment on column MM_MP_PUR_ORDER.order_type
  is '????
???????';
comment on column MM_MP_PUR_ORDER.purchase_dept
  is '????
???????';
comment on column MM_MP_PUR_ORDER.buyer
  is '???
???';
comment on column MM_MP_PUR_ORDER.deal_flag
  is '??????
0 ??? 1???';
comment on column MM_MP_PUR_ORDER.deal_time
  is '??????
';
comment on column MM_MP_PUR_ORDER.creation_user
  is '???
';
comment on column MM_MP_PUR_ORDER.creation_time
  is '????
';
comment on column MM_MP_PUR_ORDER.p_deal_flag
  is '????????
0 ??? 1???';
comment on column MM_MP_PUR_ORDER.p_deal_time
  is '??????
';
comment on column MM_MP_PUR_ORDER.status
  is '??
?? 0????  1???';
create index IDX_MM_MP_PUR_ORDER1 on MM_MP_PUR_ORDER (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_MP_PUR_ORDER
  add constraint PK_MM_MP_PUR_ORDER primary key (ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_PUR_ORDER_DETAIL
prompt =====================================
prompt
create table MM_MP_PUR_ORDER_DETAIL
(
  order_no         VARCHAR2(50) not null,
  row_no           NUMBER(10) not null,
  part_no          VARCHAR2(20),
  total_order_num  NUMBER(10),
  part_unit        VARCHAR2(20),
  arrive_time      DATE,
  order_depot      VARCHAR2(20),
  logistics_flag   VARCHAR2(10),
  shipment_time    DATE,
  unload_port      VARCHAR2(10) not null,
  purchase_no      VARCHAR2(50),
  logistics_order  VARCHAR2(30),
  order_package    NUMBER(10),
  standard_package NUMBER(12,4),
  purchase_type    VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_PUR_ORDER_DETAIL
  is 'MM_MP_PUR_ORDER_DETAIL ???????
??????';
comment on column MM_MP_PUR_ORDER_DETAIL.order_no
  is '?????
???';
comment on column MM_MP_PUR_ORDER_DETAIL.row_no
  is '??????
????';
comment on column MM_MP_PUR_ORDER_DETAIL.part_no
  is '????
????';
comment on column MM_MP_PUR_ORDER_DETAIL.total_order_num
  is '????
????';
comment on column MM_MP_PUR_ORDER_DETAIL.part_unit
  is '????
????';
comment on column MM_MP_PUR_ORDER_DETAIL.arrive_time
  is '??????
??????';
comment on column MM_MP_PUR_ORDER_DETAIL.order_depot
  is '????
????';
comment on column MM_MP_PUR_ORDER_DETAIL.logistics_flag
  is '????
????';
comment on column MM_MP_PUR_ORDER_DETAIL.shipment_time
  is '????
???????';
comment on column MM_MP_PUR_ORDER_DETAIL.unload_port
  is '????
????';
comment on column MM_MP_PUR_ORDER_DETAIL.purchase_no
  is '?????
?????';
comment on column MM_MP_PUR_ORDER_DETAIL.logistics_order
  is '????
????';
comment on column MM_MP_PUR_ORDER_DETAIL.order_package
  is '????
????';
comment on column MM_MP_PUR_ORDER_DETAIL.standard_package
  is '???
?????';
comment on column MM_MP_PUR_ORDER_DETAIL.purchase_type
  is '????';
create index IDX_MP_PUR_ORDER_DETAIL1 on MM_MP_PUR_ORDER_DETAIL (ORDER_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_PUR_ORDER_TEMP
prompt ===================================
prompt
create table MM_MP_PUR_ORDER_TEMP
(
  order_no        VARCHAR2(50) not null,
  purchase_no     VARCHAR2(50),
  factory_code    VARCHAR2(10),
  sup_factory     VARCHAR2(20),
  supplier_no     VARCHAR2(20),
  logistics_order VARCHAR2(30),
  unload_port     VARCHAR2(10),
  group_id        NUMBER(10),
  creation_user   VARCHAR2(30),
  creation_time   DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_PUR_ORDER_TEMP
  is 'MM_MP_PUR_ORDER_TEMP???????
??????????????????';
comment on column MM_MP_PUR_ORDER_TEMP.order_no
  is '?????
???';
comment on column MM_MP_PUR_ORDER_TEMP.purchase_no
  is '?????
';
comment on column MM_MP_PUR_ORDER_TEMP.factory_code
  is '??
??';
comment on column MM_MP_PUR_ORDER_TEMP.sup_factory
  is '??????
???';
comment on column MM_MP_PUR_ORDER_TEMP.supplier_no
  is '?????
?????';
comment on column MM_MP_PUR_ORDER_TEMP.logistics_order
  is '??????
??????';
comment on column MM_MP_PUR_ORDER_TEMP.unload_port
  is '????
????';
comment on column MM_MP_PUR_ORDER_TEMP.group_id
  is '??????
???';
comment on column MM_MP_PUR_ORDER_TEMP.creation_user
  is '???
';
comment on column MM_MP_PUR_ORDER_TEMP.creation_time
  is '????
';

prompt
prompt Creating table MM_MP_RESIDUAL
prompt =============================
prompt
create table MM_MP_RESIDUAL
(
  id                  NUMBER(19),
  factory_code        VARCHAR2(10) not null,
  part_no             VARCHAR2(20) not null,
  supplier_no         VARCHAR2(20) not null,
  sup_factory         VARCHAR2(20) not null,
  unload_port         VARCHAR2(10) not null,
  order_num           NUMBER(10),
  necessary_order_num NUMBER(10),
  real_residual_num   NUMBER(10),
  pre_residual_num    NUMBER(10),
  adj_diff_num        NUMBER(10),
  safe_num            NUMBER(10),
  defect_num          NUMBER(10),
  manu_residual       NUMBER(10),
  creation_user       VARCHAR2(30),
  creation_time       DATE default sysdate,
  last_modified_user  VARCHAR2(30),
  last_modified_time  DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_RESIDUAL
  is 'MM_MP_RESIDUAL??????
??????';
comment on column MM_MP_RESIDUAL.id
  is 'ID
';
comment on column MM_MP_RESIDUAL.factory_code
  is '??
??';
comment on column MM_MP_RESIDUAL.part_no
  is '???
???';
comment on column MM_MP_RESIDUAL.supplier_no
  is '?????
?????';
comment on column MM_MP_RESIDUAL.sup_factory
  is '??????
???';
comment on column MM_MP_RESIDUAL.unload_port
  is '????
????';
comment on column MM_MP_RESIDUAL.order_num
  is '?????
????';
comment on column MM_MP_RESIDUAL.necessary_order_num
  is '??????
?????';
comment on column MM_MP_RESIDUAL.real_residual_num
  is '?????
?????';
comment on column MM_MP_RESIDUAL.pre_residual_num
  is '?????
?????';
comment on column MM_MP_RESIDUAL.adj_diff_num
  is '???????
???????';
comment on column MM_MP_RESIDUAL.safe_num
  is '????
????';
comment on column MM_MP_RESIDUAL.defect_num
  is '?????
?????';
comment on column MM_MP_RESIDUAL.manu_residual
  is '????????
??????';
comment on column MM_MP_RESIDUAL.creation_user
  is '???
';
comment on column MM_MP_RESIDUAL.creation_time
  is '????
';
comment on column MM_MP_RESIDUAL.last_modified_user
  is '??????
';
comment on column MM_MP_RESIDUAL.last_modified_time
  is '??????
';
alter table MM_MP_RESIDUAL
  add constraint PK_MM_MP_RESIDUAL primary key (FACTORY_CODE, PART_NO, SUPPLIER_NO, SUP_FACTORY, UNLOAD_PORT)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_RESIDUAL_IMP
prompt =================================
prompt
create table MM_MP_RESIDUAL_IMP
(
  busi_id       NUMBER(19),
  factory_code  VARCHAR2(10),
  part_no       VARCHAR2(20),
  supplier_no   VARCHAR2(20),
  sup_factory   VARCHAR2(20),
  unload_port   VARCHAR2(10),
  adj_residual  NUMBER(10),
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate,
  imp_uuid      VARCHAR2(50),
  check_result  NUMBER(1),
  check_info    VARCHAR2(300),
  import_status NUMBER(1),
  ope_type      VARCHAR2(8) default 'I',
  pk_id         NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_RESIDUAL_IMP
  is 'MM_MP_RESIDUAL_IMP ????????
????????';
comment on column MM_MP_RESIDUAL_IMP.busi_id
  is 'BUSI_ID
ID';
comment on column MM_MP_RESIDUAL_IMP.factory_code
  is '??
??';
comment on column MM_MP_RESIDUAL_IMP.part_no
  is '????
????';
comment on column MM_MP_RESIDUAL_IMP.supplier_no
  is '?????
?????';
comment on column MM_MP_RESIDUAL_IMP.sup_factory
  is '???
???';
comment on column MM_MP_RESIDUAL_IMP.unload_port
  is '????
????';
comment on column MM_MP_RESIDUAL_IMP.adj_residual
  is '??????
??????';
comment on column MM_MP_RESIDUAL_IMP.creation_user
  is '???
';
comment on column MM_MP_RESIDUAL_IMP.creation_time
  is '????
';
comment on column MM_MP_RESIDUAL_IMP.imp_uuid
  is 'IMP_UUID
';
comment on column MM_MP_RESIDUAL_IMP.check_result
  is '????
???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_MP_RESIDUAL_IMP.check_info
  is '????
';
comment on column MM_MP_RESIDUAL_IMP.import_status
  is '????
0-???
1-???';
comment on column MM_MP_RESIDUAL_IMP.ope_type
  is '????
I ??
U??';
comment on column MM_MP_RESIDUAL_IMP.pk_id
  is 'PK_ID
';

prompt
prompt Creating table MM_MP_SEND_MAIL_LOG
prompt ==================================
prompt
create table MM_MP_SEND_MAIL_LOG
(
  id            CHAR(10),
  send_user     CHAR(10),
  get_user      CHAR(10),
  send_mail     CHAR(10),
  get_mail      CHAR(10),
  factory_code  CHAR(10),
  title         CHAR(10),
  content       CHAR(10),
  creation_time CHAR(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_SEND_MAIL_LOG
  is 'MM_MP_SEND_MAIL_LOG?????
?????';
comment on column MM_MP_SEND_MAIL_LOG.id
  is 'id
id';
comment on column MM_MP_SEND_MAIL_LOG.send_user
  is '???
???';
comment on column MM_MP_SEND_MAIL_LOG.get_user
  is '???
???';
comment on column MM_MP_SEND_MAIL_LOG.send_mail
  is '????
????';
comment on column MM_MP_SEND_MAIL_LOG.get_mail
  is '????
????';
comment on column MM_MP_SEND_MAIL_LOG.factory_code
  is '??
??';
comment on column MM_MP_SEND_MAIL_LOG.title
  is '??
??';
comment on column MM_MP_SEND_MAIL_LOG.content
  is '??
??';
comment on column MM_MP_SEND_MAIL_LOG.creation_time
  is '????
????';

prompt
prompt Creating table MM_MP_SUPPLIER_SORT
prompt ==================================
prompt
create table MM_MP_SUPPLIER_SORT
(
  supplier_no                VARCHAR2(20) not null,
  sup_factory                VARCHAR2(20) not null,
  factory_code               VARCHAR2(10) not null,
  unload_port                VARCHAR2(10) not null,
  dr_sort_id_start           NUMBER(10),
  dr_sort_id_end             NUMBER(10),
  group_id                   NUMBER(10) not null,
  cal_status                 NUMBER(1),
  final_underline_time_start DATE,
  final_underline_time_end   DATE,
  creation_time              DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_SUPPLIER_SORT
  is 'MM_MP_SUPPLIER_SORT ????????
????????';
comment on column MM_MP_SUPPLIER_SORT.supplier_no
  is '?????
?????';
comment on column MM_MP_SUPPLIER_SORT.sup_factory
  is '??????
???';
comment on column MM_MP_SUPPLIER_SORT.factory_code
  is '??
??';
comment on column MM_MP_SUPPLIER_SORT.unload_port
  is '????
????';
comment on column MM_MP_SUPPLIER_SORT.dr_sort_id_start
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_SUPPLIER_SORT.dr_sort_id_end
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_SUPPLIER_SORT.group_id
  is '??????
???';
comment on column MM_MP_SUPPLIER_SORT.cal_status
  is '????
????';
comment on column MM_MP_SUPPLIER_SORT.final_underline_time_start
  is '???????
???????';
comment on column MM_MP_SUPPLIER_SORT.final_underline_time_end
  is '???????
???????';
comment on column MM_MP_SUPPLIER_SORT.creation_time
  is '????
';
alter table MM_MP_SUPPLIER_SORT
  add constraint PK_MM_MP_SUPPLIER_SORT primary key (GROUP_ID, SUPPLIER_NO, SUP_FACTORY, UNLOAD_PORT, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_SUPPLIER_SORT_MAX
prompt ======================================
prompt
create table MM_MP_SUPPLIER_SORT_MAX
(
  factory_code       VARCHAR2(10),
  supplier_no        VARCHAR2(20),
  sup_factory        VARCHAR2(20),
  unload_port        VARCHAR2(10),
  group_id           NUMBER(10),
  dr_sort_id_start   NUMBER(10),
  dr_sort_id_end     NUMBER(10),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )
nologging;
comment on table MM_MP_SUPPLIER_SORT_MAX
  is 'MM_MP_SUPPLIER_SORT_MAX????????
????????';
comment on column MM_MP_SUPPLIER_SORT_MAX.factory_code
  is '??
????';
comment on column MM_MP_SUPPLIER_SORT_MAX.supplier_no
  is '?????
?????';
comment on column MM_MP_SUPPLIER_SORT_MAX.sup_factory
  is '??????
?????';
comment on column MM_MP_SUPPLIER_SORT_MAX.unload_port
  is '????
????';
comment on column MM_MP_SUPPLIER_SORT_MAX.group_id
  is '??????
???';
comment on column MM_MP_SUPPLIER_SORT_MAX.dr_sort_id_start
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_SUPPLIER_SORT_MAX.dr_sort_id_end
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_SUPPLIER_SORT_MAX.last_modified_time
  is '??????
';

prompt
prompt Creating table MM_MP_SUPPLIER_SORT_TEMP
prompt =======================================
prompt
create table MM_MP_SUPPLIER_SORT_TEMP
(
  supplier_no                VARCHAR2(20) not null,
  sup_factory                VARCHAR2(20) not null,
  factory_code               VARCHAR2(10) not null,
  unload_port                VARCHAR2(10) not null,
  dr_sort_id_start           NUMBER(10),
  dr_sort_id_end             NUMBER(10),
  group_id                   NUMBER(10) not null,
  cal_status                 NUMBER(1),
  final_underline_time_start DATE,
  final_underline_time_end   DATE,
  creation_time              DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_SUPPLIER_SORT_TEMP
  is 'MM_MP_SUPPLIER_SORT_TEMP????????
????????';
comment on column MM_MP_SUPPLIER_SORT_TEMP.supplier_no
  is '?????
?????';
comment on column MM_MP_SUPPLIER_SORT_TEMP.sup_factory
  is '??????
???';
comment on column MM_MP_SUPPLIER_SORT_TEMP.factory_code
  is '??
??';
comment on column MM_MP_SUPPLIER_SORT_TEMP.unload_port
  is '????
????';
comment on column MM_MP_SUPPLIER_SORT_TEMP.dr_sort_id_start
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_SUPPLIER_SORT_TEMP.dr_sort_id_end
  is 'DOCK_RANGE????
dockrange??';
comment on column MM_MP_SUPPLIER_SORT_TEMP.group_id
  is '??????
???';
comment on column MM_MP_SUPPLIER_SORT_TEMP.cal_status
  is '????
????';
comment on column MM_MP_SUPPLIER_SORT_TEMP.final_underline_time_start
  is '???????
???????';
comment on column MM_MP_SUPPLIER_SORT_TEMP.final_underline_time_end
  is '???????
???????';
comment on column MM_MP_SUPPLIER_SORT_TEMP.creation_time
  is '????
';

prompt
prompt Creating table MM_MP_TRIAL_DEMAND
prompt =================================
prompt
create table MM_MP_TRIAL_DEMAND
(
  id                 NUMBER(19) not null,
  supplier_no        VARCHAR2(20),
  sup_factory        VARCHAR2(20),
  part_no            VARCHAR2(20),
  arrive_time        DATE,
  order_num          NUMBER(10),
  exc_order_num      NUMBER(10),
  total_order_num    NUMBER(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  rel_status         NUMBER(1) default 0,
  rel_time           DATE,
  factory_code       VARCHAR2(10),
  workcenter         VARCHAR2(20),
  logistics_order    VARCHAR2(25),
  purchase_type      VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_TRIAL_DEMAND
  is 'MM_MP_TRIAL_DEMAND?????
';
comment on column MM_MP_TRIAL_DEMAND.id
  is 'ID
';
comment on column MM_MP_TRIAL_DEMAND.supplier_no
  is '?????
?????';
comment on column MM_MP_TRIAL_DEMAND.sup_factory
  is '??????
???';
comment on column MM_MP_TRIAL_DEMAND.part_no
  is '????
????';
comment on column MM_MP_TRIAL_DEMAND.arrive_time
  is '????
????';
comment on column MM_MP_TRIAL_DEMAND.order_num
  is '???
???';
comment on column MM_MP_TRIAL_DEMAND.exc_order_num
  is '????
????';
comment on column MM_MP_TRIAL_DEMAND.total_order_num
  is '???
???';
comment on column MM_MP_TRIAL_DEMAND.creation_user
  is '???
???';
comment on column MM_MP_TRIAL_DEMAND.creation_time
  is '????
????';
comment on column MM_MP_TRIAL_DEMAND.last_modified_user
  is '??????
??????';
comment on column MM_MP_TRIAL_DEMAND.last_modified_time
  is '??????
??????';
comment on column MM_MP_TRIAL_DEMAND.rel_status
  is '????
???? 0 ??? 9???';
comment on column MM_MP_TRIAL_DEMAND.rel_time
  is '????
????';
comment on column MM_MP_TRIAL_DEMAND.factory_code
  is '??
??';
comment on column MM_MP_TRIAL_DEMAND.workcenter
  is '????
????';
comment on column MM_MP_TRIAL_DEMAND.logistics_order
  is '?????
?????';
comment on column MM_MP_TRIAL_DEMAND.purchase_type
  is '????
????';

prompt
prompt Creating table MM_MP_TRIAL_DEMAND_IMP
prompt =====================================
prompt
create table MM_MP_TRIAL_DEMAND_IMP
(
  id              NUMBER(19) not null,
  supplier_no     VARCHAR2(20),
  sup_factory     VARCHAR2(20),
  part_no         VARCHAR2(20),
  arrive_time     DATE,
  order_num       NUMBER(10),
  exc_order_num   NUMBER(10),
  total_order_num NUMBER(10),
  creation_user   VARCHAR2(30),
  creation_time   DATE default sysdate,
  imp_uuid        VARCHAR2(50),
  check_result    NUMBER(1),
  check_info      VARCHAR2(300),
  import_status   NUMBER(1),
  ope_type        VARCHAR2(8) default 'I'
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_TRIAL_DEMAND_IMP
  is 'MM_MP_TRIAL_DEMAND_IMP??????????
';
comment on column MM_MP_TRIAL_DEMAND_IMP.id
  is 'ID
';
comment on column MM_MP_TRIAL_DEMAND_IMP.supplier_no
  is '?????
?????';
comment on column MM_MP_TRIAL_DEMAND_IMP.sup_factory
  is '??????
???';
comment on column MM_MP_TRIAL_DEMAND_IMP.part_no
  is '????
????';
comment on column MM_MP_TRIAL_DEMAND_IMP.arrive_time
  is '????
????';
comment on column MM_MP_TRIAL_DEMAND_IMP.order_num
  is '???
???';
comment on column MM_MP_TRIAL_DEMAND_IMP.exc_order_num
  is '????
????';
comment on column MM_MP_TRIAL_DEMAND_IMP.total_order_num
  is '???
???';
comment on column MM_MP_TRIAL_DEMAND_IMP.creation_user
  is '???
???';
comment on column MM_MP_TRIAL_DEMAND_IMP.creation_time
  is '????
????';
comment on column MM_MP_TRIAL_DEMAND_IMP.imp_uuid
  is 'IMP_UUID
';
comment on column MM_MP_TRIAL_DEMAND_IMP.check_result
  is '????
???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_MP_TRIAL_DEMAND_IMP.check_info
  is '????
';
comment on column MM_MP_TRIAL_DEMAND_IMP.import_status
  is '????
0-???
1-???';
comment on column MM_MP_TRIAL_DEMAND_IMP.ope_type
  is '????
I ??
U??';

prompt
prompt Creating table MM_MP_TRIAL_DEMAND_TEMP
prompt ======================================
prompt
create table MM_MP_TRIAL_DEMAND_TEMP
(
  part_no       VARCHAR2(20),
  arrive_time   DATE,
  order_num     NUMBER(10),
  creation_user VARCHAR2(30),
  creation_time DATE default SYSDATE,
  workcenter    VARCHAR2(20),
  factory_code  VARCHAR2(10),
  purchase_type VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_TRIAL_DEMAND_TEMP
  is 'MM_MP_TRIAL_DEMAND_TEMP
';
comment on column MM_MP_TRIAL_DEMAND_TEMP.part_no
  is 'PART_NO
????';
comment on column MM_MP_TRIAL_DEMAND_TEMP.arrive_time
  is 'ARRIVE_TIME
????';
comment on column MM_MP_TRIAL_DEMAND_TEMP.order_num
  is 'ORDER_NUM
???';
comment on column MM_MP_TRIAL_DEMAND_TEMP.creation_user
  is 'CREATION_USER
???';
comment on column MM_MP_TRIAL_DEMAND_TEMP.creation_time
  is 'CREATION_TIME
????';
comment on column MM_MP_TRIAL_DEMAND_TEMP.workcenter
  is 'WORKCENTER
????';
comment on column MM_MP_TRIAL_DEMAND_TEMP.factory_code
  is 'FACTORY_CODE
';
comment on column MM_MP_TRIAL_DEMAND_TEMP.purchase_type
  is 'PURCHASE_TYPE
????';

prompt
prompt Creating table MM_MP_TRIAL_OD_RELATION
prompt ======================================
prompt
create table MM_MP_TRIAL_OD_RELATION
(
  demand_id     NUMBER(19),
  order_no      VARCHAR2(50) not null,
  creation_user VARCHAR2(30),
  creation_time DATE default SYSDATE,
  factory_code  VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_TRIAL_OD_RELATION
  is 'MM_MP_TRIAL_OD_RELATION??????????
??????????';
comment on column MM_MP_TRIAL_OD_RELATION.demand_id
  is 'DEMAND_ID
??ID';
comment on column MM_MP_TRIAL_OD_RELATION.order_no
  is 'ORDER_NO
???';
comment on column MM_MP_TRIAL_OD_RELATION.creation_user
  is 'CREATION_USER
???';
comment on column MM_MP_TRIAL_OD_RELATION.creation_time
  is 'CREATION_TIME
????';
comment on column MM_MP_TRIAL_OD_RELATION.factory_code
  is 'FACTORY_CODE
??';

prompt
prompt Creating table MM_MP_TRIAL_ORDER
prompt ================================
prompt
create table MM_MP_TRIAL_ORDER
(
  order_no           VARCHAR2(50) not null,
  purchase_no        VARCHAR2(50),
  factory_code       VARCHAR2(10),
  supplier_no        VARCHAR2(20),
  sup_factory        VARCHAR2(20),
  arrive_date        DATE,
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  id                 NUMBER(19),
  p_deal_flag        NUMBER(1),
  p_deal_time        DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_TRIAL_ORDER
  is 'MM_MP_TRIAL_ORDER ??????
??????';
comment on column MM_MP_TRIAL_ORDER.order_no
  is '????
';
comment on column MM_MP_TRIAL_ORDER.purchase_no
  is '????
';
comment on column MM_MP_TRIAL_ORDER.factory_code
  is '??
??';
comment on column MM_MP_TRIAL_ORDER.supplier_no
  is '?????
?????';
comment on column MM_MP_TRIAL_ORDER.sup_factory
  is '??????
???';
comment on column MM_MP_TRIAL_ORDER.arrive_date
  is '????
????';
comment on column MM_MP_TRIAL_ORDER.deal_flag
  is '??????
0 ??? 1???';
comment on column MM_MP_TRIAL_ORDER.deal_time
  is '??????
';
comment on column MM_MP_TRIAL_ORDER.creation_user
  is '???
';
comment on column MM_MP_TRIAL_ORDER.creation_time
  is '????
';
comment on column MM_MP_TRIAL_ORDER.last_modified_user
  is '??????
';
comment on column MM_MP_TRIAL_ORDER.last_modified_time
  is '??????
';
comment on column MM_MP_TRIAL_ORDER.id
  is 'ID
ID';
comment on column MM_MP_TRIAL_ORDER.p_deal_flag
  is '????????
0 ??? 1???';
comment on column MM_MP_TRIAL_ORDER.p_deal_time
  is '??????
';
create index IDX_MM_MP_TRIAL_ORDER1 on MM_MP_TRIAL_ORDER (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_MP_TRIAL_ORDER
  add constraint PK_MM_MP_TRIAL_ORDER primary key (ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_TRIAL_ORDER_DETAIL
prompt =======================================
prompt
create table MM_MP_TRIAL_ORDER_DETAIL
(
  order_no      VARCHAR2(50) not null,
  row_no        NUMBER(10),
  part_no       VARCHAR2(20),
  order_num     NUMBER(10),
  purchase_type VARCHAR2(10),
  order_depot   VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_TRIAL_ORDER_DETAIL
  is 'MM_MP_TRIAL_ORDER_DETAIL????????
????????';
comment on column MM_MP_TRIAL_ORDER_DETAIL.order_no
  is '????
????';
comment on column MM_MP_TRIAL_ORDER_DETAIL.row_no
  is '??????
??';
comment on column MM_MP_TRIAL_ORDER_DETAIL.part_no
  is '???
???';
comment on column MM_MP_TRIAL_ORDER_DETAIL.order_num
  is '???
???';
comment on column MM_MP_TRIAL_ORDER_DETAIL.purchase_type
  is '????
????';
comment on column MM_MP_TRIAL_ORDER_DETAIL.order_depot
  is '????
????';
create index IDX_MP_TRIAL_ORDER_DETAIL1 on MM_MP_TRIAL_ORDER_DETAIL (ORDER_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_TRIAL_PLAN
prompt ===============================
prompt
create table MM_MP_TRIAL_PLAN
(
  sort_id            NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  car_type           VARCHAR2(10),
  order_no           VARCHAR2(50),
  weon_time          DATE,
  afoff_date         DATE,
  pro_phase          VARCHAR2(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  cal_status         NUMBER(1)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_TRIAL_PLAN
  is 'MM_MP_TRIAL_PLAN???????
???????';
comment on column MM_MP_TRIAL_PLAN.sort_id
  is '???????
SORT_ID';
comment on column MM_MP_TRIAL_PLAN.factory_code
  is '??
??';
comment on column MM_MP_TRIAL_PLAN.car_type
  is '??
??';
comment on column MM_MP_TRIAL_PLAN.order_no
  is '?????
???';
comment on column MM_MP_TRIAL_PLAN.weon_time
  is '??????
';
comment on column MM_MP_TRIAL_PLAN.afoff_date
  is '??????
';
comment on column MM_MP_TRIAL_PLAN.pro_phase
  is '????
????';
comment on column MM_MP_TRIAL_PLAN.creation_user
  is '???
';
comment on column MM_MP_TRIAL_PLAN.creation_time
  is '????
';
comment on column MM_MP_TRIAL_PLAN.last_modified_user
  is '??????
';
comment on column MM_MP_TRIAL_PLAN.last_modified_time
  is '??????
';
comment on column MM_MP_TRIAL_PLAN.cal_status
  is 'CAL_STATUS
0:????? 1;???';
create index IDX_MM_MP_TRIAL_PLAN1 on MM_MP_TRIAL_PLAN (AFOFF_DATE)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_MP_TRIAL_PLAN
  add constraint PK_MM_MP_TRIAL_PLAN primary key (SORT_ID, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_TRIAL_PLAN_IMP
prompt ===================================
prompt
create table MM_MP_TRIAL_PLAN_IMP
(
  id            NUMBER(19),
  sort_id       NUMBER(12),
  car_type      VARCHAR2(10),
  order_no      VARCHAR2(50),
  weon_time     DATE,
  afoff_date    DATE,
  pro_phase     VARCHAR2(9),
  factory_code  VARCHAR2(10),
  create_time   DATE,
  create_user   VARCHAR2(20),
  check_result  CHAR(1),
  check_info    VARCHAR2(300),
  import_status NUMBER(1) default 0,
  imp_uuid      VARCHAR2(50),
  data_ope_type VARCHAR2(8) default 'I'
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_TRIAL_PLAN_IMP
  is 'MM_MP_TRIAL_PLAN_IMP ??????????
??????????';
comment on column MM_MP_TRIAL_PLAN_IMP.id
  is 'ID
';
comment on column MM_MP_TRIAL_PLAN_IMP.sort_id
  is '?????
SORT_ID';
comment on column MM_MP_TRIAL_PLAN_IMP.car_type
  is '??
??';
comment on column MM_MP_TRIAL_PLAN_IMP.order_no
  is '???
???';
comment on column MM_MP_TRIAL_PLAN_IMP.weon_time
  is '??????
';
comment on column MM_MP_TRIAL_PLAN_IMP.afoff_date
  is '??????
??????';
comment on column MM_MP_TRIAL_PLAN_IMP.pro_phase
  is '????
????';
comment on column MM_MP_TRIAL_PLAN_IMP.factory_code
  is '??
??';
comment on column MM_MP_TRIAL_PLAN_IMP.create_time
  is '????
????';
comment on column MM_MP_TRIAL_PLAN_IMP.create_user
  is '???
???';
comment on column MM_MP_TRIAL_PLAN_IMP.check_result
  is '????
????';
comment on column MM_MP_TRIAL_PLAN_IMP.check_info
  is '????
????';
comment on column MM_MP_TRIAL_PLAN_IMP.import_status
  is '????
????';
comment on column MM_MP_TRIAL_PLAN_IMP.imp_uuid
  is 'IMP_UUID
';
comment on column MM_MP_TRIAL_PLAN_IMP.data_ope_type
  is 'DATA_OPE_TYPE
DATA_OPE_TYPE';

prompt
prompt Creating table MM_MP_VEH_PLAN
prompt =============================
prompt
create table MM_MP_VEH_PLAN
(
  sort_id            NUMBER(19) not null,
  mes_sort_id        VARCHAR2(20),
  factory_code       VARCHAR2(10) not null,
  car_type           VARCHAR2(10),
  order_no           VARCHAR2(50),
  mtoc               VARCHAR2(64),
  weon_time          DATE,
  afoff_time         DATE,
  pro_phase          VARCHAR2(10),
  cal_status         NUMBER(1),
  cal_time           DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  mes_order_no       VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_VEH_PLAN
  is 'MM_MP_VEH_PLAN ????
????';
comment on column MM_MP_VEH_PLAN.sort_id
  is '"车型物理排序号
SORT_ID"';
comment on column MM_MP_VEH_PLAN.mes_sort_id
  is '"生产排序号
生产排序号"';
comment on column MM_MP_VEH_PLAN.factory_code
  is '"工厂代码
"';
comment on column MM_MP_VEH_PLAN.car_type
  is '"车型
车型"';
comment on column MM_MP_VEH_PLAN.order_no
  is '"生产订单号
订单号"';
comment on column MM_MP_VEH_PLAN.mtoc
  is '"MTOC
"';
comment on column MM_MP_VEH_PLAN.weon_time
  is '"焊装上线时间
焊装上线时间"';
comment on column MM_MP_VEH_PLAN.afoff_time
  is '"总装下线时间
"';
comment on column MM_MP_VEH_PLAN.pro_phase
  is '"生产阶段
生产阶段"';
comment on column MM_MP_VEH_PLAN.cal_status
  is '"计算状态
0-未计算
1-已计算"';
comment on column MM_MP_VEH_PLAN.cal_time
  is '"计算时间
"';
comment on column MM_MP_VEH_PLAN.creation_user
  is '"创建人
"';
comment on column MM_MP_VEH_PLAN.creation_time
  is '"创建时间
"';
comment on column MM_MP_VEH_PLAN.last_modified_user
  is '"最后修改用户
"';
comment on column MM_MP_VEH_PLAN.last_modified_time
  is '"最后修改时间
"';
comment on column MM_MP_VEH_PLAN.mes_order_no
  is 'MES订单号 ';
create index IDX_MM_MP_VEH_PLAN1 on MM_MP_VEH_PLAN (AFOFF_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_MP_VEH_PLAN
  add constraint PK_MM_MP_VEH_PLAN primary key (SORT_ID, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_VEH_PLAN_TEMP
prompt ==================================
prompt
create table MM_MP_VEH_PLAN_TEMP
(
  sort_id            NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  car_type           VARCHAR2(10),
  order_no           VARCHAR2(50),
  car_type_sort_id   NUMBER(10),
  mtoc               VARCHAR2(64),
  weon_time          DATE,
  afoff_time         DATE,
  pro_phase          VARCHAR2(10),
  cal_status         NUMBER(1),
  cal_time           DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  is_autoed          NUMBER(1) default 0,
  mes_order_no       VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_VEH_PLAN_TEMP
  is 'MM_MP_VEH_PLAN_TEMP ?????????
?????????';
comment on column MM_MP_VEH_PLAN_TEMP.sort_id
  is '"生产订单排序
SORT_ID"';
comment on column MM_MP_VEH_PLAN_TEMP.factory_code
  is '"工厂代码
"';
comment on column MM_MP_VEH_PLAN_TEMP.car_type
  is '"车型
车型"';
comment on column MM_MP_VEH_PLAN_TEMP.order_no
  is '"生产订单号
订单号"';
comment on column MM_MP_VEH_PLAN_TEMP.car_type_sort_id
  is '"车型排序号
车型排序号"';
comment on column MM_MP_VEH_PLAN_TEMP.mtoc
  is '"MTOC
"';
comment on column MM_MP_VEH_PLAN_TEMP.weon_time
  is '"焊装上线时间
焊装上线时间"';
comment on column MM_MP_VEH_PLAN_TEMP.afoff_time
  is '"总装下线时间
"';
comment on column MM_MP_VEH_PLAN_TEMP.pro_phase
  is '"生产阶段
生产阶段"';
comment on column MM_MP_VEH_PLAN_TEMP.cal_status
  is '"计算状态
0-未计算
1-已计算"';
comment on column MM_MP_VEH_PLAN_TEMP.cal_time
  is '"计算时间
"';
comment on column MM_MP_VEH_PLAN_TEMP.creation_user
  is '"创建人
"';
comment on column MM_MP_VEH_PLAN_TEMP.creation_time
  is '"创建时间
"';
comment on column MM_MP_VEH_PLAN_TEMP.last_modified_user
  is '"最后修改用户
"';
comment on column MM_MP_VEH_PLAN_TEMP.last_modified_time
  is '"最后修改时间
"';
comment on column MM_MP_VEH_PLAN_TEMP.is_autoed
  is '"是否自动写入的数据
是否已经写入 0非自动写入, 1表示自动写入"';
comment on column MM_MP_VEH_PLAN_TEMP.mes_order_no
  is 'MES订单号 ';
create index IDX_MM_MP_VEH_PLAN2 on MM_MP_VEH_PLAN_TEMP (AFOFF_TIME)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_WEEK_PLAN
prompt ==============================
prompt
create table MM_MP_WEEK_PLAN
(
  id                 NUMBER(19) not null,
  year               VARCHAR2(10),
  week               NUMBER(10),
  start_day          DATE,
  end_day            DATE,
  day                NUMBER(10),
  week_num           NUMBER(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  factory_code       VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_WEEK_PLAN
  is 'MM_MP_WEEK_PLAN????
????';
comment on column MM_MP_WEEK_PLAN.id
  is 'ID
';
comment on column MM_MP_WEEK_PLAN.year
  is '??
2018';
comment on column MM_MP_WEEK_PLAN.week
  is '??
??????';
comment on column MM_MP_WEEK_PLAN.start_day
  is '????
????';
comment on column MM_MP_WEEK_PLAN.end_day
  is '????
????';
comment on column MM_MP_WEEK_PLAN.day
  is '??
???? 1???? 2???? 3????';
comment on column MM_MP_WEEK_PLAN.week_num
  is '???????
???????';
comment on column MM_MP_WEEK_PLAN.creation_user
  is '???
';
comment on column MM_MP_WEEK_PLAN.creation_time
  is '????
';
comment on column MM_MP_WEEK_PLAN.last_modified_user
  is '??????
';
comment on column MM_MP_WEEK_PLAN.last_modified_time
  is '??????
';
comment on column MM_MP_WEEK_PLAN.factory_code
  is '??
';
alter table MM_MP_WEEK_PLAN
  add constraint PK_MM_MP_WEEK_PLAN primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_MP_WEEK_PLAN
  add constraint AK_AK_MM_MP_WEEK_PLAN_MM_MP_WE unique (YEAR, WEEK, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_MP_WORK_CALENDAR
prompt ==================================
prompt
create table MM_MP_WORK_CALENDAR
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  workcenter         VARCHAR2(20) not null,
  shift_code         VARCHAR2(20) not null,
  work_date          DATE not null,
  work_start_time    DATE,
  work_end_time      DATE,
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_MP_WORK_CALENDAR
  is 'MM_MP_WORK_CALENDAR??????????
';
comment on column MM_MP_WORK_CALENDAR.id
  is '????????
';
comment on column MM_MP_WORK_CALENDAR.factory_code
  is '??
';
comment on column MM_MP_WORK_CALENDAR.workcenter
  is '????
';
comment on column MM_MP_WORK_CALENDAR.shift_code
  is '??
';
comment on column MM_MP_WORK_CALENDAR.work_date
  is '???
';
comment on column MM_MP_WORK_CALENDAR.work_start_time
  is '??????
';
comment on column MM_MP_WORK_CALENDAR.work_end_time
  is '??????
';
comment on column MM_MP_WORK_CALENDAR.creation_time
  is '????
';
comment on column MM_MP_WORK_CALENDAR.last_modified_time
  is '??????
';
alter table MM_MP_WORK_CALENDAR
  add constraint PK_MM_MP_WORK_CALENDAR primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_MP_WORK_CALENDAR
  add constraint AK_MM_MP_WORK_CALENDAR unique (WORK_DATE, WORKCENTER, SHIFT_CODE, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PDA_BUG_LOG
prompt =============================
prompt
create table MM_PDA_BUG_LOG
(
  username   VARCHAR2(20),
  factory    VARCHAR2(10),
  createtime DATE,
  info       VARCHAR2(1000)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_PDA_BUG_LOG
  is '?????';
comment on column MM_PDA_BUG_LOG.username
  is '???';
comment on column MM_PDA_BUG_LOG.factory
  is '??';
comment on column MM_PDA_BUG_LOG.createtime
  is '????';
comment on column MM_PDA_BUG_LOG.info
  is '??';

prompt
prompt Creating table MM_PDA_JISO_LABEL
prompt ================================
prompt
create table MM_PDA_JISO_LABEL
(
  ins_no             VARCHAR2(50) not null,
  part_no            VARCHAR2(40),
  order_rowno        NUMBER(10) not null,
  require_num        NUMBER(10),
  arrive_num         NUMBER(19),
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PDA_LABEL_SCAN_LOG
prompt ====================================
prompt
create table MM_PDA_LABEL_SCAN_LOG
(
  factory_code VARCHAR2(10),
  bar_code     VARCHAR2(150),
  order_no     VARCHAR2(50),
  row_no       NUMBER(5),
  part_no      VARCHAR2(20),
  qty          NUMBER(9),
  bar_uuid     VARCHAR2(50) not null,
  type         NUMBER(1) not null,
  shelve_id    VARCHAR2(32),
  deliver_no   VARCHAR2(20),
  tora_id      VARCHAR2(50),
  create_user  VARCHAR2(20),
  create_time  DATE,
  ip           VARCHAR2(20),
  ins_no       VARCHAR2(100),
  deal_flag    NUMBER(1) default 0,
  deal_time    DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_PDA_LABEL_SCAN_LOG
  is '??????';
comment on column MM_PDA_LABEL_SCAN_LOG.factory_code
  is '????';
comment on column MM_PDA_LABEL_SCAN_LOG.bar_code
  is '???';
comment on column MM_PDA_LABEL_SCAN_LOG.order_no
  is '????';
comment on column MM_PDA_LABEL_SCAN_LOG.row_no
  is '????';
comment on column MM_PDA_LABEL_SCAN_LOG.part_no
  is '????';
comment on column MM_PDA_LABEL_SCAN_LOG.qty
  is '??';
comment on column MM_PDA_LABEL_SCAN_LOG.bar_uuid
  is 'UUID';
comment on column MM_PDA_LABEL_SCAN_LOG.type
  is '0 ??????1  ???  2 ?? ?3 ????? 4 SPS?? ?5 SPS??';
comment on column MM_PDA_LABEL_SCAN_LOG.shelve_id
  is '??SPS????????';
comment on column MM_PDA_LABEL_SCAN_LOG.deliver_no
  is '??SPS??????????';
comment on column MM_PDA_LABEL_SCAN_LOG.tora_id
  is '???';
comment on column MM_PDA_LABEL_SCAN_LOG.create_user
  is '???';
comment on column MM_PDA_LABEL_SCAN_LOG.create_time
  is '????';
comment on column MM_PDA_LABEL_SCAN_LOG.ip
  is 'ip??';
comment on column MM_PDA_LABEL_SCAN_LOG.deal_flag
  is '???? ';
comment on column MM_PDA_LABEL_SCAN_LOG.deal_time
  is '???? ';
alter table MM_PDA_LABEL_SCAN_LOG
  add constraint PK_MM_PDA_LABEL_SCAN_LOG primary key (BAR_UUID, TYPE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PDA_MAT_ORDER_INFO
prompt ====================================
prompt
create table MM_PDA_MAT_ORDER_INFO
(
  order_no      VARCHAR2(50) not null,
  supplier_no   VARCHAR2(20),
  purchase_org  VARCHAR2(20),
  factory_code  VARCHAR2(10),
  part_no       VARCHAR2(20),
  order_num     NUMBER(10),
  inv_code      VARCHAR2(20),
  ware_address  VARCHAR2(20),
  inv_dis       VARCHAR2(20),
  cost_center   VARCHAR2(20),
  create_time   DATE,
  create_user   VARCHAR2(20),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  cost_code     VARCHAR2(20),
  min_order_num NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PDA_MAT_ORDER_INFO
  is 'MM_PDA_MAT_ORDER_INFOPDA????????';
comment on column MM_PDA_MAT_ORDER_INFO.order_no
  is '?????';
comment on column MM_PDA_MAT_ORDER_INFO.supplier_no
  is '???';
comment on column MM_PDA_MAT_ORDER_INFO.purchase_org
  is '????';
comment on column MM_PDA_MAT_ORDER_INFO.factory_code
  is '??';
comment on column MM_PDA_MAT_ORDER_INFO.part_no
  is '???';
comment on column MM_PDA_MAT_ORDER_INFO.order_num
  is '??';
comment on column MM_PDA_MAT_ORDER_INFO.inv_code
  is '????';
comment on column MM_PDA_MAT_ORDER_INFO.ware_address
  is '??????';
comment on column MM_PDA_MAT_ORDER_INFO.inv_dis
  is '????';
comment on column MM_PDA_MAT_ORDER_INFO.cost_center
  is '????';
comment on column MM_PDA_MAT_ORDER_INFO.create_time
  is '????';
comment on column MM_PDA_MAT_ORDER_INFO.create_user
  is '???';
comment on column MM_PDA_MAT_ORDER_INFO.deal_flag
  is '????';
comment on column MM_PDA_MAT_ORDER_INFO.deal_time
  is '????';
comment on column MM_PDA_MAT_ORDER_INFO.cost_code
  is '??????';
comment on column MM_PDA_MAT_ORDER_INFO.min_order_num
  is '?????';
alter table MM_PDA_MAT_ORDER_INFO
  add constraint PK_MM_PDA_MAT_ORDER_INFO primary key (ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PDA_MENU
prompt ==========================
prompt
create table MM_PDA_MENU
(
  menu_id            NUMBER(10) not null,
  menu_name          VARCHAR2(60),
  menu_desc          VARCHAR2(100),
  menu_level         NUMBER(2),
  parent_id          NUMBER(10),
  disp_order         NUMBER(5),
  menu_url           VARCHAR2(100),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_PDA_MENU
  add constraint PK_MM_PDA_MENU primary key (MENU_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_PDA_MENU
  add constraint AK_MM_PDA_MENU unique (MENU_NAME)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PDA_PICKPRO_USER
prompt ==================================
prompt
create table MM_PDA_PICKPRO_USER
(
  id             NUMBER(19),
  prepare_person VARCHAR2(30),
  emp_account    VARCHAR2(30),
  factory_code   VARCHAR2(10),
  work_date      DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PDA_PICKPRO_USER
  is '?????????';
comment on column MM_PDA_PICKPRO_USER.id
  is 'ID';
comment on column MM_PDA_PICKPRO_USER.prepare_person
  is '????';
comment on column MM_PDA_PICKPRO_USER.emp_account
  is '????';
comment on column MM_PDA_PICKPRO_USER.factory_code
  is '??';
comment on column MM_PDA_PICKPRO_USER.work_date
  is '???';

prompt
prompt Creating table MM_PDA_ROLE
prompt ==========================
prompt
create table MM_PDA_ROLE
(
  pda_role_id NUMBER(18),
  role_name   VARCHAR2(128),
  remark      VARCHAR2(256),
  create_user VARCHAR2(32),
  create_time DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PDA_ROLE_MENU
prompt ===============================
prompt
create table MM_PDA_ROLE_MENU
(
  pda_role_id NUMBER(18) not null,
  menu_id     NUMBER(10) not null,
  create_user VARCHAR2(32),
  create_time DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_PDA_ROLE_MENU
  add constraint PK_MM_PDA_ROLE_MENU primary key (PDA_ROLE_ID, MENU_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PDA_TEST
prompt ==========================
prompt
create table MM_PDA_TEST
(
  order_no      VARCHAR2(50) not null,
  supplier_no   VARCHAR2(20),
  purchase_org  VARCHAR2(20),
  factory_code  VARCHAR2(10),
  part_no       VARCHAR2(64),
  order_num     NUMBER(10),
  inv_code      VARCHAR2(20),
  ware_address  VARCHAR2(20),
  inv_dis       VARCHAR2(20),
  cost_center   VARCHAR2(20),
  create_time   DATE,
  create_user   VARCHAR2(20),
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE,
  cost_code     VARCHAR2(20),
  min_order_num NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PDA_TEST
  is 'PDA测试表';
comment on column MM_PDA_TEST.order_no
  is '物流订单号';
comment on column MM_PDA_TEST.supplier_no
  is '供应商';
comment on column MM_PDA_TEST.purchase_org
  is '采购组织';
comment on column MM_PDA_TEST.factory_code
  is '工厂';
comment on column MM_PDA_TEST.part_no
  is '零件号';
comment on column MM_PDA_TEST.order_num
  is '数量';
comment on column MM_PDA_TEST.inv_code
  is '库存代码';
comment on column MM_PDA_TEST.ware_address
  is '仓库货架地址';
comment on column MM_PDA_TEST.inv_dis
  is '库存区分';
comment on column MM_PDA_TEST.cost_center
  is '成本中心';
comment on column MM_PDA_TEST.create_time
  is '创建时间';
comment on column MM_PDA_TEST.create_user
  is '创建人';
comment on column MM_PDA_TEST.deal_flag
  is '处理标识';
comment on column MM_PDA_TEST.deal_time
  is '处理时间';
comment on column MM_PDA_TEST.cost_code
  is '费用归类代码';
comment on column MM_PDA_TEST.min_order_num
  is '最小订购量';
alter table MM_PDA_TEST
  add constraint PK_MM_PDA_TEST primary key (ORDER_NO)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PDA_TEST_LOG
prompt ==============================
prompt
create table MM_PDA_TEST_LOG
(
  id            NUMBER(19) not null,
  ui_name       VARCHAR2(20),
  ope_user      VARCHAR2(20),
  factory_code  VARCHAR2(20),
  ope_ip        VARCHAR2(20),
  ope_time      VARCHAR2(20),
  creation_time DATE,
  ope_type      VARCHAR2(200)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_PDA_TEST_LOG
  is 'PDA测试日志表';
comment on column MM_PDA_TEST_LOG.id
  is '主键ID';
comment on column MM_PDA_TEST_LOG.ui_name
  is '界面名称';
comment on column MM_PDA_TEST_LOG.ope_user
  is '操作人';
comment on column MM_PDA_TEST_LOG.factory_code
  is '工厂';
comment on column MM_PDA_TEST_LOG.ope_ip
  is '操作IP';
comment on column MM_PDA_TEST_LOG.ope_time
  is '操作耗时/毫秒数';
comment on column MM_PDA_TEST_LOG.creation_time
  is '创建时间';
comment on column MM_PDA_TEST_LOG.ope_type
  is '操作类型';
alter table MM_PDA_TEST_LOG
  add constraint PK_MM_PDA_TEST_LOG primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PDA_USER
prompt ==========================
prompt
create table MM_PDA_USER
(
  user_id            VARCHAR2(20) not null,
  user_name          VARCHAR2(30),
  factory_code       VARCHAR2(10),
  user_pwd           VARCHAR2(50),
  login_num          NUMBER(10),
  login_ip           VARCHAR2(50),
  login_time         DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_PDA_USER.user_id
  is '??ID';
comment on column MM_PDA_USER.user_name
  is '???';
comment on column MM_PDA_USER.factory_code
  is '??';
comment on column MM_PDA_USER.user_pwd
  is '??';
comment on column MM_PDA_USER.login_num
  is '????';
comment on column MM_PDA_USER.login_ip
  is '??IP';
comment on column MM_PDA_USER.login_time
  is '????';
comment on column MM_PDA_USER.creation_user
  is '???';
comment on column MM_PDA_USER.creation_time
  is '????';
comment on column MM_PDA_USER.last_modified_user
  is '??????';
comment on column MM_PDA_USER.last_modified_time
  is '??????';
alter table MM_PDA_USER
  add constraint PK_MM_PDA_USER primary key (USER_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PDA_USER_MENU
prompt ===============================
prompt
create table MM_PDA_USER_MENU
(
  user_id       VARCHAR2(20) not null,
  menu_id       NUMBER(10) not null,
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_PDA_USER_MENU
  add constraint PK_MM_PDA_USER_MENU primary key (USER_ID, MENU_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PDA_USER_ROLE
prompt ===============================
prompt
create table MM_PDA_USER_ROLE
(
  user_id     VARCHAR2(32) not null,
  pda_role_id NUMBER(18) not null,
  create_user VARCHAR2(32),
  create_time DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_PDA_USER_ROLE
  add constraint PK_MM_PDA_USER_ROLE primary key (USER_ID, PDA_ROLE_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PKG_BOX
prompt =========================
prompt
create table MM_PKG_BOX
(
  id                 NUMBER(19) not null,
  box_code           VARCHAR2(30),
  box_type           NUMBER(2),
  pack_length        NUMBER(19,3),
  pack_width         NUMBER(19,3),
  pack_height        NUMBER(19,3),
  status             NUMBER(2) default 0,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  factory_code       VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PKG_BOX.box_code
  is '?code';
comment on column MM_PKG_BOX.box_type
  is '1-??
2-EU?
3-???
4-??';
comment on column MM_PKG_BOX.pack_length
  is '???';
comment on column MM_PKG_BOX.pack_width
  is '???';
comment on column MM_PKG_BOX.pack_height
  is '???';
comment on column MM_PKG_BOX.status
  is '0-??
1-??';
alter table MM_PKG_BOX
  add constraint PK_MM_PKG_BOX primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PKG_BOX
  add constraint AK_MM_PKG_BOX unique (BOX_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PKG_BOX_QTY
prompt =============================
prompt
create table MM_PKG_BOX_QTY
(
  id                 NUMBER(19) not null,
  proposal_id        NUMBER(19),
  provide_qty        NUMBER(10),
  box_require_qty    NUMBER(10),
  hair_note_model    VARCHAR2(50),
  plan_date          DATE,
  delay_reason       VARCHAR2(300),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  factory_code       VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PKG_BOX_QTY.provide_qty
  is '????';
comment on column MM_PKG_BOX_QTY.box_require_qty
  is '?????';
comment on column MM_PKG_BOX_QTY.hair_note_model
  is '????';
comment on column MM_PKG_BOX_QTY.plan_date
  is '??????';
comment on column MM_PKG_BOX_QTY.delay_reason
  is '????';
alter table MM_PKG_BOX_QTY
  add constraint PK_MM_PKG_BOX_QTY primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PKG_BOX_QTY
  add constraint AK_MM_PKG_BOX_QTY unique (PROPOSAL_ID, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PKG_BOX_QTY_IMP
prompt =================================
prompt
create table MM_PKG_BOX_QTY_IMP
(
  id              NUMBER(19),
  provide_qty     VARCHAR2(50),
  box_require_qty VARCHAR2(50),
  hair_note_model VARCHAR2(50),
  plan_date       DATE,
  delay_reason    VARCHAR2(300),
  factory_code    VARCHAR2(10),
  imp_uuid        VARCHAR2(50),
  check_result    NUMBER(1),
  check_info      VARCHAR2(512),
  import_status   NUMBER(1) default 0,
  continue_check  NUMBER(1),
  ope_type        VARCHAR2(8) default 'I',
  busi_id         NUMBER(19),
  proposal_id     NUMBER(19),
  creation_time   DATE,
  creation_user   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PKG_EXPECT_DETAIL
prompt ===================================
prompt
create table MM_PKG_EXPECT_DETAIL
(
  id                 NUMBER(19) not null,
  proposal_id        NUMBER(19),
  box_code           VARCHAR2(20),
  pkg_length         NUMBER(10,3),
  pkg_width          NUMBER(10,3),
  pkg_height         NUMBER(10,3),
  standard_pack      NUMBER(10,3),
  is_inner_wood      NUMBER(1),
  place_between      NUMBER(1),
  is_separate_pkg    NUMBER(1),
  is_dustproof       NUMBER(1),
  is_anti_scratch    NUMBER(1),
  work_require       VARCHAR2(300),
  quality_require    VARCHAR2(300),
  remark             VARCHAR2(300),
  simple_pic         NUMBER(19),
  limit_date         DATE,
  mixed_way          NUMBER(1),
  place_order        NUMBER(1),
  trolley_type       NUMBER(1),
  is_attachment      NUMBER(1),
  word_desc          VARCHAR2(300),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PKG_EXPECT_DETAIL.is_inner_wood
  is '0-?
1-?';
comment on column MM_PKG_EXPECT_DETAIL.place_between
  is '0-?
1-?';
comment on column MM_PKG_EXPECT_DETAIL.is_separate_pkg
  is '0-?
1-?';
comment on column MM_PKG_EXPECT_DETAIL.is_dustproof
  is '0-?
1-?';
comment on column MM_PKG_EXPECT_DETAIL.is_anti_scratch
  is '0-?
1-?';
alter table MM_PKG_EXPECT_DETAIL
  add constraint PK_MM_PKG_EXPECT_DETAIL primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PKG_PART
prompt ==========================
prompt
create table MM_PKG_PART
(
  id                 NUMBER(19) not null,
  car_type           VARCHAR2(20),
  project            VARCHAR2(50),
  part_no            VARCHAR2(64),
  part_resp_user     VARCHAR2(30),
  supplier_no        VARCHAR2(20),
  status             NUMBER(1),
  creation_user      VARCHAR2(30),
  creation_time      DATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  factory_code       VARCHAR2(10),
  purchase_type      VARCHAR2(10),
  email_flag         NUMBER(1) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PKG_PART.status
  is '0??? 1???';
create index IDX_MM_PKG_PART1 on MM_PKG_PART (EMAIL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PKG_PART
  add constraint PK_MM_PKG_PART primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PKG_PART
  add constraint AK_MM_PKG_PART unique (CAR_TYPE, PART_NO, SUPPLIER_NO, PURCHASE_TYPE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PKG_PROPOSAL
prompt ==============================
prompt
create table MM_PKG_PROPOSAL
(
  id                 NUMBER(19) not null,
  car_type           VARCHAR2(20),
  supplier_no        VARCHAR2(20),
  part_no            VARCHAR2(20),
  proposal_status    NUMBER(1) default 0,
  pack_type          NUMBER(1),
  box_type           NUMBER(2),
  reply_limit_date   DATE,
  is_com_pack        NUMBER(1),
  status             NUMBER(1),
  sign_pro_file      VARCHAR2(50),
  eff_start          DATE,
  eff_end            DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  factory_code       VARCHAR2(10),
  part_resp_user     VARCHAR2(30),
  project            VARCHAR2(50),
  purchase_type      VARCHAR2(10),
  com_pack_remark    VARCHAR2(600),
  is_show_change     NUMBER(1) default 0,
  email_flag         NUMBER(1) default 0,
  check_remark       VARCHAR2(300)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_PKG_PROPOSAL.car_type
  is '??';
comment on column MM_PKG_PROPOSAL.supplier_no
  is '?????';
comment on column MM_PKG_PROPOSAL.part_no
  is '????';
comment on column MM_PKG_PROPOSAL.proposal_status
  is '0-???
1-????
2-???
3-????
4-?????
5-????
6-?????
7-??';
comment on column MM_PKG_PROPOSAL.pack_type
  is '0-???
1-??';
comment on column MM_PKG_PROPOSAL.box_type
  is '0??? 1??? 2?EU? 3???';
comment on column MM_PKG_PROPOSAL.reply_limit_date
  is '????';
comment on column MM_PKG_PROPOSAL.is_com_pack
  is '0-?
1-?';
comment on column MM_PKG_PROPOSAL.status
  is '1-??
2-??';
comment on column MM_PKG_PROPOSAL.eff_start
  is '????';
comment on column MM_PKG_PROPOSAL.eff_end
  is '????';
comment on column MM_PKG_PROPOSAL.is_show_change
  is '0?? 1?? 2????????';
comment on column MM_PKG_PROPOSAL.email_flag
  is '0???
1???';
create index IDX_MM_PKG_PROPOSAL1 on MM_PKG_PROPOSAL (CREATION_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_PKG_PROPOSAL2 on MM_PKG_PROPOSAL (PROPOSAL_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_PKG_PROPOSAL
  add constraint PK_MM_PKG_PROPOSAL primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PKG_PROPOSAL_DETAIL
prompt =====================================
prompt
create table MM_PKG_PROPOSAL_DETAIL
(
  id                    NUMBER(19) not null,
  proposal_id           NUMBER(19),
  group_no              VARCHAR2(30),
  max_package_num       NUMBER(10),
  standard_package      NUMBER(10),
  part_weight           NUMBER(10,3),
  part_total_weight     NUMBER(10,3),
  pack_weight           NUMBER(10,3),
  part_length           NUMBER(10,3),
  part_width            NUMBER(10,3),
  part_height           NUMBER(10,3),
  empty_trolley_length  NUMBER(10,3),
  empty_trolley_width   NUMBER(10,3),
  empty_trolley_height  NUMBER(10,3),
  real_trolley_length   NUMBER(10,3),
  real_trolley_width    NUMBER(10,3),
  real_trolley_height   NUMBER(10,3),
  trolley_weight        NUMBER(10,3),
  total_weight          NUMBER(10,3),
  is_trolley_code       NUMBER(1),
  is_positioner         NUMBER(1),
  dust_cover            NUMBER(1),
  one_by_package        NUMBER(1),
  int_mate              NUMBER(1),
  board_location        VARCHAR2(10),
  wheel_diameter        NUMBER(10,3),
  word_desc             VARCHAR2(600),
  traction_rod_height   NUMBER(10,3),
  important_postion_pic NUMBER(19),
  empty_tro_front_pic   VARCHAR2(50),
  empty_tro_side_pic    VARCHAR2(50),
  real_tro_pic          VARCHAR2(50),
  box_code              VARCHAR2(20),
  pack_length           NUMBER(10,3),
  pack_width            NUMBER(10,3),
  pack_height           NUMBER(10,3),
  tray_length           NUMBER(10,3),
  tray_width            NUMBER(10,3),
  tray_height           NUMBER(10,3),
  work_require          VARCHAR2(500),
  single_part_pic       NUMBER(19),
  single_part_put_pic   NUMBER(19),
  pack_over_look_pic    NUMBER(19),
  pack_side_look_pic    NUMBER(19),
  creation_user         VARCHAR2(30),
  creation_time         DATE default sysdate,
  last_modified_user    VARCHAR2(30),
  last_modified_time    DATE,
  factory_code          VARCHAR2(10),
  sup_name              VARCHAR2(30),
  mobile                VARCHAR2(30),
  mail                  VARCHAR2(30),
  is_change             NUMBER(2),
  column_54             CHAR(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_PKG_PROPOSAL_DETAIL.group_no
  is '??';
comment on column MM_PKG_PROPOSAL_DETAIL.max_package_num
  is '?????';
comment on column MM_PKG_PROPOSAL_DETAIL.standard_package
  is '?????';
comment on column MM_PKG_PROPOSAL_DETAIL.part_weight
  is '????';
comment on column MM_PKG_PROPOSAL_DETAIL.part_total_weight
  is '?????';
comment on column MM_PKG_PROPOSAL_DETAIL.part_length
  is '???';
comment on column MM_PKG_PROPOSAL_DETAIL.part_width
  is '???';
comment on column MM_PKG_PROPOSAL_DETAIL.part_height
  is '???';
comment on column MM_PKG_PROPOSAL_DETAIL.empty_trolley_length
  is '????';
comment on column MM_PKG_PROPOSAL_DETAIL.empty_trolley_width
  is '????';
comment on column MM_PKG_PROPOSAL_DETAIL.empty_trolley_height
  is '????';
comment on column MM_PKG_PROPOSAL_DETAIL.real_trolley_length
  is '????';
comment on column MM_PKG_PROPOSAL_DETAIL.real_trolley_width
  is '????';
comment on column MM_PKG_PROPOSAL_DETAIL.real_trolley_height
  is '????';
comment on column MM_PKG_PROPOSAL_DETAIL.trolley_weight
  is '????';
comment on column MM_PKG_PROPOSAL_DETAIL.total_weight
  is '???';
comment on column MM_PKG_PROPOSAL_DETAIL.is_trolley_code
  is '0-?
1-?';
comment on column MM_PKG_PROPOSAL_DETAIL.is_positioner
  is '0-?
1-?';
comment on column MM_PKG_PROPOSAL_DETAIL.dust_cover
  is '0-?
1-?';
comment on column MM_PKG_PROPOSAL_DETAIL.one_by_package
  is '0-?
1-?';
comment on column MM_PKG_PROPOSAL_DETAIL.board_location
  is 'L  / W';
comment on column MM_PKG_PROPOSAL_DETAIL.wheel_diameter
  is '????';
comment on column MM_PKG_PROPOSAL_DETAIL.word_desc
  is '????';
comment on column MM_PKG_PROPOSAL_DETAIL.traction_rod_height
  is '??????';
comment on column MM_PKG_PROPOSAL_DETAIL.important_postion_pic
  is '?????';
comment on column MM_PKG_PROPOSAL_DETAIL.empty_tro_front_pic
  is '??????';
comment on column MM_PKG_PROPOSAL_DETAIL.empty_tro_side_pic
  is '??????';
comment on column MM_PKG_PROPOSAL_DETAIL.real_tro_pic
  is '????';
comment on column MM_PKG_PROPOSAL_DETAIL.is_change
  is '0?? 1??  ????????????????????????????????????????';
alter table MM_PKG_PROPOSAL_DETAIL
  add constraint PK_MM_PKG_PROPOSAL_DETAIL primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_PKG_PROPOSAL_DETAIL
  add constraint AK_MM_PKG_PROPOSAL_DETAIL unique (PROPOSAL_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PKG_TRAY_QTY
prompt ==============================
prompt
create table MM_PKG_TRAY_QTY
(
  id                 NUMBER(19) not null,
  car_type           VARCHAR2(20),
  supplier_no        VARCHAR2(20),
  provide_qty        NUMBER(10),
  tray_require_qty   NUMBER(10),
  plan_date          DATE,
  delay_reason       VARCHAR2(300),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  factory_code       VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PKG_TRAY_QTY.car_type
  is '??';
comment on column MM_PKG_TRAY_QTY.supplier_no
  is '?????';
comment on column MM_PKG_TRAY_QTY.provide_qty
  is '????';
comment on column MM_PKG_TRAY_QTY.tray_require_qty
  is '?????';
comment on column MM_PKG_TRAY_QTY.plan_date
  is '??????';
comment on column MM_PKG_TRAY_QTY.delay_reason
  is '????';
alter table MM_PKG_TRAY_QTY
  add constraint PK_MM_PKG_TRAY_QTY primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PKG_TRAY_QTY
  add constraint AK_MM_PKG_TRAY_QTY unique (CAR_TYPE, SUPPLIER_NO, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PKG_TRAY_QTY_IMP
prompt ==================================
prompt
create table MM_PKG_TRAY_QTY_IMP
(
  id               NUMBER(19),
  car_type         VARCHAR2(20),
  supplier_no      VARCHAR2(20),
  provide_qty      NUMBER(10),
  tray_require_qty NUMBER(10),
  plan_date        DATE,
  delay_reason     VARCHAR2(300),
  factory_code     VARCHAR2(10),
  imp_uuid         VARCHAR2(50),
  check_result     NUMBER(1),
  check_info       VARCHAR2(512),
  import_status    NUMBER(1) default 0,
  ope_type         CHAR(10),
  creation_time    DATE,
  creation_user    VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PR_EXCEP_ALERT
prompt ================================
prompt
create table MM_PR_EXCEP_ALERT
(
  func_point    VARCHAR2(80),
  error_msg     VARCHAR2(300),
  creation_time DATE default SYSDATE,
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PR_EXCEP_ALERT
  is '?????';
comment on column MM_PR_EXCEP_ALERT.func_point
  is '????';
comment on column MM_PR_EXCEP_ALERT.error_msg
  is '????';
comment on column MM_PR_EXCEP_ALERT.creation_time
  is '????';
comment on column MM_PR_EXCEP_ALERT.deal_flag
  is '????';
comment on column MM_PR_EXCEP_ALERT.deal_time
  is '????';

prompt
prompt Creating table MM_PR_JOB
prompt ========================
prompt
create table MM_PR_JOB
(
  job_name           VARCHAR2(80) not null,
  description        VARCHAR2(255),
  print_type         VARCHAR2(80),
  job_type           VARCHAR2(80),
  copies             NUMBER(10),
  classes            VARCHAR2(20),
  printer_name       VARCHAR2(80),
  update_sql         VARCHAR2(1024),
  creation_time      DATE,
  creation_user      VARCHAR2(30),
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  last_modified_ip   VARCHAR2(30),
  id                 NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PR_JOB
  is '?????';
comment on column MM_PR_JOB.job_name
  is '????';
comment on column MM_PR_JOB.description
  is '??';
comment on column MM_PR_JOB.print_type
  is '????';
comment on column MM_PR_JOB.job_type
  is '????';
comment on column MM_PR_JOB.copies
  is '????';
comment on column MM_PR_JOB.classes
  is '????';
comment on column MM_PR_JOB.printer_name
  is '???';
comment on column MM_PR_JOB.update_sql
  is '??SQL';
comment on column MM_PR_JOB.creation_time
  is '????';
comment on column MM_PR_JOB.creation_user
  is '???';
comment on column MM_PR_JOB.last_modified_user
  is '?????';
comment on column MM_PR_JOB.last_modified_time
  is '??????';
comment on column MM_PR_JOB.last_modified_ip
  is 'IP';
comment on column MM_PR_JOB.id
  is 'ID';

prompt
prompt Creating table MM_PR_JOB_BUSINESS
prompt =================================
prompt
create table MM_PR_JOB_BUSINESS
(
  id                 NUMBER(19),
  business           VARCHAR2(80) not null,
  job_name           VARCHAR2(80) not null,
  description        VARCHAR2(255),
  print_interval     NUMBER(10),
  active             VARCHAR2(20),
  creation_time      DATE,
  creation_user      VARCHAR2(30),
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  last_modified_ip   VARCHAR2(80)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PR_JOB_BUSINESS
  is '???????';
comment on column MM_PR_JOB_BUSINESS.id
  is 'ID';
comment on column MM_PR_JOB_BUSINESS.business
  is '????';
comment on column MM_PR_JOB_BUSINESS.job_name
  is '?????';
comment on column MM_PR_JOB_BUSINESS.description
  is '??';
comment on column MM_PR_JOB_BUSINESS.print_interval
  is '????';
comment on column MM_PR_JOB_BUSINESS.active
  is '????';
comment on column MM_PR_JOB_BUSINESS.creation_time
  is '????';
comment on column MM_PR_JOB_BUSINESS.creation_user
  is '???';
comment on column MM_PR_JOB_BUSINESS.last_modified_user
  is '?????';
comment on column MM_PR_JOB_BUSINESS.last_modified_time
  is '??????';
comment on column MM_PR_JOB_BUSINESS.last_modified_ip
  is '????IP';

prompt
prompt Creating table MM_PR_JOB_QUEUE
prompt ==============================
prompt
create table MM_PR_JOB_QUEUE
(
  job_no             NUMBER(19) not null,
  business           VARCHAR2(80),
  job_name           VARCHAR2(80),
  print_type         VARCHAR2(80),
  job_type           VARCHAR2(80),
  classes            VARCHAR2(20),
  status             VARCHAR2(20),
  serial_number      VARCHAR2(80),
  atrow_key          NUMBER(19),
  parameters         VARCHAR2(1024),
  last_modified_time DATE,
  creation_time      DATE,
  last_modified_user VARCHAR2(30),
  last_modified_ip   VARCHAR2(80)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PR_JOB_QUEUE
  is '???????';
comment on column MM_PR_JOB_QUEUE.job_no
  is '??????';
comment on column MM_PR_JOB_QUEUE.business
  is '????';
comment on column MM_PR_JOB_QUEUE.job_name
  is '????';
comment on column MM_PR_JOB_QUEUE.print_type
  is '????';
comment on column MM_PR_JOB_QUEUE.job_type
  is '????';
comment on column MM_PR_JOB_QUEUE.classes
  is '????';
comment on column MM_PR_JOB_QUEUE.status
  is '????';
comment on column MM_PR_JOB_QUEUE.serial_number
  is '???';
comment on column MM_PR_JOB_QUEUE.atrow_key
  is '???';
comment on column MM_PR_JOB_QUEUE.parameters
  is '??';
comment on column MM_PR_JOB_QUEUE.last_modified_time
  is '??????';
comment on column MM_PR_JOB_QUEUE.creation_time
  is '????';
comment on column MM_PR_JOB_QUEUE.last_modified_user
  is '?????';
comment on column MM_PR_JOB_QUEUE.last_modified_ip
  is '????IP';

prompt
prompt Creating table MM_PR_JOB_QUEUE_BAK
prompt ==================================
prompt
create table MM_PR_JOB_QUEUE_BAK
(
  job_no             NUMBER(19),
  business           VARCHAR2(80),
  job_name           VARCHAR2(80),
  print_type         VARCHAR2(80),
  job_type           VARCHAR2(80),
  classes            VARCHAR2(20),
  status             VARCHAR2(20),
  serial_number      VARCHAR2(80),
  atrow_key          NUMBER(19),
  parameters         VARCHAR2(1024),
  last_modified_time DATE,
  creation_time      DATE,
  last_modified_user VARCHAR2(30),
  last_modified_ip   VARCHAR2(80),
  backup_time        DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PR_JOB_QUEUE_BAK
  is '?????????';
comment on column MM_PR_JOB_QUEUE_BAK.job_no
  is '??????';
comment on column MM_PR_JOB_QUEUE_BAK.business
  is '????';
comment on column MM_PR_JOB_QUEUE_BAK.job_name
  is '????';
comment on column MM_PR_JOB_QUEUE_BAK.print_type
  is '????';
comment on column MM_PR_JOB_QUEUE_BAK.job_type
  is '????';
comment on column MM_PR_JOB_QUEUE_BAK.classes
  is '????';
comment on column MM_PR_JOB_QUEUE_BAK.status
  is '??';
comment on column MM_PR_JOB_QUEUE_BAK.serial_number
  is '???';
comment on column MM_PR_JOB_QUEUE_BAK.atrow_key
  is '???';
comment on column MM_PR_JOB_QUEUE_BAK.parameters
  is '??';
comment on column MM_PR_JOB_QUEUE_BAK.last_modified_time
  is '??????';
comment on column MM_PR_JOB_QUEUE_BAK.creation_time
  is '????';
comment on column MM_PR_JOB_QUEUE_BAK.last_modified_user
  is '?????';
comment on column MM_PR_JOB_QUEUE_BAK.last_modified_ip
  is '????IP';
comment on column MM_PR_JOB_QUEUE_BAK.backup_time
  is '????';

prompt
prompt Creating table MM_PR_PRINTER
prompt ============================
prompt
create table MM_PR_PRINTER
(
  id                 NUMBER(19) not null,
  printer_name       VARCHAR2(80) not null,
  factory            VARCHAR2(20),
  description        VARCHAR2(255),
  location           VARCHAR2(255),
  ip                 VARCHAR2(80),
  port               VARCHAR2(80),
  vendor             VARCHAR2(200),
  driver             VARCHAR2(200),
  type               VARCHAR2(200),
  owner              VARCHAR2(80),
  printer_group      VARCHAR2(30),
  active             VARCHAR2(10),
  creation_time      DATE,
  creation_user      VARCHAR2(30),
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  last_modified_ip   VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PR_PRINTER
  is '??????';
comment on column MM_PR_PRINTER.id
  is '????';
comment on column MM_PR_PRINTER.printer_name
  is '???';
comment on column MM_PR_PRINTER.factory
  is '??';
comment on column MM_PR_PRINTER.description
  is '??';
comment on column MM_PR_PRINTER.location
  is '??';
comment on column MM_PR_PRINTER.ip
  is 'IP??';
comment on column MM_PR_PRINTER.port
  is '??';
comment on column MM_PR_PRINTER.vendor
  is '???';
comment on column MM_PR_PRINTER.driver
  is '??';
comment on column MM_PR_PRINTER.type
  is '?????';
comment on column MM_PR_PRINTER.owner
  is '????';
comment on column MM_PR_PRINTER.printer_group
  is '????';
comment on column MM_PR_PRINTER.active
  is '????';
comment on column MM_PR_PRINTER.creation_time
  is '????';
comment on column MM_PR_PRINTER.creation_user
  is '???';
comment on column MM_PR_PRINTER.last_modified_user
  is '?????';
comment on column MM_PR_PRINTER.last_modified_time
  is '??????';
comment on column MM_PR_PRINTER.last_modified_ip
  is '????IP';

prompt
prompt Creating table MM_PR_TIMER_LOG
prompt ==============================
prompt
create table MM_PR_TIMER_LOG
(
  id           NUMBER(19) not null,
  source       VARCHAR2(80),
  job_name     VARCHAR2(80),
  job_group    VARCHAR2(80),
  exception    VARCHAR2(2048),
  process_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PR_TIMER_LOG
  is '?????';
comment on column MM_PR_TIMER_LOG.id
  is '????';
comment on column MM_PR_TIMER_LOG.source
  is '?????';
comment on column MM_PR_TIMER_LOG.job_name
  is '?????';
comment on column MM_PR_TIMER_LOG.job_group
  is '??????';
comment on column MM_PR_TIMER_LOG.exception
  is '??';
comment on column MM_PR_TIMER_LOG.process_time
  is '??????';

prompt
prompt Creating table MM_PR_TRANSACTION_LOG
prompt ====================================
prompt
create table MM_PR_TRANSACTION_LOG
(
  id           NUMBER(19) not null,
  trx_level    VARCHAR2(80),
  category     VARCHAR2(80),
  source       VARCHAR2(80),
  trx_name     VARCHAR2(2048),
  entry_time   DATE,
  content      VARCHAR2(2048),
  printer_name VARCHAR2(80),
  trx_type     VARCHAR2(80)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PR_TRANSACTION_LOG
  is '???????';
comment on column MM_PR_TRANSACTION_LOG.id
  is '????';
comment on column MM_PR_TRANSACTION_LOG.trx_level
  is '???????????';
comment on column MM_PR_TRANSACTION_LOG.category
  is '??';
comment on column MM_PR_TRANSACTION_LOG.source
  is '?????';
comment on column MM_PR_TRANSACTION_LOG.trx_name
  is '????';
comment on column MM_PR_TRANSACTION_LOG.entry_time
  is '????';
comment on column MM_PR_TRANSACTION_LOG.content
  is '????';
comment on column MM_PR_TRANSACTION_LOG.printer_name
  is '???';
comment on column MM_PR_TRANSACTION_LOG.trx_type
  is '????';

prompt
prompt Creating table MM_PUB_ASSEMBLY_CONFIG
prompt =====================================
prompt
create table MM_PUB_ASSEMBLY_CONFIG
(
  assembly_name      VARCHAR2(64) not null,
  model_code         VARCHAR2(32) not null,
  location           VARCHAR2(32) not null,
  config_name        VARCHAR2(64) not null,
  area_code          VARCHAR2(80) not null,
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_ASSEMBLY_CONFIG
  is 'MM_PUB_ASSEMBLY_CONFIG???????
MM_PUB_ASSEMBLY_CONFIG???????
';
comment on column MM_PUB_ASSEMBLY_CONFIG.assembly_name
  is '?????
?????
';
comment on column MM_PUB_ASSEMBLY_CONFIG.model_code
  is '??
??
';
comment on column MM_PUB_ASSEMBLY_CONFIG.location
  is '??
??
';
comment on column MM_PUB_ASSEMBLY_CONFIG.config_name
  is '?????
?????
';
comment on column MM_PUB_ASSEMBLY_CONFIG.area_code
  is '??
??
?????10???20???';
comment on column MM_PUB_ASSEMBLY_CONFIG.creation_time
  is '????
????
';
comment on column MM_PUB_ASSEMBLY_CONFIG.last_modified_time
  is '??????
??????
';
alter table MM_PUB_ASSEMBLY_CONFIG
  add constraint PK_MM_PUB_ASSEMBLY_CONFIG primary key (ASSEMBLY_NAME, MODEL_CODE, LOCATION, AREA_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_BILL_PREFIX
prompt =================================
prompt
create table MM_PUB_BILL_PREFIX
(
  id                  NUMBER(19) not null,
  factory_code        VARCHAR2(10) not null,
  bill_group          VARCHAR2(20) not null,
  bill_group_type     VARCHAR2(30) not null,
  plan_code           VARCHAR2(20),
  bill_desc           VARCHAR2(100),
  factory_code_str    VARCHAR2(10),
  bill_group_type_str VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUB_BILL_PREFIX.bill_group
  is 'ORDER???
JIT_INS????????
SPS_INS?SPS?????
JISO_INS????????
JISI_INS????????';
comment on column MM_PUB_BILL_PREFIX.factory_code_str
  is '???A';
alter table MM_PUB_BILL_PREFIX
  add constraint PK_MM_PUB_BILL_PREFIX primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_BILL_PREFIX
  add constraint AK_MM_PUB_BILL_PREFIX1 unique (BILL_GROUP_TYPE, BILL_GROUP, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_BILL_SN
prompt =============================
prompt
create table MM_PUB_BILL_SN
(
  bill_prefix_id NUMBER(19) not null,
  bill_pre_str   VARCHAR2(7) not null,
  use_date       DATE not null,
  seq_pre_str    VARCHAR2(3),
  seq_no         NUMBER(3)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_PUB_BILL_SN
  add constraint PK_MM_PUB_BILL_SN primary key (USE_DATE, BILL_PRE_STR, BILL_PREFIX_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_DATA_DICT
prompt ===============================
prompt
create table MM_PUB_DATA_DICT
(
  id               NUMBER(19) not null,
  code_type        VARCHAR2(30),
  code_type_name   VARCHAR2(100),
  code_value       VARCHAR2(30),
  code_value_name  VARCHAR2(100),
  other_code_value VARCHAR2(30),
  remark           VARCHAR2(150),
  sort_no          NUMBER(5),
  is_edit          NUMBER(1),
  factory_code     VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_DATA_DICT
  is '?????';
comment on column MM_PUB_DATA_DICT.id
  is '????';
comment on column MM_PUB_DATA_DICT.code_type
  is '????';
comment on column MM_PUB_DATA_DICT.code_type_name
  is '????';
comment on column MM_PUB_DATA_DICT.code_value
  is '??';
comment on column MM_PUB_DATA_DICT.code_value_name
  is '????';
comment on column MM_PUB_DATA_DICT.other_code_value
  is '???????';
comment on column MM_PUB_DATA_DICT.remark
  is '??';
comment on column MM_PUB_DATA_DICT.sort_no
  is '??';
comment on column MM_PUB_DATA_DICT.is_edit
  is '????';
comment on column MM_PUB_DATA_DICT.factory_code
  is '??';
alter table MM_PUB_DATA_DICT
  add constraint PK_MM_PUB_DATA_DICT primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_PUB_DATA_DICT
  add constraint AK_MM_PUB_DATA_DICT unique (CODE_TYPE, CODE_VALUE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_DATA_PRIVI_BASIC
prompt ======================================
prompt
create table MM_PUB_DATA_PRIVI_BASIC
(
  access_id          NUMBER(19) not null,
  access_type        VARCHAR2(30),
  access_type_desc   VARCHAR2(80),
  access_value       VARCHAR2(30),
  access_value_desc  VARCHAR2(80),
  creation_time      DATE default SYSDATE,
  creation_user      VARCHAR2(30),
  last_modified_time DATE,
  last_modified_user VARCHAR2(30),
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_DATA_PRIVI_BASIC
  is '???????';
comment on column MM_PUB_DATA_PRIVI_BASIC.access_id
  is '??ID';
comment on column MM_PUB_DATA_PRIVI_BASIC.access_type
  is '????';
comment on column MM_PUB_DATA_PRIVI_BASIC.access_type_desc
  is '??????';
comment on column MM_PUB_DATA_PRIVI_BASIC.access_value
  is '???';
comment on column MM_PUB_DATA_PRIVI_BASIC.access_value_desc
  is '?????';
comment on column MM_PUB_DATA_PRIVI_BASIC.creation_time
  is '????';
comment on column MM_PUB_DATA_PRIVI_BASIC.creation_user
  is '???';
comment on column MM_PUB_DATA_PRIVI_BASIC.last_modified_time
  is '??????';
comment on column MM_PUB_DATA_PRIVI_BASIC.last_modified_user
  is '?????';
comment on column MM_PUB_DATA_PRIVI_BASIC.last_modified_ip
  is '????IP';

prompt
prompt Creating table MM_PUB_DATA_ROLE
prompt ===============================
prompt
create table MM_PUB_DATA_ROLE
(
  data_role_id       NUMBER(10) not null,
  role_user_type     VARCHAR2(10),
  data_role_name     VARCHAR2(60),
  department_id      VARCHAR2(10),
  status             NUMBER(1),
  pri_sort           NUMBER(4),
  remark             VARCHAR2(150),
  creation_time      DATE default SYSDATE,
  creation_user      VARCHAR2(30),
  last_modified_time DATE,
  last_modified_user VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_DATA_ROLE
  is '?????';
comment on column MM_PUB_DATA_ROLE.data_role_id
  is '????ID';
comment on column MM_PUB_DATA_ROLE.role_user_type
  is '??????';
comment on column MM_PUB_DATA_ROLE.data_role_name
  is '?????';
comment on column MM_PUB_DATA_ROLE.department_id
  is '??ID';
comment on column MM_PUB_DATA_ROLE.status
  is '??(0:??;1:??;)';
comment on column MM_PUB_DATA_ROLE.pri_sort
  is '????';
comment on column MM_PUB_DATA_ROLE.remark
  is '??';
comment on column MM_PUB_DATA_ROLE.creation_time
  is '????';
comment on column MM_PUB_DATA_ROLE.creation_user
  is '???';
comment on column MM_PUB_DATA_ROLE.last_modified_time
  is '??????';
comment on column MM_PUB_DATA_ROLE.last_modified_user
  is '?????';

prompt
prompt Creating table MM_PUB_DATA_ROLE_PRIVI
prompt =====================================
prompt
create table MM_PUB_DATA_ROLE_PRIVI
(
  data_role_id  NUMBER(10) not null,
  access_id     NUMBER(19) not null,
  creation_time DATE default SYSDATE,
  creation_user VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_DATA_ROLE_PRIVI
  is '???????';
comment on column MM_PUB_DATA_ROLE_PRIVI.data_role_id
  is '????ID';
comment on column MM_PUB_DATA_ROLE_PRIVI.access_id
  is '??ID';
comment on column MM_PUB_DATA_ROLE_PRIVI.creation_time
  is '????';
comment on column MM_PUB_DATA_ROLE_PRIVI.creation_user
  is '???';
alter table MM_PUB_DATA_ROLE_PRIVI
  add constraint PK_MM_PUB_DATA_ROLE_PRIVI primary key (DATA_ROLE_ID, ACCESS_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_DATA_ROLE_USER
prompt ====================================
prompt
create table MM_PUB_DATA_ROLE_USER
(
  user_name     VARCHAR2(20) not null,
  data_role_id  NUMBER(10) not null,
  creation_time DATE default SYSDATE,
  creation_user VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_DATA_ROLE_USER
  is '???????';
comment on column MM_PUB_DATA_ROLE_USER.user_name
  is '???';
comment on column MM_PUB_DATA_ROLE_USER.data_role_id
  is '????ID';
comment on column MM_PUB_DATA_ROLE_USER.creation_time
  is '????';
comment on column MM_PUB_DATA_ROLE_USER.creation_user
  is '???';
alter table MM_PUB_DATA_ROLE_USER
  add constraint PK_MM_PUB_DATA_ROLE_USER primary key (USER_NAME, DATA_ROLE_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_DELETE_IMP_TABLE
prompt ======================================
prompt
create table MM_PUB_DELETE_IMP_TABLE
(
  id               NUMBER(19) not null,
  table_name       VARCHAR2(50),
  is_delete        NUMBER,
  last_delete_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUB_DELETE_IMP_TABLE.id
  is 'ID';
comment on column MM_PUB_DELETE_IMP_TABLE.table_name
  is '??';
comment on column MM_PUB_DELETE_IMP_TABLE.is_delete
  is '?????';
comment on column MM_PUB_DELETE_IMP_TABLE.last_delete_time
  is '??????';

prompt
prompt Creating table MM_PUB_EXEC_TIME_LOG
prompt ===================================
prompt
create table MM_PUB_EXEC_TIME_LOG
(
  exec_code  VARCHAR2(50),
  exec_desc  VARCHAR2(200),
  start_time DATE,
  end_time   DATE,
  cost_time  NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_FACTORY
prompt =============================
prompt
create table MM_PUB_FACTORY
(
  factory_code VARCHAR2(20) not null,
  factory_name VARCHAR2(100)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 8K
    minextents 1
    maxextents unlimited
  );
alter table MM_PUB_FACTORY
  add constraint PK_MM_PUB_FACTORY primary key (FACTORY_CODE)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_FACTORY_USER
prompt ==================================
prompt
create table MM_PUB_FACTORY_USER
(
  user_id       VARCHAR2(64) not null,
  factory_code  VARCHAR2(32) not null,
  creation_time DATE default SYSDATE,
  creation_user VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 8K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUB_FACTORY_USER.creation_time
  is '创建时间';
comment on column MM_PUB_FACTORY_USER.creation_user
  is '创建人';

prompt
prompt Creating table MM_PUB_FEATURE_GROUP
prompt ===================================
prompt
create table MM_PUB_FEATURE_GROUP
(
  feature_group      VARCHAR2(64) not null,
  feature_group_desc VARCHAR2(256),
  default_value      VARCHAR2(64),
  feature_code1      VARCHAR2(32),
  feature_value1     VARCHAR2(32),
  feature_code2      VARCHAR2(32),
  feature_value2     VARCHAR2(32),
  feature_code3      VARCHAR2(32),
  feature_value3     VARCHAR2(32),
  feature_code4      VARCHAR2(32),
  feature_value4     VARCHAR2(32),
  display_value      VARCHAR2(64),
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_FEATURE_GROUP
  is 'MM_PUB_FEATURE_GROUP??????
MM_PUB_FEATURE_GROUP??????
';
comment on column MM_PUB_FEATURE_GROUP.feature_group
  is '?????
?????
';
comment on column MM_PUB_FEATURE_GROUP.feature_group_desc
  is '?????
?????
';
comment on column MM_PUB_FEATURE_GROUP.default_value
  is '???
???
';
comment on column MM_PUB_FEATURE_GROUP.feature_code1
  is '???1
???1
';
comment on column MM_PUB_FEATURE_GROUP.feature_value1
  is '???1
???1
';
comment on column MM_PUB_FEATURE_GROUP.feature_code2
  is '???2
???2
';
comment on column MM_PUB_FEATURE_GROUP.feature_value2
  is '???2
???2
';
comment on column MM_PUB_FEATURE_GROUP.feature_code3
  is '???3
???3
';
comment on column MM_PUB_FEATURE_GROUP.feature_value3
  is '???3
???3
';
comment on column MM_PUB_FEATURE_GROUP.feature_code4
  is '???4
???4
';
comment on column MM_PUB_FEATURE_GROUP.feature_value4
  is '???4
???4
';
comment on column MM_PUB_FEATURE_GROUP.display_value
  is '???
???
';
comment on column MM_PUB_FEATURE_GROUP.creation_time
  is '????
????
';
comment on column MM_PUB_FEATURE_GROUP.last_modified_time
  is '??????
??????
';

prompt
prompt Creating table MM_PUB_FILE_BUSI_RELA
prompt ====================================
prompt
create table MM_PUB_FILE_BUSI_RELA
(
  busi_id       NUMBER(19) not null,
  file_id       NUMBER(19) not null,
  creation_time DATE,
  creation_user VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_PUB_FILE_BUSI_RELA
  add constraint PK_MM_PUB_FILE_BUSI_RELA primary key (BUSI_ID, FILE_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_FILE_INFO
prompt ===============================
prompt
create table MM_PUB_FILE_INFO
(
  file_id            NUMBER(19) not null,
  file_name          VARCHAR2(150),
  file_type          VARCHAR2(100),
  file_format        VARCHAR2(20),
  server_id          NUMBER(19),
  real_path          VARCHAR2(200),
  file_size          NUMBER(10),
  creation_time      DATE,
  creation_user      VARCHAR2(30),
  last_modified_time DATE,
  last_modified_user VARCHAR2(30),
  ope_ip             VARCHAR2(50),
  description        VARCHAR2(300)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUB_FILE_INFO.file_id
  is '????';
comment on column MM_PUB_FILE_INFO.file_type
  is '???????????????????????????';
comment on column MM_PUB_FILE_INFO.file_format
  is 'word/excel/ppt/pdf?';
alter table MM_PUB_FILE_INFO
  add constraint PK_MM_PUB_FILE_INFO primary key (FILE_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_FILE_INFO
  add constraint AK_MM_PUB_FILE_INFO unique (FILE_NAME)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_FILE_SERVER_INFO
prompt ======================================
prompt
create table MM_PUB_FILE_SERVER_INFO
(
  id                 NUMBER(19) not null,
  server_ip          VARCHAR2(30),
  server_port        NUMBER(10),
  root_path          VARCHAR2(50),
  server_user        VARCHAR2(30),
  server_password    VARCHAR2(30),
  description        VARCHAR2(300),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_time DATE,
  last_modified_user VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_PUB_FILE_SERVER_INFO
  add constraint PK_MM_PUB_FILE_SERVER_INFO primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_FILE_SERVER_INFO
  add constraint AK_MM_PUB_FILE_SERVER unique (SERVER_IP)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_IMAGE
prompt ===========================
prompt
create table MM_PUB_IMAGE
(
  id                 NUMBER(19) not null,
  image_name         VARCHAR2(100),
  image_blob         LONG RAW,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_PUB_IMAGE
  add constraint AK_KEY_1_MM_PUB_I unique (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_IMAGE
  add constraint AK_MM_PUB_IMAGE unique (IMAGE_NAME)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_KEYPART_BIND
prompt ==================================
prompt
create table MM_PUB_KEYPART_BIND
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10) not null,
  order_no      VARCHAR2(50) not null,
  station_code  VARCHAR2(20) not null,
  part_bar_code VARCHAR2(150) not null,
  part_no       VARCHAR2(30),
  bind_num      VARCHAR2(10),
  vin           VARCHAR2(20),
  key_part_type VARCHAR2(10),
  creation_time DATE default sysdate,
  inv_flag      NUMBER(1) default 0,
  inv_time      DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_KEYPART_BIND
  is 'MM_PUB_KEYPART_BIND?????????
MM_PUB_KEYPART_BIND?????????
';
comment on column MM_PUB_KEYPART_BIND.id
  is 'ID
ID
';
comment on column MM_PUB_KEYPART_BIND.factory_code
  is '??
??
';
comment on column MM_PUB_KEYPART_BIND.order_no
  is '?????
?????
';
comment on column MM_PUB_KEYPART_BIND.station_code
  is '????
????
';
comment on column MM_PUB_KEYPART_BIND.part_bar_code
  is '???????
???????
?????????????????';
comment on column MM_PUB_KEYPART_BIND.part_no
  is '???
???
';
comment on column MM_PUB_KEYPART_BIND.bind_num
  is '????
????
???????????????????';
comment on column MM_PUB_KEYPART_BIND.vin
  is 'VIN?
VIN?
';
comment on column MM_PUB_KEYPART_BIND.key_part_type
  is '?????
?????
1-?????2-????';
comment on column MM_PUB_KEYPART_BIND.creation_time
  is '????
????
';
comment on column MM_PUB_KEYPART_BIND.inv_flag
  is '??????
??????
0 ???
1???';
comment on column MM_PUB_KEYPART_BIND.inv_time
  is '??????
??????
??????';
create index IDX_MM_PUB_KEYPART_BIND on MM_PUB_KEYPART_BIND (KEY_PART_TYPE, INV_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_KEYPART_BIND
  add constraint PK_MM_PUB_KEYPART_BIND primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_MODEL_BOM
prompt ===============================
prompt
create table MM_PUB_MODEL_BOM
(
  factory_code       VARCHAR2(10) not null,
  mto                VARCHAR2(20) not null,
  part_no            VARCHAR2(30) not null,
  model_code         VARCHAR2(20),
  station_code       VARCHAR2(30) not null,
  stage              NUMBER(10),
  version            VARCHAR2(10),
  purchase_type      VARCHAR2(10),
  feature            VARCHAR2(30),
  num                NUMBER(10),
  part_unit          VARCHAR2(20),
  supplier_no        VARCHAR2(20),
  next_placement     VARCHAR2(20),
  process            VARCHAR2(20),
  a                  VARCHAR2(20),
  b                  VARCHAR2(20),
  c                  VARCHAR2(20),
  eff_start          DATE,
  eff_end            DATE,
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_MODEL_BOM
  is 'MM_PUB_MODEL_BOM???????
MM_PUB_MODEL_BOM???????
';
comment on column MM_PUB_MODEL_BOM.factory_code
  is '??
??
';
comment on column MM_PUB_MODEL_BOM.mto
  is 'MTO
MTO
';
comment on column MM_PUB_MODEL_BOM.part_no
  is '????
????
';
comment on column MM_PUB_MODEL_BOM.model_code
  is '??
??
';
comment on column MM_PUB_MODEL_BOM.station_code
  is '?????
?????
';
comment on column MM_PUB_MODEL_BOM.stage
  is '??
??
';
comment on column MM_PUB_MODEL_BOM.version
  is '??
??
';
comment on column MM_PUB_MODEL_BOM.purchase_type
  is '????
????
';
comment on column MM_PUB_MODEL_BOM.feature
  is '??
??
';
comment on column MM_PUB_MODEL_BOM.num
  is '??
??
';
comment on column MM_PUB_MODEL_BOM.part_unit
  is '????
????
';
comment on column MM_PUB_MODEL_BOM.supplier_no
  is '???
???
';
comment on column MM_PUB_MODEL_BOM.next_placement
  is '????
????
?';
comment on column MM_PUB_MODEL_BOM.process
  is '????
????
';
comment on column MM_PUB_MODEL_BOM.a
  is '???????
???????
';
comment on column MM_PUB_MODEL_BOM.b
  is '???????
???????
';
comment on column MM_PUB_MODEL_BOM.c
  is '???????
???????
';
comment on column MM_PUB_MODEL_BOM.eff_start
  is '????
????
';
comment on column MM_PUB_MODEL_BOM.eff_end
  is '????
????
';
comment on column MM_PUB_MODEL_BOM.creation_time
  is '????
????
';
comment on column MM_PUB_MODEL_BOM.last_modified_time
  is '??????
??????
';
create index IDX_MM_PUB_MODEL_BOM1 on MM_PUB_MODEL_BOM (PART_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_MODEL_BOM
  add constraint PK_MM_PUB_MODEL_BOM primary key (MTO, PART_NO, STATION_CODE, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_MODEL_CODE
prompt ================================
prompt
create table MM_PUB_MODEL_CODE
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10),
  model_code    VARCHAR2(20),
  creation_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_MODEL_CODE
  is '?????';
alter table MM_PUB_MODEL_CODE
  add constraint PK_MM_PUB_MODEL_CODE primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_MODEL_CODE
  add constraint AK_PK_MM_PUB_MODEL_CO_MM_PUB_M unique (FACTORY_CODE, MODEL_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_MODEL_FLOW_NUM
prompt ====================================
prompt
create table MM_PUB_MODEL_FLOW_NUM
(
  station_code     VARCHAR2(20),
  paoff_afon_num   NUMBER,
  paoff_aft1on_num NUMBER,
  vin              VARCHAR2(20),
  max_pass_time    DATE,
  creation_time    DATE default SYSDATE,
  is_send_email    NUMBER(1) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUB_MODEL_FLOW_NUM.station_code
  is '信息点';
comment on column MM_PUB_MODEL_FLOW_NUM.paoff_afon_num
  is 'PAOFF_AFON流动数';
comment on column MM_PUB_MODEL_FLOW_NUM.paoff_aft1on_num
  is 'PAOFF_AFT1ON流动数';
comment on column MM_PUB_MODEL_FLOW_NUM.vin
  is 'VIN';
comment on column MM_PUB_MODEL_FLOW_NUM.max_pass_time
  is '最大过点时间';
comment on column MM_PUB_MODEL_FLOW_NUM.creation_time
  is '创建时间';
comment on column MM_PUB_MODEL_FLOW_NUM.is_send_email
  is '是否已发送邮件';

prompt
prompt Creating table MM_PUB_MSG_GROUP
prompt ===============================
prompt
create table MM_PUB_MSG_GROUP
(
  id           NUMBER not null,
  group_code   VARCHAR2(10),
  group_name   VARCHAR2(30),
  record       VARCHAR2(40),
  del_flag     VARCHAR2(2),
  entry_id     VARCHAR2(30),
  entyry_date  DATE,
  modify_id    VARCHAR2(30),
  modfify_date DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUB_MSG_GROUP.group_code
  is '????';
comment on column MM_PUB_MSG_GROUP.group_name
  is '????';
comment on column MM_PUB_MSG_GROUP.record
  is '??';
comment on column MM_PUB_MSG_GROUP.del_flag
  is '????';
alter table MM_PUB_MSG_GROUP
  add constraint PK_MM_PUB_MSG_GROUP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_MSG_GROUP_TIMER
prompt =====================================
prompt
create table MM_PUB_MSG_GROUP_TIMER
(
  timer_id   NUMBER(19) not null,
  group_code VARCHAR2(32) not null,
  entry_id   VARCHAR2(32),
  entry_date DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_PUB_MSG_GROUP_TIMER
  add constraint PK_MM_PUB_MSG_GROUP_TIMER primary key (TIMER_ID, GROUP_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_MSG_GROUP_USER
prompt ====================================
prompt
create table MM_PUB_MSG_GROUP_USER
(
  id          NUMBER not null,
  group_code  VARCHAR2(20),
  user_id     VARCHAR2(40),
  user_cname  VARCHAR2(64),
  email       VARCHAR2(80),
  mobile      VARCHAR2(32),
  timer_code  VARCHAR2(20),
  del_flag    VARCHAR2(2),
  entry_id    VARCHAR2(40),
  entry_date  DATE,
  modify_id   VARCHAR2(40),
  modify_date DATE,
  sort_id     NUMBER
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUB_MSG_GROUP_USER.group_code
  is '分组代码';
comment on column MM_PUB_MSG_GROUP_USER.user_id
  is '用户';
comment on column MM_PUB_MSG_GROUP_USER.timer_code
  is '定时器代码';
comment on column MM_PUB_MSG_GROUP_USER.del_flag
  is '删除标识';
alter table MM_PUB_MSG_GROUP_USER
  add constraint PK_MM_PUB_MSG_GROUP_USER primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_MSG_QUEUE
prompt ===============================
prompt
create table MM_PUB_MSG_QUEUE
(
  pk_id          NUMBER(20) not null,
  email_type     VARCHAR2(16) default 'DEFAULT',
  send_flg       NUMBER(1) default 0,
  send_deal_time DATE,
  send_param     VARCHAR2(128),
  class_name     VARCHAR2(64),
  method_name    VARCHAR2(32),
  send_to        VARCHAR2(80),
  send_group     VARCHAR2(128),
  subject        VARCHAR2(64),
  send_msg       VARCHAR2(512),
  model_name     VARCHAR2(32),
  create_time    DATE default SYSDATE,
  create_user    VARCHAR2(32)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUB_MSG_QUEUE.send_flg
  is '?????(0:???;1:???;2:??;)';
comment on column MM_PUB_MSG_QUEUE.send_group
  is '?????(?????,?????)';
alter table MM_PUB_MSG_QUEUE
  add constraint PK_MM_PUB_MSG_QUEUE primary key (PK_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_MSG_TIMER
prompt ===============================
prompt
create table MM_PUB_MSG_TIMER
(
  id            NUMBER not null,
  timer_code    VARCHAR2(100),
  timer_name    VARCHAR2(100),
  timer_param   VARCHAR2(40),
  run_code      VARCHAR2(200),
  start_time    DATE,
  last_run_time DATE,
  next_run_time DATE,
  run_state     VARCHAR2(2),
  update_state  VARCHAR2(2),
  del_flag      VARCHAR2(2),
  entry_id      VARCHAR2(30),
  entry_date    DATE,
  modify_id     VARCHAR2(30),
  modify_date   DATE,
  timer_group   VARCHAR2(30),
  timer_desc    VARCHAR2(256),
  app_type      VARCHAR2(32)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 8K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUB_MSG_TIMER.timer_code
  is '?????';
comment on column MM_PUB_MSG_TIMER.timer_name
  is '?????';
comment on column MM_PUB_MSG_TIMER.timer_param
  is '?????';
comment on column MM_PUB_MSG_TIMER.run_code
  is '?????class??';
comment on column MM_PUB_MSG_TIMER.start_time
  is '????';
comment on column MM_PUB_MSG_TIMER.last_run_time
  is '??????';
comment on column MM_PUB_MSG_TIMER.next_run_time
  is '??????';
comment on column MM_PUB_MSG_TIMER.run_state
  is '????';
comment on column MM_PUB_MSG_TIMER.update_state
  is '????';
comment on column MM_PUB_MSG_TIMER.del_flag
  is '????';
comment on column MM_PUB_MSG_TIMER.timer_group
  is '?????';
comment on column MM_PUB_MSG_TIMER.timer_desc
  is '?????';
comment on column MM_PUB_MSG_TIMER.app_type
  is '????';
alter table MM_PUB_MSG_TIMER
  add constraint PK_MM_PUB_MSG_TIMER primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_OPE_LOG
prompt =============================
prompt
create table MM_PUB_OPE_LOG
(
  id         NUMBER(19) not null,
  form_name  VARCHAR2(250),
  table_name VARCHAR2(60),
  trx_type   VARCHAR2(10),
  id_column  VARCHAR2(100),
  record_key VARCHAR2(100),
  old_value  VARCHAR2(4000),
  trx_time   DATE,
  user_id    VARCHAR2(30),
  local_ip   VARCHAR2(30),
  table_type VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_OPE_LOG
  is '?????';
comment on column MM_PUB_OPE_LOG.trx_type
  is 'U-??
D-??';
comment on column MM_PUB_OPE_LOG.table_type
  is '???';
create index IDX_MM_PUB_OPE_LOG1 on MM_PUB_OPE_LOG (TRX_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_PUB_OPE_LOG
  add constraint PK_MM_PUB_OPE_LOG primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_ORDER_BOM
prompt ===============================
prompt
create table MM_PUB_ORDER_BOM
(
  factory_code       VARCHAR2(10) not null,
  order_no           VARCHAR2(50) not null,
  model_code         VARCHAR2(10),
  part_rowno         NUMBER(10) not null,
  vehicle_part_no    VARCHAR2(30),
  part_no            VARCHAR2(30),
  workcenter         VARCHAR2(20),
  station_code       VARCHAR2(30),
  num                NUMBER(18,3),
  usage_amount_unit  VARCHAR2(20),
  purchase_type      VARCHAR2(10),
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_ORDER_BOM
  is 'MM_PUB_ORDER_BOM??BOM
MM_PUB_ORDER_BOM??BOM
';
comment on column MM_PUB_ORDER_BOM.factory_code
  is '??
??
';
comment on column MM_PUB_ORDER_BOM.order_no
  is '?????
?????
?????';
comment on column MM_PUB_ORDER_BOM.model_code
  is '?? ';
comment on column MM_PUB_ORDER_BOM.part_rowno
  is '??????
??????
?????';
comment on column MM_PUB_ORDER_BOM.vehicle_part_no
  is '?????(?MTOC)
?????(?MTOC)
????';
comment on column MM_PUB_ORDER_BOM.part_no
  is '????
????
???';
comment on column MM_PUB_ORDER_BOM.workcenter
  is '??
??
???????????????????';
comment on column MM_PUB_ORDER_BOM.station_code
  is '?????
?????
???';
comment on column MM_PUB_ORDER_BOM.num
  is '??
??
?????????????';
comment on column MM_PUB_ORDER_BOM.usage_amount_unit
  is '????
????
????';
comment on column MM_PUB_ORDER_BOM.purchase_type
  is '????
????
';
comment on column MM_PUB_ORDER_BOM.creation_time
  is '????
????
';
comment on column MM_PUB_ORDER_BOM.last_modified_time
  is '??????
??????
';
create index IDX_MM_PUB_ORDER_BOM1 on MM_PUB_ORDER_BOM (ORDER_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_ORDER_BOM
  add constraint PK_MM_PUB_ORDER_BOM primary key (ORDER_NO, PART_ROWNO, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_ORDER_FEATURE
prompt ===================================
prompt
create table MM_PUB_ORDER_FEATURE
(
  factory_code       VARCHAR2(10) not null,
  order_no           VARCHAR2(50) not null,
  feature_code       VARCHAR2(20) not null,
  feature_code_desc  VARCHAR2(100),
  feature_value      VARCHAR2(20) not null,
  feature_value_desc VARCHAR2(100),
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_ORDER_FEATURE
  is 'MM_PUB_ORDER_FEATURE????
MM_PUB_ORDER_FEATURE????
';
comment on column MM_PUB_ORDER_FEATURE.factory_code
  is '??
??
';
comment on column MM_PUB_ORDER_FEATURE.order_no
  is '?????
?????
';
comment on column MM_PUB_ORDER_FEATURE.feature_code
  is '???????
???????
';
comment on column MM_PUB_ORDER_FEATURE.feature_code_desc
  is '?????
?????
';
comment on column MM_PUB_ORDER_FEATURE.feature_value
  is '???
???
';
comment on column MM_PUB_ORDER_FEATURE.feature_value_desc
  is '?????
?????
';
comment on column MM_PUB_ORDER_FEATURE.creation_time
  is '????
????
';
comment on column MM_PUB_ORDER_FEATURE.last_modified_time
  is '??????
??????
';
alter table MM_PUB_ORDER_FEATURE
  add constraint PK_MM_PUB_ORDER_FEATURE primary key (ORDER_NO, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_PART
prompt ==========================
prompt
create table MM_PUB_PART
(
  part_no            VARCHAR2(64) not null,
  part_short_no      VARCHAR2(10),
  part_name_cn       VARCHAR2(150),
  part_name_en       VARCHAR2(150),
  part_spec          VARCHAR2(200),
  purchase_type      VARCHAR2(10),
  part_unit          VARCHAR2(20),
  creation_time      DATE default sysdate,
  last_modified_time DATE,
  factory_code       VARCHAR2(10) not null,
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_PART
  is 'MM_PUB_PART物料主数据表
';
comment on column MM_PUB_PART.part_no
  is '零件编号
零件编号
';
comment on column MM_PUB_PART.part_short_no
  is '零件简号
零件简号
待确认维护系统';
comment on column MM_PUB_PART.part_name_cn
  is '零件中文名称
零件中文名称
';
comment on column MM_PUB_PART.part_name_en
  is '零件英文名称
零件英文名称
';
comment on column MM_PUB_PART.part_spec
  is '规格型号
规格型号
主要为资材规格信息';
comment on column MM_PUB_PART.purchase_type
  is '采购类型
采购类型
W；Z；AW';
comment on column MM_PUB_PART.part_unit
  is '用量单位
用量单位
';
comment on column MM_PUB_PART.creation_time
  is '创建时间
创建时间
';
comment on column MM_PUB_PART.last_modified_time
  is '最后修改时间
最后修改时间
';
comment on column MM_PUB_PART.factory_code
  is '工厂
工厂
';
comment on column MM_PUB_PART.deal_flag
  is '处理标识
处理标识
0 未处理 1已处理';
comment on column MM_PUB_PART.deal_time
  is '处理时间
处理时间
';
alter table MM_PUB_PART
  add constraint PK_MM_PUB_PART primary key (PART_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_PART_DTP
prompt ==============================
prompt
create table MM_PUB_PART_DTP
(
  part_no            VARCHAR2(64) not null,
  part_short_no      VARCHAR2(10),
  part_name_cn       VARCHAR2(150),
  part_name_en       VARCHAR2(150),
  part_spec          VARCHAR2(200),
  purchase_type      VARCHAR2(10),
  part_unit          VARCHAR2(20),
  creation_time      DATE default sysdate,
  last_modified_time DATE,
  factory_code       VARCHAR2(10) not null,
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_PART_IMP
prompt ==============================
prompt
create table MM_PUB_PART_IMP
(
  factory_code            VARCHAR2(10),
  supplier_no             VARCHAR2(20),
  supplier_name           VARCHAR2(100),
  sup_factory             VARCHAR2(20),
  mp_unload_port          VARCHAR2(10),
  unload_port             VARCHAR2(10),
  part_no                 VARCHAR2(30),
  part_short_no           VARCHAR2(10),
  part_name               VARCHAR2(254),
  part_unit               VARCHAR2(20),
  standard_package        NUMBER(12,4),
  order_package           NUMBER(12,4),
  supply_rate             NUMBER(12,4),
  safe_num                NUMBER(10),
  logistics_flag          VARCHAR2(8),
  eff_start               DATE,
  eff_end                 DATE,
  first_sort_id           NUMBER(10),
  workcenter              VARCHAR2(10),
  arr_depot               VARCHAR2(20),
  plan_code               VARCHAR2(20),
  ship_depot              VARCHAR2(20),
  prepare_num             NUMBER(10),
  dispatch_num            NUMBER(10),
  delivery_num            NUMBER(10),
  arrive_num              NUMBER(10),
  distribution_num        NUMBER(10),
  distri_package          NUMBER(10),
  part_mark               VARCHAR2(20),
  ship_depot_type         VARCHAR2(10),
  arr_depot_type          VARCHAR2(10),
  order_product_num       NUMBER(10),
  ahead_product_num       NUMBER(10),
  s_prepare_product_seqno NUMBER(19),
  e_prepare_product_seqno NUMBER(19),
  ins_product_num         NUMBER(10),
  order_ins_num           NUMBER(10),
  gen_ins_way             NUMBER(1),
  order_flg               NUMBER(1),
  partgroup_no            VARCHAR2(20),
  partgroup_name          VARCHAR2(150),
  route_code              VARCHAR2(20),
  route_desc              VARCHAR2(20),
  creation_time           DATE default sysdate,
  imp_uuid                VARCHAR2(50),
  check_result            NUMBER(1),
  check_info              VARCHAR2(2000),
  import_status           NUMBER(1),
  ope_type                VARCHAR2(8),
  pk_id                   NUMBER(19),
  logistics_model         VARCHAR2(10),
  id                      NUMBER(19),
  model_code              VARCHAR2(20),
  creation_user           VARCHAR2(30),
  loc_depth               NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUB_PART_IMP.supplier_no
  is '?????';
comment on column MM_PUB_PART_IMP.sup_factory
  is '???';
comment on column MM_PUB_PART_IMP.mp_unload_port
  is '????';
comment on column MM_PUB_PART_IMP.unload_port
  is '???';
comment on column MM_PUB_PART_IMP.part_no
  is '????';
comment on column MM_PUB_PART_IMP.part_unit
  is '????';
comment on column MM_PUB_PART_IMP.standard_package
  is '?????';
comment on column MM_PUB_PART_IMP.order_package
  is '?????';
comment on column MM_PUB_PART_IMP.supply_rate
  is '????';
comment on column MM_PUB_PART_IMP.safe_num
  is '????';
comment on column MM_PUB_PART_IMP.logistics_flag
  is '????';
comment on column MM_PUB_PART_IMP.eff_start
  is '????';
comment on column MM_PUB_PART_IMP.eff_end
  is '????';
comment on column MM_PUB_PART_IMP.first_sort_id
  is '??????SORTID';
comment on column MM_PUB_PART_IMP.workcenter
  is '????';
comment on column MM_PUB_PART_IMP.arr_depot
  is '???? ';
comment on column MM_PUB_PART_IMP.plan_code
  is '???';
comment on column MM_PUB_PART_IMP.ship_depot
  is '????';
comment on column MM_PUB_PART_IMP.prepare_num
  is '???????';
comment on column MM_PUB_PART_IMP.dispatch_num
  is '???????';
comment on column MM_PUB_PART_IMP.delivery_num
  is '???????';
comment on column MM_PUB_PART_IMP.arrive_num
  is '???????';
comment on column MM_PUB_PART_IMP.distribution_num
  is '???????';
comment on column MM_PUB_PART_IMP.distri_package
  is '?????';
comment on column MM_PUB_PART_IMP.part_mark
  is '??';
comment on column MM_PUB_PART_IMP.ship_depot_type
  is '??????';
comment on column MM_PUB_PART_IMP.arr_depot_type
  is '??????';
comment on column MM_PUB_PART_IMP.order_product_num
  is '?????';
comment on column MM_PUB_PART_IMP.ahead_product_num
  is '???????';
comment on column MM_PUB_PART_IMP.s_prepare_product_seqno
  is '???????????';
comment on column MM_PUB_PART_IMP.e_prepare_product_seqno
  is '???????????';
comment on column MM_PUB_PART_IMP.ins_product_num
  is '?????';
comment on column MM_PUB_PART_IMP.order_ins_num
  is '??????';
comment on column MM_PUB_PART_IMP.gen_ins_way
  is '0?????????
1????????
';
comment on column MM_PUB_PART_IMP.order_flg
  is '???????TRUE_FALSE"
';
comment on column MM_PUB_PART_IMP.partgroup_no
  is '?????';
comment on column MM_PUB_PART_IMP.partgroup_name
  is '?????';
comment on column MM_PUB_PART_IMP.route_code
  is '????';
comment on column MM_PUB_PART_IMP.route_desc
  is '????';
comment on column MM_PUB_PART_IMP.creation_time
  is '????';
comment on column MM_PUB_PART_IMP.imp_uuid
  is 'IMP_UUID';
comment on column MM_PUB_PART_IMP.check_result
  is '???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_PUB_PART_IMP.import_status
  is '0-???
1-???';
comment on column MM_PUB_PART_IMP.ope_type
  is 'I ??
U??';
comment on column MM_PUB_PART_IMP.logistics_model
  is '????, ??, ??';
comment on column MM_PUB_PART_IMP.id
  is 'ID';
comment on column MM_PUB_PART_IMP.model_code
  is '??';
comment on column MM_PUB_PART_IMP.loc_depth
  is '????';

prompt
prompt Creating table MM_PUB_PART_SUPPLIER
prompt ===================================
prompt
create table MM_PUB_PART_SUPPLIER
(
  factory_code         VARCHAR2(10) not null,
  supplier_no          VARCHAR2(10) not null,
  sup_factory          VARCHAR2(10) not null,
  part_no              VARCHAR2(30) not null,
  min_order_num        NUMBER(10),
  standard_package     NUMBER(10),
  in_plan_forward_time NUMBER(10),
  eff_start            DATE,
  eff_end              DATE,
  creation_time        DATE default sysdate,
  last_modified_time   DATE,
  deal_flag            NUMBER(1) default 0,
  deal_time            DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_PART_SUPPLIER
  is 'MM_PUB_PART_SUPPLIER物料与供应商关系表
MM_PUB_PART_SUPPLIER物料与供应商关系表
';
comment on column MM_PUB_PART_SUPPLIER.factory_code
  is '工厂
工厂
';
comment on column MM_PUB_PART_SUPPLIER.supplier_no
  is '供应商编号
供应商编号
';
comment on column MM_PUB_PART_SUPPLIER.sup_factory
  is '供应商出货地
供应商出货地
';
comment on column MM_PUB_PART_SUPPLIER.part_no
  is '零件编号
零件编号
';
comment on column MM_PUB_PART_SUPPLIER.min_order_num
  is '最小采购量
最小采购量
';
comment on column MM_PUB_PART_SUPPLIER.standard_package
  is '规格包装数
规格包装数
';
comment on column MM_PUB_PART_SUPPLIER.in_plan_forward_time
  is '厂内提前期
厂内提前期
单位(天)';
comment on column MM_PUB_PART_SUPPLIER.eff_start
  is '生效日期
生效日期
格式：yyyy-MM-dd HH:mm:ss';
comment on column MM_PUB_PART_SUPPLIER.eff_end
  is '失效日期
失效日期
格式：yyyy-MM-dd HH:mm:ss';
comment on column MM_PUB_PART_SUPPLIER.creation_time
  is '创建时间
创建时间
';
comment on column MM_PUB_PART_SUPPLIER.last_modified_time
  is '最后修改时间
最后修改时间
';
comment on column MM_PUB_PART_SUPPLIER.deal_flag
  is '处理标识
处理标识
0 未处理 1已处理';
comment on column MM_PUB_PART_SUPPLIER.deal_time
  is '处理时间
处理时间
';
alter table MM_PUB_PART_SUPPLIER
  add constraint PK_MM_PUB_PART_SUPPLIER primary key (PART_NO, SUPPLIER_NO, SUP_FACTORY, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_PART_SUPPLIER_HIS
prompt =======================================
prompt
create table MM_PUB_PART_SUPPLIER_HIS
(
  factory_code         VARCHAR2(10) not null,
  supplier_no          VARCHAR2(10) not null,
  sup_factory          VARCHAR2(10),
  part_no              VARCHAR2(30) not null,
  min_order_num        NUMBER(10),
  standard_package     NUMBER(10),
  in_plan_forward_time NUMBER(10),
  eff_start            DATE,
  eff_end              DATE,
  creation_time        DATE default sysdate,
  last_modified_time   DATE,
  deal_flag            NUMBER(1) default 0,
  deal_time            DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_PART_SUPPLIER_HIS
  is 'MM_PUB_PART_SUPPLIER?????????';
comment on column MM_PUB_PART_SUPPLIER_HIS.factory_code
  is '??
??
';
comment on column MM_PUB_PART_SUPPLIER_HIS.supplier_no
  is '?????
?????
';
comment on column MM_PUB_PART_SUPPLIER_HIS.sup_factory
  is '??????
??????
';
comment on column MM_PUB_PART_SUPPLIER_HIS.part_no
  is '????
????
';
comment on column MM_PUB_PART_SUPPLIER_HIS.min_order_num
  is '?????
?????
';
comment on column MM_PUB_PART_SUPPLIER_HIS.standard_package
  is '?????
?????
';
comment on column MM_PUB_PART_SUPPLIER_HIS.in_plan_forward_time
  is '?????
?????
??(?)';
comment on column MM_PUB_PART_SUPPLIER_HIS.eff_start
  is '????
????
???yyyy-MM-dd HH:mm:ss';
comment on column MM_PUB_PART_SUPPLIER_HIS.eff_end
  is '????
????
???yyyy-MM-dd HH:mm:ss';
comment on column MM_PUB_PART_SUPPLIER_HIS.creation_time
  is '????
????
';
comment on column MM_PUB_PART_SUPPLIER_HIS.last_modified_time
  is '??????
??????
';
comment on column MM_PUB_PART_SUPPLIER_HIS.deal_flag
  is '????
????
0 ??? 1???';
comment on column MM_PUB_PART_SUPPLIER_HIS.deal_time
  is '????
????
';
alter table MM_PUB_PART_SUPPLIER_HIS
  add constraint AK_PK_MM_PUB_PART_SUP unique (FACTORY_CODE, SUPPLIER_NO, PART_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_PART_UDA
prompt ==============================
prompt
create table MM_PUB_PART_UDA
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  part_no            VARCHAR2(30) not null,
  supplier_no        VARCHAR2(10),
  sup_factory        VARCHAR2(10),
  part_short_no      VARCHAR2(10),
  part_name_cn       VARCHAR2(100),
  supplier_name      VARCHAR2(100),
  standard_package   NUMBER(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  logistics_model    VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_PUB_PART_UDA
  add constraint PK_MM_PUB_PART_UDA primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_PUB_PART_UDA
  add constraint AK_MM_PUB_PART_UDA unique (PART_NO, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_PART_UNLOAD
prompt =================================
prompt
create table MM_PUB_PART_UNLOAD
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  workcenter         VARCHAR2(20) not null,
  part_no            VARCHAR2(64) not null,
  logistics_model    VARCHAR2(10),
  unload_port        VARCHAR2(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUB_PART_UNLOAD.logistics_model
  is '????, ??, ??';
comment on column MM_PUB_PART_UNLOAD.unload_port
  is '???';
alter table MM_PUB_PART_UNLOAD
  add constraint PK_MM_PUB_PART_UNLOAD primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_PART_UNLOAD
  add constraint AK_MM_PUB_PART_UNLOAD unique (PART_NO, LOGISTICS_MODEL, FACTORY_CODE, WORKCENTER)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_PLAN_CODE
prompt ===============================
prompt
create table MM_PUB_PLAN_CODE
(
  plan_code          VARCHAR2(20) not null,
  plan_code_desc     VARCHAR2(50) not null,
  factory_code       VARCHAR2(10),
  production_line    VARCHAR2(20),
  workcenter         VARCHAR2(20),
  station_code       VARCHAR2(20),
  plan_code_type     VARCHAR2(10),
  is_auto_exec       NUMBER(1) default 0,
  exec_state         NUMBER(1) default 0,
  last_exec_time     DATE,
  kb_id              NUMBER(19),
  is_enable          NUMBER(1),
  is_show            NUMBER(1),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUB_PLAN_CODE.plan_code
  is '???????+?????+????
??1_JISO_PAOFF';
comment on column MM_PUB_PLAN_CODE.plan_code_type
  is 'SPS?SPS
JISI?????
JISO?????
JISOP?????????
JITI?????
JITO?????
JITD?????';
comment on column MM_PUB_PLAN_CODE.is_auto_exec
  is '0??
1??';
comment on column MM_PUB_PLAN_CODE.exec_state
  is '0????
1????';
comment on column MM_PUB_PLAN_CODE.is_enable
  is '???????TRUE_FALSE?';
comment on column MM_PUB_PLAN_CODE.is_show
  is '???????TRUE_FALSE?';
alter table MM_PUB_PLAN_CODE
  add constraint PK_MM_PUB_PLAN_CODE primary key (PLAN_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_PLAN_CODE_SCRAP
prompt =====================================
prompt
create table MM_PUB_PLAN_CODE_SCRAP
(
  scrap_workcenter VARCHAR2(20),
  plan_code        VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_PRODUCTION_LINE
prompt =====================================
prompt
create table MM_PUB_PRODUCTION_LINE
(
  factory_code         VARCHAR2(10) not null,
  production_line      VARCHAR2(20) not null,
  production_line_desc VARCHAR2(100)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table MM_PUB_PRODUCTION_LINE
  add constraint PK_MM_PUB_PRODUCTION_LINE primary key (FACTORY_CODE, PRODUCTION_LINE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_PRO_ERROR
prompt ===============================
prompt
create table MM_PUB_PRO_ERROR
(
  id             NUMBER(19) not null,
  alert_type     VARCHAR2(50),
  error_name     NUMBER(19),
  error_desc     VARCHAR2(500),
  creation_date  DATE,
  key_name       VARCHAR2(100),
  send_mail_flag NUMBER(1) default 0,
  error_level    VARCHAR2(10),
  deal_flag      NUMBER(1) default 0,
  deal_time      DATE,
  deal_user      VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_PUB_PRO_ERROR1 on MM_PUB_PRO_ERROR (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_PRO_ERROR
  add constraint PK_MM_PUB_PRO_ERROR primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_PRO_PLAN
prompt ==============================
prompt
create table MM_PUB_PRO_PLAN
(
  factory_code       VARCHAR2(10) not null,
  order_no           VARCHAR2(50) not null,
  order_type         VARCHAR2(10),
  weon_time          DATE,
  afoff_time         DATE,
  sort_id            NUMBER(19),
  mtoc               VARCHAR2(64),
  model_code         VARCHAR2(10),
  phase              VARCHAR2(10),
  creation_time      DATE default sysdate,
  last_modified_time DATE,
  cal_status         NUMBER(1) default 0,
  cal_time           DATE,
  use_flag           NUMBER(1) default 0,
  dms_order_no       VARCHAR2(50),
  dms_order_row_no   NUMBER(10),
  mes_order_no       VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_PRO_PLAN
  is 'MM_PUB_PRO_PLAN??W+3??????
MM_PUB_PRO_PLAN??W+3??????
';
comment on column MM_PUB_PRO_PLAN.factory_code
  is '"工厂
工厂
"';
comment on column MM_PUB_PRO_PLAN.order_no
  is '"订单号
订单号
"';
comment on column MM_PUB_PRO_PLAN.order_type
  is '"订单类型
订单类型
"';
comment on column MM_PUB_PRO_PLAN.weon_time
  is '"焊装上线时间
焊装上线时间
"';
comment on column MM_PUB_PRO_PLAN.afoff_time
  is '"总装下线时间
总装下线时间
"';
comment on column MM_PUB_PRO_PLAN.sort_id
  is '"排序码
排序码
"';
comment on column MM_PUB_PRO_PLAN.mtoc
  is '"MTOC
MTOC
"';
comment on column MM_PUB_PRO_PLAN.model_code
  is '"车型
车型
A16、A28"';
comment on column MM_PUB_PRO_PLAN.phase
  is '"生产阶段
生产阶段
"';
comment on column MM_PUB_PRO_PLAN.creation_time
  is '"创建时间
创建时间
"';
comment on column MM_PUB_PRO_PLAN.last_modified_time
  is '"最后修改时间
最后修改时间
"';
comment on column MM_PUB_PRO_PLAN.cal_status
  is '"计算状态
计算状态
计算状态 默认值0未计算 1已计算 主要用于抓取新车型计划"';
comment on column MM_PUB_PRO_PLAN.cal_time
  is '"计算时间
计算时间
计算时间"';
comment on column MM_PUB_PRO_PLAN.use_flag
  is '"使用状态
使用状态
使用状态 默认值0 未使用 1已使用"';
comment on column MM_PUB_PRO_PLAN.dms_order_no
  is 'DMS订单号';
comment on column MM_PUB_PRO_PLAN.dms_order_row_no
  is 'DMS订单行号';
comment on column MM_PUB_PRO_PLAN.mes_order_no
  is 'MES订单号 ';
create index IDX_MM_PUB_PRO_PLAN1 on MM_PUB_PRO_PLAN (AFOFF_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_PRO_PLAN
  add constraint PK_MM_PUB_PRO_PLAN primary key (FACTORY_CODE, ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_PRO_ROUTE
prompt ===============================
prompt
create table MM_PUB_PRO_ROUTE
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  route_code         VARCHAR2(20) not null,
  route_name         VARCHAR2(100),
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_PRO_ROUTE
  is 'MM_PUB_PRO_ROUTE???????
MM_PUB_PRO_ROUTE???????
';
comment on column MM_PUB_PRO_ROUTE.id
  is 'ID
ID
';
comment on column MM_PUB_PRO_ROUTE.factory_code
  is '??
??
';
comment on column MM_PUB_PRO_ROUTE.route_code
  is '??????
??????
';
comment on column MM_PUB_PRO_ROUTE.route_name
  is '??????
??????
';
comment on column MM_PUB_PRO_ROUTE.creation_time
  is '????
????
';
comment on column MM_PUB_PRO_ROUTE.last_modified_time
  is '??????
??????
';
alter table MM_PUB_PRO_ROUTE
  add constraint PK_MM_PUB_PRO_ROUTE primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_PRO_ROUTE
  add constraint AK_MM_PUB_PRO_ROUTE unique (FACTORY_CODE, ROUTE_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_PRO_ROUTE_DETAIL
prompt ======================================
prompt
create table MM_PUB_PRO_ROUTE_DETAIL
(
  route_id         NUMBER(19),
  work_center      VARCHAR2(20),
  station_code     VARCHAR2(20),
  station_name     VARCHAR2(100),
  station_order_by VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_PRO_ROUTE_DETAIL
  is 'MM_PUB_PRO_ROUTE_DETAIL?????????
MM_PUB_PRO_ROUTE_DETAIL?????????
';
comment on column MM_PUB_PRO_ROUTE_DETAIL.route_id
  is '????ID
????ID
';
comment on column MM_PUB_PRO_ROUTE_DETAIL.work_center
  is '????
????
';
comment on column MM_PUB_PRO_ROUTE_DETAIL.station_code
  is '????
????
';
comment on column MM_PUB_PRO_ROUTE_DETAIL.station_name
  is '????
????
';
comment on column MM_PUB_PRO_ROUTE_DETAIL.station_order_by
  is '??????
??????
I-???U-???D-???';

prompt
prompt Creating table MM_PUB_SPS_CONFIG
prompt ================================
prompt
create table MM_PUB_SPS_CONFIG
(
  config_name        VARCHAR2(64) not null,
  config_desc        VARCHAR2(256),
  feature_group      VARCHAR2(64) not null,
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_SPS_CONFIG
  is 'MM_PUB_SPS_CONFIG?????
MM_PUB_SPS_CONFIG?????
';
comment on column MM_PUB_SPS_CONFIG.config_name
  is '?????
?????
';
comment on column MM_PUB_SPS_CONFIG.config_desc
  is '?????
?????
';
comment on column MM_PUB_SPS_CONFIG.feature_group
  is '?????
?????
';
comment on column MM_PUB_SPS_CONFIG.creation_time
  is '????
????
';
comment on column MM_PUB_SPS_CONFIG.last_modified_time
  is '??????
??????
';
alter table MM_PUB_SPS_CONFIG
  add constraint PK_MM_PUB_SPS_CONFIG primary key (CONFIG_NAME)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_SUPER_BOM
prompt ===============================
prompt
create table MM_PUB_SUPER_BOM
(
  model_code         VARCHAR2(40) not null,
  factory_code       VARCHAR2(40) not null,
  part_no            VARCHAR2(40) not null,
  parent_part_code   VARCHAR2(40) not null,
  part_name_cn       VARCHAR2(80),
  part_name_en       VARCHAR2(150),
  part_version       VARCHAR2(8),
  line_no            NUMBER(10) not null,
  uc                 VARCHAR2(2000),
  amount             NUMBER(10,2),
  unit_code          VARCHAR2(8),
  plate_code         VARCHAR2(40),
  purchase_type      VARCHAR2(20),
  next_placement     VARCHAR2(200),
  process_type       VARCHAR2(200),
  plan_eff_start     VARCHAR2(40),
  plan_eff_end       VARCHAR2(40),
  actual_eff_start   VARCHAR2(40),
  actual_eff_end     VARCHAR2(40),
  pco                VARCHAR2(40),
  raw_num            VARCHAR2(256),
  gacne_key_part     VARCHAR2(10),
  inter_change_group VARCHAR2(20),
  after_sale_flag    VARCHAR2(10),
  creation_time      DATE default sysdate,
  creation_user      VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_SUPER_BOM
  is 'G-BOM???ERP???BOM???';
comment on column MM_PUB_SUPER_BOM.model_code
  is '??
??
??';
comment on column MM_PUB_SUPER_BOM.factory_code
  is '??
??
??';
comment on column MM_PUB_SUPER_BOM.part_no
  is '????
????
????';
comment on column MM_PUB_SUPER_BOM.parent_part_code
  is '??????
??????
??????';
comment on column MM_PUB_SUPER_BOM.part_name_cn
  is '??????
??????
??????';
comment on column MM_PUB_SUPER_BOM.part_name_en
  is '??????
??????
??????';
comment on column MM_PUB_SUPER_BOM.part_version
  is '????
????
????';
comment on column MM_PUB_SUPER_BOM.line_no
  is '??
??
??';
comment on column MM_PUB_SUPER_BOM.uc
  is '??
??
??';
comment on column MM_PUB_SUPER_BOM.amount
  is '??
??
??';
comment on column MM_PUB_SUPER_BOM.unit_code
  is '??
??
??';
comment on column MM_PUB_SUPER_BOM.plate_code
  is '????
????
????';
comment on column MM_PUB_SUPER_BOM.purchase_type
  is 'GACNE????
GACNE????
GACNE????';
comment on column MM_PUB_SUPER_BOM.next_placement
  is '????
????
????';
comment on column MM_PUB_SUPER_BOM.process_type
  is '????
????
????';
comment on column MM_PUB_SUPER_BOM.plan_eff_start
  is '??????
??????
??????';
comment on column MM_PUB_SUPER_BOM.plan_eff_end
  is '??????
??????
??????';
comment on column MM_PUB_SUPER_BOM.actual_eff_start
  is '??????
??????
??????';
comment on column MM_PUB_SUPER_BOM.actual_eff_end
  is '??????
??????
??????';
comment on column MM_PUB_SUPER_BOM.pco
  is 'PCO??
PCO??
PCO??';
comment on column MM_PUB_SUPER_BOM.raw_num
  is '??
??
??';
comment on column MM_PUB_SUPER_BOM.gacne_key_part
  is 'GACNE???
GACNE???
GACNE???';
comment on column MM_PUB_SUPER_BOM.inter_change_group
  is '????
????
????';
comment on column MM_PUB_SUPER_BOM.after_sale_flag
  is '????
????
????';
comment on column MM_PUB_SUPER_BOM.creation_time
  is '????
????
????';
comment on column MM_PUB_SUPER_BOM.creation_user
  is '???
';
comment on column MM_PUB_SUPER_BOM.last_modified_time
  is '??????
??????
';
alter table MM_PUB_SUPER_BOM
  add constraint PK_MM_PUB_SUPER_BOM primary key (FACTORY_CODE, PARENT_PART_CODE, LINE_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_SUPPLIER
prompt ==============================
prompt
create table MM_PUB_SUPPLIER
(
  sup_factory        VARCHAR2(10) not null,
  supplier_no        VARCHAR2(10) not null,
  supplier_name      VARCHAR2(150),
  sup_factory_addr   VARCHAR2(200),
  detail_addr        VARCHAR2(200),
  sup_status         VARCHAR2(10),
  email              VARCHAR2(50),
  contact            VARCHAR2(30),
  mobile_no          VARCHAR2(30),
  tel_no             VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_time DATE,
  blong_area         VARCHAR2(50),
  supplier_address   VARCHAR2(300),
  sup_leader_name    VARCHAR2(30),
  sup_leader_tel     VARCHAR2(30),
  sup_leader_mail    VARCHAR2(100),
  order_contact      VARCHAR2(30),
  order_tel          VARCHAR2(30),
  order_mail         VARCHAR2(100),
  deliv_contact      VARCHAR2(30),
  delivery_tel       VARCHAR2(30),
  delivery_mail      VARCHAR2(100),
  excep_contact      VARCHAR2(30),
  excep_tel          VARCHAR2(30),
  excep_mail         VARCHAR2(100),
  pack_dept_name     VARCHAR2(60),
  pack_dept_tel      VARCHAR2(30),
  pack_dept_mail     VARCHAR2(100),
  pack_dept_contact  VARCHAR2(30),
  pack_dept_chief    VARCHAR2(30),
  pack_dept_minister VARCHAR2(30),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_SUPPLIER
  is 'MM_PUB_SUPPLIER???????
MM_PUB_SUPPLIER???????
';
comment on column MM_PUB_SUPPLIER.sup_factory
  is '??????
??????
???????';
comment on column MM_PUB_SUPPLIER.supplier_no
  is '?????
?????
';
comment on column MM_PUB_SUPPLIER.supplier_name
  is '??????
??????
';
comment on column MM_PUB_SUPPLIER.sup_factory_addr
  is '?????
?????
';
comment on column MM_PUB_SUPPLIER.detail_addr
  is '???????
???????
';
comment on column MM_PUB_SUPPLIER.sup_status
  is '?????
?????
1????2????3???';
comment on column MM_PUB_SUPPLIER.email
  is '????
????
';
comment on column MM_PUB_SUPPLIER.contact
  is '???
???
';
comment on column MM_PUB_SUPPLIER.mobile_no
  is '???????
???????
';
comment on column MM_PUB_SUPPLIER.tel_no
  is '?????
?????
';
comment on column MM_PUB_SUPPLIER.creation_time
  is '????
????
';
comment on column MM_PUB_SUPPLIER.last_modified_time
  is '??????
??????
';
comment on column MM_PUB_SUPPLIER.order_tel
  is '????(0:???1:?????2:GAMC??3:????)';
comment on column MM_PUB_SUPPLIER.deal_flag
  is '????
????
0 ??? 1???';
comment on column MM_PUB_SUPPLIER.deal_time
  is '????
????
';
alter table MM_PUB_SUPPLIER
  add constraint PK_MM_PUB_SUPPLIER primary key (SUP_FACTORY, SUPPLIER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_SUPPLIER_DETAIL
prompt =====================================
prompt
create table MM_PUB_SUPPLIER_DETAIL
(
  sup_factory               VARCHAR2(10),
  supplier_no               VARCHAR2(10),
  sup_factory_addr          VARCHAR2(100),
  import_dep                VARCHAR2(60),
  import_position           VARCHAR2(50),
  import_name               VARCHAR2(30),
  import_mobile             VARCHAR2(30),
  import_tel                VARCHAR2(30),
  import_mail               VARCHAR2(50),
  pt_dep                    VARCHAR2(60),
  pt_position               VARCHAR2(50),
  pt_name                   VARCHAR2(30),
  pt_mobile                 VARCHAR2(30),
  pt_tel                    VARCHAR2(30),
  pt_mail                   VARCHAR2(50),
  mass_dep                  VARCHAR2(60),
  mass_position             VARCHAR2(50),
  mass_name                 VARCHAR2(30),
  mass_mobile               VARCHAR2(30),
  mass_tel                  VARCHAR2(30),
  mass_mail                 VARCHAR2(50),
  excep_dep_a               VARCHAR2(60),
  excep_dep_b               VARCHAR2(50),
  excep_position_a          VARCHAR2(50),
  excep_position_b          VARCHAR2(50),
  excep_name_a              VARCHAR2(30),
  excep_name_b              VARCHAR2(30),
  excep_mobile_a            VARCHAR2(30),
  excep_mobile_b            VARCHAR2(30),
  excep_tel_a               VARCHAR2(30),
  excep_tel_b               VARCHAR2(30),
  excep_mail_a              VARCHAR2(50),
  excep_mail_b              VARCHAR2(50),
  device_dep                VARCHAR2(60),
  device_position           VARCHAR2(30),
  device_name               VARCHAR2(30),
  device_mobile             VARCHAR2(30),
  device_tel                VARCHAR2(30),
  device_mail               VARCHAR2(50),
  import_dep_a              VARCHAR2(50),
  import_position_a         VARCHAR2(30),
  import_name_a             VARCHAR2(30),
  import_mobile_a           VARCHAR2(30),
  import_tel_a              VARCHAR2(30),
  import_mail_a             VARCHAR2(50),
  pt_dep_a                  VARCHAR2(60),
  pt_position_a             VARCHAR2(30),
  pt_name_a                 VARCHAR2(30),
  pt_mobile_a               VARCHAR2(30),
  pt_tel_a                  VARCHAR2(30),
  pt_mail_a                 VARCHAR2(50),
  mass_dep_a                VARCHAR2(60),
  mass_position_a           VARCHAR2(30),
  mass_name_a               VARCHAR2(30),
  mass_mobile_a             VARCHAR2(30),
  mass_tel_a                VARCHAR2(30),
  mass_mail_a               VARCHAR2(50),
  device_dep_a              VARCHAR2(60),
  device_position_a         VARCHAR2(30),
  device_name_a             VARCHAR2(30),
  device_mobile_a           VARCHAR2(30),
  device_tel_a              VARCHAR2(30),
  device_mail_a             VARCHAR2(50),
  pack_dep_a                VARCHAR2(60),
  pack_position_a           VARCHAR2(30),
  pack_name_a               VARCHAR2(30),
  pack_mobile_a             VARCHAR2(30),
  pack_tel_a                VARCHAR2(30),
  pack_mail_a               VARCHAR2(50),
  pack_dep_b                VARCHAR2(60),
  pack_position_b           VARCHAR2(30),
  pack_name_b               VARCHAR2(30),
  pack_mobile_b             VARCHAR2(30),
  pack_tel_b                VARCHAR2(30),
  pack_mail_b               VARCHAR2(50),
  pt_logistics_dep          VARCHAR2(60),
  pt_logistics_name         VARCHAR2(30),
  pt_logistics_position     VARCHAR2(30),
  pt_logistics_mobile       VARCHAR2(30),
  pt_logistics_tel          VARCHAR2(30),
  pt_logistics_mail         VARCHAR2(50),
  pt_logistics_dep_a        VARCHAR2(60),
  pt_logistics_name_a       VARCHAR2(30),
  pt_logistics_position_a   VARCHAR2(30),
  pt_logistics_mobile_a     VARCHAR2(30),
  pt_logistics_tel_a        VARCHAR2(30),
  pt_logistics_mail_a       VARCHAR2(50),
  mass_logistics_dep        VARCHAR2(60),
  mass_logistics_position   VARCHAR2(30),
  mass_logistics_name       VARCHAR2(30),
  mass_logistics_mobile     VARCHAR2(30),
  mass_logistics_tel        VARCHAR2(30),
  mass_logistics_mail       VARCHAR2(50),
  mass_logistics_dep_a      VARCHAR2(60),
  mass_logistics_position_a VARCHAR2(30),
  mass_logistics_name_a     VARCHAR2(30),
  mass_logistics_mobile_a   VARCHAR2(30),
  mass_logistics_tel_a      VARCHAR2(30),
  mass_logistics_mail_a     VARCHAR2(50),
  creation_time             DATE,
  last_modified_time        DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUB_SUPPLIER_DETAIL.sup_factory
  is '??????(???????)';
comment on column MM_PUB_SUPPLIER_DETAIL.supplier_no
  is '?????';
comment on column MM_PUB_SUPPLIER_DETAIL.sup_factory_addr
  is '?????';
comment on column MM_PUB_SUPPLIER_DETAIL.import_dep
  is '???????';
comment on column MM_PUB_SUPPLIER_DETAIL.import_position
  is '???????';
comment on column MM_PUB_SUPPLIER_DETAIL.import_name
  is '???????';
comment on column MM_PUB_SUPPLIER_DETAIL.import_mobile
  is '?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.import_tel
  is '?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.import_mail
  is '?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_dep
  is 'PT???????';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_position
  is 'PT???????';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_name
  is 'PT???????';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_mobile
  is 'PT?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_tel
  is 'PT?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_mail
  is 'PT?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_dep
  is '?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_position
  is '?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_name
  is '?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_mobile
  is '???????????';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_tel
  is '???????????';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_mail
  is '???????????';
comment on column MM_PUB_SUPPLIER_DETAIL.excep_dep_a
  is '???????A';
comment on column MM_PUB_SUPPLIER_DETAIL.excep_dep_b
  is '???????B';
comment on column MM_PUB_SUPPLIER_DETAIL.excep_position_a
  is '???????A';
comment on column MM_PUB_SUPPLIER_DETAIL.excep_position_b
  is '???????B';
comment on column MM_PUB_SUPPLIER_DETAIL.excep_name_a
  is '???????A';
comment on column MM_PUB_SUPPLIER_DETAIL.excep_name_b
  is '???????B';
comment on column MM_PUB_SUPPLIER_DETAIL.excep_mobile_a
  is '?????????A';
comment on column MM_PUB_SUPPLIER_DETAIL.excep_mobile_b
  is '?????????B';
comment on column MM_PUB_SUPPLIER_DETAIL.excep_tel_a
  is '?????????A';
comment on column MM_PUB_SUPPLIER_DETAIL.excep_tel_b
  is '?????????B';
comment on column MM_PUB_SUPPLIER_DETAIL.excep_mail_a
  is '?????????A';
comment on column MM_PUB_SUPPLIER_DETAIL.excep_mail_b
  is '?????????B';
comment on column MM_PUB_SUPPLIER_DETAIL.device_dep
  is '???????';
comment on column MM_PUB_SUPPLIER_DETAIL.device_position
  is '???????';
comment on column MM_PUB_SUPPLIER_DETAIL.device_name
  is '???????';
comment on column MM_PUB_SUPPLIER_DETAIL.device_mobile
  is '?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.device_tel
  is '?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.device_mail
  is '?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.import_dep_a
  is '???????1';
comment on column MM_PUB_SUPPLIER_DETAIL.import_position_a
  is '???????1';
comment on column MM_PUB_SUPPLIER_DETAIL.import_name_a
  is '???????1';
comment on column MM_PUB_SUPPLIER_DETAIL.import_mobile_a
  is '?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.import_tel_a
  is '?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.import_mail_a
  is '?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_dep_a
  is 'PT???????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_position_a
  is 'PT???????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_name_a
  is 'PT???????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_mobile_a
  is 'PT?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_tel_a
  is 'PT?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_mail_a
  is 'PT?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_dep_a
  is '?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_position_a
  is '?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_name_a
  is '?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_mobile_a
  is '???????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_tel_a
  is '???????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_mail_a
  is '???????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.device_dep_a
  is '???????1';
comment on column MM_PUB_SUPPLIER_DETAIL.device_position_a
  is '???????1';
comment on column MM_PUB_SUPPLIER_DETAIL.device_name_a
  is '???????1';
comment on column MM_PUB_SUPPLIER_DETAIL.device_mobile_a
  is '?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.device_tel_a
  is '?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.device_mail_a
  is '?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pack_dep_a
  is '???????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pack_position_a
  is '???????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pack_name_a
  is '???????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pack_mobile_a
  is '?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pack_tel_a
  is '?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pack_mail_a
  is '?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pack_dep_b
  is '???????2';
comment on column MM_PUB_SUPPLIER_DETAIL.pack_position_b
  is '???????2';
comment on column MM_PUB_SUPPLIER_DETAIL.pack_name_b
  is '???????2';
comment on column MM_PUB_SUPPLIER_DETAIL.pack_mobile_b
  is '?????????2';
comment on column MM_PUB_SUPPLIER_DETAIL.pack_tel_b
  is '?????????2';
comment on column MM_PUB_SUPPLIER_DETAIL.pack_mail_b
  is '?????????2';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_logistics_dep
  is 'PT?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_logistics_name
  is 'PT?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_logistics_position
  is 'PT?????????';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_logistics_mobile
  is 'PT???????????';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_logistics_tel
  is 'PT???????????';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_logistics_mail
  is 'PT???????????';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_logistics_dep_a
  is 'PT?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_logistics_name_a
  is 'PT?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_logistics_position_a
  is 'PT?????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_logistics_mobile_a
  is 'PT???????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_logistics_tel_a
  is 'PT???????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.pt_logistics_mail_a
  is 'PT???????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_logistics_dep
  is '???????????';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_logistics_position
  is '???????????';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_logistics_name
  is '???????????';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_logistics_mobile
  is '?????????????';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_logistics_tel
  is '?????????????';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_logistics_mail
  is '?????????????';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_logistics_dep_a
  is '???????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_logistics_position_a
  is '???????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_logistics_name_a
  is '???????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_logistics_mobile_a
  is '?????????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_logistics_tel_a
  is '?????????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.mass_logistics_mail_a
  is '?????????????1';
comment on column MM_PUB_SUPPLIER_DETAIL.creation_time
  is '????';
comment on column MM_PUB_SUPPLIER_DETAIL.last_modified_time
  is '??????';
alter table MM_PUB_SUPPLIER_DETAIL
  add constraint AK_KEY_1_MM_PUB_S unique (SUP_FACTORY, SUPPLIER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_SUPPORTING_PART
prompt =====================================
prompt
create table MM_PUB_SUPPORTING_PART
(
  factory_code        VARCHAR2(10) not null,
  partf_id            VARCHAR2(30) not null,
  part_row_no         NUMBER(10) not null,
  part_no             VARCHAR2(30),
  num                 NUMBER(18),
  use_age_amount_unit VARCHAR2(20),
  line_station        VARCHAR2(30),
  next_placement      VARCHAR2(30),
  purchase_type       VARCHAR2(10),
  creation_time       DATE default sysdate,
  last_modified_time  DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_SUPPORTING_PART
  is '???';
comment on column MM_PUB_SUPPORTING_PART.factory_code
  is '??
??
';
comment on column MM_PUB_SUPPORTING_PART.partf_id
  is '??';
comment on column MM_PUB_SUPPORTING_PART.part_row_no
  is '??????';
comment on column MM_PUB_SUPPORTING_PART.part_no
  is '????';
comment on column MM_PUB_SUPPORTING_PART.num
  is '??';
comment on column MM_PUB_SUPPORTING_PART.use_age_amount_unit
  is '????';
comment on column MM_PUB_SUPPORTING_PART.line_station
  is '?????';
comment on column MM_PUB_SUPPORTING_PART.next_placement
  is '????';
comment on column MM_PUB_SUPPORTING_PART.purchase_type
  is '????';
comment on column MM_PUB_SUPPORTING_PART.creation_time
  is '????
????
';
comment on column MM_PUB_SUPPORTING_PART.last_modified_time
  is '??????
??????
';
alter table MM_PUB_SUPPORTING_PART
  add constraint PK_MM_PUB_SUPPORTING_PART primary key (FACTORY_CODE, PARTF_ID, PART_ROW_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_SYS_ALERT
prompt ===============================
prompt
create table MM_PUB_SYS_ALERT
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10),
  alert_module  VARCHAR2(30),
  alert_code    VARCHAR2(20),
  alert_level   VARCHAR2(20),
  alert_info    VARCHAR2(500),
  creation_time DATE default sysdate,
  deal_flag     NUMBER(1) default 0,
  deal_time     DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
alter table MM_PUB_SYS_ALERT
  add constraint PK_MM_PUB_SYS_ALERT primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_SYS_PARAM
prompt ===============================
prompt
create table MM_PUB_SYS_PARAM
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  param_code         VARCHAR2(50) not null,
  param_name         VARCHAR2(100),
  param_val          VARCHAR2(100),
  param_group        VARCHAR2(50),
  is_edit            NUMBER(1) default 0,
  note               VARCHAR2(200),
  check_by           VARCHAR2(20),
  check_comp         VARCHAR2(2000),
  message            VARCHAR2(100),
  uda_1              VARCHAR2(50),
  uda_2              VARCHAR2(50),
  uda_3              VARCHAR2(50),
  creation_time      DATE default SYSDATE,
  creation_user      VARCHAR2(30),
  last_modified_time DATE,
  last_modified_user VARCHAR2(30),
  last_modified_ip   VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_SYS_PARAM
  is '?????';
comment on column MM_PUB_SYS_PARAM.check_by
  is '???????PUB_CHECK_BY?';
alter table MM_PUB_SYS_PARAM
  add constraint PK_MM_PUB_SYS_PARAM primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_PUB_SYS_PARAM
  add constraint AK_MM_PUB_SYS_PARAM unique (FACTORY_CODE, PARAM_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUB_TACT_TIME
prompt ===============================
prompt
create table MM_PUB_TACT_TIME
(
  factory_code       VARCHAR2(10) not null,
  workcenter         VARCHAR2(20) not null,
  production_line    VARCHAR2(20) not null,
  eff_date           DATE not null,
  jph                VARCHAR2(20),
  oee                VARCHAR2(20),
  produce_time       NUMBER(10),
  pro_capacity       VARCHAR2(30),
  remark             VARCHAR2(200),
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_TACT_TIME
  is 'MM_PUB_TACT_TIME?????
MM_PUB_TACT_TIME?????
';
comment on column MM_PUB_TACT_TIME.factory_code
  is '??
??
';
comment on column MM_PUB_TACT_TIME.workcenter
  is '????
????
';
comment on column MM_PUB_TACT_TIME.production_line
  is '???
???
?????????';
comment on column MM_PUB_TACT_TIME.eff_date
  is '????
????
';
comment on column MM_PUB_TACT_TIME.jph
  is 'JPH
JPH
';
comment on column MM_PUB_TACT_TIME.oee
  is '???
???
';
comment on column MM_PUB_TACT_TIME.produce_time
  is '????
????
';
comment on column MM_PUB_TACT_TIME.pro_capacity
  is '????
????
';
comment on column MM_PUB_TACT_TIME.remark
  is '??
??
';
comment on column MM_PUB_TACT_TIME.creation_time
  is '????
????
';
comment on column MM_PUB_TACT_TIME.last_modified_time
  is '??????
??????
';

prompt
prompt Creating table MM_PUB_VEH_CONF_ITEM
prompt ===================================
prompt
create table MM_PUB_VEH_CONF_ITEM
(
  id NUMBER(19) not null
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_VEH_CONF_ITEM
  is 'MM_PUB_VEH_CONF_ITEM???????
MM_PUB_VEH_CONF_ITEM???????
';
comment on column MM_PUB_VEH_CONF_ITEM.id
  is 'ID
ID
';

prompt
prompt Creating table MM_PUB_VEH_PASS
prompt ==============================
prompt
create table MM_PUB_VEH_PASS
(
  factory_code       VARCHAR2(10) not null,
  order_no           VARCHAR2(50) not null,
  erp_order_no       VARCHAR2(50) not null,
  station_code       VARCHAR2(20) not null,
  pass_time          DATE,
  vin                VARCHAR2(20),
  phase              VARCHAR2(10),
  mtoc               VARCHAR2(64),
  model_code         VARCHAR2(20),
  wc_seqno           VARCHAR2(3),
  pl_seqno           VARCHAR2(6),
  creation_time      DATE default sysdate,
  last_modified_time DATE,
  sale_no            VARCHAR2(50),
  sale_rowno         NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_VEH_PASS
  is 'MM_PUB_VEH_PASS?????????
MM_PUB_VEH_PASS?????????
';
comment on column MM_PUB_VEH_PASS.factory_code
  is '??
??
';
comment on column MM_PUB_VEH_PASS.order_no
  is '?????
?????
?????';
comment on column MM_PUB_VEH_PASS.erp_order_no
  is 'ERP???
ERP???
ERP???';
comment on column MM_PUB_VEH_PASS.station_code
  is '????
????
';
comment on column MM_PUB_VEH_PASS.pass_time
  is '????
????
';
comment on column MM_PUB_VEH_PASS.vin
  is 'VIN?
VIN?
';
comment on column MM_PUB_VEH_PASS.phase
  is '????
????
';
comment on column MM_PUB_VEH_PASS.mtoc
  is 'MTOC
MTOC
';
comment on column MM_PUB_VEH_PASS.model_code
  is '??
??
';
comment on column MM_PUB_VEH_PASS.wc_seqno
  is '?????
?????
';
comment on column MM_PUB_VEH_PASS.pl_seqno
  is '?????
?????
';
comment on column MM_PUB_VEH_PASS.creation_time
  is '????
????
';
comment on column MM_PUB_VEH_PASS.last_modified_time
  is '??????
??????
';
comment on column MM_PUB_VEH_PASS.sale_no
  is '????
  ';
comment on column MM_PUB_VEH_PASS.sale_rowno
  is '?????
  ';
create index IDX_MM_PUB_VEH_PASS on MM_PUB_VEH_PASS (PASS_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_VEH_PASS
  add constraint PK_MM_PUB_VEH_PASS primary key (FACTORY_CODE, ORDER_NO, STATION_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_WAREHOUSE
prompt ===============================
prompt
create table MM_PUB_WAREHOUSE
(
  factory_code       VARCHAR2(10) not null,
  warehouse_id       VARCHAR2(20) not null,
  warehouse_name     VARCHAR2(150),
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_WAREHOUSE
  is 'MM_PUB_WAREHOUSE???
MM_PUB_WAREHOUSE???
';
comment on column MM_PUB_WAREHOUSE.factory_code
  is '??
??
';
comment on column MM_PUB_WAREHOUSE.warehouse_id
  is '????
????
';
comment on column MM_PUB_WAREHOUSE.warehouse_name
  is '????
????
';
comment on column MM_PUB_WAREHOUSE.creation_time
  is '????
????
';
comment on column MM_PUB_WAREHOUSE.last_modified_time
  is '??????
??????
';
alter table MM_PUB_WAREHOUSE
  add constraint PK_MM_PUB_WAREHOUSE primary key (FACTORY_CODE, WAREHOUSE_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_WORK_CALENDAR
prompt ===================================
prompt
create table MM_PUB_WORK_CALENDAR
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  workcenter         VARCHAR2(20) not null,
  shift_code         VARCHAR2(20) not null,
  work_date          DATE not null,
  work_start_time    DATE,
  work_end_time      DATE,
  creation_time      DATE default sysdate,
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_WORK_CALENDAR
  is 'MM_PUB_WORK_CALENDAR???????
MM_PUB_WORK_CALENDAR???????
';
comment on column MM_PUB_WORK_CALENDAR.id
  is '????????
????????
';
comment on column MM_PUB_WORK_CALENDAR.factory_code
  is '??
??
';
comment on column MM_PUB_WORK_CALENDAR.workcenter
  is '????
????
';
comment on column MM_PUB_WORK_CALENDAR.shift_code
  is '??
??
';
comment on column MM_PUB_WORK_CALENDAR.work_date
  is '???
???
';
comment on column MM_PUB_WORK_CALENDAR.work_start_time
  is '??????
??????
';
comment on column MM_PUB_WORK_CALENDAR.work_end_time
  is '??????
??????
';
comment on column MM_PUB_WORK_CALENDAR.creation_time
  is '????
????
';
comment on column MM_PUB_WORK_CALENDAR.last_modified_time
  is '??????
??????
';
alter table MM_PUB_WORK_CALENDAR
  add constraint PK_MM_PUB_WORK_CALENDAR primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUB_WORK_CALENDAR
  add constraint AK_MM_PUB_WORK_CALENDAR unique (WORK_DATE, WORKCENTER, SHIFT_CODE, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUB_WORK_CALENDAR_DETAIL
prompt ==========================================
prompt
create table MM_PUB_WORK_CALENDAR_DETAIL
(
  work_calendar_id NUMBER(19) not null,
  id               NUMBER(19) not null,
  start_time       DATE,
  end_time         DATE,
  time_type        VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUB_WORK_CALENDAR_DETAIL
  is 'MM_PUB_WORK_CALENDAR_DETAIL?????????
MM_PUB_WORK_CALENDAR_DETAIL?????????
';
comment on column MM_PUB_WORK_CALENDAR_DETAIL.work_calendar_id
  is '????????
????????
';
comment on column MM_PUB_WORK_CALENDAR_DETAIL.id
  is '????????
????????
';
comment on column MM_PUB_WORK_CALENDAR_DETAIL.start_time
  is '????
????
';
comment on column MM_PUB_WORK_CALENDAR_DETAIL.end_time
  is '????
????
';
comment on column MM_PUB_WORK_CALENDAR_DETAIL.time_type
  is '?????
?????
1-?????2-????';
create index IDX_MM_PUB_WORK_CAL_DETAIL1 on MM_PUB_WORK_CALENDAR_DETAIL (WORK_CALENDAR_ID)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUP_DCS_DATA_IMP
prompt ==================================
prompt
create table MM_PUP_DCS_DATA_IMP
(
  factory_code  VARCHAR2(10),
  pickup_type   VARCHAR2(30),
  area          VARCHAR2(20),
  car_type      VARCHAR2(10),
  route_code    VARCHAR2(20),
  total_no      VARCHAR2(30),
  merge_no      NUMBER(10),
  sup_factory   VARCHAR2(20),
  supplier_name VARCHAR2(50),
  order_no      VARCHAR2(50),
  purchase_no   VARCHAR2(50),
  workday       VARCHAR2(20),
  today_no      NUMBER(10),
  pick_date     DATE,
  arrive_date   DATE,
  assemble_date DATE,
  wwl_manager   VARCHAR2(20),
  nwl_manager   VARCHAR2(20),
  order_use     VARCHAR2(100),
  imp_uuid      VARCHAR2(50),
  check_result  NUMBER(1),
  check_info    VARCHAR2(300),
  import_status NUMBER(1),
  ope_type      VARCHAR2(8),
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate,
  supplier_no   VARCHAR2(20),
  unload_port   VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUP_DCS_DATA_IMP
  is 'DCS?????';
comment on column MM_PUP_DCS_DATA_IMP.factory_code
  is '????';
comment on column MM_PUP_DCS_DATA_IMP.pickup_type
  is '??????';
comment on column MM_PUP_DCS_DATA_IMP.area
  is '??';
comment on column MM_PUP_DCS_DATA_IMP.car_type
  is '??';
comment on column MM_PUP_DCS_DATA_IMP.route_code
  is '????';
comment on column MM_PUP_DCS_DATA_IMP.total_no
  is '????';
comment on column MM_PUP_DCS_DATA_IMP.merge_no
  is '????';
comment on column MM_PUP_DCS_DATA_IMP.sup_factory
  is '?????';
comment on column MM_PUP_DCS_DATA_IMP.supplier_name
  is '?????';
comment on column MM_PUP_DCS_DATA_IMP.order_no
  is '????';
comment on column MM_PUP_DCS_DATA_IMP.purchase_no
  is '????';
comment on column MM_PUP_DCS_DATA_IMP.workday
  is '???';
comment on column MM_PUP_DCS_DATA_IMP.today_no
  is '????';
comment on column MM_PUP_DCS_DATA_IMP.pick_date
  is '??????';
comment on column MM_PUP_DCS_DATA_IMP.arrive_date
  is '??????';
comment on column MM_PUP_DCS_DATA_IMP.assemble_date
  is '??????';
comment on column MM_PUP_DCS_DATA_IMP.wwl_manager
  is '??ID';
comment on column MM_PUP_DCS_DATA_IMP.nwl_manager
  is '??????';
comment on column MM_PUP_DCS_DATA_IMP.order_use
  is '????';
comment on column MM_PUP_DCS_DATA_IMP.check_result
  is '???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_PUP_DCS_DATA_IMP.import_status
  is '0-???
1-???';
comment on column MM_PUP_DCS_DATA_IMP.ope_type
  is 'I ?? U??';
comment on column MM_PUP_DCS_DATA_IMP.supplier_no
  is '?????';
comment on column MM_PUP_DCS_DATA_IMP.unload_port
  is '????';

prompt
prompt Creating table MM_PUP_DCS_PICK_PLAN
prompt ===================================
prompt
create table MM_PUP_DCS_PICK_PLAN
(
  plan_sheet_no      VARCHAR2(50) not null,
  factory_code       VARCHAR2(10),
  route_code         VARCHAR2(20),
  plan_start_time    DATE,
  plan_arrive_time   DATE,
  plan_type          VARCHAR2(10),
  pick_type          NUMBER(1),
  car_num            VARCHAR2(30),
  take_car           VARCHAR2(30),
  plate_num          VARCHAR2(30),
  remark             VARCHAR2(50),
  route_name         VARCHAR2(30),
  workday            DATE,
  status             NUMBER(1) default 0,
  excute_status      NUMBER(1) default 0,
  operation_user     VARCHAR2(30),
  print_time         DATE,
  ret_empty_platform VARCHAR2(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_DCS_PICK_PLAN.plan_sheet_no
  is 'DCS??';
comment on column MM_PUP_DCS_PICK_PLAN.factory_code
  is '????';
comment on column MM_PUP_DCS_PICK_PLAN.route_code
  is '????';
comment on column MM_PUP_DCS_PICK_PLAN.plan_start_time
  is '??????';
comment on column MM_PUP_DCS_PICK_PLAN.plan_arrive_time
  is '??????';
comment on column MM_PUP_DCS_PICK_PLAN.plan_type
  is '?????';
comment on column MM_PUP_DCS_PICK_PLAN.pick_type
  is '0 ?? 1??';
comment on column MM_PUP_DCS_PICK_PLAN.car_num
  is '??';
comment on column MM_PUP_DCS_PICK_PLAN.take_car
  is '????';
comment on column MM_PUP_DCS_PICK_PLAN.plate_num
  is '???';
comment on column MM_PUP_DCS_PICK_PLAN.remark
  is '??';
comment on column MM_PUP_DCS_PICK_PLAN.route_name
  is '????';
comment on column MM_PUP_DCS_PICK_PLAN.workday
  is '???';
comment on column MM_PUP_DCS_PICK_PLAN.status
  is '0 ??? 1 ???';
comment on column MM_PUP_DCS_PICK_PLAN.excute_status
  is '????';
comment on column MM_PUP_DCS_PICK_PLAN.operation_user
  is '???';
comment on column MM_PUP_DCS_PICK_PLAN.print_time
  is '????';
comment on column MM_PUP_DCS_PICK_PLAN.ret_empty_platform
  is '????';
create unique index AK_MM_PUP_DCS_PLAN on MM_PUP_DCS_PICK_PLAN (PLAN_SHEET_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUP_DCS_PICK_PLAN_DETAIL
prompt ==========================================
prompt
create table MM_PUP_DCS_PICK_PLAN_DETAIL
(
  plan_sheet_no VARCHAR2(50) not null,
  order_no      VARCHAR2(50),
  supplier_no   VARCHAR2(20),
  purchase_no   VARCHAR2(50) not null,
  pick_time     DATE,
  order_depot   VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_DCS_PICK_PLAN_DETAIL.plan_sheet_no
  is 'DCS??';
comment on column MM_PUP_DCS_PICK_PLAN_DETAIL.order_no
  is '????';
comment on column MM_PUP_DCS_PICK_PLAN_DETAIL.supplier_no
  is '?????';
comment on column MM_PUP_DCS_PICK_PLAN_DETAIL.purchase_no
  is '????';
comment on column MM_PUP_DCS_PICK_PLAN_DETAIL.pick_time
  is '????';
comment on column MM_PUP_DCS_PICK_PLAN_DETAIL.order_depot
  is '????';
create unique index AK_MM_PUP_DCS_PLAN_D on MM_PUP_DCS_PICK_PLAN_DETAIL (PLAN_SHEET_NO, ORDER_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUP_DCS_PLAN_TEMP
prompt ===================================
prompt
create table MM_PUP_DCS_PLAN_TEMP
(
  pickup_type       VARCHAR2(20),
  area              VARCHAR2(20),
  car_type_dist     VARCHAR2(10),
  sup_factory       VARCHAR2(20),
  route_code        VARCHAR2(20),
  total_no          VARCHAR2(30),
  merge_no          NUMBER(10),
  supplier_name     VARCHAR2(100),
  purchase_no       VARCHAR2(50),
  order_no          VARCHAR2(50),
  workday           DATE,
  today_no          NUMBER(10),
  pick_time         DATE,
  arrive_time       DATE,
  assemble_date     DATE,
  nwl_manager       VARCHAR2(20),
  wwl_manager       VARCHAR2(30),
  order_use         VARCHAR2(100),
  creation_user     VARCHAR2(30),
  creation_time     DATE default sysdate,
  factory_code      VARCHAR2(10),
  order_depot       VARCHAR2(20),
  order_desc        VARCHAR2(100),
  logistic_flag     VARCHAR2(10),
  spe_arrive_time   DATE,
  depart_time_point NUMBER(10),
  pickup_car        VARCHAR2(30),
  plan_sheet_no     VARCHAR2(50),
  route_name        VARCHAR2(50),
  plan_begin_time   DATE,
  plan_end_time     DATE,
  supplier_no       VARCHAR2(20),
  unload_port       VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_DCS_PLAN_TEMP.pickup_type
  is '??????';
comment on column MM_PUP_DCS_PLAN_TEMP.area
  is '??';
comment on column MM_PUP_DCS_PLAN_TEMP.sup_factory
  is '???';
comment on column MM_PUP_DCS_PLAN_TEMP.route_code
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.total_no
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.merge_no
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.purchase_no
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.order_no
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.workday
  is '???';
comment on column MM_PUP_DCS_PLAN_TEMP.today_no
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.pick_time
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.arrive_time
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.assemble_date
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.nwl_manager
  is '??????';
comment on column MM_PUP_DCS_PLAN_TEMP.wwl_manager
  is '??ID';
comment on column MM_PUP_DCS_PLAN_TEMP.order_use
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.factory_code
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.order_depot
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.order_desc
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.logistic_flag
  is '???? GAM GAM VMI VMI';
comment on column MM_PUP_DCS_PLAN_TEMP.spe_arrive_time
  is '??????';
comment on column MM_PUP_DCS_PLAN_TEMP.depart_time_point
  is '??????';
comment on column MM_PUP_DCS_PLAN_TEMP.pickup_car
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.plan_sheet_no
  is 'DCS??';
comment on column MM_PUP_DCS_PLAN_TEMP.route_name
  is '????';
comment on column MM_PUP_DCS_PLAN_TEMP.plan_begin_time
  is '??????';
comment on column MM_PUP_DCS_PLAN_TEMP.plan_end_time
  is '??????';
comment on column MM_PUP_DCS_PLAN_TEMP.supplier_no
  is '?????';
comment on column MM_PUP_DCS_PLAN_TEMP.unload_port
  is '????';

prompt
prompt Creating table MM_PUP_DCS_SEAL
prompt ==============================
prompt
create table MM_PUP_DCS_SEAL
(
  seal_no            VARCHAR2(50),
  deal_flag          NUMBER(1) default 0,
  factory_code       VARCHAR2(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_DCS_SEAL.seal_no
  is '???';
comment on column MM_PUP_DCS_SEAL.deal_flag
  is '???? 0 ??? 1 ???';
comment on column MM_PUP_DCS_SEAL.factory_code
  is '????';
create unique index AK_MM_PUP_DCS_SEAL on MM_PUP_DCS_SEAL (SEAL_NO, FACTORY_CODE)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUP_DCS_SEAL_IMP
prompt ==================================
prompt
create table MM_PUP_DCS_SEAL_IMP
(
  seal_no            VARCHAR2(50),
  deal_flag          NUMBER(1) default 0,
  factory_code       VARCHAR2(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  imp_uuid           VARCHAR2(50),
  check_result       NUMBER(1),
  check_info         VARCHAR2(300),
  import_status      NUMBER(1) default 0,
  ope_type           VARCHAR2(8)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_DCS_SEAL_IMP.seal_no
  is '???';
comment on column MM_PUP_DCS_SEAL_IMP.deal_flag
  is '???? 0 ??? 1 ???';
comment on column MM_PUP_DCS_SEAL_IMP.factory_code
  is '????';
comment on column MM_PUP_DCS_SEAL_IMP.check_result
  is '???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_PUP_DCS_SEAL_IMP.import_status
  is '0-???
1-???';
comment on column MM_PUP_DCS_SEAL_IMP.ope_type
  is 'I ?? U??';

prompt
prompt Creating table MM_PUP_DCS_SEAL_TEMP
prompt ===================================
prompt
create table MM_PUP_DCS_SEAL_TEMP
(
  seal_no       VARCHAR2(50),
  session_no    VARCHAR2(50),
  plan_sheet_no VARCHAR2(50),
  factory_code  VARCHAR2(10),
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_DCS_SEAL_TEMP.seal_no
  is '???';
comment on column MM_PUP_DCS_SEAL_TEMP.session_no
  is '????';
comment on column MM_PUP_DCS_SEAL_TEMP.plan_sheet_no
  is 'DCS??';
comment on column MM_PUP_DCS_SEAL_TEMP.factory_code
  is '????';

prompt
prompt Creating table MM_PUP_DR
prompt ========================
prompt
create table MM_PUP_DR
(
  supplier_no                VARCHAR2(20),
  sup_factory                VARCHAR2(20),
  supplier_name              VARCHAR2(150),
  factory_code               VARCHAR2(10),
  total_no                   VARCHAR2(20),
  unload_port                VARCHAR2(20),
  dr_sort_id_start           NUMBER(10),
  dr_sort_id_end             NUMBER(10),
  final_underline_time_start DATE,
  final_underline_time_end   DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUP_DR
  is ' ?????';
comment on column MM_PUP_DR.supplier_no
  is '?????';
comment on column MM_PUP_DR.sup_factory
  is '?????';
comment on column MM_PUP_DR.factory_code
  is '????';
comment on column MM_PUP_DR.total_no
  is '????';
comment on column MM_PUP_DR.unload_port
  is '????';
comment on column MM_PUP_DR.dr_sort_id_start
  is 'dockrange??';
comment on column MM_PUP_DR.dr_sort_id_end
  is 'dockrange??';
create index IDX_MM_PUP_DR on MM_PUP_DR (SUP_FACTORY, UNLOAD_PORT, DR_SORT_ID_START, DR_SORT_ID_END)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_PUP_FIX_PICKUP_TIME
prompt =====================================
prompt
create table MM_PUP_FIX_PICKUP_TIME
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  route_code         VARCHAR2(20) not null,
  today_no           NUMBER(10) not null,
  pick_time          DATE not null,
  arrive_time        DATE not null,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_PUP_FIX_PICKUP_TIME
  is '?????????';
comment on column MM_PUP_FIX_PICKUP_TIME.factory_code
  is '????';
comment on column MM_PUP_FIX_PICKUP_TIME.route_code
  is '????';
comment on column MM_PUP_FIX_PICKUP_TIME.today_no
  is '??';
comment on column MM_PUP_FIX_PICKUP_TIME.pick_time
  is '????';
comment on column MM_PUP_FIX_PICKUP_TIME.arrive_time
  is '????';
alter table MM_PUP_FIX_PICKUP_TIME
  add constraint PK_MM_PUP_FIX_PICKUP_TIME primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUP_FIX_PICKUP_TIME
  add constraint AK_MM_PUP_FIX_PICKUP_TIME unique (FACTORY_CODE, ROUTE_CODE, TODAY_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUP_FIX_PICKUP_TIME_IMP
prompt =========================================
prompt
create table MM_PUP_FIX_PICKUP_TIME_IMP
(
  id            NUMBER(19) not null,
  factory_code  VARCHAR2(10),
  route_code    VARCHAR2(20),
  today_no      NUMBER(10),
  pick_time     DATE,
  arrive_time   DATE,
  imp_uuid      VARCHAR2(50),
  check_result  NUMBER(1),
  check_info    VARCHAR2(300),
  import_status NUMBER(1),
  ope_type      VARCHAR2(8),
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate,
  busi_id       NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_FIX_PICKUP_TIME_IMP.factory_code
  is '????';
comment on column MM_PUP_FIX_PICKUP_TIME_IMP.route_code
  is '????';
comment on column MM_PUP_FIX_PICKUP_TIME_IMP.today_no
  is '??';
comment on column MM_PUP_FIX_PICKUP_TIME_IMP.pick_time
  is '????';
comment on column MM_PUP_FIX_PICKUP_TIME_IMP.arrive_time
  is '????';
comment on column MM_PUP_FIX_PICKUP_TIME_IMP.check_result
  is '???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_PUP_FIX_PICKUP_TIME_IMP.import_status
  is '0-???
1-???';
comment on column MM_PUP_FIX_PICKUP_TIME_IMP.ope_type
  is 'I ?? U??';
alter table MM_PUP_FIX_PICKUP_TIME_IMP
  add constraint PK_MM_PUP_FIX_PICKUP_TIME_IMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUP_LOCK_PLAN
prompt ===============================
prompt
create table MM_PUP_LOCK_PLAN
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  area               VARCHAR2(20),
  unload_place       VARCHAR2(50),
  pickup_type        VARCHAR2(30),
  car_type           VARCHAR2(10),
  route_code         VARCHAR2(20),
  total_no           VARCHAR2(30),
  merge_no           NUMBER(19),
  today_no           NUMBER(19),
  workday            VARCHAR2(20),
  pick_date          DATE,
  arrive_date        DATE,
  assemble_date      DATE,
  unload_port        VARCHAR2(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_LOCK_PLAN.factory_code
  is '????';
comment on column MM_PUP_LOCK_PLAN.area
  is '??';
comment on column MM_PUP_LOCK_PLAN.unload_place
  is '????';
comment on column MM_PUP_LOCK_PLAN.pickup_type
  is '??????';
comment on column MM_PUP_LOCK_PLAN.car_type
  is '??';
comment on column MM_PUP_LOCK_PLAN.route_code
  is '????';
comment on column MM_PUP_LOCK_PLAN.total_no
  is '????';
comment on column MM_PUP_LOCK_PLAN.merge_no
  is '????';
comment on column MM_PUP_LOCK_PLAN.today_no
  is '????';
comment on column MM_PUP_LOCK_PLAN.workday
  is '???';
comment on column MM_PUP_LOCK_PLAN.pick_date
  is '????';
comment on column MM_PUP_LOCK_PLAN.arrive_date
  is '????';
comment on column MM_PUP_LOCK_PLAN.assemble_date
  is '????';
comment on column MM_PUP_LOCK_PLAN.unload_port
  is '????';
alter table MM_PUP_LOCK_PLAN
  add constraint PK_MM_PUP_LOCK_PLAN primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUP_LOCK_PLAN
  add constraint AK_MM_PUP_LOCK_PLAN unique (TOTAL_NO, ROUTE_CODE, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUP_MANU_ORDER
prompt ================================
prompt
create table MM_PUP_MANU_ORDER
(
  purchase_no        VARCHAR2(50) not null,
  order_no           VARCHAR2(50),
  factory_code       VARCHAR2(10),
  pickup_flag        NUMBER(1) default 0,
  merge_no           NUMBER(10),
  area               VARCHAR2(30),
  order_desc         VARCHAR2(100),
  sup_factory        VARCHAR2(20),
  pickup_type        VARCHAR2(20),
  car_type           VARCHAR2(10),
  workday            DATE,
  pick_date          DATE,
  arrive_date        DATE,
  order_date         DATE,
  route_code         VARCHAR2(20),
  total_no           VARCHAR2(30),
  today_no           NUMBER(10),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  supplier_no        VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_MANU_ORDER.purchase_no
  is '????';
comment on column MM_PUP_MANU_ORDER.order_no
  is '????';
comment on column MM_PUP_MANU_ORDER.factory_code
  is '????';
comment on column MM_PUP_MANU_ORDER.pickup_flag
  is '0 ???
1 ??';
comment on column MM_PUP_MANU_ORDER.merge_no
  is '????';
comment on column MM_PUP_MANU_ORDER.area
  is '??';
comment on column MM_PUP_MANU_ORDER.order_desc
  is '????';
comment on column MM_PUP_MANU_ORDER.sup_factory
  is '???';
comment on column MM_PUP_MANU_ORDER.pickup_type
  is '??????';
comment on column MM_PUP_MANU_ORDER.car_type
  is '??';
comment on column MM_PUP_MANU_ORDER.workday
  is '???';
comment on column MM_PUP_MANU_ORDER.pick_date
  is '????';
comment on column MM_PUP_MANU_ORDER.arrive_date
  is '????';
comment on column MM_PUP_MANU_ORDER.order_date
  is '??????';
comment on column MM_PUP_MANU_ORDER.route_code
  is '????';
comment on column MM_PUP_MANU_ORDER.total_no
  is '????';
comment on column MM_PUP_MANU_ORDER.today_no
  is '????';
comment on column MM_PUP_MANU_ORDER.supplier_no
  is '?????';
alter table MM_PUP_MANU_ORDER
  add constraint PK_MM_PUP_MANU_ORDER primary key (PURCHASE_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUP_MANU_ORDER_IMP
prompt ====================================
prompt
create table MM_PUP_MANU_ORDER_IMP
(
  id            NUMBER(19) not null,
  order_no      VARCHAR2(50),
  purchase_no   VARCHAR2(50),
  factory_code  VARCHAR2(10),
  pickup_flag   NUMBER(1) default 0,
  merge_no      NUMBER(10),
  area          VARCHAR2(20),
  order_desc    VARCHAR2(100),
  sup_factory   VARCHAR2(20),
  pickup_type   VARCHAR2(20),
  car_type      VARCHAR2(10),
  workday       DATE,
  pick_date     DATE,
  arrive_date   DATE,
  order_date    DATE,
  route_code    VARCHAR2(20),
  total_no      VARCHAR2(20),
  today_no      NUMBER(10),
  imp_uuid      VARCHAR2(50),
  check_result  NUMBER(1),
  check_info    VARCHAR2(300),
  import_status NUMBER(1),
  ope_type      VARCHAR2(8),
  creation_user VARCHAR2(30),
  creation_time DATE default sysdate,
  supplier_no   VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_MANU_ORDER_IMP.order_no
  is '????';
comment on column MM_PUP_MANU_ORDER_IMP.purchase_no
  is '????';
comment on column MM_PUP_MANU_ORDER_IMP.factory_code
  is '????';
comment on column MM_PUP_MANU_ORDER_IMP.pickup_flag
  is '0 ?? 1 ???';
comment on column MM_PUP_MANU_ORDER_IMP.merge_no
  is '????';
comment on column MM_PUP_MANU_ORDER_IMP.area
  is '??';
comment on column MM_PUP_MANU_ORDER_IMP.order_desc
  is '????';
comment on column MM_PUP_MANU_ORDER_IMP.sup_factory
  is '???';
comment on column MM_PUP_MANU_ORDER_IMP.pickup_type
  is '??????';
comment on column MM_PUP_MANU_ORDER_IMP.car_type
  is '??';
comment on column MM_PUP_MANU_ORDER_IMP.workday
  is '???';
comment on column MM_PUP_MANU_ORDER_IMP.pick_date
  is '????';
comment on column MM_PUP_MANU_ORDER_IMP.arrive_date
  is '????';
comment on column MM_PUP_MANU_ORDER_IMP.order_date
  is '??????';
comment on column MM_PUP_MANU_ORDER_IMP.route_code
  is '????';
comment on column MM_PUP_MANU_ORDER_IMP.total_no
  is '????';
comment on column MM_PUP_MANU_ORDER_IMP.today_no
  is '????';
comment on column MM_PUP_MANU_ORDER_IMP.check_result
  is '???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_PUP_MANU_ORDER_IMP.import_status
  is '0-???
1-???';
comment on column MM_PUP_MANU_ORDER_IMP.ope_type
  is 'I ?? U??';
comment on column MM_PUP_MANU_ORDER_IMP.supplier_no
  is '?????';
alter table MM_PUP_MANU_ORDER_IMP
  add constraint PK_MM_PUP_MANU_ORDER_IMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUP_ORDER_CAL
prompt ===============================
prompt
create table MM_PUP_ORDER_CAL
(
  factory_code     VARCHAR2(10),
  pickup_type      VARCHAR2(30),
  area             VARCHAR2(20),
  car_type         VARCHAR2(10),
  route_code       VARCHAR2(20),
  total_no         VARCHAR2(30),
  merge_no         NUMBER(10),
  dr_sort_id_start NUMBER(10),
  dr_sort_id_end   NUMBER(10),
  today_no         NUMBER(10),
  pick_date        DATE,
  arrive_date      DATE,
  assemble_date    DATE,
  order_no         VARCHAR2(50),
  purchase_no      VARCHAR2(50),
  sup_factory      VARCHAR2(20),
  unload_port      VARCHAR2(10),
  workday          VARCHAR2(20),
  wwl_manager      VARCHAR2(20),
  nwl_manager      VARCHAR2(20),
  rec_date         DATE,
  logistic_flag    VARCHAR2(10),
  supplier_no      VARCHAR2(20),
  order_type       VARCHAR2(20),
  creation_time    DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_ORDER_CAL.factory_code
  is '????';
comment on column MM_PUP_ORDER_CAL.pickup_type
  is '??????';
comment on column MM_PUP_ORDER_CAL.area
  is '??';
comment on column MM_PUP_ORDER_CAL.car_type
  is '??';
comment on column MM_PUP_ORDER_CAL.route_code
  is '????';
comment on column MM_PUP_ORDER_CAL.total_no
  is '????';
comment on column MM_PUP_ORDER_CAL.merge_no
  is '????';
comment on column MM_PUP_ORDER_CAL.dr_sort_id_start
  is 'dockrange??';
comment on column MM_PUP_ORDER_CAL.dr_sort_id_end
  is 'dockrange??';
comment on column MM_PUP_ORDER_CAL.today_no
  is '????';
comment on column MM_PUP_ORDER_CAL.pick_date
  is '??????';
comment on column MM_PUP_ORDER_CAL.arrive_date
  is '??????';
comment on column MM_PUP_ORDER_CAL.assemble_date
  is '??????';
comment on column MM_PUP_ORDER_CAL.order_no
  is '????';
comment on column MM_PUP_ORDER_CAL.purchase_no
  is '????';
comment on column MM_PUP_ORDER_CAL.sup_factory
  is '?????';
comment on column MM_PUP_ORDER_CAL.unload_port
  is '????';
comment on column MM_PUP_ORDER_CAL.workday
  is '???';
comment on column MM_PUP_ORDER_CAL.wwl_manager
  is '??ID';
comment on column MM_PUP_ORDER_CAL.nwl_manager
  is '??????';
comment on column MM_PUP_ORDER_CAL.rec_date
  is '????';
comment on column MM_PUP_ORDER_CAL.logistic_flag
  is '???? GAM GAM VMI VMI';
comment on column MM_PUP_ORDER_CAL.supplier_no
  is '?????';
comment on column MM_PUP_ORDER_CAL.order_type
  is '????';
comment on column MM_PUP_ORDER_CAL.creation_time
  is '????';

prompt
prompt Creating table MM_PUP_ORDER_RECORD
prompt ==================================
prompt
create table MM_PUP_ORDER_RECORD
(
  plan_order_id    NUMBER(19),
  supplier_no      VARCHAR2(20),
  sup_factory      VARCHAR2(20),
  unload_port      VARCHAR2(10),
  part_no          VARCHAR2(20),
  logistic_flag    VARCHAR2(10),
  group_id         NUMBER(10),
  order_no         VARCHAR2(50),
  dr_sort_id_start NUMBER(10),
  dr_sort_id_end   NUMBER(10),
  lr_sort_id_start NUMBER(10),
  lr_sort_id_end   NUMBER(10),
  order_num        NUMBER(10),
  total_order_num  NUMBER(10),
  issue_date       DATE,
  arrive_time      DATE,
  order_status     NUMBER(1),
  factory_code     VARCHAR2(10),
  order_type       NUMBER(1),
  car_type_dist    VARCHAR2(10),
  creation_time    DATE default sysdate,
  logistics_order  VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_ORDER_RECORD.logistic_flag
  is 'GAM GAM VMI VMI';
comment on column MM_PUP_ORDER_RECORD.group_id
  is '???';
comment on column MM_PUP_ORDER_RECORD.dr_sort_id_start
  is 'dockrange??';
comment on column MM_PUP_ORDER_RECORD.dr_sort_id_end
  is 'dockrange??';
comment on column MM_PUP_ORDER_RECORD.lr_sort_id_start
  is 'linesiderange??';
comment on column MM_PUP_ORDER_RECORD.lr_sort_id_end
  is 'linesiderange??';
comment on column MM_PUP_ORDER_RECORD.order_type
  is '0 ???? 1 ??????';
comment on column MM_PUP_ORDER_RECORD.logistics_order
  is '????';

prompt
prompt Creating table MM_PUP_PRO_PLAN
prompt ==============================
prompt
create table MM_PUP_PRO_PLAN
(
  factory_code       VARCHAR2(10) not null,
  sort_id            NUMBER(10) not null,
  order_no           VARCHAR2(50),
  car_type           VARCHAR2(10),
  mark               VARCHAR2(20),
  mix_sort_id        VARCHAR2(200),
  single_sort_id     NUMBER(15),
  afoff_time         DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  send_flag          NUMBER(1) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_PRO_PLAN.factory_code
  is '??';
comment on column MM_PUP_PRO_PLAN.sort_id
  is '???';
comment on column MM_PUP_PRO_PLAN.order_no
  is '???';
comment on column MM_PUP_PRO_PLAN.car_type
  is '??';
comment on column MM_PUP_PRO_PLAN.mark
  is '??';
comment on column MM_PUP_PRO_PLAN.mix_sort_id
  is '??????';
comment on column MM_PUP_PRO_PLAN.single_sort_id
  is '?????';
comment on column MM_PUP_PRO_PLAN.afoff_time
  is '??????';
comment on column MM_PUP_PRO_PLAN.send_flag
  is '??????';
create index IDX_MM_PUP_PRO_PLAN1 on MM_PUP_PRO_PLAN (SINGLE_SORT_ID)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_PUP_PRO_PLAN2 on MM_PUP_PRO_PLAN (AFOFF_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUP_PRO_PLAN
  add constraint PK_MM_PUP_PRO_PLAN primary key (FACTORY_CODE, SORT_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUP_PRO_PLAN_IMP
prompt ==================================
prompt
create table MM_PUP_PRO_PLAN_IMP
(
  id             NUMBER(19) not null,
  factory_code   VARCHAR2(10),
  sort_id        NUMBER(15),
  order_no       VARCHAR2(50),
  car_type       VARCHAR2(10),
  mark           VARCHAR2(20),
  mix_sort_id    VARCHAR2(200),
  single_sort_id NUMBER(15),
  afoff_time     DATE,
  imp_uuid       VARCHAR2(50),
  check_result   NUMBER(1),
  check_info     VARCHAR2(300),
  import_status  NUMBER(1),
  ope_type       VARCHAR2(8),
  creation_user  VARCHAR2(30),
  creation_time  DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_PRO_PLAN_IMP.factory_code
  is '????';
comment on column MM_PUP_PRO_PLAN_IMP.sort_id
  is '???';
comment on column MM_PUP_PRO_PLAN_IMP.order_no
  is '???';
comment on column MM_PUP_PRO_PLAN_IMP.car_type
  is '??';
comment on column MM_PUP_PRO_PLAN_IMP.mark
  is '??';
comment on column MM_PUP_PRO_PLAN_IMP.mix_sort_id
  is '??????';
comment on column MM_PUP_PRO_PLAN_IMP.single_sort_id
  is '?????';
comment on column MM_PUP_PRO_PLAN_IMP.afoff_time
  is '??????';
comment on column MM_PUP_PRO_PLAN_IMP.check_result
  is '???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_PUP_PRO_PLAN_IMP.import_status
  is '0-???
1-???';
comment on column MM_PUP_PRO_PLAN_IMP.ope_type
  is 'I ?? U??';
alter table MM_PUP_PRO_PLAN_IMP
  add constraint PK_MM_PUP_PRO_PLAN_IMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUP_PRO_PLAN_TEMP
prompt ===================================
prompt
create table MM_PUP_PRO_PLAN_TEMP
(
  factory_code  VARCHAR2(10),
  car_type      VARCHAR2(10),
  mix_sort_id   VARCHAR2(200),
  afoff_time    DATE,
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_PRO_PLAN_TEMP.factory_code
  is '????';
comment on column MM_PUP_PRO_PLAN_TEMP.car_type
  is '??';
comment on column MM_PUP_PRO_PLAN_TEMP.mix_sort_id
  is '??????';
comment on column MM_PUP_PRO_PLAN_TEMP.afoff_time
  is '??????';

prompt
prompt Creating table MM_PUP_ROUTE
prompt ===========================
prompt
create table MM_PUP_ROUTE
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  area               VARCHAR2(20),
  unload_place       VARCHAR2(30),
  supplier_no        VARCHAR2(20),
  sup_factory        VARCHAR2(20),
  unload_port        VARCHAR2(20),
  car_type           VARCHAR2(10),
  sup_cal_num        NUMBER(10),
  start_sort_id      NUMBER(10),
  ware_code          VARCHAR2(20),
  pickup_type        VARCHAR2(20),
  route_code         VARCHAR2(20),
  route_name         VARCHAR2(50),
  pickup_car         VARCHAR2(30),
  loc_depth          NUMBER(10) default 0,
  advance_arr_num    NUMBER(10),
  first_arrive_time  DATE,
  spe_arrive_time    DATE,
  trans_time         NUMBER(10,2),
  rec_shift_a        VARCHAR2(30),
  rec_shift_b        VARCHAR2(30),
  merge_num          NUMBER(10) default 0,
  wwl_manager        VARCHAR2(20),
  nwl_manager        VARCHAR2(20),
  pick_cycle         VARCHAR2(20),
  sup_out_time       DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  first_sort_id      NUMBER(10),
  batch              NUMBER(1),
  route_dist         VARCHAR2(15),
  depart_time_point  NUMBER(10),
  ret_empty_platform VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_ROUTE.factory_code
  is '????';
comment on column MM_PUP_ROUTE.area
  is '??';
comment on column MM_PUP_ROUTE.unload_place
  is '???';
comment on column MM_PUP_ROUTE.supplier_no
  is '?????';
comment on column MM_PUP_ROUTE.sup_factory
  is '?????';
comment on column MM_PUP_ROUTE.unload_port
  is '????';
comment on column MM_PUP_ROUTE.car_type
  is '??';
comment on column MM_PUP_ROUTE.sup_cal_num
  is '????????';
comment on column MM_PUP_ROUTE.start_sort_id
  is '?????????sortid';
comment on column MM_PUP_ROUTE.ware_code
  is '????';
comment on column MM_PUP_ROUTE.pickup_type
  is '??????';
comment on column MM_PUP_ROUTE.route_code
  is '????';
comment on column MM_PUP_ROUTE.route_name
  is '????';
comment on column MM_PUP_ROUTE.pickup_car
  is '????';
comment on column MM_PUP_ROUTE.loc_depth
  is '????';
comment on column MM_PUP_ROUTE.advance_arr_num
  is '?????';
comment on column MM_PUP_ROUTE.first_arrive_time
  is '??????';
comment on column MM_PUP_ROUTE.spe_arrive_time
  is '??????';
comment on column MM_PUP_ROUTE.trans_time
  is '?????????';
comment on column MM_PUP_ROUTE.rec_shift_a
  is 'A???';
comment on column MM_PUP_ROUTE.rec_shift_b
  is 'B???';
comment on column MM_PUP_ROUTE.merge_num
  is '????';
comment on column MM_PUP_ROUTE.wwl_manager
  is '??ID';
comment on column MM_PUP_ROUTE.nwl_manager
  is '??????';
comment on column MM_PUP_ROUTE.pick_cycle
  is '????';
comment on column MM_PUP_ROUTE.sup_out_time
  is '???????';
comment on column MM_PUP_ROUTE.first_sort_id
  is '??????SORTID';
comment on column MM_PUP_ROUTE.batch
  is '?????? 0 ? 1?';
comment on column MM_PUP_ROUTE.route_dist
  is '???????????';
comment on column MM_PUP_ROUTE.depart_time_point
  is '??????';
comment on column MM_PUP_ROUTE.ret_empty_platform
  is '????';
alter table MM_PUP_ROUTE
  add constraint PK_MM_PUP_ROUTE primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_PUP_ROUTE
  add constraint AK_MM_PUP_ROUTE unique (FACTORY_CODE, SUPPLIER_NO, SUP_FACTORY, UNLOAD_PORT, ROUTE_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUP_ROUTE_CAL
prompt ===============================
prompt
create table MM_PUP_ROUTE_CAL
(
  id              NUMBER(19),
  area            VARCHAR2(20),
  pickup_type     VARCHAR2(30),
  car_type        VARCHAR2(10),
  route_code      VARCHAR2(20),
  total_no        VARCHAR2(30),
  merge_no        NUMBER(10),
  today_no        NUMBER(10),
  pick_time       DATE,
  arrive_time     DATE,
  assemble_time   DATE,
  adj_pickup_time DATE,
  unload_place    VARCHAR2(50),
  factory_code    VARCHAR2(10),
  merge_num       NUMBER(10),
  workday         VARCHAR2(20),
  creation_time   DATE default SYSDATE,
  start_sort_id   NUMBER(10),
  end_sort_id     NUMBER(10),
  unload_port     VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_ROUTE_CAL.area
  is '??';
comment on column MM_PUP_ROUTE_CAL.pickup_type
  is '??????';
comment on column MM_PUP_ROUTE_CAL.car_type
  is '????';
comment on column MM_PUP_ROUTE_CAL.route_code
  is '????';
comment on column MM_PUP_ROUTE_CAL.total_no
  is '????';
comment on column MM_PUP_ROUTE_CAL.merge_no
  is '????';
comment on column MM_PUP_ROUTE_CAL.today_no
  is '????';
comment on column MM_PUP_ROUTE_CAL.pick_time
  is '????';
comment on column MM_PUP_ROUTE_CAL.arrive_time
  is '????';
comment on column MM_PUP_ROUTE_CAL.assemble_time
  is '????';
comment on column MM_PUP_ROUTE_CAL.adj_pickup_time
  is '??????';
comment on column MM_PUP_ROUTE_CAL.unload_place
  is '???';
comment on column MM_PUP_ROUTE_CAL.factory_code
  is '????';
comment on column MM_PUP_ROUTE_CAL.merge_num
  is '????';
comment on column MM_PUP_ROUTE_CAL.workday
  is '???';
comment on column MM_PUP_ROUTE_CAL.creation_time
  is '????';
comment on column MM_PUP_ROUTE_CAL.start_sort_id
  is '??sort_id';
comment on column MM_PUP_ROUTE_CAL.end_sort_id
  is '??sort_id';
comment on column MM_PUP_ROUTE_CAL.unload_port
  is '????';

prompt
prompt Creating table MM_PUP_ROUTE_CAL_TEMP
prompt ====================================
prompt
create table MM_PUP_ROUTE_CAL_TEMP
(
  id                 NUMBER(19),
  factory_code       VARCHAR2(10),
  area               VARCHAR2(20),
  sup_factory        VARCHAR2(20),
  unload_port        VARCHAR2(10),
  unload_place       VARCHAR2(30),
  car_type           VARCHAR2(10),
  route_code         VARCHAR2(20),
  total_no           VARCHAR2(30),
  start_sort_id      NUMBER(10),
  end_sort_id        NUMBER(10),
  pick_time          DATE,
  arrive_time        DATE,
  assemble_time      DATE,
  advance_arr_num    NUMBER(10),
  trans_time         NUMBER(10,2),
  pick_cycle         VARCHAR2(30),
  adj_pickup_time    DATE,
  merge_num          NUMBER(10),
  first_arrive_time  DATE,
  sup_deliv_time     DATE,
  spe_arr_time       DATE,
  creation_time      DATE default SYSDATE,
  flag               NUMBER(1),
  assembleid         NUMBER(10),
  token_num          NUMBER(10),
  pickup_type        VARCHAR2(30),
  depart_time_point  NUMBER(10),
  ret_empty_platform VARCHAR2(10),
  supplier_no        VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_ROUTE_CAL_TEMP.factory_code
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.area
  is '??';
comment on column MM_PUP_ROUTE_CAL_TEMP.sup_factory
  is '???';
comment on column MM_PUP_ROUTE_CAL_TEMP.unload_port
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.unload_place
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.car_type
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.route_code
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.total_no
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.start_sort_id
  is '??sort_id';
comment on column MM_PUP_ROUTE_CAL_TEMP.end_sort_id
  is '??sort_id';
comment on column MM_PUP_ROUTE_CAL_TEMP.pick_time
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.arrive_time
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.assemble_time
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.advance_arr_num
  is '?????';
comment on column MM_PUP_ROUTE_CAL_TEMP.trans_time
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.pick_cycle
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.adj_pickup_time
  is '??????';
comment on column MM_PUP_ROUTE_CAL_TEMP.merge_num
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.first_arrive_time
  is '??????';
comment on column MM_PUP_ROUTE_CAL_TEMP.sup_deliv_time
  is '???????';
comment on column MM_PUP_ROUTE_CAL_TEMP.spe_arr_time
  is '??????';
comment on column MM_PUP_ROUTE_CAL_TEMP.creation_time
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.pickup_type
  is '??????';
comment on column MM_PUP_ROUTE_CAL_TEMP.depart_time_point
  is '??????';
comment on column MM_PUP_ROUTE_CAL_TEMP.ret_empty_platform
  is '????';
comment on column MM_PUP_ROUTE_CAL_TEMP.supplier_no
  is '?????';

prompt
prompt Creating table MM_PUP_ROUTE_IMP
prompt ===============================
prompt
create table MM_PUP_ROUTE_IMP
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  area               VARCHAR2(20),
  route_dist         VARCHAR2(20),
  unload_place       VARCHAR2(30),
  supplier_no        VARCHAR2(20),
  sup_factory        VARCHAR2(20),
  unload_port        VARCHAR2(20),
  car_type           VARCHAR2(10),
  sup_cal_num        NUMBER(10),
  start_sort_id      NUMBER(10),
  ware_code          VARCHAR2(20),
  route_code         VARCHAR2(20),
  route_name         VARCHAR2(30),
  pickup_type        VARCHAR2(20),
  pickup_car         VARCHAR2(30),
  loc_depth          NUMBER(10) default 0,
  advance_arr_num    NUMBER(10),
  first_arrive_time  DATE,
  spe_arrive_time    DATE,
  trans_time         NUMBER(10,2),
  rec_shift_a        VARCHAR2(30),
  rec_shift_b        VARCHAR2(30),
  merge_num          NUMBER(10) default 0,
  wwl_manager        VARCHAR2(30),
  nwl_manager        VARCHAR2(30),
  pick_cycle         VARCHAR2(20),
  sup_out_time       DATE,
  batch              NUMBER(1),
  depart_time_point  NUMBER(10),
  ret_empty_platform VARCHAR2(10),
  imp_uuid           VARCHAR2(50),
  check_result       NUMBER(1),
  check_info         VARCHAR2(300),
  import_status      NUMBER(1),
  ope_type           VARCHAR2(8),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_ROUTE_IMP.factory_code
  is '????';
comment on column MM_PUP_ROUTE_IMP.area
  is '??';
comment on column MM_PUP_ROUTE_IMP.route_dist
  is '????';
comment on column MM_PUP_ROUTE_IMP.unload_place
  is '???';
comment on column MM_PUP_ROUTE_IMP.supplier_no
  is '?????';
comment on column MM_PUP_ROUTE_IMP.sup_factory
  is '?????';
comment on column MM_PUP_ROUTE_IMP.unload_port
  is '????';
comment on column MM_PUP_ROUTE_IMP.car_type
  is '??';
comment on column MM_PUP_ROUTE_IMP.sup_cal_num
  is '???';
comment on column MM_PUP_ROUTE_IMP.start_sort_id
  is '??sortid';
comment on column MM_PUP_ROUTE_IMP.ware_code
  is '????';
comment on column MM_PUP_ROUTE_IMP.route_code
  is '????';
comment on column MM_PUP_ROUTE_IMP.route_name
  is '????';
comment on column MM_PUP_ROUTE_IMP.pickup_type
  is '??????';
comment on column MM_PUP_ROUTE_IMP.pickup_car
  is '????';
comment on column MM_PUP_ROUTE_IMP.loc_depth
  is '????';
comment on column MM_PUP_ROUTE_IMP.advance_arr_num
  is '?????';
comment on column MM_PUP_ROUTE_IMP.first_arrive_time
  is '??????';
comment on column MM_PUP_ROUTE_IMP.spe_arrive_time
  is '??????';
comment on column MM_PUP_ROUTE_IMP.trans_time
  is '?????????';
comment on column MM_PUP_ROUTE_IMP.rec_shift_a
  is 'A???';
comment on column MM_PUP_ROUTE_IMP.rec_shift_b
  is 'B???';
comment on column MM_PUP_ROUTE_IMP.merge_num
  is '????';
comment on column MM_PUP_ROUTE_IMP.wwl_manager
  is '??ID';
comment on column MM_PUP_ROUTE_IMP.nwl_manager
  is '??????';
comment on column MM_PUP_ROUTE_IMP.pick_cycle
  is '????';
comment on column MM_PUP_ROUTE_IMP.sup_out_time
  is '???????';
comment on column MM_PUP_ROUTE_IMP.batch
  is '0-? 1-?';
comment on column MM_PUP_ROUTE_IMP.check_result
  is '???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_PUP_ROUTE_IMP.import_status
  is '0-???
1-???';
comment on column MM_PUP_ROUTE_IMP.ope_type
  is 'I ?? U??';
alter table MM_PUP_ROUTE_IMP
  add constraint PK_MM_PUP_ROUTE_IMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_PUP_VERSION
prompt =============================
prompt
create table MM_PUP_VERSION
(
  id            NUMBER(19),
  factory_code  VARCHAR2(10),
  area          VARCHAR2(20),
  unload_place  VARCHAR2(30),
  pickup_type   VARCHAR2(30),
  car_type      VARCHAR2(10),
  route_code    VARCHAR2(20),
  total_no      VARCHAR2(30),
  merge_no      NUMBER(10),
  workday       DATE,
  today_no      NUMBER(10),
  pick_date     DATE,
  arrive_date   DATE,
  assemble_date DATE,
  creation_time DATE,
  unload_port   VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_VERSION.factory_code
  is '????';
comment on column MM_PUP_VERSION.area
  is '??';
comment on column MM_PUP_VERSION.unload_place
  is '???';
comment on column MM_PUP_VERSION.pickup_type
  is '??????';
comment on column MM_PUP_VERSION.car_type
  is '??';
comment on column MM_PUP_VERSION.route_code
  is '????';
comment on column MM_PUP_VERSION.total_no
  is '????';
comment on column MM_PUP_VERSION.merge_no
  is '????';
comment on column MM_PUP_VERSION.workday
  is '???';
comment on column MM_PUP_VERSION.today_no
  is '????';
comment on column MM_PUP_VERSION.pick_date
  is '????';
comment on column MM_PUP_VERSION.arrive_date
  is '????';
comment on column MM_PUP_VERSION.assemble_date
  is '????';
comment on column MM_PUP_VERSION.creation_time
  is '????';
comment on column MM_PUP_VERSION.unload_port
  is '????';

prompt
prompt Creating table MM_PUP_VERSION_RECORD
prompt ====================================
prompt
create table MM_PUP_VERSION_RECORD
(
  factory_code  VARCHAR2(10),
  area          VARCHAR2(20),
  unload_place  VARCHAR2(30),
  pickup_type   VARCHAR2(30),
  unload_port   VARCHAR2(10),
  car_type      VARCHAR2(10),
  version_no    VARCHAR2(50),
  route_code    VARCHAR2(20),
  total_no      VARCHAR2(30),
  merge_no      NUMBER(10),
  workday       DATE,
  today_no      NUMBER(10),
  pick_date     DATE,
  arrive_date   DATE,
  assemble_date DATE,
  creation_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_PUP_VERSION_RECORD.factory_code
  is '????';
comment on column MM_PUP_VERSION_RECORD.area
  is '??';
comment on column MM_PUP_VERSION_RECORD.unload_place
  is '???';
comment on column MM_PUP_VERSION_RECORD.pickup_type
  is '??????';
comment on column MM_PUP_VERSION_RECORD.unload_port
  is '????';
comment on column MM_PUP_VERSION_RECORD.car_type
  is '??';
comment on column MM_PUP_VERSION_RECORD.version_no
  is '???';
comment on column MM_PUP_VERSION_RECORD.route_code
  is '????';
comment on column MM_PUP_VERSION_RECORD.total_no
  is '????';
comment on column MM_PUP_VERSION_RECORD.merge_no
  is '????';
comment on column MM_PUP_VERSION_RECORD.workday
  is '???';
comment on column MM_PUP_VERSION_RECORD.today_no
  is '????';
comment on column MM_PUP_VERSION_RECORD.pick_date
  is '????';
comment on column MM_PUP_VERSION_RECORD.arrive_date
  is '????';
comment on column MM_PUP_VERSION_RECORD.assemble_date
  is '????';
comment on column MM_PUP_VERSION_RECORD.creation_time
  is '????';

prompt
prompt Creating table MM_SPS_CONFIG
prompt ============================
prompt
create table MM_SPS_CONFIG
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10) not null,
  production_line    VARCHAR2(20) not null,
  config_code        VARCHAR2(50) not null,
  config_desc        VARCHAR2(100),
  config_type        VARCHAR2(2),
  config_value       VARCHAR2(254),
  is_edit            NUMBER(1) default 1,
  creation_time      DATE default sysdate,
  creation_user      VARCHAR2(30),
  last_modified_user VARCHAR2(30),
  last_modified_ip   VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_CONFIG
  is 'MM_SPS_CONFIG SPS?????
';
comment on column MM_SPS_CONFIG.id
  is 'ID
';
comment on column MM_SPS_CONFIG.factory_code
  is '??
';
comment on column MM_SPS_CONFIG.production_line
  is '??
';
comment on column MM_SPS_CONFIG.config_code
  is '?????
';
comment on column MM_SPS_CONFIG.config_desc
  is '?????
';
comment on column MM_SPS_CONFIG.config_type
  is '????
???????SPS_CONFIG_TYPE"';
comment on column MM_SPS_CONFIG.config_value
  is '???
';
comment on column MM_SPS_CONFIG.is_edit
  is '?????
???????TRUE_FLASE"';
comment on column MM_SPS_CONFIG.creation_time
  is '????
';
comment on column MM_SPS_CONFIG.creation_user
  is '???
';
comment on column MM_SPS_CONFIG.last_modified_user
  is '??????
';
comment on column MM_SPS_CONFIG.last_modified_ip
  is '????IP
';
comment on column MM_SPS_CONFIG.last_modified_time
  is '??????
';
create index IDX_MM_SPS_CONFIG1 on MM_SPS_CONFIG (CONFIG_DESC)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_SPS_CONFIG2 on MM_SPS_CONFIG (CONFIG_TYPE)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SPS_CONFIG
  add constraint PK_MM_SPS_CONFIG primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SPS_CONFIG
  add constraint AK_MM_SPS_CONFIG unique (FACTORY_CODE, PRODUCTION_LINE, CONFIG_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SPS_CONFIG_DETAIL
prompt ===================================
prompt
create table MM_SPS_CONFIG_DETAIL
(
  id                 NUMBER(19) not null,
  config_id          NUMBER(19) not null,
  model_code         VARCHAR2(10) not null,
  station_code       VARCHAR2(20),
  part_no            VARCHAR2(40) not null,
  part_mark          VARCHAR2(50),
  shelf_no           VARCHAR2(50),
  creation_time      DATE default sysdate,
  creation_user      VARCHAR2(30),
  last_modified_user VARCHAR2(30),
  last_modified_ip   VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_CONFIG_DETAIL
  is 'MM_SPS_CONFIG_DETAIL SPS?????
';
comment on column MM_SPS_CONFIG_DETAIL.id
  is 'ID
';
comment on column MM_SPS_CONFIG_DETAIL.config_id
  is '???ID
MM_SPS_CONFIG_ITEM.ID';
comment on column MM_SPS_CONFIG_DETAIL.model_code
  is '??
';
comment on column MM_SPS_CONFIG_DETAIL.station_code
  is '??
';
comment on column MM_SPS_CONFIG_DETAIL.part_no
  is '????
';
comment on column MM_SPS_CONFIG_DETAIL.part_mark
  is '????
';
comment on column MM_SPS_CONFIG_DETAIL.shelf_no
  is '???
';
comment on column MM_SPS_CONFIG_DETAIL.creation_time
  is '????
';
comment on column MM_SPS_CONFIG_DETAIL.creation_user
  is '???
';
comment on column MM_SPS_CONFIG_DETAIL.last_modified_user
  is '??????
';
comment on column MM_SPS_CONFIG_DETAIL.last_modified_ip
  is '????IP
';
comment on column MM_SPS_CONFIG_DETAIL.last_modified_time
  is '??????
';
alter table MM_SPS_CONFIG_DETAIL
  add constraint PK_MM_SPS_CONFIG_DETAIL primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SPS_CONFIG_DETAIL
  add constraint AK_MM_SPS_CONFIG_DETAIL unique (CONFIG_ID, MODEL_CODE, STATION_CODE, PART_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SPS_CONFIG_DETAIL_IMP
prompt =======================================
prompt
create table MM_SPS_CONFIG_DETAIL_IMP
(
  id              NUMBER(19) not null,
  factory_code    VARCHAR2(10),
  production_line VARCHAR2(20),
  config_code     VARCHAR2(50),
  station_code    VARCHAR2(10),
  part_no         VARCHAR2(40),
  model_code      VARCHAR2(10),
  part_mark       VARCHAR2(20),
  shelf_no        VARCHAR2(20),
  imp_uuid        VARCHAR2(50),
  check_result    NUMBER(1) default 0,
  check_info      VARCHAR2(512),
  import_status   NUMBER(1) default 0,
  continue_check  NUMBER(1) default 1,
  ope_type        VARCHAR2(8) default 'I',
  busi_id         NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_CONFIG_DETAIL_IMP
  is 'MM_SPS_CONFIG_DETAIL_IMP SPS????????????
';
comment on column MM_SPS_CONFIG_DETAIL_IMP.id
  is 'ID
';
comment on column MM_SPS_CONFIG_DETAIL_IMP.factory_code
  is '??
';
comment on column MM_SPS_CONFIG_DETAIL_IMP.production_line
  is '??
';
comment on column MM_SPS_CONFIG_DETAIL_IMP.config_code
  is '?????
';
comment on column MM_SPS_CONFIG_DETAIL_IMP.station_code
  is '??
';
comment on column MM_SPS_CONFIG_DETAIL_IMP.part_no
  is '????
';
comment on column MM_SPS_CONFIG_DETAIL_IMP.model_code
  is '??
';
comment on column MM_SPS_CONFIG_DETAIL_IMP.part_mark
  is '????
';
comment on column MM_SPS_CONFIG_DETAIL_IMP.shelf_no
  is '???
';
comment on column MM_SPS_CONFIG_DETAIL_IMP.imp_uuid
  is '??UUID
';
comment on column MM_SPS_CONFIG_DETAIL_IMP.check_result
  is '????
??????"PUB_IMP_CK_RESULT"';
comment on column MM_SPS_CONFIG_DETAIL_IMP.check_info
  is '????????
';
comment on column MM_SPS_CONFIG_DETAIL_IMP.import_status
  is '????
???????PUB_IMP_STATUS?';
comment on column MM_SPS_CONFIG_DETAIL_IMP.continue_check
  is '??????
0:?
1:?';
comment on column MM_SPS_CONFIG_DETAIL_IMP.ope_type
  is '????????
I:??
U:??';
comment on column MM_SPS_CONFIG_DETAIL_IMP.busi_id
  is '????????
';
alter table MM_SPS_CONFIG_DETAIL_IMP
  add constraint PK_MM_SPS_CONFIG_DETAIL_IMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SPS_CONFIG_IMP
prompt ================================
prompt
create table MM_SPS_CONFIG_IMP
(
  id              NUMBER(19) not null,
  factory_code    VARCHAR2(10),
  production_line VARCHAR2(20),
  config_code     VARCHAR2(50),
  config_desc     VARCHAR2(100),
  config_type     VARCHAR2(2),
  config_value    VARCHAR2(254),
  imp_uuid        VARCHAR2(50),
  check_result    NUMBER(1) default 0,
  check_info      VARCHAR2(512),
  import_status   NUMBER(1) default 0,
  continue_check  NUMBER(1) default 1,
  ope_type        VARCHAR2(8) default 'I',
  busi_id         NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_CONFIG_IMP
  is 'MM_SPS_CONFIG_IMP SPS??????????
';
comment on column MM_SPS_CONFIG_IMP.id
  is 'ID
';
comment on column MM_SPS_CONFIG_IMP.factory_code
  is '??
';
comment on column MM_SPS_CONFIG_IMP.production_line
  is '??
';
comment on column MM_SPS_CONFIG_IMP.config_code
  is '?????
';
comment on column MM_SPS_CONFIG_IMP.config_desc
  is '?????
';
comment on column MM_SPS_CONFIG_IMP.config_type
  is '????
???????SPS_CONFIG_TYPE"';
comment on column MM_SPS_CONFIG_IMP.config_value
  is '???
';
comment on column MM_SPS_CONFIG_IMP.imp_uuid
  is '??UUID
';
comment on column MM_SPS_CONFIG_IMP.check_result
  is '????
??????"PUB_IMP_CK_RESULT"';
comment on column MM_SPS_CONFIG_IMP.check_info
  is '????????
';
comment on column MM_SPS_CONFIG_IMP.import_status
  is '????
???????PUB_IMP_STATUS?';
comment on column MM_SPS_CONFIG_IMP.continue_check
  is '??????
0:?
1:?';
comment on column MM_SPS_CONFIG_IMP.ope_type
  is '????????
I:??
U:??';
comment on column MM_SPS_CONFIG_IMP.busi_id
  is '????????
';
alter table MM_SPS_CONFIG_IMP
  add constraint PK_MM_SPS_CONFIG_IMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SPS_INS
prompt =========================
prompt
create table MM_SPS_INS
(
  ins_no        VARCHAR2(30) not null,
  plan_code     VARCHAR2(20),
  mould_id      NUMBER(19),
  order_no      VARCHAR2(50),
  vin           VARCHAR2(20),
  model_code    VARCHAR2(20),
  phase         VARCHAR2(20),
  wc_seqno      VARCHAR2(10),
  pl_seqno      VARCHAR2(20),
  pass_time     DATE,
  print_status  VARCHAR2(2) default '0',
  print_time    DATE,
  print_user    VARCHAR2(30),
  print_user_ip VARCHAR2(30),
  creation_time DATE default sysdate,
  is_load       NUMBER(1) default 0,
  load_time     DATE,
  inv_flag      NUMBER(1) default 0,
  inv_time      DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_INS
  is 'MM_SPS_INS SPS??????
';
comment on column MM_SPS_INS.ins_no
  is 'SPS????
';
comment on column MM_SPS_INS.plan_code
  is '???
';
comment on column MM_SPS_INS.mould_id
  is '??ID
';
comment on column MM_SPS_INS.order_no
  is '?????
';
comment on column MM_SPS_INS.vin
  is 'VIN?
';
comment on column MM_SPS_INS.model_code
  is '??
';
comment on column MM_SPS_INS.phase
  is '????
';
comment on column MM_SPS_INS.wc_seqno
  is '?????
';
comment on column MM_SPS_INS.pl_seqno
  is '?????
';
comment on column MM_SPS_INS.pass_time
  is '????
';
comment on column MM_SPS_INS.print_status
  is '????
0????
1????';
comment on column MM_SPS_INS.print_time
  is '????
';
comment on column MM_SPS_INS.print_user
  is '????
';
comment on column MM_SPS_INS.print_user_ip
  is '???IP
';
comment on column MM_SPS_INS.creation_time
  is '????
';
comment on column MM_SPS_INS.is_load
  is '????????
';
comment on column MM_SPS_INS.load_time
  is '????????
';
comment on column MM_SPS_INS.inv_flag
  is '??????
0???,1???';
comment on column MM_SPS_INS.inv_time
  is '??????
??????';
create index IDX_MM_SPS_INS1 on MM_SPS_INS (PRINT_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_SPS_INS2 on MM_SPS_INS (PASS_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_SPS_INS3 on MM_SPS_INS (IS_LOAD)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_SPS_INS4 on MM_SPS_INS (VIN)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SPS_INS
  add constraint PK_MM_SPS_INS primary key (INS_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SPS_INS_DETAIL
prompt ================================
prompt
create table MM_SPS_INS_DETAIL
(
  ins_no             VARCHAR2(30) not null,
  mould_place        NUMBER(3) not null,
  config_code        VARCHAR2(50),
  config_desc        VARCHAR2(100),
  config_type        VARCHAR2(2),
  part_no            VARCHAR2(40),
  part_name          VARCHAR2(150),
  quantity           NUMBER(10),
  show_value         VARCHAR2(100),
  creation_time      DATE default SYSDATE,
  last_modified_time DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_INS_DETAIL
  is 'MM_SPS_INS_DETAIL SPS???????
';
comment on column MM_SPS_INS_DETAIL.ins_no
  is '????
MM_SPS_INS.INS_NO';
comment on column MM_SPS_INS_DETAIL.mould_place
  is '???????
';
comment on column MM_SPS_INS_DETAIL.config_code
  is '?????
';
comment on column MM_SPS_INS_DETAIL.config_desc
  is '?????
';
comment on column MM_SPS_INS_DETAIL.config_type
  is '????
???????SPS_CONFIG_TYPE"';
comment on column MM_SPS_INS_DETAIL.part_no
  is '????
';
comment on column MM_SPS_INS_DETAIL.part_name
  is '????
';
comment on column MM_SPS_INS_DETAIL.quantity
  is '??
';
comment on column MM_SPS_INS_DETAIL.show_value
  is '???
';
comment on column MM_SPS_INS_DETAIL.creation_time
  is '????
';
comment on column MM_SPS_INS_DETAIL.last_modified_time
  is '??????
';
create index IDX_MM_SPS_INS_DETAIL1 on MM_SPS_INS_DETAIL (INS_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SPS_INS_DETAIL
  add constraint PK_MM_SPS_INS_DETAIL primary key (INS_NO, MOULD_PLACE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SPS_INS_SN
prompt ============================
prompt
create table MM_SPS_INS_SN
(
  plan_code  VARCHAR2(20) not null,
  mould_code VARCHAR2(20) not null,
  use_date   DATE not null,
  seq_no     NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_INS_SN
  is 'MM_SPS_INS_SN SPS??????
';
comment on column MM_SPS_INS_SN.plan_code
  is '???
';
comment on column MM_SPS_INS_SN.mould_code
  is '????
';
comment on column MM_SPS_INS_SN.use_date
  is '????
';
comment on column MM_SPS_INS_SN.seq_no
  is '???
';
alter table MM_SPS_INS_SN
  add constraint PK_MM_SPS_INS_SN primary key (PLAN_CODE, MOULD_CODE, USE_DATE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SPS_MOULD
prompt ===========================
prompt
create table MM_SPS_MOULD
(
  id                 NUMBER(19) not null,
  mould_code         VARCHAR2(20) not null,
  version            NUMBER(2),
  mould_name         VARCHAR2(50),
  model_code         VARCHAR2(10),
  plan_code          VARCHAR2(20),
  is_enable          NUMBER(1) default 0,
  is_auto_print      NUMBER(1) default 0,
  printer_id         NUMBER(19),
  mould_head_place   NUMBER(19),
  assembly_ins       VARCHAR2(100),
  creation_time      DATE default sysdate,
  creation_user      VARCHAR2(30),
  last_modified_user VARCHAR2(30),
  last_modified_ip   VARCHAR2(30),
  last_modified_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_MOULD
  is 'MM_SPS_MOULD SPS???????
';
comment on column MM_SPS_MOULD.id
  is 'ID
';
comment on column MM_SPS_MOULD.mould_code
  is '????
';
comment on column MM_SPS_MOULD.version
  is '???
';
comment on column MM_SPS_MOULD.mould_name
  is '????
';
comment on column MM_SPS_MOULD.model_code
  is '??
';
comment on column MM_SPS_MOULD.plan_code
  is '???
';
comment on column MM_SPS_MOULD.is_enable
  is '????
???????IS_ENABLE?';
comment on column MM_SPS_MOULD.is_auto_print
  is '??????
???????TRUE_FALSE?';
comment on column MM_SPS_MOULD.printer_id
  is '???ID
';
comment on column MM_SPS_MOULD.mould_head_place
  is '????????';
comment on column MM_SPS_MOULD.assembly_ins
  is '???????
';
comment on column MM_SPS_MOULD.creation_time
  is '????
';
comment on column MM_SPS_MOULD.creation_user
  is '???
';
comment on column MM_SPS_MOULD.last_modified_user
  is '??????
';
comment on column MM_SPS_MOULD.last_modified_ip
  is '????IP
';
comment on column MM_SPS_MOULD.last_modified_time
  is '??????
';
alter table MM_SPS_MOULD
  add constraint PK_MM_SPS_MOULD primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SPS_MOULD_CONFIG
prompt ==================================
prompt
create table MM_SPS_MOULD_CONFIG
(
  id                 NUMBER(19) not null,
  mould_id           NUMBER(19) not null,
  mould_place        NUMBER(3) not null,
  config_show        VARCHAR2(2),
  image_id           NUMBER(19),
  creation_time      DATE default sysdate,
  creation_user      VARCHAR2(30),
  last_modified_time DATE,
  last_modified_user VARCHAR2(30),
  last_modified_ip   VARCHAR2(30),
  config_code        VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_MOULD_CONFIG
  is 'MM_SPS_MOULD_CONFIG SPS???????
';
comment on column MM_SPS_MOULD_CONFIG.id
  is 'ID
';
comment on column MM_SPS_MOULD_CONFIG.mould_id
  is '??ID
MM_SPS_MOULD.ID';
comment on column MM_SPS_MOULD_CONFIG.mould_place
  is '???????
';
comment on column MM_SPS_MOULD_CONFIG.config_show
  is '???????
???????SPS_CONFIG_SHOW"';
comment on column MM_SPS_MOULD_CONFIG.image_id
  is '??ID
';
comment on column MM_SPS_MOULD_CONFIG.creation_time
  is '????
';
comment on column MM_SPS_MOULD_CONFIG.creation_user
  is '???
';
comment on column MM_SPS_MOULD_CONFIG.last_modified_time
  is '??????
';
comment on column MM_SPS_MOULD_CONFIG.last_modified_user
  is '??????
';
comment on column MM_SPS_MOULD_CONFIG.last_modified_ip
  is '????IP
';
comment on column MM_SPS_MOULD_CONFIG.config_code
  is '?????
';
alter table MM_SPS_MOULD_CONFIG
  add constraint PK_MM_SPS_MOULD_CONFIG primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SPS_MOULD_CONFIG
  add constraint AK_AK_MM_SPS_MOULD_CO_MM_SPS_M unique (MOULD_ID, MOULD_PLACE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SPS_MOULD_CONFIG_IMP
prompt ======================================
prompt
create table MM_SPS_MOULD_CONFIG_IMP
(
  id             NUMBER(19) not null,
  mould_id       NUMBER(19),
  mould_place    NUMBER(3),
  config_id      VARCHAR2(20),
  config_show    VARCHAR2(2),
  imp_uuid       VARCHAR2(50),
  check_result   NUMBER(1) default 0,
  check_info     VARCHAR2(512),
  import_status  NUMBER(1) default 0,
  continue_check NUMBER(1) default 1,
  ope_type       VARCHAR2(8) default 'I',
  busi_id        NUMBER(19),
  config_code    VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_MOULD_CONFIG_IMP
  is 'MM_SPS_MOULD_CONFIG_IMP SPS??????????????
';
comment on column MM_SPS_MOULD_CONFIG_IMP.id
  is 'ID
';
comment on column MM_SPS_MOULD_CONFIG_IMP.mould_id
  is '??ID
';
comment on column MM_SPS_MOULD_CONFIG_IMP.mould_place
  is '???????
';
comment on column MM_SPS_MOULD_CONFIG_IMP.config_id
  is '???ID
';
comment on column MM_SPS_MOULD_CONFIG_IMP.config_show
  is '???????
???????SPS_CONFIG_SHOW"';
comment on column MM_SPS_MOULD_CONFIG_IMP.imp_uuid
  is '??UUID
';
comment on column MM_SPS_MOULD_CONFIG_IMP.check_result
  is '????
??????"PUB_IMP_CK_RESULT"';
comment on column MM_SPS_MOULD_CONFIG_IMP.check_info
  is '????????
';
comment on column MM_SPS_MOULD_CONFIG_IMP.import_status
  is '????
???????PUB_IMP_STATUS?';
comment on column MM_SPS_MOULD_CONFIG_IMP.continue_check
  is '??????
0:?
1:?';
comment on column MM_SPS_MOULD_CONFIG_IMP.ope_type
  is '????????
I:??
U:??';
comment on column MM_SPS_MOULD_CONFIG_IMP.busi_id
  is '????????
';
comment on column MM_SPS_MOULD_CONFIG_IMP.config_code
  is '?????
';
alter table MM_SPS_MOULD_CONFIG_IMP
  add constraint PK_MM_SPS_MOULD_CONFIG_IMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SPS_QUEUE_CONFIG
prompt ==================================
prompt
create table MM_SPS_QUEUE_CONFIG
(
  plan_code     VARCHAR2(20) not null,
  is_plan       NUMBER(1) not null,
  max_pass_time DATE,
  work_date     DATE,
  wc_seqno      VARCHAR2(10),
  creation_time DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_QUEUE_CONFIG
  is 'MM_SPS_QUEUE_CONFIG SPS?????????
';
comment on column MM_SPS_QUEUE_CONFIG.plan_code
  is '???
';
comment on column MM_SPS_QUEUE_CONFIG.is_plan
  is '?????';
comment on column MM_SPS_QUEUE_CONFIG.max_pass_time
  is 'SPS???????????
';
comment on column MM_SPS_QUEUE_CONFIG.work_date
  is 'SPS??????????
';
comment on column MM_SPS_QUEUE_CONFIG.wc_seqno
  is 'SPS????????
';
comment on column MM_SPS_QUEUE_CONFIG.creation_time
  is '????
';
alter table MM_SPS_QUEUE_CONFIG
  add constraint PK_MM_SPS_QUEUE_CONFIG primary key (PLAN_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SPS_SHELF_LABLE_IMP
prompt =====================================
prompt
create table MM_SPS_SHELF_LABLE_IMP
(
  id             NUMBER(19) not null,
  part_no        VARCHAR2(40),
  part_short_no  VARCHAR2(10),
  part_name      VARCHAR2(150),
  model_code     VARCHAR2(10),
  shelf_no       VARCHAR2(20),
  shelf_no_view  VARCHAR2(20),
  mark           VARCHAR2(20),
  imp_uuid       VARCHAR2(50),
  check_result   NUMBER(1) default 0,
  check_info     VARCHAR2(512),
  import_status  NUMBER(1) default 0,
  continue_check NUMBER(1) default 1,
  ope_type       VARCHAR2(8) default 'I',
  busi_id        NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_SHELF_LABLE_IMP
  is 'MM_SPS_SHELF_LABLE_IMP SPS????
';
comment on column MM_SPS_SHELF_LABLE_IMP.id
  is 'ID
';
comment on column MM_SPS_SHELF_LABLE_IMP.part_no
  is '????
';
comment on column MM_SPS_SHELF_LABLE_IMP.part_short_no
  is '????
';
comment on column MM_SPS_SHELF_LABLE_IMP.part_name
  is '????
';
comment on column MM_SPS_SHELF_LABLE_IMP.model_code
  is '??
';
comment on column MM_SPS_SHELF_LABLE_IMP.shelf_no
  is '???
';
comment on column MM_SPS_SHELF_LABLE_IMP.shelf_no_view
  is '?????
';
comment on column MM_SPS_SHELF_LABLE_IMP.mark
  is '??
';
comment on column MM_SPS_SHELF_LABLE_IMP.imp_uuid
  is '??UUID
';
comment on column MM_SPS_SHELF_LABLE_IMP.check_result
  is '????
??????"PUB_IMP_CK_RESULT"';
comment on column MM_SPS_SHELF_LABLE_IMP.check_info
  is '????????
';
comment on column MM_SPS_SHELF_LABLE_IMP.import_status
  is '????
???????PUB_IMP_STATUS?';
comment on column MM_SPS_SHELF_LABLE_IMP.continue_check
  is '??????
0:?
1:?';
comment on column MM_SPS_SHELF_LABLE_IMP.ope_type
  is '????????
I:??
U:??';
comment on column MM_SPS_SHELF_LABLE_IMP.busi_id
  is '????????
';
alter table MM_SPS_SHELF_LABLE_IMP
  add constraint PK_MM_SPS_SHELF_LABLE_IMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SPS_TEST_PRINT_IMP
prompt ====================================
prompt
create table MM_SPS_TEST_PRINT_IMP
(
  id           NUMBER(19) not null,
  plan_code    VARCHAR2(20) not null,
  erp_order_no VARCHAR2(20) not null,
  uuid         VARCHAR2(50) not null,
  mould_id     VARCHAR2(20) not null,
  ins_no       VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_TEST_PRINT_IMP
  is 'MM_SPS_TEST_PRINT_IMP SPS????
';
comment on column MM_SPS_TEST_PRINT_IMP.id
  is 'ID
';
comment on column MM_SPS_TEST_PRINT_IMP.plan_code
  is '???
';
comment on column MM_SPS_TEST_PRINT_IMP.erp_order_no
  is 'ERP???
';
comment on column MM_SPS_TEST_PRINT_IMP.uuid
  is 'UUID
';
comment on column MM_SPS_TEST_PRINT_IMP.mould_id
  is '??ID';
comment on column MM_SPS_TEST_PRINT_IMP.ins_no
  is '????
';
alter table MM_SPS_TEST_PRINT_IMP
  add constraint PK_MM_SPS_TEST_PRINT_IMP primary key (ID, PLAN_CODE, ERP_ORDER_NO, UUID, MOULD_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SPS_VEH_QUEUE
prompt ===============================
prompt
create table MM_SPS_VEH_QUEUE
(
  plan_code     VARCHAR2(20) not null,
  order_no      VARCHAR2(50) not null,
  erp_order_no  VARCHAR2(50) not null,
  vin           VARCHAR2(20),
  model_code    VARCHAR2(20),
  phase         VARCHAR2(20),
  pass_time     DATE,
  wc_seqno      VARCHAR2(10),
  pl_seqno      VARCHAR2(20),
  mtco          VARCHAR2(50),
  exec_status   NUMBER(1) default 0,
  exec_time     DATE,
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SPS_VEH_QUEUE
  is 'MM_SPS_VEH_QUEUE SPS??????
';
comment on column MM_SPS_VEH_QUEUE.plan_code
  is '???
';
comment on column MM_SPS_VEH_QUEUE.order_no
  is '?????
';
comment on column MM_SPS_VEH_QUEUE.erp_order_no
  is 'ERP?????
';
comment on column MM_SPS_VEH_QUEUE.vin
  is 'VIN
';
comment on column MM_SPS_VEH_QUEUE.model_code
  is '??
';
comment on column MM_SPS_VEH_QUEUE.phase
  is '????
';
comment on column MM_SPS_VEH_QUEUE.pass_time
  is '????
';
comment on column MM_SPS_VEH_QUEUE.wc_seqno
  is '?????
';
comment on column MM_SPS_VEH_QUEUE.pl_seqno
  is '?????
';
comment on column MM_SPS_VEH_QUEUE.mtco
  is 'MTCO';
comment on column MM_SPS_VEH_QUEUE.exec_status
  is '????
??????" TRUE_FLASE"';
comment on column MM_SPS_VEH_QUEUE.exec_time
  is '????
';
comment on column MM_SPS_VEH_QUEUE.creation_time
  is '????
';
create index IDX_MM_SPS_VEH_QUEUE1 on MM_SPS_VEH_QUEUE (EXEC_STATUS)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_SPS_VEH_QUEUE2 on MM_SPS_VEH_QUEUE (PASS_TIME DESC)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SPS_VEH_QUEUE
  add constraint PK_MM_SPS_VEH_QUEUE primary key (ORDER_NO, PLAN_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SW_ACCOUNT_BILL
prompt =================================
prompt
create table MM_SW_ACCOUNT_BILL
(
  bill_no            VARCHAR2(30) not null,
  factory_code       VARCHAR2(10),
  supplier_no        VARCHAR2(20),
  tax_excluded       NUMBER(19,3),
  tax_inclusive      NUMBER(19,3),
  total_tax          NUMBER(19,3),
  make_date          DATE,
  currency_type      VARCHAR2(20),
  rebate             NUMBER(19,3),
  rebate_desc        VARCHAR2(300),
  deduct_money       NUMBER(19,3),
  deduct_money_desc  VARCHAR2(300),
  year_adjust        NUMBER(19,3),
  year_adjust_desc   VARCHAR2(300),
  mould_amount       NUMBER(19,3),
  mould_amount_desc  VARCHAR2(300),
  pay_term           VARCHAR2(100),
  invoice_status     NUMBER(1) default 0,
  invoice_entry_time DATE,
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  remark             VARCHAR2(300),
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  submit_status      NUMBER(1) default 0,
  account_status     VARCHAR2(10),
  do_flag            VARCHAR2(10),
  deal_flag2         NUMBER(1) default 0,
  deal_time2         DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_ACCOUNT_BILL
  is 'MM_SW_ACCOUNT_BILL??????
MM_SW_ACCOUNT_BILL??????
MM_SW_ACCOUNT_BILL??????
';
comment on column MM_SW_ACCOUNT_BILL.bill_no
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL.factory_code
  is '??
??
??
';
comment on column MM_SW_ACCOUNT_BILL.supplier_no
  is '?????
?????
?????
';
comment on column MM_SW_ACCOUNT_BILL.tax_excluded
  is '????????
????????
????????
';
comment on column MM_SW_ACCOUNT_BILL.tax_inclusive
  is '???????
???????
???????
';
comment on column MM_SW_ACCOUNT_BILL.total_tax
  is '???????
???????
???????
';
comment on column MM_SW_ACCOUNT_BILL.make_date
  is '????
????
????
';
comment on column MM_SW_ACCOUNT_BILL.currency_type
  is '????
????
????
';
comment on column MM_SW_ACCOUNT_BILL.rebate
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL.rebate_desc
  is '???????
???????
???????
';
comment on column MM_SW_ACCOUNT_BILL.deduct_money
  is '?????
?????
?????
';
comment on column MM_SW_ACCOUNT_BILL.deduct_money_desc
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL.year_adjust
  is '?????
?????
?????
';
comment on column MM_SW_ACCOUNT_BILL.year_adjust_desc
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL.mould_amount
  is '?????
?????
?????
';
comment on column MM_SW_ACCOUNT_BILL.mould_amount_desc
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL.pay_term
  is '????
????
????
';
comment on column MM_SW_ACCOUNT_BILL.invoice_status
  is '??????
??????
??????
0-???
1-???
';
comment on column MM_SW_ACCOUNT_BILL.invoice_entry_time
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL.deal_flag
  is '??????
??????
??????
0-???
1-???';
comment on column MM_SW_ACCOUNT_BILL.deal_time
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL.remark
  is '??
??
??
';
comment on column MM_SW_ACCOUNT_BILL.creation_user
  is '???
???
???
';
comment on column MM_SW_ACCOUNT_BILL.creation_time
  is '????
????
????
';
comment on column MM_SW_ACCOUNT_BILL.last_modified_user
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL.last_modified_time
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL.submit_status
  is '????
????
????
';
comment on column MM_SW_ACCOUNT_BILL.do_flag
  is '????
????
I-???U-???D-??';
comment on column MM_SW_ACCOUNT_BILL.deal_flag2
  is '????
????
0 ??? 1???';
comment on column MM_SW_ACCOUNT_BILL.deal_time2
  is '????
????
';
create index IDX_MM_SW_ACCOUNT_BILL1 on MM_SW_ACCOUNT_BILL (MAKE_DATE)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_SW_ACCOUNT_BILL2 on MM_SW_ACCOUNT_BILL (DEAL_FLAG)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;
create index IDX_MM_SW_ACCOUNT_BILL3 on MM_SW_ACCOUNT_BILL (INVOICE_STATUS)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SW_ACCOUNT_BILL
  add constraint PK_MM_SW_ACCOUNT_BILL primary key (BILL_NO)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SW_ACCOUNT_BILL_DETAIL
prompt ========================================
prompt
create table MM_SW_ACCOUNT_BILL_DETAIL
(
  bill_no               VARCHAR2(30) not null,
  bill_row_no           NUMBER(10) not null,
  purchase_no           VARCHAR2(50),
  purchase_row_no       NUMBER(10),
  rec_voucher_year      VARCHAR2(20),
  rec_voucher_billno    VARCHAR2(50),
  rec_voucher_rowno     NUMBER(10),
  ref_rec_voucher_bill  VARCHAR2(50),
  ref_rec_voucher_rowno NUMBER(10),
  rec_date              DATE,
  loan_flag             VARCHAR2(10),
  price_status          NUMBER(1),
  eva_price             NUMBER(19,3),
  official_price        NUMBER(19,3),
  adjust_diff_price     NUMBER(19,3),
  eva_price_percent     NUMBER(19,3),
  eva_settle_price      NUMBER(19,3),
  erp_factory_code      VARCHAR2(10),
  part_no               VARCHAR2(20),
  supplier_no           VARCHAR2(20),
  rec_num               NUMBER(19,3),
  pay_amount            NUMBER(19,3),
  tax_rate              NUMBER(19,3),
  tax_amount            NUMBER(19,3),
  currency_type         VARCHAR2(20),
  part_unit             VARCHAR2(20),
  do_flag               VARCHAR2(10),
  deal_flag             NUMBER(1) default 0,
  deal_time             DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_ACCOUNT_BILL_DETAIL
  is 'MM_SW_ACCOUNT_BILL_DETAIL????????
MM_SW_ACCOUNT_BILL_DETAIL????????
MM_SW_ACCOUNT_BILL_DETAIL????????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.bill_no
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.bill_row_no
  is '?????
?????
?????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.purchase_no
  is '?????
?????
?????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.purchase_row_no
  is '?????
?????
?????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.rec_voucher_year
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.rec_voucher_billno
  is '????
????
????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.rec_voucher_rowno
  is '???????
???????
???????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.ref_rec_voucher_bill
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.ref_rec_voucher_rowno
  is '?????????
?????????
?????????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.rec_date
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.loan_flag
  is '????
????
????
S-??
H-??';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.price_status
  is '????
????
????
1-????
2-????
3-???';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.eva_price
  is '???(???)
???(???)
???(???)
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.official_price
  is '???(???)
???(???)
???(???)
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.adjust_diff_price
  is '????(???)
????(???)
????(???)
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.eva_price_percent
  is '??(???)???
??(???)???
??(???)???
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.eva_settle_price
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.erp_factory_code
  is 'ERP????
ERP????
ERP????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.part_no
  is '???
???
???
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.supplier_no
  is '?????
?????
?????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.rec_num
  is '?????
?????
?????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.pay_amount
  is '??(???)??
??(???)??
??(???)??
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.tax_rate
  is '??
??
??
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.tax_amount
  is '??
??
??
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.currency_type
  is '????
????
????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.part_unit
  is '??????
??????
??????
';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.do_flag
  is '????
????
I-???U-???D-??';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.deal_flag
  is '????
????
0 ??? 1???';
comment on column MM_SW_ACCOUNT_BILL_DETAIL.deal_time
  is '????
????
';
alter table MM_SW_ACCOUNT_BILL_DETAIL
  add constraint PK_MM_SW_ACCOUNT_BILL_DETAIL primary key (BILL_NO, BILL_ROW_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SW_ACCOUNT_INVOICE
prompt ====================================
prompt
create table MM_SW_ACCOUNT_INVOICE
(
  bill_no            VARCHAR2(30) not null,
  invoice_no         VARCHAR2(50) not null,
  invoice_code       VARCHAR2(50) not null,
  invoice_amount     NUMBER(19,3),
  tax_amount         NUMBER(19,3),
  invoice_date       DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  check_code         VARCHAR2(30),
  invoice_net_price  NUMBER(19,3)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_ACCOUNT_INVOICE
  is 'MM_SW_ACCOUNT_INVOICE???????????
';
comment on column MM_SW_ACCOUNT_INVOICE.bill_no
  is '??????
';
comment on column MM_SW_ACCOUNT_INVOICE.invoice_no
  is '?????
';
comment on column MM_SW_ACCOUNT_INVOICE.invoice_code
  is '????
';
comment on column MM_SW_ACCOUNT_INVOICE.invoice_amount
  is '???????
';
comment on column MM_SW_ACCOUNT_INVOICE.tax_amount
  is '????
';
comment on column MM_SW_ACCOUNT_INVOICE.invoice_date
  is '??????
';
comment on column MM_SW_ACCOUNT_INVOICE.creation_user
  is '???
';
comment on column MM_SW_ACCOUNT_INVOICE.creation_time
  is '????
';
comment on column MM_SW_ACCOUNT_INVOICE.last_modified_user
  is '??????
';
comment on column MM_SW_ACCOUNT_INVOICE.last_modified_time
  is '??????
';
comment on column MM_SW_ACCOUNT_INVOICE.deal_flag
  is '?????
';
comment on column MM_SW_ACCOUNT_INVOICE.deal_time
  is '????
';
comment on column MM_SW_ACCOUNT_INVOICE.check_code
  is '???
';
comment on column MM_SW_ACCOUNT_INVOICE.invoice_net_price
  is '???????????
';
create index IDX_MM_SW_ACCOUNT_INVOICE1 on MM_SW_ACCOUNT_INVOICE (BILL_NO)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SW_ACCOUNT_INVOICE
  add constraint PK_MM_SW_ACCOUNT_INVOICE primary key (BILL_NO, INVOICE_NO, INVOICE_CODE)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SW_DEMAND_FORECAST
prompt ====================================
prompt
create table MM_SW_DEMAND_FORECAST
(
  id                 NUMBER(10) not null,
  factory_code       VARCHAR2(20),
  fore_type          NUMBER(1),
  version            VARCHAR2(20),
  plan_delivery      DATE,
  start_date         DATE,
  end_date           DATE,
  phase              VARCHAR2(20),
  unload_port        VARCHAR2(20),
  part_no            VARCHAR2(64),
  part_unit          VARCHAR2(20),
  order_qty          NUMBER(10),
  supplier_no        VARCHAR2(20),
  supplier_name      VARCHAR2(100),
  sup_factory_addr   VARCHAR2(100),
  sup_factory        VARCHAR2(20),
  model_code         VARCHAR2(20),
  logistics_mode     VARCHAR2(50),
  download_status    NUMBER(1) default 0,
  download_time      DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  release_status     NUMBER(1) default 1,
  feedback_status    NUMBER(1),
  feedback_remark    VARCHAR2(300),
  publish_month      VARCHAR2(30),
  obj_month          VARCHAR2(30),
  do_flag            VARCHAR2(10),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  workcenter         VARCHAR2(10),
  advance_time       VARCHAR2(50),
  obj_week           VARCHAR2(30),
  publish_week       VARCHAR2(30),
  p_supplier         VARCHAR2(20),
  seq                VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_DEMAND_FORECAST
  is 'MM_SW_DEMAND_FORECAST???????
MM_SW_DEMAND_FORECAST???????
';
comment on column MM_SW_DEMAND_FORECAST.id
  is 'ID
ID
';
comment on column MM_SW_DEMAND_FORECAST.factory_code
  is '??
??
';
comment on column MM_SW_DEMAND_FORECAST.fore_type
  is '????
????
1-???
2-???';
comment on column MM_SW_DEMAND_FORECAST.version
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.plan_delivery
  is '??????
??????
';
comment on column MM_SW_DEMAND_FORECAST.start_date
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.end_date
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.phase
  is '????
????
0-??
1-??';
comment on column MM_SW_DEMAND_FORECAST.unload_port
  is '???
???
';
comment on column MM_SW_DEMAND_FORECAST.part_no
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.part_unit
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.order_qty
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.supplier_no
  is '?????
?????
';
comment on column MM_SW_DEMAND_FORECAST.supplier_name
  is '?????
?????
';
comment on column MM_SW_DEMAND_FORECAST.sup_factory_addr
  is '?????
?????
';
comment on column MM_SW_DEMAND_FORECAST.sup_factory
  is '?????
?????
';
comment on column MM_SW_DEMAND_FORECAST.model_code
  is '??
??
';
comment on column MM_SW_DEMAND_FORECAST.logistics_mode
  is '??????
??????
';
comment on column MM_SW_DEMAND_FORECAST.download_status
  is '????
????
0-???
1-???';
comment on column MM_SW_DEMAND_FORECAST.download_time
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.creation_user
  is '???
???
';
comment on column MM_SW_DEMAND_FORECAST.creation_time
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.last_modified_user
  is '??????
??????
';
comment on column MM_SW_DEMAND_FORECAST.last_modified_time
  is '??????
??????
';
comment on column MM_SW_DEMAND_FORECAST.release_status
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.feedback_status
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.feedback_remark
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.publish_month
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.obj_month
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.do_flag
  is '????
????
I-???U-???D-??';
comment on column MM_SW_DEMAND_FORECAST.deal_flag
  is '????
????
0 ??? 1???';
comment on column MM_SW_DEMAND_FORECAST.deal_time
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST.workcenter
  is '??';
comment on column MM_SW_DEMAND_FORECAST.advance_time
  is '??????';
comment on column MM_SW_DEMAND_FORECAST.seq
  is '??????????????????';
create index IDX_MM_SW_DEMAND_FORE1 on MM_SW_DEMAND_FORECAST (PLAN_DELIVERY)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SW_DEMAND_FORECAST
  add constraint PK_MM_SW_DEMAND_FORECAST primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SW_DEMAND_FORECAST_IMP
prompt ========================================
prompt
create table MM_SW_DEMAND_FORECAST_IMP
(
  id                 NUMBER(10) not null,
  factory_code       VARCHAR2(20),
  fore_type          NUMBER(1),
  version            VARCHAR2(20),
  plan_delivery      DATE,
  start_date         DATE,
  end_date           DATE,
  phase              VARCHAR2(20),
  unload_port        VARCHAR2(20),
  part_no            VARCHAR2(50),
  part_unit          VARCHAR2(20),
  order_qty          NUMBER(10),
  supplier_no        VARCHAR2(20),
  supplier_name      VARCHAR2(100),
  sup_factory_addr   VARCHAR2(100),
  sup_factory        VARCHAR2(20),
  model_code         VARCHAR2(20),
  logistics_mode     VARCHAR2(50),
  download_status    NUMBER(1) default 0,
  download_time      DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  release_status     NUMBER(1),
  feedback_status    NUMBER(1),
  feedback_remark    VARCHAR2(300),
  workcenter         VARCHAR2(10),
  obj_week           VARCHAR2(30),
  publish_week       VARCHAR2(30),
  advance_time       VARCHAR2(50),
  do_flag            VARCHAR2(10),
  deal_flag          NUMBER(1),
  deal_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_DEMAND_FORECAST_IMP
  is 'MM_SW_DEMAND_FORECAST_IMP???????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.id
  is 'ID
';
comment on column MM_SW_DEMAND_FORECAST_IMP.factory_code
  is '??
';
comment on column MM_SW_DEMAND_FORECAST_IMP.fore_type
  is '????
1-???
2-???';
comment on column MM_SW_DEMAND_FORECAST_IMP.version
  is '????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.plan_delivery
  is '??????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.start_date
  is '????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.end_date
  is '????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.phase
  is '????
0-??
1-??';
comment on column MM_SW_DEMAND_FORECAST_IMP.unload_port
  is '???
';
comment on column MM_SW_DEMAND_FORECAST_IMP.part_no
  is '????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.part_unit
  is '????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.order_qty
  is '????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.supplier_no
  is '?????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.supplier_name
  is '?????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.sup_factory_addr
  is '?????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.sup_factory
  is '?????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.model_code
  is '??
';
comment on column MM_SW_DEMAND_FORECAST_IMP.logistics_mode
  is '??????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.download_status
  is '????
0-???
1-???';
comment on column MM_SW_DEMAND_FORECAST_IMP.download_time
  is '????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.creation_user
  is '???
';
comment on column MM_SW_DEMAND_FORECAST_IMP.creation_time
  is '????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.last_modified_user
  is '??????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.last_modified_time
  is '??????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.release_status
  is '????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.feedback_status
  is '????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.feedback_remark
  is '????
';
comment on column MM_SW_DEMAND_FORECAST_IMP.obj_week
  is '???';
comment on column MM_SW_DEMAND_FORECAST_IMP.publish_week
  is '???';
comment on column MM_SW_DEMAND_FORECAST_IMP.advance_time
  is '??????';
alter table MM_SW_DEMAND_FORECAST_IMP
  add constraint PK_MM_SW_DEMAND_FORECAST_IMP primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SW_DEMAND_FORECAST_SUPPIMP
prompt ============================================
prompt
create table MM_SW_DEMAND_FORECAST_SUPPIMP
(
  id                 NUMBER(10),
  factory_code       VARCHAR2(20),
  fore_type          NUMBER(1),
  version            VARCHAR2(20),
  plan_delivery      DATE,
  start_date         DATE,
  end_date           DATE,
  phase              VARCHAR2(20),
  unload_port        VARCHAR2(20),
  part_no            VARCHAR2(30),
  part_unit          VARCHAR2(20),
  order_qty          NUMBER(10),
  supplier_no        VARCHAR2(20),
  supplier_name      VARCHAR2(100),
  sup_factory_addr   VARCHAR2(100),
  sup_factory        VARCHAR2(20),
  model_code         VARCHAR2(20),
  logistics_mode     VARCHAR2(50),
  download_status    NUMBER(1) default 0,
  download_time      DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  release_status     NUMBER(1) default 0,
  feedback_status    NUMBER(1),
  feedback_remark    VARCHAR2(300),
  publish_month      VARCHAR2(30),
  obj_month          VARCHAR2(30),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  p_supplier         VARCHAR2(20),
  partf_id           VARCHAR2(30),
  partf_order_qty    NUMBER(10),
  seq                VARCHAR2(10),
  imp_uuid           VARCHAR2(50),
  check_result       NUMBER(1),
  check_info         VARCHAR2(300),
  import_status      NUMBER(1),
  ope_type           VARCHAR2(3) default 'I',
  obj_week           VARCHAR2(30),
  publish_week       VARCHAR2(30),
  advance_time       VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.id
  is 'ID
ID
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.factory_code
  is '??
??
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.fore_type
  is '????
????
1-???
2-???';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.version
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.plan_delivery
  is '??????
??????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.start_date
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.end_date
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.phase
  is '????
????
0-??
1-??';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.unload_port
  is '???
???
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.part_no
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.part_unit
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.order_qty
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.supplier_no
  is '?????
?????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.supplier_name
  is '?????
?????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.sup_factory_addr
  is '?????
?????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.sup_factory
  is '?????
?????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.model_code
  is '??
??
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.logistics_mode
  is '??????
??????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.download_status
  is '????
????
0-???
1-???';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.download_time
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.creation_user
  is '???
???
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.creation_time
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.last_modified_user
  is '??????
??????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.last_modified_time
  is '??????
??????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.release_status
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.feedback_status
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.feedback_remark
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.publish_month
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.obj_month
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.deal_flag
  is '????
????
0 ??? 1???';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.deal_time
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.imp_uuid
  is 'IMP_UUID
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.check_result
  is 'CHECK_RESULT
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.check_info
  is 'CHECK_INFO
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.import_status
  is 'IMPORT_STATUS
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.ope_type
  is 'OPE_TYPE
';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.obj_week
  is '???';
comment on column MM_SW_DEMAND_FORECAST_SUPPIMP.publish_week
  is '???';

prompt
prompt Creating table MM_SW_DEMAND_FORECAST_SUPPORT
prompt ============================================
prompt
create table MM_SW_DEMAND_FORECAST_SUPPORT
(
  id                 NUMBER(10) not null,
  factory_code       VARCHAR2(20),
  fore_type          NUMBER(1),
  version            VARCHAR2(20),
  plan_delivery      DATE,
  start_date         DATE,
  end_date           DATE,
  phase              VARCHAR2(20),
  unload_port        VARCHAR2(20),
  part_no            VARCHAR2(30),
  part_unit          VARCHAR2(20),
  order_qty          NUMBER(10),
  supplier_no        VARCHAR2(20),
  supplier_name      VARCHAR2(100),
  sup_factory_addr   VARCHAR2(100),
  sup_factory        VARCHAR2(20),
  model_code         VARCHAR2(20),
  logistics_mode     VARCHAR2(50),
  download_status    NUMBER(1) default 0,
  download_time      DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  release_status     NUMBER(1) default 0,
  feedback_status    NUMBER(1),
  feedback_remark    VARCHAR2(300),
  publish_month      VARCHAR2(30),
  obj_month          VARCHAR2(30),
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  p_supplier         VARCHAR2(20),
  partf_id           VARCHAR2(30),
  partf_order_qty    NUMBER(10),
  seq                VARCHAR2(10),
  obj_week           VARCHAR2(30),
  publish_week       VARCHAR2(30),
  advance_time       VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_DEMAND_FORECAST_SUPPORT
  is 'MM_SW_DEMAND_FORECAST_SUPPORT??????????';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.id
  is 'ID
ID
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.factory_code
  is '??
??
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.fore_type
  is '????
????
1-???
2-???';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.version
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.plan_delivery
  is '??????
??????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.start_date
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.end_date
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.phase
  is '????
????
0-??
1-??';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.unload_port
  is '???
???
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.part_no
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.part_unit
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.order_qty
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.supplier_no
  is '?????
?????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.supplier_name
  is '?????
?????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.sup_factory_addr
  is '?????
?????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.sup_factory
  is '?????
?????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.model_code
  is '??
??
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.logistics_mode
  is '??????
??????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.download_status
  is '????
????
0-???
1-???';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.download_time
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.creation_user
  is '???
???
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.creation_time
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.last_modified_user
  is '??????
??????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.last_modified_time
  is '??????
??????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.release_status
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.feedback_status
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.feedback_remark
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.publish_month
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.obj_month
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.deal_flag
  is '????
????
0 ??? 1???';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.deal_time
  is '????
????
';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.obj_week
  is '???';
comment on column MM_SW_DEMAND_FORECAST_SUPPORT.publish_week
  is '???';
create index IDX_MM_SW_DEMAND_FORE2 on MM_SW_DEMAND_FORECAST_SUPPORT (PLAN_DELIVERY)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SW_DEMAND_FORECAST_SUPPORT
  add constraint PK_MM_SW_DEMAND_FORECAST_SUPPO primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SW_FEEDBACK_ZC
prompt ================================
prompt
create table MM_SW_FEEDBACK_ZC
(
  id                 VARCHAR2(19),
  factory_code       VARCHAR2(20) not null,
  purchase_no        VARCHAR2(50) not null,
  reply_seq_no       NUMBER(10) not null,
  purchase_row_no    NUMBER(10) not null,
  plan_time          DATE,
  plan_num           NUMBER(19),
  return_msg         VARCHAR2(500),
  return_time        DATE,
  deal_flag          NUMBER(1) default 0,
  deal_time          DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  print_status       NUMBER(1),
  print_time         DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_FEEDBACK_ZC
  is 'MM_SW_FEEDBACK_ZC??????
';
comment on column MM_SW_FEEDBACK_ZC.factory_code
  is '????
';
comment on column MM_SW_FEEDBACK_ZC.purchase_no
  is '????
';
comment on column MM_SW_FEEDBACK_ZC.reply_seq_no
  is '?????
';
comment on column MM_SW_FEEDBACK_ZC.purchase_row_no
  is '??????
';
comment on column MM_SW_FEEDBACK_ZC.plan_time
  is '??????
';
comment on column MM_SW_FEEDBACK_ZC.plan_num
  is '??????
';
comment on column MM_SW_FEEDBACK_ZC.return_msg
  is '????
';
comment on column MM_SW_FEEDBACK_ZC.return_time
  is '????
';
comment on column MM_SW_FEEDBACK_ZC.deal_flag
  is '??????
';
comment on column MM_SW_FEEDBACK_ZC.deal_time
  is '??????
';
comment on column MM_SW_FEEDBACK_ZC.creation_user
  is '???
';
comment on column MM_SW_FEEDBACK_ZC.creation_time
  is '????
';
comment on column MM_SW_FEEDBACK_ZC.last_modified_user
  is '??????
';
comment on column MM_SW_FEEDBACK_ZC.last_modified_time
  is '??????
';
comment on column MM_SW_FEEDBACK_ZC.print_status
  is '??????
';
comment on column MM_SW_FEEDBACK_ZC.print_time
  is '??????
';
create index IDX_MM_SW_FEEDBACK_ZC1 on MM_SW_FEEDBACK_ZC (DEAL_FLAG)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SW_FEEDBACK_ZC
  add constraint PK_MM_SW_FEEDBACK_ZC primary key (PURCHASE_NO, PURCHASE_ROW_NO, REPLY_SEQ_NO, FACTORY_CODE)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SW_LONG_ORDER
prompt ===============================
prompt
create table MM_SW_LONG_ORDER
(
  id                  NUMBER(19) not null,
  version             VARCHAR2(30),
  order_no            VARCHAR2(50),
  current_month       VARCHAR2(30),
  obj_month           VARCHAR2(30),
  order_period        NUMBER(19),
  forecast_period     NUMBER(19),
  forecast_first      VARCHAR2(30),
  forecast_first_num  NUMBER(19),
  forecast_second     VARCHAR2(30),
  forecast_second_num NUMBER(19),
  forecast_third      VARCHAR2(30),
  forecast_third_num  NUMBER(19),
  creation_time       DATE,
  creation_user       VARCHAR2(30),
  last_modified_user  VARCHAR2(30),
  last_modified_time  DATE,
  print_status        NUMBER(1),
  print_time          DATE,
  do_flag             VARCHAR2(10),
  deal_flag           NUMBER(1) default 0,
  deal_time           DATE,
  factory_code        VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_LONG_ORDER
  is 'MM_SW_LONG_ORDER??????
';
comment on column MM_SW_LONG_ORDER.version
  is '???
';
comment on column MM_SW_LONG_ORDER.order_no
  is '???
';
comment on column MM_SW_LONG_ORDER.current_month
  is '???
';
comment on column MM_SW_LONG_ORDER.obj_month
  is '???
';
comment on column MM_SW_LONG_ORDER.order_period
  is '????
';
comment on column MM_SW_LONG_ORDER.forecast_period
  is '????
';
comment on column MM_SW_LONG_ORDER.forecast_first
  is '?????1
';
comment on column MM_SW_LONG_ORDER.forecast_first_num
  is '?????1??
';
comment on column MM_SW_LONG_ORDER.forecast_second
  is '?????2
';
comment on column MM_SW_LONG_ORDER.forecast_second_num
  is '?????2??
';
comment on column MM_SW_LONG_ORDER.forecast_third
  is '?????3
';
comment on column MM_SW_LONG_ORDER.forecast_third_num
  is '?????3??
';
comment on column MM_SW_LONG_ORDER.creation_time
  is '????
';
comment on column MM_SW_LONG_ORDER.creation_user
  is '???
';
comment on column MM_SW_LONG_ORDER.last_modified_user
  is '?????
';
comment on column MM_SW_LONG_ORDER.last_modified_time
  is '??????
';
comment on column MM_SW_LONG_ORDER.print_status
  is '????
';
comment on column MM_SW_LONG_ORDER.print_time
  is '????
';
comment on column MM_SW_LONG_ORDER.do_flag
  is '????
????
I-???U-???D-??';
comment on column MM_SW_LONG_ORDER.deal_flag
  is '????
????
0 ??? 1???';
comment on column MM_SW_LONG_ORDER.deal_time
  is '????
????
';
alter table MM_SW_LONG_ORDER
  add constraint PK_MM_SW_LONG_ORDER primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SW_LONG_ORDER2
prompt ================================
prompt
create table MM_SW_LONG_ORDER2
(
  id                 NUMBER(19) not null,
  version            VARCHAR2(30),
  order_no           VARCHAR2(50),
  current_month      VARCHAR2(30),
  obj_month          VARCHAR2(30),
  order_period       NUMBER(19),
  forecast_period    NUMBER(19),
  obj_first          VARCHAR2(30),
  obj_first_num      NUMBER(19),
  forecast_second    VARCHAR2(30),
  obj_second_num     NUMBER(19),
  forecast_third     VARCHAR2(30),
  forecast_third_num NUMBER(19),
  creation_time      DATE,
  creation_user      VARCHAR2(30),
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  print_status       NUMBER(1),
  print_time         DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_LONG_ORDER2
  is 'MM_SW_LONG_ORDER长周期订单表
';
comment on column MM_SW_LONG_ORDER2.version
  is '版本号
';
comment on column MM_SW_LONG_ORDER2.order_no
  is '订单号
';
comment on column MM_SW_LONG_ORDER2.current_month
  is '当前月
';
comment on column MM_SW_LONG_ORDER2.obj_month
  is '对象月
';
comment on column MM_SW_LONG_ORDER2.order_period
  is '订单周期
';
comment on column MM_SW_LONG_ORDER2.forecast_period
  is '预测周期
';
comment on column MM_SW_LONG_ORDER2.obj_first
  is '预测对象月1
';
comment on column MM_SW_LONG_ORDER2.obj_first_num
  is '预测对象月1数量
';
comment on column MM_SW_LONG_ORDER2.forecast_second
  is '预测对象月2
';
comment on column MM_SW_LONG_ORDER2.obj_second_num
  is '预测对象月2数量
';
comment on column MM_SW_LONG_ORDER2.forecast_third
  is '预测对象月3
';
comment on column MM_SW_LONG_ORDER2.forecast_third_num
  is '预测对象月3数量
';
comment on column MM_SW_LONG_ORDER2.creation_time
  is '创建时间
';
comment on column MM_SW_LONG_ORDER2.creation_user
  is '创建人
';
comment on column MM_SW_LONG_ORDER2.last_modified_user
  is '最后修改人
';
comment on column MM_SW_LONG_ORDER2.last_modified_time
  is '最后修改时间
';
comment on column MM_SW_LONG_ORDER2.print_status
  is '打印状态
';
comment on column MM_SW_LONG_ORDER2.print_time
  is '打印时间
';
alter table MM_SW_LONG_ORDER2
  add constraint PK_MM_SW_LONG_ORDER2 primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SW_LONG_ORDER2
  add constraint AK_KEY_1_MM_SW_LO unique (VERSION, ORDER_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SW_LONG_ORDER_DETAIL
prompt ======================================
prompt
create table MM_SW_LONG_ORDER_DETAIL
(
  version             VARCHAR2(30),
  order_no            VARCHAR2(50),
  part_no             VARCHAR2(64),
  car_type            VARCHAR2(10),
  supplier_no         VARCHAR2(10),
  sup_factory         VARCHAR2(10),
  require_num         NUMBER(19),
  order_require_num   NUMBER(19),
  part_unit           VARCHAR2(10),
  order_num           NUMBER(19),
  order_box           NUMBER(19),
  current_deliv_qty   NUMBER(10),
  total_deliv_qty     NUMBER(10),
  do_flag             VARCHAR2(10),
  deal_flag           NUMBER(1) default 0,
  deal_time           DATE,
  do_flag2            VARCHAR2(10),
  deal_flag2          NUMBER(1) default 0,
  deal_time2          DATE,
  forecast_first_num  NUMBER(19),
  forecast_second_num NUMBER(19),
  forecast_third_num  NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_LONG_ORDER_DETAIL
  is 'MM_SW_LONG_ORDER_DETAIL????????
';
comment on column MM_SW_LONG_ORDER_DETAIL.version
  is '???
';
comment on column MM_SW_LONG_ORDER_DETAIL.order_no
  is '???
';
comment on column MM_SW_LONG_ORDER_DETAIL.part_no
  is '???
';
comment on column MM_SW_LONG_ORDER_DETAIL.car_type
  is '??
';
comment on column MM_SW_LONG_ORDER_DETAIL.supplier_no
  is '?????
';
comment on column MM_SW_LONG_ORDER_DETAIL.sup_factory
  is 'ERP?????
';
comment on column MM_SW_LONG_ORDER_DETAIL.require_num
  is '???
';
comment on column MM_SW_LONG_ORDER_DETAIL.order_require_num
  is '?????
';
comment on column MM_SW_LONG_ORDER_DETAIL.part_unit
  is '??
';
comment on column MM_SW_LONG_ORDER_DETAIL.order_num
  is '????
';
comment on column MM_SW_LONG_ORDER_DETAIL.order_box
  is '????
';
comment on column MM_SW_LONG_ORDER_DETAIL.current_deliv_qty
  is '??????
';
comment on column MM_SW_LONG_ORDER_DETAIL.total_deliv_qty
  is '?????
';
comment on column MM_SW_LONG_ORDER_DETAIL.do_flag
  is '????
????
I-???U-???D-??';
comment on column MM_SW_LONG_ORDER_DETAIL.deal_flag
  is '????
????
0 ??? 1???';
comment on column MM_SW_LONG_ORDER_DETAIL.deal_time
  is '????
????
';
comment on column MM_SW_LONG_ORDER_DETAIL.do_flag2
  is '????
????
I-???U-???D-??';
comment on column MM_SW_LONG_ORDER_DETAIL.deal_flag2
  is '????
????
0 ??? 1???';
comment on column MM_SW_LONG_ORDER_DETAIL.deal_time2
  is '????
????
';

prompt
prompt Creating table MM_SW_LONG_ORDER_DETAIL2
prompt =======================================
prompt
create table MM_SW_LONG_ORDER_DETAIL2
(
  version           VARCHAR2(30),
  order_no          VARCHAR2(50),
  part_no           VARCHAR2(30),
  car_type          VARCHAR2(10),
  supplier_no       VARCHAR2(10),
  sup_factory       VARCHAR2(10),
  require_num       NUMBER(19),
  order_require_num NUMBER(19),
  part_unit         VARCHAR2(10),
  order_num         NUMBER(19),
  order_box         NUMBER(19),
  current_deliv_qty NUMBER(10),
  total_deliv_qty   NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_LONG_ORDER_DETAIL2
  is 'MM_SW_LONG_ORDER_DETAIL长周期订单明细表
';
comment on column MM_SW_LONG_ORDER_DETAIL2.version
  is '版本号
';
comment on column MM_SW_LONG_ORDER_DETAIL2.order_no
  is '订单号
';
comment on column MM_SW_LONG_ORDER_DETAIL2.part_no
  is '零件号
';
comment on column MM_SW_LONG_ORDER_DETAIL2.car_type
  is '车型
';
comment on column MM_SW_LONG_ORDER_DETAIL2.supplier_no
  is '供应商代码
';
comment on column MM_SW_LONG_ORDER_DETAIL2.sup_factory
  is 'ERP下发出货地
';
comment on column MM_SW_LONG_ORDER_DETAIL2.require_num
  is '收容数
';
comment on column MM_SW_LONG_ORDER_DETAIL2.order_require_num
  is '订单收容数
';
comment on column MM_SW_LONG_ORDER_DETAIL2.part_unit
  is '单位
';
comment on column MM_SW_LONG_ORDER_DETAIL2.order_num
  is '订单个数
';
comment on column MM_SW_LONG_ORDER_DETAIL2.order_box
  is '订单箱数
';
comment on column MM_SW_LONG_ORDER_DETAIL2.current_deliv_qty
  is '本次发货数量
';
comment on column MM_SW_LONG_ORDER_DETAIL2.total_deliv_qty
  is '已发货数量
';

prompt
prompt Creating table MM_SW_NON_STANDARD
prompt =================================
prompt
create table MM_SW_NON_STANDARD
(
  id                 NUMBER(19) not null,
  factory_code       VARCHAR2(10),
  order_no           VARCHAR2(50),
  sale_no            VARCHAR2(50),
  sale_row_no        NUMBER(10),
  supplier_no        VARCHAR2(20),
  sup_factory        VARCHAR2(10),
  supplier_name      VARCHAR2(150),
  part_no            VARCHAR2(30),
  part_short_no      VARCHAR2(10),
  part_name_cn       VARCHAR2(150),
  order_num          NUMBER(19),
  creation_user      VARCHAR2(30),
  creation_time      DATE,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  last_check_id      NUMBER(19),
  pic_upload_status  NUMBER(2) default 0,
  deal_flag          NUMBER(2),
  deal_time          DATE,
  do_flag            VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_SW_NON_STANDARD.last_check_id
  is '????ID';
comment on column MM_SW_NON_STANDARD.pic_upload_status
  is '0???? 1????';
alter table MM_SW_NON_STANDARD
  add constraint PK_MM_SW_NON_STANDARD primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SW_NON_STANDARD_DETAIL
prompt ========================================
prompt
create table MM_SW_NON_STANDARD_DETAIL
(
  sale_no            VARCHAR2(50),
  sale_row_no        NUMBER(10),
  part_no            VARCHAR2(30),
  feature            VARCHAR2(20),
  feature_type       VARCHAR2(2),
  feature_value      VARCHAR2(500),
  sort_no            NUMBER(5),
  creation_time      DATE,
  last_modified_time DATE,
  deal_flag          NUMBER(2),
  deal_time          DATE,
  do_flag            VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_SW_NON_STANDARD_DETAIL.sale_no
  is '????';
comment on column MM_SW_NON_STANDARD_DETAIL.sale_row_no
  is '?????';
comment on column MM_SW_NON_STANDARD_DETAIL.part_no
  is '???';
comment on column MM_SW_NON_STANDARD_DETAIL.feature
  is '????';
comment on column MM_SW_NON_STANDARD_DETAIL.feature_type
  is '????';
comment on column MM_SW_NON_STANDARD_DETAIL.feature_value
  is '???';
comment on column MM_SW_NON_STANDARD_DETAIL.sort_no
  is '???';

prompt
prompt Creating table MM_SW_NON_STANDAR_CHECK
prompt ======================================
prompt
create table MM_SW_NON_STANDAR_CHECK
(
  id               NUMBER(19) not null,
  sale_no          VARCHAR2(50),
  sale_row_no      NUMBER(10),
  part_no          VARCHAR2(50),
  remark           VARCHAR2(300),
  check_result     NUMBER(1) default 0,
  checker          VARCHAR2(30),
  check_time       DATE,
  creation_user    VARCHAR2(30),
  creation_user_ip VARCHAR2(30),
  creation_time    DATE default SYSDATE,
  deal_flag        NUMBER(2),
  deal_time        DATE,
  do_flag          VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_SW_NON_STANDAR_CHECK.check_result
  is '0????
1????
2???';
alter table MM_SW_NON_STANDAR_CHECK
  add constraint PK_MM_SW_NON_STANDAR_CHECK primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_SW_NON_STAND_PIC
prompt ==================================
prompt
create table MM_SW_NON_STAND_PIC
(
  check_id           NUMBER(19),
  sale_no            VARCHAR2(50),
  sale_row_no        NUMBER(10),
  part_no            VARCHAR2(30),
  pic_type           NUMBER(2),
  creation_time      DATE,
  creation_user      VARCHAR2(30),
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  pic_id             VARCHAR2(60),
  email_flag         NUMBER(2) default 0,
  deal_flag          NUMBER(2),
  deal_time          DATE,
  do_flag            VARCHAR2(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_SW_NON_STAND_PIC.pic_type
  is '0????????  1??????';
comment on column MM_SW_NON_STAND_PIC.email_flag
  is '????';

prompt
prompt Creating table MM_SW_ORDER
prompt ==========================
prompt
create table MM_SW_ORDER
(
  purchase_no         VARCHAR2(50) not null,
  order_no            VARCHAR2(50),
  order_type          VARCHAR2(2),
  factory_code        VARCHAR2(10),
  supplier_no         VARCHAR2(20),
  order_date          DATE,
  arrive_date         DATE,
  depot_no            VARCHAR2(20),
  sup_factory         VARCHAR2(20),
  print_status        NUMBER(1) default 0,
  print_time          DATE,
  label_print_status  NUMBER(1) default 0,
  label_print_time    DATE,
  delivery_status     NUMBER(1) default 0,
  receive_status      NUMBER(1) default 0,
  download_status     NUMBER(1) default 0,
  download_time       DATE,
  reply_delivery_date DATE,
  is_urgent           NUMBER(1) default 0,
  creation_user       VARCHAR2(30),
  creation_time       DATE default sysdate,
  last_modified_user  VARCHAR2(30),
  last_modified_time  DATE,
  sp_type             VARCHAR2(2),
  receive_date        DATE,
  receive_count       NUMBER(5),
  prepare_status      NUMBER(1),
  prepare_count       NUMBER(5),
  prepare_time        DATE,
  hms_order_no        VARCHAR2(50),
  rec_address         VARCHAR2(300),
  rec_user            VARCHAR2(30),
  rec_tel             VARCHAR2(30),
  planner             VARCHAR2(30),
  deal_flag           NUMBER(1) default 0,
  deal_time           DATE,
  plan_prepare_time   DATE,
  zg_flag             NUMBER(1),
  print_user          VARCHAR2(30),
  print_user_ip       VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 8K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_ORDER
  is 'MM_SW_ORDER?????
';
comment on column MM_SW_ORDER.purchase_no
  is '????
????
????
????
';
comment on column MM_SW_ORDER.order_no
  is '?????
?????
?????
?????
';
comment on column MM_SW_ORDER.order_type
  is '????
????
????
????
01:?????02:?????03:????:?04:?????05:??????11:??????12:????(SP)?14??????';
comment on column MM_SW_ORDER.factory_code
  is '????
????
????
????
';
comment on column MM_SW_ORDER.supplier_no
  is '?????
?????
?????
?????
';
comment on column MM_SW_ORDER.order_date
  is '????
????
????
????
';
comment on column MM_SW_ORDER.arrive_date
  is '????
????
????
????
';
comment on column MM_SW_ORDER.depot_no
  is '????
????
????
????
';
comment on column MM_SW_ORDER.sup_factory
  is '?????
?????
?????
?????
';
comment on column MM_SW_ORDER.print_status
  is '????
????
????
????
0:???
1:???';
comment on column MM_SW_ORDER.print_time
  is '????
????
????
????
';
comment on column MM_SW_ORDER.label_print_status
  is '??????
??????
??????
??????
0:???
1:???';
comment on column MM_SW_ORDER.label_print_time
  is '??????
??????
??????
??????
';
comment on column MM_SW_ORDER.delivery_status
  is '????
????
????
????
0-???
1-????
2-????';
comment on column MM_SW_ORDER.receive_status
  is '????
????
????
????
0-???
1-????
2-????';
comment on column MM_SW_ORDER.download_status
  is '????
????
????
????
0-???
1-???';
comment on column MM_SW_ORDER.download_time
  is '????
????
????
????
';
comment on column MM_SW_ORDER.reply_delivery_date
  is '?????????
?????????
?????????
?????????
';
comment on column MM_SW_ORDER.is_urgent
  is '??????
??????
??????
??????
0-??
1-??';
comment on column MM_SW_ORDER.creation_user
  is '???
???
???
???
';
comment on column MM_SW_ORDER.creation_time
  is '????
????
????
????
';
comment on column MM_SW_ORDER.last_modified_user
  is '??????
??????
??????
??????
';
comment on column MM_SW_ORDER.last_modified_time
  is '??????
??????
??????
??????
';
comment on column MM_SW_ORDER.sp_type
  is '??????
??????
??????
??????
1:????2?????3:???';
comment on column MM_SW_ORDER.receive_date
  is '????
????
????
????
';
comment on column MM_SW_ORDER.receive_count
  is '????
????
????
????
';
comment on column MM_SW_ORDER.prepare_status
  is '????
???????PREPARE_STATUS?
????
???????PREPARE_STATUS?
????
???????PREPARE_STATUS?
????
???????PREPARE_STATUS?
';
comment on column MM_SW_ORDER.prepare_count
  is '????
????
????
????
';
comment on column MM_SW_ORDER.prepare_time
  is '????
????
????
????
';
comment on column MM_SW_ORDER.hms_order_no
  is 'HMS???
HMS???
HMS???
HMS???
';
comment on column MM_SW_ORDER.rec_address
  is '??????
??????
??????
??????
';
comment on column MM_SW_ORDER.rec_user
  is '?????
?????
?????
?????
';
comment on column MM_SW_ORDER.rec_tel
  is '??????
??????
??????
??????
';
comment on column MM_SW_ORDER.planner
  is '???/???
???/???
???/???
???/???
';
comment on column MM_SW_ORDER.deal_flag
  is '????
????
0 ??? 1???';
comment on column MM_SW_ORDER.deal_time
  is '????
????
';
comment on column MM_SW_ORDER.plan_prepare_time
  is '?????? ';
comment on column MM_SW_ORDER.zg_flag
  is '???? ';
comment on column MM_SW_ORDER.print_user
  is '???';
comment on column MM_SW_ORDER.print_user_ip
  is '??IP';
create index IDX_MM_SW_ORDER1 on MM_SW_ORDER (ORDER_NO)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_SW_ORDER2 on MM_SW_ORDER (CREATION_TIME)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_SW_ORDER3 on MM_SW_ORDER (PRINT_STATUS)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_SW_ORDER4 on MM_SW_ORDER (DELIVERY_STATUS)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_MM_SW_ORDER5 on MM_SW_ORDER (RECEIVE_STATUS)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_SW_ORDER
  add constraint PK_MM_SW_ORDER primary key (PURCHASE_NO)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_SW_ORDER_DETAIL
prompt =================================
prompt
create table MM_SW_ORDER_DETAIL
(
  id                 NUMBER(10) not null,
  purchase_no        VARCHAR2(50),
  purchase_rowno     NUMBER(10),
  order_rowno        NUMBER(10),
  depot_no           VARCHAR2(20),
  order_qty          NUMBER(19),
  order_unit         VARCHAR2(20),
  part_no            VARCHAR2(20),
  standard_package   NUMBER(10),
  total_deliv_qty    NUMBER(10),
  total_rec_qty      NUMBER(10) default 0,
  delivery_status    NUMBER(1) default 0,
  receive_status     NUMBER(1) default 0,
  receive_date       DATE,
  receive_count      NUMBER(5) default 0,
  cancel_num         NUMBER(19) default 0,
  cost_center        VARCHAR2(50),
  zk_flag            VARCHAR2(10),
  inv_type           VARCHAR2(30),
  cost_code          VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_time DATE,
  prepare_num        NUMBER(19),
  arrive_num         NUMBER(19),
  order_no           VARCHAR2(50),
  current_qty        NUMBER(10),
  package_num        NUMBER(16),
  depot_address      VARCHAR2(20),
  use                VARCHAR2(300),
  demand_department  VARCHAR2(150),
  demander           VARCHAR2(100),
  con_number         VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_ORDER_DETAIL
  is 'MM_SW_ORDER_DETAIL???????
MM_SW_ORDER_DETAIL???????
MM_SW_ORDER_DETAIL???????
MM_SW_ORDER_DETAIL???????
';
comment on column MM_SW_ORDER_DETAIL.id
  is '????ID
????ID
????ID
????ID
';
comment on column MM_SW_ORDER_DETAIL.purchase_no
  is '?????
?????
?????
?????
';
comment on column MM_SW_ORDER_DETAIL.purchase_rowno
  is '??????
??????
??????
??????
';
comment on column MM_SW_ORDER_DETAIL.order_rowno
  is '??????
??????
??????
??????
';
comment on column MM_SW_ORDER_DETAIL.depot_no
  is '????
????
????
????
';
comment on column MM_SW_ORDER_DETAIL.order_qty
  is '????
????
????
????
';
comment on column MM_SW_ORDER_DETAIL.order_unit
  is '????
????
????
????
';
comment on column MM_SW_ORDER_DETAIL.part_no
  is '????
????
????
????
';
comment on column MM_SW_ORDER_DETAIL.standard_package
  is '????
????
????
????
';
comment on column MM_SW_ORDER_DETAIL.total_deliv_qty
  is '??????
??????
??????
??????
';
comment on column MM_SW_ORDER_DETAIL.total_rec_qty
  is '??????
??????
??????
??????
';
comment on column MM_SW_ORDER_DETAIL.delivery_status
  is '????
????
????
????
0:???
1:????
2:????';
comment on column MM_SW_ORDER_DETAIL.receive_status
  is '????
????
????
????
0:???
1:????
2:????';
comment on column MM_SW_ORDER_DETAIL.receive_date
  is '????
????
????
????
';
comment on column MM_SW_ORDER_DETAIL.receive_count
  is '????
????
????
????
';
comment on column MM_SW_ORDER_DETAIL.cancel_num
  is '????
????
????
????
';
comment on column MM_SW_ORDER_DETAIL.cost_center
  is '????
????
????
????
??????';
comment on column MM_SW_ORDER_DETAIL.zk_flag
  is '????
????
????
????
N-?
Y-?
2019/01/08??';
comment on column MM_SW_ORDER_DETAIL.inv_type
  is '????
????
????
????
??????';
comment on column MM_SW_ORDER_DETAIL.cost_code
  is '??????
??????
??????
??????
??????';
comment on column MM_SW_ORDER_DETAIL.creation_time
  is '????
????
????
????
';
comment on column MM_SW_ORDER_DETAIL.last_modified_time
  is '??????
??????
??????
??????
';
comment on column MM_SW_ORDER_DETAIL.prepare_num
  is '????
????
????
????
';
comment on column MM_SW_ORDER_DETAIL.arrive_num
  is '????
????
????
????
';
comment on column MM_SW_ORDER_DETAIL.order_no
  is '?????
?????
?????
?????
';
comment on column MM_SW_ORDER_DETAIL.current_qty
  is '??????';
comment on column MM_SW_ORDER_DETAIL.package_num
  is '???';
comment on column MM_SW_ORDER_DETAIL.depot_address
  is '?????';
comment on column MM_SW_ORDER_DETAIL.use
  is '??';
comment on column MM_SW_ORDER_DETAIL.demand_department
  is '????';
comment on column MM_SW_ORDER_DETAIL.demander
  is '???';
comment on column MM_SW_ORDER_DETAIL.con_number
  is '????';
create index IDX_MM_SW_ORDER_DETAIL1 on MM_SW_ORDER_DETAIL (PURCHASE_NO)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_SW_ORDER_DETAIL
  add constraint PK_MM_SW_ORDER_DETAIL primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table MM_SW_ORDER_DETAIL
  add constraint AK_MM_SW_ORDER_DETAIL unique (PURCHASE_NO, PURCHASE_ROWNO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MM_SW_PICKUP_PLAN
prompt ================================
prompt
create table MM_SW_PICKUP_PLAN
(
  order_no            VARCHAR2(50) not null,
  purchase_no         VARCHAR2(50) not null,
  confirm_days        NUMBER(10),
  inter_logis_manager VARCHAR2(30),
  order_use           VARCHAR2(100),
  plan_assemble_time  DATE,
  plan_arr_time       DATE,
  plan_pickup_time    DATE,
  today_car_batch     NUMBER(10),
  feedback_status     NUMBER(1) default 0,
  logistics_mode      VARCHAR2(50),
  area                VARCHAR2(50),
  car_type            VARCHAR2(30),
  route_code          VARCHAR2(30),
  total_batchs        VARCHAR2(30),
  merge_batchs        NUMBER(10),
  sup_factory         VARCHAR2(20),
  supplier_no         VARCHAR2(20),
  work_date           DATE,
  factory_code        VARCHAR2(10),
  diff_flag           NUMBER(1),
  order_desc          VARCHAR2(200),
  pickup_type         VARCHAR2(30),
  order_arr_date      DATE,
  unload_port         VARCHAR2(20),
  adj_status          NUMBER(1),
  download_status     NUMBER(1) default 0,
  download_time       DATE,
  creation_user       VARCHAR2(30),
  creation_time       DATE default sysdate,
  last_modified_user  VARCHAR2(30),
  last_modified_time  DATE,
  deal_flag           NUMBER(1) default 0,
  deal_time           DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column MM_SW_PICKUP_PLAN.feedback_status
  is '0-???
1-NG
2-OK';
comment on column MM_SW_PICKUP_PLAN.diff_flag
  is '0-???  1-???';
comment on column MM_SW_PICKUP_PLAN.pickup_type
  is '????(0:??;1:??;2:??)';
comment on column MM_SW_PICKUP_PLAN.adj_status
  is '0-???  1-??? 2-???';
comment on column MM_SW_PICKUP_PLAN.download_status
  is '0-???
1-???';
comment on column MM_SW_PICKUP_PLAN.deal_flag
  is '处理标识
处理标识
0 未处理 1已处理 2失败';
comment on column MM_SW_PICKUP_PLAN.deal_time
  is '处理时间
处理时间
';
create index IDX_MM_SW_PICKUP_PLAN1 on MM_SW_PICKUP_PLAN (PLAN_PICKUP_TIME)
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;
alter table MM_SW_PICKUP_PLAN
  add constraint PK_MM_SW_PICKUP_PLAN primary key (ORDER_NO, PURCHASE_NO)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table MM_SW_PICKUP_PLAN_IMP
prompt ====================================
prompt
create table MM_SW_PICKUP_PLAN_IMP
(
  id                  NUMBER(19),
  factory_code        VARCHAR2(10),
  area                VARCHAR2(50),
  car_type            VARCHAR2(30),
  total_batchs        VARCHAR2(30),
  merge_batchs        NUMBER(10),
  sup_factory         VARCHAR2(20),
  supplier_no         VARCHAR2(20),
  order_no            VARCHAR2(50) not null,
  purchase_no         VARCHAR2(50) not null,
  work_date           DATE,
  today_car_batch     NUMBER(10),
  plan_pickup_time    DATE,
  plan_arr_time       DATE,
  plan_assemble_time  DATE,
  order_use           VARCHAR2(100),
  route_code          VARCHAR2(30),
  inter_logis_manager VARCHAR2(30),
  confirm_days        NUMBER(10),
  imp_uuid            VARCHAR2(32),
  check_result        NUMBER(1),
  check_info          VARCHAR2(300),
  import_status       NUMBER(1),
  ope_type            VARCHAR2(8),
  creation_user       VARCHAR2(30),
  creation_time       DATE default SYSDATE,
  pickup_type         VARCHAR2(30),
  unload_port         VARCHAR2(20)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table MM_SW_PICKUP_PLAN_IMP
  is '?????????';
comment on column MM_SW_PICKUP_PLAN_IMP.factory_code
  is '??';
comment on column MM_SW_PICKUP_PLAN_IMP.area
  is '??';
comment on column MM_SW_PICKUP_PLAN_IMP.car_type
  is '??';
comment on column MM_SW_PICKUP_PLAN_IMP.total_batchs
  is '????';
comment on column MM_SW_PICKUP_PLAN_IMP.merge_batchs
  is '????';
comment on column MM_SW_PICKUP_PLAN_IMP.sup_factory
  is '???';
comment on column MM_SW_PICKUP_PLAN_IMP.supplier_no
  is '?????';
comment on column MM_SW_PICKUP_PLAN_IMP.order_no
  is '????';
comment on column MM_SW_PICKUP_PLAN_IMP.purchase_no
  is '????';
comment on column MM_SW_PICKUP_PLAN_IMP.work_date
  is '???';
comment on column MM_SW_PICKUP_PLAN_IMP.today_car_batch
  is '????';
comment on column MM_SW_PICKUP_PLAN_IMP.plan_pickup_time
  is '??????';
comment on column MM_SW_PICKUP_PLAN_IMP.plan_arr_time
  is '??????';
comment on column MM_SW_PICKUP_PLAN_IMP.plan_assemble_time
  is '???????';
comment on column MM_SW_PICKUP_PLAN_IMP.order_use
  is '????';
comment on column MM_SW_PICKUP_PLAN_IMP.inter_logis_manager
  is '??????';
comment on column MM_SW_PICKUP_PLAN_IMP.confirm_days
  is '????';
comment on column MM_SW_PICKUP_PLAN_IMP.check_result
  is '???????IMP_CHECK_RESULT?
0-???
1-??';
comment on column MM_SW_PICKUP_PLAN_IMP.check_info
  is '????';
comment on column MM_SW_PICKUP_PLAN_IMP.import_status
  is '0-???
1-???';
comment on column MM_SW_PICKUP_PLAN_IMP.ope_type
  is 'I ?? U??';
comment on column MM_SW_PICKUP_PLAN_IMP.creation_user
  is '???';
comment on column MM_SW_PICKUP_PLAN_IMP.creation_time
  is '????';
comment on column MM_SW_PICKUP_PLAN_IMP.pickup_type
  is '????(0:??;1:??;2:??)';

prompt
prompt Creating table MM_SYS_ORG
prompt =========================
prompt
create table MM_SYS_ORG
(
  id_        VARCHAR2(64) not null,
  name_      VARCHAR2(64) not null,
  parent_id_ VARCHAR2(64),
  order_no_  NUMBER,
  code_      VARCHAR2(64),
  grade_     VARCHAR2(64),
  path_      VARCHAR2(600),
  path_name_ VARCHAR2(600),
  dem_id_    VARCHAR2(64)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_SYS_ORG
  is '????';
comment on column MM_SYS_ORG.id_
  is '??';
comment on column MM_SYS_ORG.name_
  is '????';
comment on column MM_SYS_ORG.parent_id_
  is '??ID';
comment on column MM_SYS_ORG.order_no_
  is '??';
comment on column MM_SYS_ORG.code_
  is '??';
comment on column MM_SYS_ORG.grade_
  is '??';
comment on column MM_SYS_ORG.path_
  is '??id?????????';
comment on column MM_SYS_ORG.path_name_
  is '????????????';
comment on column MM_SYS_ORG.dem_id_
  is '????id';

prompt
prompt Creating table MM_SYS_ORG_AUTH
prompt ==============================
prompt
create table MM_SYS_ORG_AUTH
(
  id_            VARCHAR2(64) not null,
  user_id_       VARCHAR2(64),
  org_id         VARCHAR2(64),
  dem_id_        VARCHAR2(64),
  org_perms_     VARCHAR2(200),
  user_perms_    VARCHAR2(200),
  pos_perms_     VARCHAR2(200),
  orgauth_perms_ VARCHAR2(200),
  layout_perms_  VARCHAR2(200)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_SYS_ORG_AUTH
  is '??????';
comment on column MM_SYS_ORG_AUTH.id_
  is '??';
comment on column MM_SYS_ORG_AUTH.user_id_
  is '???????id';
comment on column MM_SYS_ORG_AUTH.org_id
  is '??????id';
comment on column MM_SYS_ORG_AUTH.dem_id_
  is '????id';
comment on column MM_SYS_ORG_AUTH.org_perms_
  is '??????';
comment on column MM_SYS_ORG_AUTH.user_perms_
  is '??????';
comment on column MM_SYS_ORG_AUTH.pos_perms_
  is '??????';
comment on column MM_SYS_ORG_AUTH.orgauth_perms_
  is '???????';
comment on column MM_SYS_ORG_AUTH.layout_perms_
  is '??????';

prompt
prompt Creating table MM_SYS_ROLE
prompt ==========================
prompt
create table MM_SYS_ROLE
(
  id          VARCHAR2(64) not null,
  name        VARCHAR2(64) not null,
  alias       VARCHAR2(64) not null,
  enabled     NUMBER default 1 not null,
  description VARCHAR2(200)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_SYS_ROLE
  is '????';
comment on column MM_SYS_ROLE.id
  is '??';
comment on column MM_SYS_ROLE.name
  is '????';
comment on column MM_SYS_ROLE.alias
  is '????';
comment on column MM_SYS_ROLE.enabled
  is '?? 0????1???';
comment on column MM_SYS_ROLE.description
  is '??';

prompt
prompt Creating table MM_SYS_TYPE
prompt ==========================
prompt
create table MM_SYS_TYPE
(
  id             VARCHAR2(64) not null,
  type_group_key VARCHAR2(64) not null,
  name           VARCHAR2(128) not null,
  type_key       VARCHAR2(64) not null,
  stru_type      VARCHAR2(40) not null,
  parent_id      VARCHAR2(64),
  depth          INTEGER,
  path           VARCHAR2(255),
  is_leaf        CHAR(1),
  owner_id       VARCHAR2(64),
  sn             INTEGER,
  create_by      VARCHAR2(64),
  create_time    TIMESTAMP(6),
  create_org_id  VARCHAR2(64),
  update_by      VARCHAR2(64),
  update_time    TIMESTAMP(6)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_SYS_TYPE
  is '????';
comment on column MM_SYS_TYPE.id
  is '????';
comment on column MM_SYS_TYPE.type_group_key
  is '?????????';
comment on column MM_SYS_TYPE.name
  is '????';
comment on column MM_SYS_TYPE.type_key
  is '?????Key';
comment on column MM_SYS_TYPE.stru_type
  is 'flat ???tree ??';
comment on column MM_SYS_TYPE.parent_id
  is '???';
comment on column MM_SYS_TYPE.depth
  is '??';
comment on column MM_SYS_TYPE.path
  is '??';
comment on column MM_SYS_TYPE.is_leaf
  is '???????Y=??N=?';
comment on column MM_SYS_TYPE.owner_id
  is '???ID';
comment on column MM_SYS_TYPE.sn
  is '??';
comment on column MM_SYS_TYPE.create_by
  is '???ID';
comment on column MM_SYS_TYPE.create_time
  is '????';
comment on column MM_SYS_TYPE.create_org_id
  is '???????ID';
comment on column MM_SYS_TYPE.update_by
  is '???ID';
comment on column MM_SYS_TYPE.update_time
  is '????';

prompt
prompt Creating table MM_SYS_USER_PARAMS
prompt =================================
prompt
create table MM_SYS_USER_PARAMS
(
  id      VARCHAR2(50),
  user_id VARCHAR2(50),
  alias   VARCHAR2(50),
  value   VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_SYS_USER_PARAMS
  is '???????';
comment on column MM_SYS_USER_PARAMS.id
  is '??';
comment on column MM_SYS_USER_PARAMS.user_id
  is '??ID';
comment on column MM_SYS_USER_PARAMS.alias
  is '????';
comment on column MM_SYS_USER_PARAMS.value
  is '???';

prompt
prompt Creating table MM_SYS_USER_ROLE
prompt ===============================
prompt
create table MM_SYS_USER_ROLE
(
  id      VARCHAR2(64) not null,
  role_id VARCHAR2(64) not null,
  user_id VARCHAR2(64) not null
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_SYS_USER_ROLE
  is '??????';
comment on column MM_SYS_USER_ROLE.id
  is '????';
comment on column MM_SYS_USER_ROLE.role_id
  is '??ID';
comment on column MM_SYS_USER_ROLE.user_id
  is '??ID';

prompt
prompt Creating table MM_SYS_USER_UNDER
prompt ================================
prompt
create table MM_SYS_USER_UNDER
(
  id      VARCHAR2(50),
  user_id VARCHAR2(50),
  alias   VARCHAR2(50),
  value   VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table MM_SYS_USER_UNDER
  is '????';
comment on column MM_SYS_USER_UNDER.id
  is '??';
comment on column MM_SYS_USER_UNDER.user_id
  is '??ID';
comment on column MM_SYS_USER_UNDER.alias
  is '????';
comment on column MM_SYS_USER_UNDER.value
  is '???';

prompt
prompt Creating table SYS_DATASOURCE
prompt =============================
prompt
create table SYS_DATASOURCE
(
  id_            VARCHAR2(64) not null,
  name_          VARCHAR2(128) default '名称',
  alias_         VARCHAR2(64) not null,
  db_type_       VARCHAR2(64),
  setting_json_  CLOB,
  init_on_start_ NUMBER,
  enabled_       NUMBER,
  class_path_    VARCHAR2(128),
  init_method_   VARCHAR2(200) default '初始化方法，有些可以不填写',
  close_method_  VARCHAR2(150) default '关闭数据源的时候应该调用的方法，可不填'
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column SYS_DATASOURCE.id_
  is '??';
comment on column SYS_DATASOURCE.alias_
  is '??';
comment on column SYS_DATASOURCE.db_type_
  is '???id';
comment on column SYS_DATASOURCE.setting_json_
  is 'Json????';
comment on column SYS_DATASOURCE.init_on_start_
  is '???????????????spring??????';
comment on column SYS_DATASOURCE.enabled_
  is '????';
alter table SYS_DATASOURCE
  add constraint PK_SYS_DATASOURCE primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table SYS_DEMENSION
prompt ============================
prompt
create table SYS_DEMENSION
(
  id_         VARCHAR2(64) not null,
  dem_name_   VARCHAR2(100),
  dem_desc    VARCHAR2(300),
  dem_code_   VARCHAR2(100),
  is_default_ NUMBER
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table SYS_DEMENSION
  is '????';
comment on column SYS_DEMENSION.id_
  is '??id';
comment on column SYS_DEMENSION.dem_name_
  is '????';
comment on column SYS_DEMENSION.dem_desc
  is '??';
comment on column SYS_DEMENSION.is_default_
  is '??????';
alter table SYS_DEMENSION
  add constraint PK_SYS_DEMENSION primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table SYS_DIC
prompt ======================
prompt
create table SYS_DIC
(
  id_        VARCHAR2(64) not null,
  type_id_   VARCHAR2(64),
  key_       VARCHAR2(40),
  name_      VARCHAR2(128),
  parent_id_ VARCHAR2(64),
  sn_        NUMBER
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table SYS_DIC
  is '????';
comment on column SYS_DIC.id_
  is '??';
comment on column SYS_DIC.type_id_
  is '??ID';
comment on column SYS_DIC.key_
  is '?????,????????????';
comment on column SYS_DIC.name_
  is '?????';
comment on column SYS_DIC.parent_id_
  is '?ID';
comment on column SYS_DIC.sn_
  is '???';
alter table SYS_DIC
  add constraint PK_SYS_DIC primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table SYS_DP_BASE_DATA
prompt ===============================
prompt
create table SYS_DP_BASE_DATA
(
  dp_base_id       NUMBER(18) not null,
  type_code        VARCHAR2(32) not null,
  value_code       VARCHAR2(64) not null,
  value_desc       VARCHAR2(128),
  sort_num         NUMBER(8),
  create_user      VARCHAR2(32),
  create_time      DATE default SYSDATE,
  last_modify_user VARCHAR2(32),
  last_modify_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYS_DP_BASE_DATA
  add constraint PK_SYS_DP_BASE_DATA primary key (DP_BASE_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_DP_ROLE
prompt ==========================
prompt
create table SYS_DP_ROLE
(
  data_role_id     NUMBER(18) not null,
  data_role_name   VARCHAR2(256),
  data_role_type   VARCHAR2(32),
  remark           VARCHAR2(512),
  sort_num         NUMBER(8),
  create_user      VARCHAR2(32),
  create_time      DATE default SYSDATE,
  last_modify_user VARCHAR2(32),
  last_modify_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYS_DP_ROLE
  add constraint PK_SYS_DP_ROLE primary key (DATA_ROLE_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_DP_ROLE_DATA
prompt ===============================
prompt
create table SYS_DP_ROLE_DATA
(
  dp_base_id   NUMBER(18) not null,
  data_role_id NUMBER(18) not null,
  create_user  VARCHAR2(32),
  create_time  DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYS_DP_ROLE_DATA
  add constraint PK_SYS_DP_ROLE_DATA primary key (DATA_ROLE_ID, DP_BASE_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_DP_USER_ROLE
prompt ===============================
prompt
create table SYS_DP_USER_ROLE
(
  user_id      VARCHAR2(64) not null,
  data_role_id NUMBER(18) not null,
  create_user  VARCHAR2(32),
  create_time  DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYS_DP_USER_ROLE
  add constraint PK_SYS_DP_USER_ROLE primary key (USER_ID, DATA_ROLE_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_FILE
prompt =======================
prompt
create table SYS_FILE
(
  id_           VARCHAR2(64) not null,
  xb_type_id_   VARCHAR2(64),
  file_name_    VARCHAR2(128) not null,
  file_type_    VARCHAR2(40),
  store_type_   VARCHAR2(40) not null,
  file_path_    VARCHAR2(255),
  bytes_        BLOB,
  byte_count_   NUMBER,
  ext_          VARCHAR2(20),
  note_         VARCHAR2(255),
  creator_      VARCHAR2(64),
  creator_name_ VARCHAR2(64),
  create_time_  TIMESTAMP(6) default SYSDATE not null,
  is_del_       CHAR(1) not null
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column SYS_FILE.id_
  is '??';
comment on column SYS_FILE.xb_type_id_
  is '????ID';
alter table SYS_FILE
  add constraint PK_SYS_FILE primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_IDENTITY
prompt ===========================
prompt
create table SYS_IDENTITY
(
  id_         VARCHAR2(64) not null,
  name_       VARCHAR2(64),
  alias_      VARCHAR2(20),
  regulation_ VARCHAR2(128),
  gen_type_   NUMBER,
  no_length_  NUMBER,
  cur_date_   VARCHAR2(20),
  init_value_ NUMBER,
  cur_value_  NUMBER,
  step_       NUMBER
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYS_IDENTITY
  is '?????';
comment on column SYS_IDENTITY.id_
  is '??';
comment on column SYS_IDENTITY.name_
  is '??';
comment on column SYS_IDENTITY.alias_
  is '??';
comment on column SYS_IDENTITY.regulation_
  is '??';
comment on column SYS_IDENTITY.gen_type_
  is '????';
comment on column SYS_IDENTITY.no_length_
  is '?????';
comment on column SYS_IDENTITY.cur_date_
  is '????';
comment on column SYS_IDENTITY.init_value_
  is '???';
comment on column SYS_IDENTITY.cur_value_
  is '???';
comment on column SYS_IDENTITY.step_
  is '??';
alter table SYS_IDENTITY
  add constraint PK_SYS_IDENTITY primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_LOG_ERR
prompt ==========================
prompt
create table SYS_LOG_ERR
(
  id_          VARCHAR2(50) not null,
  account_     VARCHAR2(20),
  ip_          VARCHAR2(20),
  url_         VARCHAR2(1500),
  content_     CLOB,
  create_time_ TIMESTAMP(6)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYS_LOG_ERR
  is '??????';
comment on column SYS_LOG_ERR.id_
  is '??';
comment on column SYS_LOG_ERR.account_
  is '??';
comment on column SYS_LOG_ERR.ip_
  is 'IP??';
comment on column SYS_LOG_ERR.url_
  is '??URL';
comment on column SYS_LOG_ERR.content_
  is '????';
comment on column SYS_LOG_ERR.create_time_
  is '????';
alter table SYS_LOG_ERR
  add constraint PK_SYS_LOG_ERR primary key (ID_)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_ORG
prompt ======================
prompt
create table SYS_ORG
(
  id_        VARCHAR2(64) not null,
  name_      VARCHAR2(64) not null,
  parent_id_ VARCHAR2(64),
  order_no_  NUMBER default 100,
  code_      VARCHAR2(64) not null,
  grade_     VARCHAR2(64),
  path_      VARCHAR2(600),
  path_name_ VARCHAR2(600),
  dem_id_    VARCHAR2(64)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table SYS_ORG
  is '????';
comment on column SYS_ORG.id_
  is '??';
comment on column SYS_ORG.grade_
  is '??';
comment on column SYS_ORG.path_
  is '??id?????????  ';
comment on column SYS_ORG.path_name_
  is '????????????';
comment on column SYS_ORG.dem_id_
  is '????id';
alter table SYS_ORG
  add constraint PK_SYS_ORG primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table SYS_ORG_AUTH
prompt ===========================
prompt
create table SYS_ORG_AUTH
(
  id_            VARCHAR2(64) not null,
  user_id_       VARCHAR2(64),
  org_id_        VARCHAR2(64),
  dem_id_        VARCHAR2(64),
  org_perms_     VARCHAR2(200),
  user_perms_    VARCHAR2(200),
  pos_perms_     VARCHAR2(200),
  orgauth_perms_ VARCHAR2(200),
  layout_perms_  VARCHAR2(200)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table SYS_ORG_AUTH
  is '??????';
comment on column SYS_ORG_AUTH.user_id_
  is '???????id';
comment on column SYS_ORG_AUTH.org_id_
  is '??????id';
comment on column SYS_ORG_AUTH.dem_id_
  is '????id';
comment on column SYS_ORG_AUTH.org_perms_
  is '??????';
comment on column SYS_ORG_AUTH.user_perms_
  is '??????';
comment on column SYS_ORG_AUTH.pos_perms_
  is '??????';
comment on column SYS_ORG_AUTH.orgauth_perms_
  is '???????';
alter table SYS_ORG_AUTH
  add constraint PK_SYS_ORG_AUTH primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table SYS_ORG_PARAMS
prompt =============================
prompt
create table SYS_ORG_PARAMS
(
  id_     VARCHAR2(50) not null,
  org_id_ VARCHAR2(50),
  alias_  VARCHAR2(50),
  value_  VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table SYS_ORG_PARAMS
  is '????';
alter table SYS_ORG_PARAMS
  add constraint PK_SYS_ORG_PARAMS primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table SYS_ORG_REL
prompt ==========================
prompt
create table SYS_ORG_REL
(
  id_         VARCHAR2(64) not null,
  org_id_     VARCHAR2(64),
  rel_def_id_ VARCHAR2(64),
  rel_name_   VARCHAR2(64),
  rel_code_   VARCHAR2(64)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table SYS_ORG_REL
  is '????';
comment on column SYS_ORG_REL.rel_name_
  is '????';
comment on column SYS_ORG_REL.rel_code_
  is '????';
alter table SYS_ORG_REL
  add constraint PK_SYS_ORG_REL primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table SYS_ORG_RELDEF
prompt =============================
prompt
create table SYS_ORG_RELDEF
(
  id_          VARCHAR2(64) not null,
  name_        VARCHAR2(64) not null,
  code_        VARCHAR2(64) not null,
  post_level_  VARCHAR2(64),
  description_ VARCHAR2(500)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table SYS_ORG_RELDEF
  is '????';
comment on column SYS_ORG_RELDEF.name_
  is '??';
comment on column SYS_ORG_RELDEF.code_
  is '??';
comment on column SYS_ORG_RELDEF.post_level_
  is '????';
comment on column SYS_ORG_RELDEF.description_
  is '??';
alter table SYS_ORG_RELDEF
  add constraint PK_SYS_ORG_RELDEF primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table SYS_ORG_USER
prompt ===========================
prompt
create table SYS_ORG_USER
(
  id_        VARCHAR2(64) not null,
  org_id_    VARCHAR2(64) not null,
  user_id_   VARCHAR2(64) not null,
  is_master_ NUMBER default 0 not null,
  rel_id_    VARCHAR2(64),
  is_charge_ NUMBER default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table SYS_ORG_USER
  is '??????';
comment on column SYS_ORG_USER.org_id_
  is '????';
comment on column SYS_ORG_USER.user_id_
  is '????';
comment on column SYS_ORG_USER.is_master_
  is '0:?????1????';
comment on column SYS_ORG_USER.rel_id_
  is '????';
comment on column SYS_ORG_USER.is_charge_
  is '2???????1??????0 ?????  ';
alter table SYS_ORG_USER
  add constraint PK_SYS_ORG_USER primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table SYS_PROPERTIES
prompt =============================
prompt
create table SYS_PROPERTIES
(
  id          VARCHAR2(64) not null,
  name        VARCHAR2(64),
  alias       VARCHAR2(64),
  group_      VARCHAR2(64),
  value       VARCHAR2(2000),
  encrypt     NUMBER,
  createtime  TIMESTAMP(6),
  description VARCHAR2(300)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYS_PROPERTIES
  is '??????';
comment on column SYS_PROPERTIES.id
  is '??';
comment on column SYS_PROPERTIES.name
  is '??';
comment on column SYS_PROPERTIES.alias
  is '??';
comment on column SYS_PROPERTIES.group_
  is '??';
comment on column SYS_PROPERTIES.value
  is '???';
comment on column SYS_PROPERTIES.encrypt
  is '????';
comment on column SYS_PROPERTIES.createtime
  is '????';
comment on column SYS_PROPERTIES.description
  is '??';
alter table SYS_PROPERTIES
  add constraint PK_SYS_PROPERTIES primary key (ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_ROLE
prompt =======================
prompt
create table SYS_ROLE
(
  id_         VARCHAR2(64) not null,
  name_       VARCHAR2(64) not null,
  alias_      VARCHAR2(64) not null,
  enabled_    NUMBER default 1 not null,
  description VARCHAR2(200)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYS_ROLE
  is '????';
comment on column SYS_ROLE.id_
  is '??';
comment on column SYS_ROLE.name_
  is '????';
comment on column SYS_ROLE.alias_
  is '????';
comment on column SYS_ROLE.enabled_
  is '?? 0????1???';
comment on column SYS_ROLE.description
  is '??';
alter table SYS_ROLE
  add constraint PK_SYS_ROLE primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_TYPE
prompt =======================
prompt
create table SYS_TYPE
(
  id_             VARCHAR2(64) not null,
  type_group_key_ VARCHAR2(64) not null,
  name_           VARCHAR2(128) not null,
  type_key_       VARCHAR2(64) not null,
  stru_type_      VARCHAR2(40) not null,
  parent_id_      VARCHAR2(64),
  depth_          NUMBER,
  path_           VARCHAR2(255),
  is_leaf_        CHAR(1),
  owner_id_       VARCHAR2(64),
  sn_             NUMBER not null,
  create_by_      VARCHAR2(64),
  create_time_    TIMESTAMP(6),
  create_org_id_  VARCHAR2(64),
  update_by_      VARCHAR2(64),
  update_time_    TIMESTAMP(6)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYS_TYPE
  is '????????????????????????????????';
comment on column SYS_TYPE.id_
  is '??ID';
comment on column SYS_TYPE.type_group_key_
  is '?????????';
comment on column SYS_TYPE.name_
  is '????';
comment on column SYS_TYPE.type_key_
  is '?????Key';
comment on column SYS_TYPE.stru_type_
  is 'flat ???tree ??';
comment on column SYS_TYPE.parent_id_
  is '???';
comment on column SYS_TYPE.depth_
  is '??';
comment on column SYS_TYPE.path_
  is '??';
comment on column SYS_TYPE.is_leaf_
  is '???????Y=??N=?';
comment on column SYS_TYPE.sn_
  is '??';
comment on column SYS_TYPE.create_by_
  is '???ID';
comment on column SYS_TYPE.create_time_
  is '????';
comment on column SYS_TYPE.create_org_id_
  is '???????ID';
comment on column SYS_TYPE.update_by_
  is '???ID';
comment on column SYS_TYPE.update_time_
  is '????';
alter table SYS_TYPE
  add constraint PK_SYS_TYPE primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_TYPE_GROUP
prompt =============================
prompt
create table SYS_TYPE_GROUP
(
  id_            VARCHAR2(64) not null,
  group_key_     VARCHAR2(64) not null,
  name_          VARCHAR2(128) not null,
  flag_          NUMBER,
  sn_            NUMBER,
  type_          NUMBER,
  create_by_     VARCHAR2(64),
  create_time_   TIMESTAMP(6),
  create_org_id_ VARCHAR2(64),
  update_by_     VARCHAR2(64),
  update_time_   TIMESTAMP(6)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYS_TYPE_GROUP
  is '???????';
comment on column SYS_TYPE_GROUP.id_
  is '??ID';
comment on column SYS_TYPE_GROUP.group_key_
  is '???????';
comment on column SYS_TYPE_GROUP.name_
  is '???';
comment on column SYS_TYPE_GROUP.flag_
  is '??';
comment on column SYS_TYPE_GROUP.sn_
  is '??';
comment on column SYS_TYPE_GROUP.type_
  is '???0=?????1=????';
comment on column SYS_TYPE_GROUP.create_by_
  is '???ID';
comment on column SYS_TYPE_GROUP.create_time_
  is '????';
comment on column SYS_TYPE_GROUP.create_org_id_
  is '???????ID';
comment on column SYS_TYPE_GROUP.update_by_
  is '???ID';
comment on column SYS_TYPE_GROUP.update_time_
  is '????';
alter table SYS_TYPE_GROUP
  add constraint PK_SYS_TYPE_GROUP primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_USER
prompt =======================
prompt
create table SYS_USER
(
  id_              VARCHAR2(64) not null,
  fullname_        VARCHAR2(255) not null,
  account_         VARCHAR2(255) not null,
  password_        VARCHAR2(64) not null,
  email_           VARCHAR2(64),
  mobile_          VARCHAR2(32),
  weixin_          VARCHAR2(64),
  create_time_     TIMESTAMP(6) default sysdate,
  address_         VARCHAR2(512),
  photo_           VARCHAR2(255),
  sex_             VARCHAR2(10),
  from_            VARCHAR2(64),
  status_          NUMBER default 1 not null,
  has_sync_to_wx_  NUMBER,
  open_id_         VARCHAR2(64),
  sign_name_fileid VARCHAR2(64),
  factory_code     VARCHAR2(10),
  user_type        NUMBER(1),
  supplier_no      VARCHAR2(10),
  department       VARCHAR2(52),
  temp_field1      VARCHAR2(64),
  temp_field2      VARCHAR2(64),
  temp_field3      VARCHAR2(64),
  temp_field4      VARCHAR2(64),
  temp_field5      VARCHAR2(64)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYS_USER
  is '???';
comment on column SYS_USER.fullname_
  is '姓名';
comment on column SYS_USER.account_
  is '账号';
comment on column SYS_USER.password_
  is '密码';
comment on column SYS_USER.email_
  is '邮箱';
comment on column SYS_USER.mobile_
  is '手机号码';
comment on column SYS_USER.weixin_
  is '微信号';
comment on column SYS_USER.create_time_
  is '创建时间';
comment on column SYS_USER.address_
  is '地址';
comment on column SYS_USER.photo_
  is '头像';
comment on column SYS_USER.sex_
  is '性别：男，女，未知';
comment on column SYS_USER.from_
  is '来源';
comment on column SYS_USER.status_
  is '0:禁用，1正常';
comment on column SYS_USER.open_id_
  is '微信的open_id_';
comment on column SYS_USER.sign_name_fileid
  is '电子签名文件ID';
comment on column SYS_USER.factory_code
  is '工厂';
comment on column SYS_USER.user_type
  is '用户类型（1-广新用户  2-供应商用户,3-PDA用户）用户测试临时添加';
comment on column SYS_USER.supplier_no
  is '用户测试临时添加';
comment on column SYS_USER.department
  is '部门';
comment on column SYS_USER.temp_field1
  is '申请人';
comment on column SYS_USER.temp_field2
  is '处理人';
alter table SYS_USER
  add constraint PK_SYS_USER primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYS_USER
  add constraint PK_SYS_USER_ACCOUNT unique (ACCOUNT_)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_USER_PARAMS
prompt ==============================
prompt
create table SYS_USER_PARAMS
(
  id_      VARCHAR2(50),
  user_id_ VARCHAR2(50),
  alias_   VARCHAR2(50),
  value_   VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table SYS_USER_PARAMS
  is '??????';

prompt
prompt Creating table SYS_USER_REL
prompt ===========================
prompt
create table SYS_USER_REL
(
  id_        VARCHAR2(64) not null,
  user_id_   VARCHAR2(64),
  level_     VARCHAR2(64),
  parent_id_ VARCHAR2(64),
  type_id_   VARCHAR2(64)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table SYS_USER_REL
  is '?????';
comment on column SYS_USER_REL.id_
  is '??';
comment on column SYS_USER_REL.level_
  is '??(????????????)';
comment on column SYS_USER_REL.parent_id_
  is '?id';
comment on column SYS_USER_REL.type_id_
  is '????????id';
alter table SYS_USER_REL
  add constraint PK_SYS_USER_REL primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table SYS_USER_ROLE
prompt ============================
prompt
create table SYS_USER_ROLE
(
  id_      VARCHAR2(64) not null,
  role_id_ VARCHAR2(64) not null,
  user_id_ VARCHAR2(64) not null
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYS_USER_ROLE
  is '??????';
alter table SYS_USER_ROLE
  add constraint PK_SYS_USER_ROLE primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_USER_UNDER
prompt =============================
prompt
create table SYS_USER_UNDER
(
  id_              VARCHAR2(64) not null,
  user_id_         VARCHAR2(64),
  under_user_id_   VARCHAR2(64),
  under_user_name_ VARCHAR2(100),
  org_id_          VARCHAR2(64)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table SYS_USER_UNDER
  is '????';
comment on column SYS_USER_UNDER.user_id_
  is '??id';
comment on column SYS_USER_UNDER.under_user_id_
  is '????id';
comment on column SYS_USER_UNDER.under_user_name_
  is '?????';
comment on column SYS_USER_UNDER.org_id_
  is '??id';
alter table SYS_USER_UNDER
  add constraint PK_SYS_USER_UNDER primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table S_IF_CONFIG
prompt ==========================
prompt
create table S_IF_CONFIG
(
  next_hi NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table S_IF_EXECUTION
prompt =============================
prompt
create table S_IF_EXECUTION
(
  next_hi NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table S_IF_QUERY_LOG
prompt =============================
prompt
create table S_IF_QUERY_LOG
(
  next_hi NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table S_IF_RECEIVE_FILE
prompt ================================
prompt
create table S_IF_RECEIVE_FILE
(
  next_hi NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table S_IF_RECEIVE_LOG
prompt ===============================
prompt
create table S_IF_RECEIVE_LOG
(
  next_hi NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table S_IF_XML_FILE_LOG
prompt ================================
prompt
create table S_IF_XML_FILE_LOG
(
  next_hi NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_PKG
prompt =======================
prompt
create table TEMP_PKG
(
  car_type           VARCHAR2(20),
  supplier_no        VARCHAR2(20),
  part_no            VARCHAR2(20),
  proposal_status    NUMBER(1) default 0,
  pack_type          NUMBER(1),
  box_type           NUMBER(2),
  reply_limit_date   DATE,
  is_com_pack        NUMBER(1),
  status             NUMBER(1),
  sign_pro_file      VARCHAR2(50),
  eff_start          DATE,
  eff_end            DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  factory_code       VARCHAR2(10),
  part_resp_user     VARCHAR2(30),
  project            VARCHAR2(50),
  purchase_type      VARCHAR2(10),
  com_pack_remark    VARCHAR2(600),
  is_show_change     NUMBER(1) default 0,
  email_flag         NUMBER(1) default 0,
  check_remark       VARCHAR2(300),
  id                 VARCHAR2(50),
  proposal_id        VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column TEMP_PKG.car_type
  is '??';
comment on column TEMP_PKG.supplier_no
  is '?????';
comment on column TEMP_PKG.part_no
  is '????';
comment on column TEMP_PKG.proposal_status
  is '0-???
1-????
2-???
3-????
4-?????
5-????
6-?????
7-??';
comment on column TEMP_PKG.pack_type
  is '0-???
1-??';
comment on column TEMP_PKG.box_type
  is '0??? 1??? 2?EU? 3???';
comment on column TEMP_PKG.reply_limit_date
  is '????';
comment on column TEMP_PKG.is_com_pack
  is '0-?
1-?';
comment on column TEMP_PKG.status
  is '1-??
2-??';
comment on column TEMP_PKG.eff_start
  is '????';
comment on column TEMP_PKG.eff_end
  is '????';
comment on column TEMP_PKG.is_show_change
  is '0?? 1?? 2????????';
comment on column TEMP_PKG.email_flag
  is '0???
1???';
comment on column TEMP_PKG.proposal_id
  is '??ID';

prompt
prompt Creating table TEMP_PKG_DETAIL
prompt ==============================
prompt
create table TEMP_PKG_DETAIL
(
  proposal_id           NUMBER(19),
  group_no              VARCHAR2(30),
  max_package_num       NUMBER(10),
  standard_package      NUMBER(10),
  part_weight           NUMBER(10,3),
  part_total_weight     NUMBER(10,3),
  pack_weight           NUMBER(10,3),
  part_length           NUMBER(10,3),
  part_width            NUMBER(10,3),
  part_height           NUMBER(10,3),
  empty_trolley_length  NUMBER(10,3),
  empty_trolley_width   NUMBER(10,3),
  empty_trolley_height  NUMBER(10,3),
  real_trolley_length   NUMBER(10,3),
  real_trolley_width    NUMBER(10,3),
  real_trolley_height   NUMBER(10,3),
  trolley_weight        NUMBER(10,3),
  total_weight          NUMBER(10,3),
  is_trolley_code       NUMBER(1),
  is_positioner         NUMBER(1),
  dust_cover            NUMBER(1),
  one_by_package        NUMBER(1),
  int_mate              NUMBER(1),
  board_location        VARCHAR2(10),
  wheel_diameter        NUMBER(10,3),
  word_desc             VARCHAR2(600),
  traction_rod_height   NUMBER(10,3),
  important_postion_pic VARCHAR2(50),
  empty_tro_front_pic   VARCHAR2(50),
  empty_tro_side_pic    VARCHAR2(50),
  real_tro_pic          VARCHAR2(50),
  box_code              VARCHAR2(20),
  pack_length           NUMBER(10,3),
  pack_width            NUMBER(10,3),
  pack_height           NUMBER(10,3),
  tray_length           NUMBER(10,3),
  tray_width            NUMBER(10,3),
  tray_height           NUMBER(10,3),
  work_require          VARCHAR2(500),
  single_part_pic       VARCHAR2(50),
  single_part_put_pic   VARCHAR2(50),
  pack_over_look_pic    VARCHAR2(50),
  pack_side_look_pic    VARCHAR2(50),
  creation_user         VARCHAR2(30),
  creation_time         DATE default sysdate,
  last_modified_user    VARCHAR2(30),
  last_modified_time    DATE,
  factory_code          VARCHAR2(10),
  sup_name              VARCHAR2(30),
  mobile                VARCHAR2(30),
  mail                  VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column TEMP_PKG_DETAIL.group_no
  is '??';
comment on column TEMP_PKG_DETAIL.max_package_num
  is '?????';
comment on column TEMP_PKG_DETAIL.standard_package
  is '?????';
comment on column TEMP_PKG_DETAIL.part_weight
  is '????';
comment on column TEMP_PKG_DETAIL.part_total_weight
  is '?????';
comment on column TEMP_PKG_DETAIL.part_length
  is '???';
comment on column TEMP_PKG_DETAIL.part_width
  is '???';
comment on column TEMP_PKG_DETAIL.part_height
  is '???';
comment on column TEMP_PKG_DETAIL.empty_trolley_length
  is '????';
comment on column TEMP_PKG_DETAIL.empty_trolley_width
  is '????';
comment on column TEMP_PKG_DETAIL.empty_trolley_height
  is '????';
comment on column TEMP_PKG_DETAIL.real_trolley_length
  is '????';
comment on column TEMP_PKG_DETAIL.real_trolley_width
  is '????';
comment on column TEMP_PKG_DETAIL.real_trolley_height
  is '????';
comment on column TEMP_PKG_DETAIL.trolley_weight
  is '????';
comment on column TEMP_PKG_DETAIL.total_weight
  is '???';
comment on column TEMP_PKG_DETAIL.is_trolley_code
  is '0-?
1-?';
comment on column TEMP_PKG_DETAIL.is_positioner
  is '0-?
1-?';
comment on column TEMP_PKG_DETAIL.dust_cover
  is '0-?
1-?';
comment on column TEMP_PKG_DETAIL.one_by_package
  is '0-?
1-?';
comment on column TEMP_PKG_DETAIL.board_location
  is 'L  / W';
comment on column TEMP_PKG_DETAIL.wheel_diameter
  is '????';
comment on column TEMP_PKG_DETAIL.word_desc
  is '????';
comment on column TEMP_PKG_DETAIL.traction_rod_height
  is '??????';
comment on column TEMP_PKG_DETAIL.important_postion_pic
  is '?????';
comment on column TEMP_PKG_DETAIL.empty_tro_front_pic
  is '??????';
comment on column TEMP_PKG_DETAIL.empty_tro_side_pic
  is '??????';
comment on column TEMP_PKG_DETAIL.real_tro_pic
  is '????';

prompt
prompt Creating table TESTA
prompt ====================
prompt
create table TESTA
(
  part_no          VARCHAR2(30),
  standard_package NUMBER
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
  );

prompt
prompt Creating table TESTMP
prompt =====================
prompt
create table TESTMP
(
  factory_code    VARCHAR2(10),
  supplier_no     VARCHAR2(20),
  sup_factory     VARCHAR2(20),
  unload_port     VARCHAR2(10),
  part_no         VARCHAR2(64),
  logistics_flag  VARCHAR2(10),
  group_id        NUMBER(10),
  logistics_order VARCHAR2(30),
  total_order_num NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_DATA_DICT
prompt =============================
prompt
create table TEST_DATA_DICT
(
  factory_code     VARCHAR2(10),
  code_type        VARCHAR2(30),
  code_type_name   VARCHAR2(100),
  code_value       VARCHAR2(30),
  code_value_name  VARCHAR2(100),
  other_code_value VARCHAR2(30),
  remark           VARCHAR2(150),
  sort_no          NUMBER(5),
  is_edit          NUMBER(1)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_INV
prompt =======================
prompt
create table TEST_INV
(
  order_no VARCHAR2(50),
  part_no  VARCHAR2(30),
  rec_qty  NUMBER(19)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_INV_STOCK
prompt =============================
prompt
create table TEST_INV_STOCK
(
  part_no       VARCHAR2(50),
  ware_code     VARCHAR2(30),
  num           NUMBER,
  part_short_no VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 8K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_MM_INV_IN
prompt =============================
prompt
create table TEST_MM_INV_IN
(
  rec_no               VARCHAR2(50) not null,
  factory_code         VARCHAR2(10),
  order_no             VARCHAR2(50),
  rec_times            NUMBER(2),
  depot_no             VARCHAR2(20),
  ope_ip               VARCHAR2(50),
  rec_client           NUMBER(1),
  order_type           VARCHAR2(10),
  actual_arr_pro_seqno NUMBER(19),
  inv_flag             NUMBER(1) default 0,
  inv_time             DATE,
  deal_flag            NUMBER(1) default 0,
  deal_time            DATE,
  creation_user        VARCHAR2(30),
  creation_time        DATE default sysdate,
  note                 VARCHAR2(100),
  p_deal_flag          NUMBER(1) default 0,
  p_deal_time          DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_MM_INV_IN_DETAIL
prompt ====================================
prompt
create table TEST_MM_INV_IN_DETAIL
(
  rec_no        VARCHAR2(50),
  row_no        NUMBER(5),
  rec_times     NUMBER(2),
  part_no       VARCHAR2(64),
  order_qty     NUMBER(10),
  rec_qty       NUMBER(10),
  creation_time DATE default sysdate
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_MM_JIT_NET_REQ
prompt ==================================
prompt
create table TEST_MM_JIT_NET_REQ
(
  plan_code        VARCHAR2(20) not null,
  order_no         VARCHAR2(50) not null,
  part_no          VARCHAR2(64) not null,
  location         VARCHAR2(20),
  require_num      NUMBER(10),
  model_code       VARCHAR2(20),
  pass_time        DATE,
  kb_product_seqno NUMBER(19),
  kb_time          DATE,
  deal_state       NUMBER(1) default 0,
  creation_time    DATE default SYSDATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_MM_PUB_PRO_PLAN
prompt ===================================
prompt
create table TEST_MM_PUB_PRO_PLAN
(
  factory_code       VARCHAR2(10) not null,
  order_no           VARCHAR2(50) not null,
  order_type         VARCHAR2(10),
  weon_time          DATE,
  afoff_time         DATE,
  sort_id            NUMBER(19),
  mtoc               VARCHAR2(64),
  model_code         VARCHAR2(10),
  phase              VARCHAR2(10),
  creation_time      DATE default sysdate,
  last_modified_time DATE,
  cal_status         NUMBER(1) default 0,
  cal_time           DATE,
  use_flag           NUMBER(1) default 0,
  dms_order_no       VARCHAR2(50),
  dms_order_row_no   NUMBER(10),
  mes_order_no       VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table TEST_MM_PUB_PRO_PLAN
  is 'MM_PUB_PRO_PLAN整车W+3周生产计划表';
comment on column TEST_MM_PUB_PRO_PLAN.factory_code
  is '"工厂
工厂
"';
comment on column TEST_MM_PUB_PRO_PLAN.order_no
  is '"订单号
订单号
"';
comment on column TEST_MM_PUB_PRO_PLAN.order_type
  is '"订单类型
订单类型
"';
comment on column TEST_MM_PUB_PRO_PLAN.weon_time
  is '"焊装上线时间
焊装上线时间
"';
comment on column TEST_MM_PUB_PRO_PLAN.afoff_time
  is '"总装下线时间
总装下线时间
"';
comment on column TEST_MM_PUB_PRO_PLAN.sort_id
  is '"排序码
排序码
"';
comment on column TEST_MM_PUB_PRO_PLAN.mtoc
  is '"MTOC
MTOC
"';
comment on column TEST_MM_PUB_PRO_PLAN.model_code
  is '"车型
车型
A16、A28"';
comment on column TEST_MM_PUB_PRO_PLAN.phase
  is '"生产阶段
生产阶段
"';
comment on column TEST_MM_PUB_PRO_PLAN.creation_time
  is '"创建时间
创建时间
"';
comment on column TEST_MM_PUB_PRO_PLAN.last_modified_time
  is '"最后修改时间
最后修改时间
"';
comment on column TEST_MM_PUB_PRO_PLAN.cal_status
  is '"计算状态
计算状态
计算状态 默认值0未计算 1已计算 主要用于抓取新车型计划"';
comment on column TEST_MM_PUB_PRO_PLAN.cal_time
  is '"计算时间
计算时间
计算时间"';
comment on column TEST_MM_PUB_PRO_PLAN.use_flag
  is '"使用状态
使用状态
使用状态 默认值0 未使用 1已使用"';
comment on column TEST_MM_PUB_PRO_PLAN.dms_order_no
  is 'DMS订单号';
comment on column TEST_MM_PUB_PRO_PLAN.dms_order_row_no
  is 'DMS订单行号';
comment on column TEST_MM_PUB_PRO_PLAN.mes_order_no
  is 'MES订单号 ';
create index IDX_TEST_MM_PUB_PRO_PLAN on TEST_MM_PUB_PRO_PLAN (AFOFF_TIME)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table TEST_ORDER
prompt =========================
prompt
create table TEST_ORDER
(
  purchase_no         VARCHAR2(50) not null,
  order_no            VARCHAR2(50),
  order_type          VARCHAR2(2),
  factory_code        VARCHAR2(10),
  supplier_no         VARCHAR2(20),
  order_date          DATE,
  arrive_date         DATE,
  depot_no            VARCHAR2(20),
  sup_factory         VARCHAR2(20),
  print_status        NUMBER(1) default 0,
  print_time          DATE,
  label_print_status  NUMBER(1) default 0,
  label_print_time    DATE,
  delivery_status     NUMBER(1) default 0,
  receive_status      NUMBER(1) default 0,
  download_status     NUMBER(1) default 0,
  download_time       DATE,
  reply_delivery_date DATE,
  is_urgent           NUMBER(1) default 0,
  creation_user       VARCHAR2(30),
  creation_time       DATE default sysdate,
  last_modified_user  VARCHAR2(30),
  last_modified_time  DATE,
  sp_type             VARCHAR2(2),
  receive_date        DATE,
  receive_count       NUMBER(5),
  prepare_status      NUMBER(1),
  prepare_count       NUMBER(5),
  prepare_time        DATE,
  hms_order_no        VARCHAR2(50),
  rec_address         VARCHAR2(300),
  rec_user            VARCHAR2(30),
  rec_tel             VARCHAR2(30),
  planner             VARCHAR2(30),
  deal_flag           NUMBER(1) default 0,
  deal_time           DATE,
  plan_prepare_time   DATE,
  zg_flag             NUMBER(1),
  print_user          VARCHAR2(30),
  print_user_ip       VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_ORDER_DETAIL
prompt ================================
prompt
create table TEST_ORDER_DETAIL
(
  id                 NUMBER(10) not null,
  purchase_no        VARCHAR2(50),
  purchase_rowno     NUMBER(10),
  order_rowno        NUMBER(10),
  depot_no           VARCHAR2(20),
  order_qty          NUMBER(19),
  order_unit         VARCHAR2(20),
  part_no            VARCHAR2(64),
  standard_package   NUMBER(10),
  total_deliv_qty    NUMBER(10),
  total_rec_qty      NUMBER(10) default 0,
  delivery_status    NUMBER(1) default 0,
  receive_status     NUMBER(1) default 0,
  receive_date       DATE,
  receive_count      NUMBER(5) default 0,
  cancel_num         NUMBER(19) default 0,
  cost_center        VARCHAR2(50),
  zk_flag            VARCHAR2(10),
  inv_type           VARCHAR2(30),
  cost_code          VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_time DATE,
  prepare_num        NUMBER(19),
  arrive_num         NUMBER(19),
  order_no           VARCHAR2(50),
  current_qty        NUMBER(10),
  package_num        NUMBER(16)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_PART
prompt ========================
prompt
create table TEST_PART
(
  part_no VARCHAR2(500),
  rec_num NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_PART_26
prompt ===========================
prompt
create table TEST_PART_26
(
  part_no VARCHAR2(30),
  rec_num NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_PKG
prompt =======================
prompt
create table TEST_PKG
(
  id                 NUMBER(19),
  car_type           VARCHAR2(20),
  supplier_no        VARCHAR2(20),
  part_no            VARCHAR2(20),
  proposal_status    NUMBER(1) default 0,
  pack_type          NUMBER(1),
  box_type           NUMBER(2),
  reply_limit_date   DATE,
  is_com_pack        NUMBER(1),
  status             NUMBER(1),
  sign_pro_file      VARCHAR2(50),
  eff_start          DATE,
  eff_end            DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  factory_code       VARCHAR2(10),
  part_resp_user     VARCHAR2(30),
  project            VARCHAR2(50),
  purchase_type      VARCHAR2(10),
  com_pack_remark    VARCHAR2(100),
  is_show_change     NUMBER(1) default 0,
  email_flag         NUMBER(1) default 0,
  check_remark       VARCHAR2(300)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column TEST_PKG.car_type
  is '??';
comment on column TEST_PKG.supplier_no
  is '?????';
comment on column TEST_PKG.part_no
  is '????';
comment on column TEST_PKG.proposal_status
  is '0-???
1-????
2-???
3-????
4-?????
5-????
6-?????
7-??';
comment on column TEST_PKG.pack_type
  is '0-???
1-??';
comment on column TEST_PKG.box_type
  is '0??? 1??? 2?EU? 3???';
comment on column TEST_PKG.reply_limit_date
  is '????';
comment on column TEST_PKG.is_com_pack
  is '0-?
1-?';
comment on column TEST_PKG.status
  is '1-??
2-??';
comment on column TEST_PKG.eff_start
  is '????';
comment on column TEST_PKG.eff_end
  is '????';
comment on column TEST_PKG.is_show_change
  is '0?? 1?? 2????????';
comment on column TEST_PKG.email_flag
  is '0???
1???';

prompt
prompt Creating table TEST_PKG_DETAIL
prompt ==============================
prompt
create table TEST_PKG_DETAIL
(
  id                    NUMBER(19),
  proposal_id           NUMBER(19),
  group_no              VARCHAR2(30),
  max_package_num       NUMBER(10),
  standard_package      NUMBER(10),
  part_weight           NUMBER(10,3),
  part_total_weight     NUMBER(10,3),
  pack_weight           NUMBER(10,3),
  part_length           NUMBER(10,3),
  part_width            NUMBER(10,3),
  part_height           NUMBER(10,3),
  empty_trolley_length  NUMBER(10,3),
  empty_trolley_width   NUMBER(10,3),
  empty_trolley_height  NUMBER(10,3),
  real_trolley_length   NUMBER(10,3),
  real_trolley_width    NUMBER(10,3),
  real_trolley_height   NUMBER(10,3),
  trolley_weight        NUMBER(10,3),
  total_weight          NUMBER(10,3),
  is_trolley_code       NUMBER(1),
  is_positioner         NUMBER(1),
  dust_cover            NUMBER(1),
  one_by_package        NUMBER(1),
  int_mate              NUMBER(1),
  board_location        VARCHAR2(10),
  wheel_diameter        NUMBER(10,3),
  word_desc             VARCHAR2(600),
  traction_rod_height   NUMBER(10,3),
  important_postion_pic VARCHAR2(50),
  empty_tro_front_pic   VARCHAR2(50),
  empty_tro_side_pic    VARCHAR2(50),
  real_tro_pic          VARCHAR2(50),
  box_code              VARCHAR2(20),
  pack_length           NUMBER(10,3),
  pack_width            NUMBER(10,3),
  pack_height           NUMBER(10,3),
  tray_length           NUMBER(10,3),
  tray_width            NUMBER(10,3),
  tray_height           NUMBER(10,3),
  work_require          VARCHAR2(500),
  single_part_pic       VARCHAR2(50),
  single_part_put_pic   VARCHAR2(50),
  pack_over_look_pic    VARCHAR2(50),
  pack_side_look_pic    VARCHAR2(50),
  creation_user         VARCHAR2(30),
  creation_time         DATE default sysdate,
  last_modified_user    VARCHAR2(30),
  last_modified_time    DATE,
  factory_code          VARCHAR2(10),
  sup_name              VARCHAR2(30),
  mobile                VARCHAR2(30),
  mail                  VARCHAR2(30),
  is_change             NUMBER(2)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column TEST_PKG_DETAIL.group_no
  is '??';
comment on column TEST_PKG_DETAIL.max_package_num
  is '?????';
comment on column TEST_PKG_DETAIL.standard_package
  is '?????';
comment on column TEST_PKG_DETAIL.part_weight
  is '????';
comment on column TEST_PKG_DETAIL.part_total_weight
  is '?????';
comment on column TEST_PKG_DETAIL.part_length
  is '???';
comment on column TEST_PKG_DETAIL.part_width
  is '???';
comment on column TEST_PKG_DETAIL.part_height
  is '???';
comment on column TEST_PKG_DETAIL.empty_trolley_length
  is '????';
comment on column TEST_PKG_DETAIL.empty_trolley_width
  is '????';
comment on column TEST_PKG_DETAIL.empty_trolley_height
  is '????';
comment on column TEST_PKG_DETAIL.real_trolley_length
  is '????';
comment on column TEST_PKG_DETAIL.real_trolley_width
  is '????';
comment on column TEST_PKG_DETAIL.real_trolley_height
  is '????';
comment on column TEST_PKG_DETAIL.trolley_weight
  is '????';
comment on column TEST_PKG_DETAIL.total_weight
  is '???';
comment on column TEST_PKG_DETAIL.is_trolley_code
  is '0-?
1-?';
comment on column TEST_PKG_DETAIL.is_positioner
  is '0-?
1-?';
comment on column TEST_PKG_DETAIL.dust_cover
  is '0-?
1-?';
comment on column TEST_PKG_DETAIL.one_by_package
  is '0-?
1-?';
comment on column TEST_PKG_DETAIL.board_location
  is 'L  / W';
comment on column TEST_PKG_DETAIL.wheel_diameter
  is '????';
comment on column TEST_PKG_DETAIL.word_desc
  is '????';
comment on column TEST_PKG_DETAIL.traction_rod_height
  is '??????';
comment on column TEST_PKG_DETAIL.important_postion_pic
  is '?????';
comment on column TEST_PKG_DETAIL.empty_tro_front_pic
  is '??????';
comment on column TEST_PKG_DETAIL.empty_tro_side_pic
  is '??????';
comment on column TEST_PKG_DETAIL.real_tro_pic
  is '????';

prompt
prompt Creating table TEST_STOCK
prompt =========================
prompt
create table TEST_STOCK
(
  ware_code VARCHAR2(30),
  part_no   VARCHAR2(50),
  min_stock NUMBER(10,2),
  max_stock NUMBER(10,2),
  adj_stock NUMBER(10,2),
  remark    VARCHAR2(200)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
comment on column TEST_STOCK.adj_stock
  is '????';

prompt
prompt Creating table TEST_SW_DEMAND_FORECAST_IMP
prompt ==========================================
prompt
create table TEST_SW_DEMAND_FORECAST_IMP
(
  id                 NUMBER(10) not null,
  factory_code       VARCHAR2(20),
  fore_type          NUMBER(1),
  version            VARCHAR2(20),
  plan_delivery      DATE,
  start_date         DATE,
  end_date           DATE,
  phase              VARCHAR2(20),
  unload_port        VARCHAR2(20),
  part_no            VARCHAR2(50),
  part_unit          VARCHAR2(20),
  order_qty          NUMBER(10),
  supplier_no        VARCHAR2(20),
  supplier_name      VARCHAR2(100),
  sup_factory_addr   VARCHAR2(100),
  sup_factory        VARCHAR2(20),
  model_code         VARCHAR2(20),
  logistics_mode     VARCHAR2(50),
  download_status    NUMBER(1) default 0,
  download_time      DATE,
  creation_user      VARCHAR2(30),
  creation_time      DATE default sysdate,
  last_modified_user VARCHAR2(30),
  last_modified_time DATE,
  release_status     NUMBER(1),
  feedback_status    NUMBER(1),
  feedback_remark    VARCHAR2(300),
  workcenter         VARCHAR2(10),
  obj_week           VARCHAR2(30),
  publish_week       VARCHAR2(30),
  advance_time       VARCHAR2(50),
  do_flag            VARCHAR2(10),
  deal_flag          NUMBER(1),
  deal_time          DATE,
  p_supplier         VARCHAR2(10),
  obj_month          VARCHAR2(50),
  publish_month      VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table TEST_SW_DEMAND_FORECAST_IMP
  is 'TEST_SW_DEMAND_FORECAST_IMP需求预测数据表';
comment on column TEST_SW_DEMAND_FORECAST_IMP.id
  is '"ID
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.factory_code
  is '"工厂
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.fore_type
  is '"预测类型
1-月预测
2-日预测"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.version
  is '"发布版本
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.plan_delivery
  is '"需求到货日期
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.start_date
  is '"开始日期
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.end_date
  is '"结束日期
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.phase
  is '"生产阶段
0-试制
1-量产"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.unload_port
  is '"卸货口
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.part_no
  is '"零件编号
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.part_unit
  is '"零件单位
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.order_qty
  is '"需求数量
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.supplier_no
  is '"供应商代码
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.supplier_name
  is '"供应商名称
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.sup_factory_addr
  is '"出货地地址
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.sup_factory
  is '"出货地代码
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.model_code
  is '"车型
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.logistics_mode
  is '"订单物流模式
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.download_status
  is '"下载状态
0-未下载
1-已下载"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.download_time
  is '"下载日期
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.creation_user
  is '"创建人
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.creation_time
  is '"创建时间
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.last_modified_user
  is '"最后修改用户
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.last_modified_time
  is '"最后修改时间
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.release_status
  is '"发布状态
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.feedback_status
  is '"反馈状态
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.feedback_remark
  is '"反馈备注
"';
comment on column TEST_SW_DEMAND_FORECAST_IMP.obj_week
  is '对象周';
comment on column TEST_SW_DEMAND_FORECAST_IMP.publish_week
  is '发布周';
comment on column TEST_SW_DEMAND_FORECAST_IMP.advance_time
  is '提前取货时间';
alter table TEST_SW_DEMAND_FORECAST_IMP
  add constraint PK_TEST_SW_DEMAND_FORECAST_IMP primary key (ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table TEST_SW_ORDER_DETAIL
prompt ===================================
prompt
create table TEST_SW_ORDER_DETAIL
(
  order_no VARCHAR2(50),
  row_no   VARCHAR2(10),
  part_no  VARCHAR2(30),
  num      NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_SYS_PARAM
prompt =============================
prompt
create table TEST_SYS_PARAM
(
  factory_code VARCHAR2(10),
  param_code   VARCHAR2(50),
  param_group  VARCHAR2(50),
  param_name   VARCHAR2(100),
  param_val    VARCHAR2(100),
  is_edit      NUMBER(1),
  data_type    VARCHAR2(20),
  note         VARCHAR2(200),
  check_by     VARCHAR2(40),
  check_comp   VARCHAR2(2000),
  message      VARCHAR2(100)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_SYS_USER
prompt ============================
prompt
create table TEST_SYS_USER
(
  id_              VARCHAR2(64) not null,
  fullname_        VARCHAR2(255) not null,
  account_         VARCHAR2(255) not null,
  password_        VARCHAR2(64) not null,
  email_           VARCHAR2(64),
  mobile_          VARCHAR2(32),
  weixin_          VARCHAR2(64),
  create_time_     TIMESTAMP(6),
  address_         VARCHAR2(512),
  photo_           VARCHAR2(255),
  sex_             VARCHAR2(10),
  from_            VARCHAR2(64),
  status_          NUMBER default 1 not null,
  has_sync_to_wx_  NUMBER,
  open_id_         VARCHAR2(64),
  sign_name_fileid VARCHAR2(64),
  factory_code     VARCHAR2(10),
  user_type        NUMBER(1),
  supplier_no      VARCHAR2(10),
  department       VARCHAR2(52)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_VEH_PASS
prompt ============================
prompt
create table TEST_VEH_PASS
(
  old_order_no VARCHAR2(50),
  new_order_no VARCHAR2(50),
  new_mtco     VARCHAR2(50)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_WXL
prompt =======================
prompt
create table TEST_WXL
(
  depot_no VARCHAR2(20),
  part_no  VARCHAR2(30),
  quantity NUMBER(10)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_WXL_AF_EXP
prompt ==============================
prompt
create table TEST_WXL_AF_EXP
(
  depot_no VARCHAR2(30),
  sup      VARCHAR2(50),
  part_no  VARCHAR2(50),
  sh_num   NUMBER(10),
  deal_num NUMBER(10) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_WXL_AF_PS
prompt =============================
prompt
create table TEST_WXL_AF_PS
(
  depot_no VARCHAR2(30),
  sup      VARCHAR2(50),
  part_no  VARCHAR2(50),
  ps_num   NUMBER(10),
  deal_num NUMBER(10) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_WXL_AF_PS1
prompt ==============================
prompt
create table TEST_WXL_AF_PS1
(
  depot_no VARCHAR2(30),
  sup      VARCHAR2(50),
  part_no  VARCHAR2(50),
  ps_num   NUMBER(10),
  deal_num NUMBER(10) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_WXL_AF_SH
prompt =============================
prompt
create table TEST_WXL_AF_SH
(
  depot_no VARCHAR2(30),
  sup      VARCHAR2(50),
  part_no  VARCHAR2(50),
  sh_num   NUMBER(10),
  deal_num NUMBER(10) default 0,
  deal_way VARCHAR2(30) default 'manu'
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_WXL_WE_EXP
prompt ==============================
prompt
create table TEST_WXL_WE_EXP
(
  depot_no VARCHAR2(30),
  sup      VARCHAR2(50),
  part_no  VARCHAR2(50),
  sh_num   NUMBER(10),
  deal_num NUMBER(10) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_WXL_WE_PS
prompt =============================
prompt
create table TEST_WXL_WE_PS
(
  depot_no VARCHAR2(30),
  sup      VARCHAR2(50),
  part_no  VARCHAR2(50),
  ps_num   NUMBER(10),
  deal_num NUMBER(10) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEST_WXL_WE_PS1
prompt ==============================
prompt
create table TEST_WXL_WE_PS1
(
  depot_no VARCHAR2(30),
  sup      VARCHAR2(50),
  part_no  VARCHAR2(50),
  ps_num   NUMBER(10),
  deal_num NUMBER(10) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;

prompt
prompt Creating table TEST_WXL_WE_SH
prompt =============================
prompt
create table TEST_WXL_WE_SH
(
  depot_no VARCHAR2(30),
  sup      VARCHAR2(50),
  part_no  VARCHAR2(50),
  sh_num   NUMBER(10),
  deal_num NUMBER(10) default 0
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_CONFIG
prompt ==========================
prompt
create table T_IF_CONFIG
(
  if_code                 VARCHAR2(20) not null,
  if_name                 VARCHAR2(255),
  if_name_zh              VARCHAR2(255),
  to_sys_name             VARCHAR2(64),
  if_type                 NUMBER(2),
  service_type            VARCHAR2(10),
  service_class           VARCHAR2(255),
  receive_transation_type NUMBER(2),
  receive_delete_flag     VARCHAR2(64),
  send_success_flag       VARCHAR2(64),
  db_proc                 VARCHAR2(255)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_CONFIG
  add primary key (IF_CODE)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_DATA_DICT
prompt =============================
prompt
create table T_IF_DATA_DICT
(
  pk_id            NUMBER(19) not null,
  code_type        VARCHAR2(40),
  code_type_name   VARCHAR2(80),
  code_value       VARCHAR2(255),
  code_value_name  VARCHAR2(255),
  sort_no          NUMBER(4),
  code_desc        VARCHAR2(128),
  is_edit          NUMBER(1),
  create_time      DATE,
  last_update_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_IF_DATA_DICT on T_IF_DATA_DICT (CODE_TYPE)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_DATA_DICT
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_ELEMENT
prompt ===========================
prompt
create table T_IF_ELEMENT
(
  pk_id           NUMBER(19) not null,
  if_code         VARCHAR2(20),
  element_name    VARCHAR2(64),
  table_id        VARCHAR2(64),
  field_name      VARCHAR2(64),
  default_value   VARCHAR2(64),
  xml_attr        VARCHAR2(512),
  creator         VARCHAR2(64),
  field_type      NUMBER(2),
  user_field_type CHAR(20),
  max_length      NUMBER(6),
  is_active       NUMBER(2),
  null_able       NUMBER(2),
  insert_able     NUMBER(2),
  update_able     NUMBER(2),
  sort_no         NUMBER(5),
  element_desc    VARCHAR2(255),
  data_convert    VARCHAR2(255),
  data_format     VARCHAR2(64)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_IF_ELEMENT on T_IF_ELEMENT (IF_CODE, TABLE_ID)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_ELEMENT
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_EXECUTION_DAY
prompt =================================
prompt
create table T_IF_EXECUTION_DAY
(
  pk_id        NUMBER(19) not null,
  day          VARCHAR2(10),
  if_code      VARCHAR2(20),
  auto_success NUMBER(9),
  auto_total   NUMBER(9),
  hand_success NUMBER(9),
  hand_total   NUMBER(9)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_EXECUTION_DAY
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_EXECUTION_MONTH
prompt ===================================
prompt
create table T_IF_EXECUTION_MONTH
(
  pk_id        NUMBER(19) not null,
  month        VARCHAR2(7),
  if_code      VARCHAR2(20),
  auto_success NUMBER(9),
  auto_total   NUMBER(9),
  hand_success NUMBER(9),
  hand_total   NUMBER(9)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_EXECUTION_MONTH
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_EXECUTION_QUARTER
prompt =====================================
prompt
create table T_IF_EXECUTION_QUARTER
(
  pk_id        NUMBER(19) not null,
  quarter      VARCHAR2(6),
  if_code      VARCHAR2(20),
  auto_success NUMBER(13),
  auto_total   NUMBER(13),
  hand_success NUMBER(13),
  hand_total   NUMBER(13)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_EXECUTION_QUARTER
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_EXECUTION_WEEK
prompt ==================================
prompt
create table T_IF_EXECUTION_WEEK
(
  pk_id        NUMBER(19) not null,
  week         VARCHAR2(7),
  if_code      VARCHAR2(20),
  auto_success NUMBER(9),
  auto_total   NUMBER(9),
  hand_success NUMBER(9),
  hand_total   NUMBER(9)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_EXECUTION_WEEK
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_EXECUTION_YEAR
prompt ==================================
prompt
create table T_IF_EXECUTION_YEAR
(
  pk_id        NUMBER(19) not null,
  year         VARCHAR2(4),
  if_code      VARCHAR2(20),
  auto_success NUMBER(13),
  auto_total   NUMBER(13),
  hand_success NUMBER(13),
  hand_total   NUMBER(13)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_EXECUTION_YEAR
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_MODULE
prompt ==========================
prompt
create table T_IF_MODULE
(
  parent_module    VARCHAR2(40),
  module_code      VARCHAR2(40) not null,
  module_name      VARCHAR2(64),
  sort_no          NUMBER(4),
  module_level     NUMBER(4),
  create_time      DATE,
  last_update_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_MODULE
  add primary key (MODULE_CODE)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_PARAM
prompt =========================
prompt
create table T_IF_PARAM
(
  pk_id            NUMBER(19) not null,
  to_sys_name      VARCHAR2(64),
  if_code          VARCHAR2(20),
  param_group      VARCHAR2(64),
  param_code       VARCHAR2(64),
  param_name       VARCHAR2(64),
  param_value      VARCHAR2(255),
  param_desc       VARCHAR2(255),
  edit_able        VARCHAR2(1),
  last_update_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_IF_PARAM on T_IF_PARAM (IF_CODE, TO_SYS_NAME)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_PARAM
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_PARAM_TEMPLATE
prompt ==================================
prompt
create table T_IF_PARAM_TEMPLATE
(
  pk_id       NUMBER(19) not null,
  param_group VARCHAR2(64),
  param_code  VARCHAR2(64),
  param_name  VARCHAR2(64),
  param_value VARCHAR2(255),
  param_desc  VARCHAR2(255)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_IF_PARAM_TEMPLATE on T_IF_PARAM_TEMPLATE (PARAM_GROUP)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_PARAM_TEMPLATE
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_PARAM_TEMPLATE_GROUP
prompt ========================================
prompt
create table T_IF_PARAM_TEMPLATE_GROUP
(
  pk_id            NUMBER(19) not null,
  param_group      VARCHAR2(64),
  param_group_name VARCHAR2(64)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_PARAM_TEMPLATE_GROUP
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_PRIVILEGES
prompt ==============================
prompt
create table T_IF_PRIVILEGES
(
  pk_id            NUMBER(19) not null,
  module_code      VARCHAR2(40),
  privileges_type  VARCHAR2(20),
  content          VARCHAR2(64),
  privileges_desc  VARCHAR2(255),
  sort_no          NUMBER(4),
  create_time      DATE,
  last_update_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_PRIVILEGES
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_QUERY_CONFIG
prompt ================================
prompt
create table T_IF_QUERY_CONFIG
(
  pk_id              NUMBER(19) not null,
  if_code            VARCHAR2(20),
  table_id           VARCHAR2(64),
  table_desc         VARCHAR2(255),
  parent_table_id    VARCHAR2(64),
  approach           VARCHAR2(255),
  approach_suffix    VARCHAR2(255),
  approach_prefix    VARCHAR2(255),
  xml_attr           VARCHAR2(2000),
  auto_query_sql     VARCHAR2(2000),
  hand_query_sql     VARCHAR2(2000),
  empty_from_default NUMBER(2),
  allow_empty        NUMBER(2),
  max_number         NUMBER(5),
  success_sql        VARCHAR2(2000),
  failure_sql        VARCHAR2(2000),
  sort_no            NUMBER(5)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_IF_QUERY_CONFIG on T_IF_QUERY_CONFIG (IF_CODE)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_QUERY_CONFIG
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_QUERY_LOG
prompt =============================
prompt
create table T_IF_QUERY_LOG
(
  pk_id                NUMBER(19) not null,
  if_code              VARCHAR2(20),
  if_type              NUMBER(2),
  table_id             VARCHAR2(64),
  query_key            CHAR(32),
  orig_query_file_key  CHAR(32),
  third_query_file_key CHAR(32),
  send_result          NUMBER(2),
  receive_file_key     CHAR(32),
  receive_result       NUMBER(2),
  log_type             NUMBER(2),
  error_code           VARCHAR2(64),
  error_msg            VARCHAR2(2000),
  create_time          DATE,
  key1_name            VARCHAR2(64),
  key1_value           VARCHAR2(255),
  key2_name            VARCHAR2(64),
  key2_value           VARCHAR2(255),
  key3_name            VARCHAR2(64),
  key3_value           VARCHAR2(255),
  key4_name            VARCHAR2(64),
  key4_value           VARCHAR2(255),
  key5_name            VARCHAR2(64),
  key5_value           VARCHAR2(255),
  key6_name            VARCHAR2(64),
  key6_value           VARCHAR2(255),
  key7_name            VARCHAR2(64),
  key7_value           VARCHAR2(255),
  key8_name            VARCHAR2(64),
  key8_value           VARCHAR2(255),
  key9_name            VARCHAR2(64),
  key9_value           VARCHAR2(255),
  key10_name           VARCHAR2(64),
  key10_value          VARCHAR2(255)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index IDX_IF_QUERY_LOG on T_IF_QUERY_LOG (IF_CODE, IF_TYPE)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 23M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_QUERY_LOG
  add primary key (PK_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table T_IF_QUERY_LOG_HIS
prompt =================================
prompt
create table T_IF_QUERY_LOG_HIS
(
  pk_id                NUMBER(19) not null,
  if_code              VARCHAR2(20),
  if_type              NUMBER(2),
  table_id             VARCHAR2(64),
  query_key            CHAR(32),
  orig_query_file_key  CHAR(32),
  third_query_file_key CHAR(32),
  send_result          NUMBER(2),
  receive_file_key     CHAR(32),
  receive_result       NUMBER(2),
  log_type             NUMBER(2),
  error_code           VARCHAR2(64),
  error_msg            VARCHAR2(2000),
  create_time          DATE,
  key1_name            VARCHAR2(64),
  key1_value           VARCHAR2(255),
  key2_name            VARCHAR2(64),
  key2_value           VARCHAR2(255),
  key3_name            VARCHAR2(64),
  key3_value           VARCHAR2(255),
  key4_name            VARCHAR2(64),
  key4_value           VARCHAR2(255),
  key5_name            VARCHAR2(64),
  key5_value           VARCHAR2(255),
  key6_name            VARCHAR2(64),
  key6_value           VARCHAR2(255),
  key7_name            VARCHAR2(64),
  key7_value           VARCHAR2(255),
  key8_name            VARCHAR2(64),
  key8_value           VARCHAR2(255),
  key9_name            VARCHAR2(64),
  key9_value           VARCHAR2(255),
  key10_name           VARCHAR2(64),
  key10_value          VARCHAR2(255)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index IDX_IF_QUERY_LOG_HIS on T_IF_QUERY_LOG_HIS (IF_CODE, IF_TYPE)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 19M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_QUERY_LOG_HIS
  add primary key (PK_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table T_IF_RECEIVE_CONFIG
prompt ==================================
prompt
create table T_IF_RECEIVE_CONFIG
(
  pk_id             NUMBER(19) not null,
  if_code           VARCHAR2(20),
  table_id          VARCHAR2(64),
  table_desc        VARCHAR2(255),
  table_name        VARCHAR2(64),
  parent_table_id   VARCHAR2(64),
  approach          VARCHAR2(255),
  is_value_approach NUMBER(2),
  approach_suffix   VARCHAR2(255),
  revision_name     VARCHAR2(64),
  table_type        NUMBER(2),
  key_sequence      VARCHAR2(64),
  key_class         VARCHAR2(64),
  create_type       NUMBER(2),
  update_type       NUMBER(2),
  delete_sql        VARCHAR2(2000),
  empty_from_parent NUMBER(2),
  sort_no           NUMBER(5)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_IF_RECEIVE_CONFIG on T_IF_RECEIVE_CONFIG (IF_CODE)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_RECEIVE_CONFIG
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_RECEIVE_FILE
prompt ================================
prompt
create table T_IF_RECEIVE_FILE
(
  pk_id            NUMBER(19) not null,
  file_key         CHAR(32),
  file_path        VARCHAR2(255),
  if_code          VARCHAR2(20),
  token            VARCHAR2(50),
  create_time      DATE,
  start_parse_time DATE,
  end_parse_time   DATE,
  received         NUMBER(2)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index IDX_IF_RECEIVE_FILE on T_IF_RECEIVE_FILE (IF_CODE)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 320K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_RECEIVE_FILE
  add primary key (PK_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table T_IF_RECEIVE_FILE_HIS
prompt ====================================
prompt
create table T_IF_RECEIVE_FILE_HIS
(
  pk_id            NUMBER(19),
  file_key         CHAR(32),
  file_path        VARCHAR2(255),
  if_code          VARCHAR2(20),
  token            VARCHAR2(50),
  create_time      DATE,
  start_parse_time DATE,
  end_parse_time   DATE,
  received         NUMBER(2)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index IDX_IF_RECEIVE_FILE_HIS on T_IF_RECEIVE_FILE_HIS (IF_CODE)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_RECEIVE_LOCKER
prompt ==================================
prompt
create table T_IF_RECEIVE_LOCKER
(
  table_name VARCHAR2(64),
  state      VARCHAR2(1)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
create index IDX_IF_RECEIVE_LOCKER on T_IF_RECEIVE_LOCKER (TABLE_NAME)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table T_IF_RECEIVE_LOG
prompt ===============================
prompt
create table T_IF_RECEIVE_LOG
(
  pk_id                 NUMBER(19) not null,
  if_code               VARCHAR2(20),
  if_type               NUMBER(2),
  table_id              VARCHAR2(64),
  third_if_code         VARCHAR2(64),
  third_key             VARCHAR2(64),
  query_key             CHAR(32),
  orig_query_file_key   CHAR(32),
  third_query_file_key  CHAR(32),
  receive_file_key      CHAR(32),
  back_receive_file_key CHAR(32),
  receive_result        NUMBER(2),
  log_type              NUMBER(2),
  error_code            VARCHAR2(64),
  error_msg             VARCHAR2(2000),
  create_time           DATE,
  key1_name             VARCHAR2(64),
  key1_value            VARCHAR2(255),
  key2_name             VARCHAR2(64),
  key2_value            VARCHAR2(255),
  key3_name             VARCHAR2(64),
  key3_value            VARCHAR2(255),
  key4_name             VARCHAR2(64),
  key4_value            VARCHAR2(255),
  key5_name             VARCHAR2(64),
  key5_value            VARCHAR2(255),
  key6_name             VARCHAR2(64),
  key6_value            VARCHAR2(255),
  key7_name             VARCHAR2(64),
  key7_value            VARCHAR2(255),
  key8_name             VARCHAR2(64),
  key8_value            VARCHAR2(255),
  key9_name             VARCHAR2(64),
  key9_value            VARCHAR2(255),
  key10_name            VARCHAR2(64),
  key10_value           VARCHAR2(255)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index IDX_IF_RECEIVE_LOG on T_IF_RECEIVE_LOG (IF_CODE, IF_TYPE)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 6M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_RECEIVE_LOG
  add primary key (PK_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table T_IF_RECEIVE_LOG_HIS
prompt ===================================
prompt
create table T_IF_RECEIVE_LOG_HIS
(
  pk_id                 NUMBER(19) not null,
  if_code               VARCHAR2(20),
  if_type               NUMBER(2),
  table_id              VARCHAR2(64),
  third_if_code         VARCHAR2(64),
  third_key             VARCHAR2(64),
  query_key             CHAR(32),
  orig_query_file_key   CHAR(32),
  third_query_file_key  CHAR(32),
  receive_file_key      CHAR(32),
  back_receive_file_key CHAR(32),
  receive_result        NUMBER(2),
  log_type              NUMBER(2),
  error_code            VARCHAR2(64),
  error_msg             VARCHAR2(2000),
  create_time           DATE,
  key1_name             VARCHAR2(64),
  key1_value            VARCHAR2(255),
  key2_name             VARCHAR2(64),
  key2_value            VARCHAR2(255),
  key3_name             VARCHAR2(64),
  key3_value            VARCHAR2(255),
  key4_name             VARCHAR2(64),
  key4_value            VARCHAR2(255),
  key5_name             VARCHAR2(64),
  key5_value            VARCHAR2(255),
  key6_name             VARCHAR2(64),
  key6_value            VARCHAR2(255),
  key7_name             VARCHAR2(64),
  key7_value            VARCHAR2(255),
  key8_name             VARCHAR2(64),
  key8_value            VARCHAR2(255),
  key9_name             VARCHAR2(64),
  key9_value            VARCHAR2(255),
  key10_name            VARCHAR2(64),
  key10_value           VARCHAR2(255)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index IDX_IF_RECEIVE_LOG_HIS on T_IF_RECEIVE_LOG_HIS (IF_CODE, IF_TYPE)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 5M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_RECEIVE_LOG_HIS
  add primary key (PK_ID)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table T_IF_RECEIVE_SERVICE_STATE
prompt =========================================
prompt
create table T_IF_RECEIVE_SERVICE_STATE
(
  pk_id           NUMBER(19) not null,
  if_code         VARCHAR2(20),
  to_sys_name     VARCHAR2(64),
  service_state   NUMBER(2),
  service_message VARCHAR2(2000)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
alter table T_IF_RECEIVE_SERVICE_STATE
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table T_IF_ROLE
prompt ========================
prompt
create table T_IF_ROLE
(
  pk_id            NUMBER(19) not null,
  role_name        VARCHAR2(64),
  role_desc        VARCHAR2(255),
  create_time      DATE,
  last_update_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
alter table T_IF_ROLE
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table T_IF_ROLE_PRIVILEGES
prompt ===================================
prompt
create table T_IF_ROLE_PRIVILEGES
(
  role_id          NUMBER(19) not null,
  privileges_id    NUMBER(19) not null,
  create_time      DATE,
  last_update_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
alter table T_IF_ROLE_PRIVILEGES
  add primary key (ROLE_ID, PRIVILEGES_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table T_IF_TIMER
prompt =========================
prompt
create table T_IF_TIMER
(
  job_code              VARCHAR2(40) not null,
  job_desc              VARCHAR2(255),
  if_code               VARCHAR2(20),
  master_query_table_id VARCHAR2(255),
  job_group             VARCHAR2(40),
  job_class             VARCHAR2(200),
  trigger_name          VARCHAR2(40),
  trigger_value         VARCHAR2(40),
  start_time            DATE,
  update_state          NUMBER(2),
  run_state             NUMBER(2),
  last_run_time         DATE,
  next_run_time         DATE,
  thread_state          NUMBER(2),
  thread_run_time       DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_TIMER
  add primary key (JOB_CODE)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_USER
prompt ========================
prompt
create table T_IF_USER
(
  user_name        VARCHAR2(36) not null,
  user_desc        VARCHAR2(64),
  user_pwd         VARCHAR2(100),
  user_status      NUMBER(1),
  is_update_pwd    NUMBER(1),
  create_time      DATE,
  last_update_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_USER
  add primary key (USER_NAME)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_IF_USER_ROLE
prompt =============================
prompt
create table T_IF_USER_ROLE
(
  user_name        VARCHAR2(36) not null,
  role_id          NUMBER(19) not null,
  create_time      DATE,
  last_update_time DATE
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255;
alter table T_IF_USER_ROLE
  add primary key (USER_NAME, ROLE_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table T_IF_XML_FILE_LOG
prompt ================================
prompt
create table T_IF_XML_FILE_LOG
(
  pk_id         NUMBER(19) not null,
  file_key      CHAR(32),
  file_path     VARCHAR2(255),
  if_code       VARCHAR2(20),
  create_time   DATE,
  asyn_received NUMBER(2)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 19M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index IDX_IF_XML_FILE_LOG on T_IF_XML_FILE_LOG (FILE_KEY)
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 11M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table T_IF_XML_FILE_LOG
  add primary key (PK_ID)
  using index 
  tablespace ILMSPEC
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table USER_ROLE_TEMP
prompt =============================
prompt
create table USER_ROLE_TEMP
(
  account VARCHAR2(30),
  role1   VARCHAR2(30),
  role2   VARCHAR2(30),
  role3   VARCHAR2(30),
  role4   VARCHAR2(30),
  role5   VARCHAR2(30),
  role6   VARCHAR2(30),
  role7   VARCHAR2(30),
  role8   VARCHAR2(30),
  role9   VARCHAR2(30),
  role10  VARCHAR2(30),
  role11  VARCHAR2(30),
  role12  VARCHAR2(30),
  role13  VARCHAR2(30),
  role14  VARCHAR2(30)
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XB_DB_ID
prompt =======================
prompt
create table XB_DB_ID
(
  id_       VARCHAR2(64) not null,
  start_    NUMBER not null,
  max_      NUMBER not null,
  mac_name_ VARCHAR2(255) not null
)
tablespace ILMSPEC
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table XB_DB_ID
  is '?????';
comment on column XB_DB_ID.id_
  is '??';
comment on column XB_DB_ID.start_
  is '??ID?';
comment on column XB_DB_ID.max_
  is '???????ID?';
comment on column XB_DB_ID.mac_name_
  is '????';
alter table XB_DB_ID
  add constraint PK_XB_DB_ID primary key (ID_)
  using index 
  tablespace USERS
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating sequence JOB_NO
prompt ========================
prompt
create sequence JOB_NO
minvalue 0
maxvalue 9999999999999999999999999999
start with 5720
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_ASSEMBLY_MOULD
prompt =======================================
prompt
create sequence SEQ_IF_ASSEMBLY_MOULD
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_FEATURE_GROUP
prompt ======================================
prompt
create sequence SEQ_IF_FEATURE_GROUP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_INV_TRAN_ERP
prompt =====================================
prompt
create sequence SEQ_IF_INV_TRAN_ERP
minvalue 1
maxvalue 9999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_INV_WAREHOUSE
prompt ======================================
prompt
create sequence SEQ_IF_INV_WAREHOUSE
minvalue 1
maxvalue 9999999999999999999999999999
start with 161
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_JISO_INS
prompt =================================
prompt
create sequence SEQ_IF_JISO_INS
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_KEYPART
prompt ================================
prompt
create sequence SEQ_IF_KEYPART
minvalue 2
maxvalue 9999999999999999999999999999
start with 22
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_LONG_CYCLE_ORDER
prompt =========================================
prompt
create sequence SEQ_IF_LONG_CYCLE_ORDER
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_MM_PUB_PART_UDA_IN
prompt ===========================================
prompt
create sequence SEQ_IF_MM_PUB_PART_UDA_IN
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_MM_PUB_SUPPLIER
prompt ========================================
prompt
create sequence SEQ_IF_MM_PUB_SUPPLIER
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_MM_SW_ACCOUNT_BILL
prompt ===========================================
prompt
create sequence SEQ_IF_MM_SW_ACCOUNT_BILL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_MM_SW_ACCOUNT_DETAIL
prompt =============================================
prompt
create sequence SEQ_IF_MM_SW_ACCOUNT_DETAIL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_MM_SW_LONG_ORDER
prompt =========================================
prompt
create sequence SEQ_IF_MM_SW_LONG_ORDER
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_MM_SW_LONG_ORDER_DET
prompt =============================================
prompt
create sequence SEQ_IF_MM_SW_LONG_ORDER_DET
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_MM_SW_PICKUP_PLAN
prompt ==========================================
prompt
create sequence SEQ_IF_MM_SW_PICKUP_PLAN
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_MODEL_BOM
prompt ==================================
prompt
create sequence SEQ_IF_MODEL_BOM
minvalue 1
maxvalue 9999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_MON_BATERY_KB
prompt ======================================
prompt
create sequence SEQ_IF_MON_BATERY_KB
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_MP_ADJUST_PLAN
prompt =======================================
prompt
create sequence SEQ_IF_MP_ADJUST_PLAN
minvalue 1
maxvalue 9999999999999999999999999999
start with 61
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_NON_STANDARD
prompt =====================================
prompt
create sequence SEQ_IF_NON_STANDARD
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_NON_STANDARD_DETAIL
prompt ============================================
prompt
create sequence SEQ_IF_NON_STANDARD_DETAIL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_NON_STANDAR_CHECK
prompt ==========================================
prompt
create sequence SEQ_IF_NON_STANDAR_CHECK
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_NON_STAND_PIC
prompt ======================================
prompt
create sequence SEQ_IF_NON_STAND_PIC
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_ORDER_BOM
prompt ==================================
prompt
create sequence SEQ_IF_ORDER_BOM
minvalue 1
maxvalue 9999999999999999999999999999
start with 1361
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_ORDER_FEATURE
prompt ======================================
prompt
create sequence SEQ_IF_ORDER_FEATURE
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_PART
prompt =============================
prompt
create sequence SEQ_IF_PART
minvalue 1
maxvalue 9999999999999999999999999999
start with 5701
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_PART_SUPPLIER
prompt ======================================
prompt
create sequence SEQ_IF_PART_SUPPLIER
minvalue 1
maxvalue 9999999999999999999999999999
start with 45
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_PKG_BOX
prompt ================================
prompt
create sequence SEQ_IF_PKG_BOX
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_PKG_BOX_QTY
prompt ====================================
prompt
create sequence SEQ_IF_PKG_BOX_QTY
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_PKG_PART
prompt =================================
prompt
create sequence SEQ_IF_PKG_PART
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_PKG_PROPOSAL
prompt =====================================
prompt
create sequence SEQ_IF_PKG_PROPOSAL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_PKG_PROPOSAL_DETAIL
prompt ============================================
prompt
create sequence SEQ_IF_PKG_PROPOSAL_DETAIL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_PKG_TRAY_QTY
prompt =====================================
prompt
create sequence SEQ_IF_PKG_TRAY_QTY
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_RGV_RECEIVE
prompt ====================================
prompt
create sequence SEQ_IF_RGV_RECEIVE
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_ROUTE
prompt ==============================
prompt
create sequence SEQ_IF_ROUTE
minvalue 2
maxvalue 9999999999999999999999999999
start with 22
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_ROUTE_DATEIL
prompt =====================================
prompt
create sequence SEQ_IF_ROUTE_DATEIL
minvalue 2
maxvalue 9999999999999999999999999999
start with 2
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_SPS_CONFIG
prompt ===================================
prompt
create sequence SEQ_IF_SPS_CONFIG
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_SUPER_BOM
prompt ==================================
prompt
create sequence SEQ_IF_SUPER_BOM
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_SUPPLIER
prompt =================================
prompt
create sequence SEQ_IF_SUPPLIER
minvalue 1
maxvalue 9999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_SUPPORTING_PART
prompt ========================================
prompt
create sequence SEQ_IF_SUPPORTING_PART
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_SW_ACCOUNT_BILL
prompt ========================================
prompt
create sequence SEQ_IF_SW_ACCOUNT_BILL
minvalue 1
maxvalue 9999999999999999999999999999
start with 61
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_SW_DEMAND_FORECAST
prompt ===========================================
prompt
create sequence SEQ_IF_SW_DEMAND_FORECAST
minvalue 1
maxvalue 9999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_SW_ORDER
prompt =================================
prompt
create sequence SEQ_IF_SW_ORDER
minvalue 1
maxvalue 9999999999999999999999999999
start with 90
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_TACT_TIME
prompt ==================================
prompt
create sequence SEQ_IF_TACT_TIME
minvalue 2
maxvalue 9999999999999999999999999999
start with 42
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_VEH_CONF_ITEM
prompt ======================================
prompt
create sequence SEQ_IF_VEH_CONF_ITEM
minvalue 2
maxvalue 9999999999999999999999999999
start with 2
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_VEH_LOCK_PLAN
prompt ======================================
prompt
create sequence SEQ_IF_VEH_LOCK_PLAN
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_VEH_PASS
prompt =================================
prompt
create sequence SEQ_IF_VEH_PASS
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_VEH_PRO_PLAN
prompt =====================================
prompt
create sequence SEQ_IF_VEH_PRO_PLAN
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_VEH_SCRAP
prompt ==================================
prompt
create sequence SEQ_IF_VEH_SCRAP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IF_WORK_CALENDAR
prompt ======================================
prompt
create sequence SEQ_IF_WORK_CALENDAR
minvalue 2
maxvalue 9999999999999999999999999999
start with 842
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_IMPORT_DATA_TEMP
prompt ======================================
prompt
create sequence SEQ_IMPORT_DATA_TEMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 51
increment by 1
cache 50;

prompt
prompt Creating sequence SEQ_MM_BATERY_KB
prompt ==================================
prompt
create sequence SEQ_MM_BATERY_KB
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_DPM_AREA
prompt =================================
prompt
create sequence SEQ_MM_DPM_AREA
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_DPM_DEPARTMENT
prompt =======================================
prompt
create sequence SEQ_MM_DPM_DEPARTMENT
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_DPM_DEP_PERSON
prompt =======================================
prompt
create sequence SEQ_MM_DPM_DEP_PERSON
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_DPM_ITEM
prompt =================================
prompt
create sequence SEQ_MM_DPM_ITEM
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_INV_BENCHMARK
prompt ======================================
prompt
create sequence SEQ_MM_INV_BENCHMARK
minvalue 1
maxvalue 9999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_INV_DEVELOP
prompt ====================================
prompt
create sequence SEQ_MM_INV_DEVELOP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_INV_DIFFERENCE
prompt =======================================
prompt
create sequence SEQ_MM_INV_DIFFERENCE
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_INV_EC
prompt ===============================
prompt
create sequence SEQ_MM_INV_EC
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence SEQ_MM_INV_EC_IN
prompt ==================================
prompt
create sequence SEQ_MM_INV_EC_IN
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence SEQ_MM_INV_IN
prompt ===============================
prompt
create sequence SEQ_MM_INV_IN
minvalue 1
maxvalue 9999999999999999999999999999
start with 61
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_INV_PART_LOCATION
prompt ==========================================
prompt
create sequence SEQ_MM_INV_PART_LOCATION
minvalue 1
maxvalue 9999999999999999999999999999
start with 1133
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_INV_PART_LOCATION_TEMP
prompt ===============================================
prompt
create sequence SEQ_MM_INV_PART_LOCATION_TEMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_INV_REC_TEMP
prompt =====================================
prompt
create sequence SEQ_MM_INV_REC_TEMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 81
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_INV_SHELVES
prompt ====================================
prompt
create sequence SEQ_MM_INV_SHELVES
minvalue 1
maxvalue 9999999999999999999999999999
start with 82
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_INV_SHELVES_TEMP
prompt =========================================
prompt
create sequence SEQ_MM_INV_SHELVES_TEMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_INV_STOCK
prompt ==================================
prompt
create sequence SEQ_MM_INV_STOCK
minvalue 1
maxvalue 9999999999999999999999999999
start with 241
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_INV_STOCK_IMP
prompt ======================================
prompt
create sequence SEQ_MM_INV_STOCK_IMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_INV_UNLOAD
prompt ===================================
prompt
create sequence SEQ_MM_INV_UNLOAD
minvalue 1
maxvalue 9999999999999999999
start with 51
increment by 1
cache 50;

prompt
prompt Creating sequence SEQ_MM_INV_WARE
prompt =================================
prompt
create sequence SEQ_MM_INV_WARE
minvalue 1
maxvalue 9999999999999999999
start with 161
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JISI_PART
prompt ==================================
prompt
create sequence SEQ_MM_JISI_PART
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JISI_PARTGROUP
prompt =======================================
prompt
create sequence SEQ_MM_JISI_PARTGROUP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JISO_PART
prompt ==================================
prompt
create sequence SEQ_MM_JISO_PART
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JISO_PARTGROUP
prompt =======================================
prompt
create sequence SEQ_MM_JISO_PARTGROUP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JISO_PARTGROUP_ROUTE
prompt =============================================
prompt
create sequence SEQ_MM_JISO_PARTGROUP_ROUTE
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JISO_PART_PLAN
prompt =======================================
prompt
create sequence SEQ_MM_JISO_PART_PLAN
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JIT_ACCOUNT_FILTER
prompt ===========================================
prompt
create sequence SEQ_MM_JIT_ACCOUNT_FILTER
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JIT_INS_DETAIL
prompt =======================================
prompt
create sequence SEQ_MM_JIT_INS_DETAIL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JIT_INS_PRINTER_CONFIG
prompt ===============================================
prompt
create sequence SEQ_MM_JIT_INS_PRINTER_CONFIG
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JIT_INVEN_COMP
prompt =======================================
prompt
create sequence SEQ_MM_JIT_INVEN_COMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_JIT_LABEL
prompt ==================================
prompt
create sequence SEQ_MM_JIT_LABEL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JIT_ORDER_CONFIG
prompt =========================================
prompt
create sequence SEQ_MM_JIT_ORDER_CONFIG
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JIT_ORDER_DETAIL
prompt =========================================
prompt
create sequence SEQ_MM_JIT_ORDER_DETAIL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JIT_PART
prompt =================================
prompt
create sequence SEQ_MM_JIT_PART
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JIT_PART_LACK
prompt ======================================
prompt
create sequence SEQ_MM_JIT_PART_LACK
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JIT_PART_LACK_DEAL
prompt ===========================================
prompt
create sequence SEQ_MM_JIT_PART_LACK_DEAL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JIT_PART_REMAIN
prompt ========================================
prompt
create sequence SEQ_MM_JIT_PART_REMAIN
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JIT_PART_REMAIN_IMP
prompt ============================================
prompt
create sequence SEQ_MM_JIT_PART_REMAIN_IMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_JIT_PART_REMAIN_LOG
prompt ============================================
prompt
create sequence SEQ_MM_JIT_PART_REMAIN_LOG
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 1000;

prompt
prompt Creating sequence SEQ_MM_JIT_PART_REM_PROD
prompt ==========================================
prompt
create sequence SEQ_MM_JIT_PART_REM_PROD
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_JIT_PKG_REQ
prompt ====================================
prompt
create sequence SEQ_MM_JIT_PKG_REQ
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_KB_IP_CONFIG
prompt =====================================
prompt
create sequence SEQ_MM_KB_IP_CONFIG
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_KB_IP_CONFIG_DETAIL
prompt ============================================
prompt
create sequence SEQ_MM_KB_IP_CONFIG_DETAIL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_MON_ALLOW_DEVIATION
prompt ============================================
prompt
create sequence SEQ_MM_MON_ALLOW_DEVIATION
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 50;

prompt
prompt Creating sequence SEQ_MM_MON_ALLOW_DEVIATION_IMP
prompt ================================================
prompt
create sequence SEQ_MM_MON_ALLOW_DEVIATION_IMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 50;

prompt
prompt Creating sequence SEQ_MM_MON_DISTRIBUTION_LOG
prompt =============================================
prompt
create sequence SEQ_MM_MON_DISTRIBUTION_LOG
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_MON_KB
prompt ===============================
prompt
create sequence SEQ_MM_MON_KB
minvalue 1
maxvalue 9999999999999999999999999999
start with 103
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_MON_KB_DETAIL
prompt ======================================
prompt
create sequence SEQ_MM_MON_KB_DETAIL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_MP_ADJ_BOM
prompt ===================================
prompt
create sequence SEQ_MM_MP_ADJ_BOM
minvalue 1
maxvalue 9999999999999999999999999999
start with 261
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_MP_ADJ_ORDER_DIFF
prompt ==========================================
prompt
create sequence SEQ_MM_MP_ADJ_ORDER_DIFF
minvalue 1
maxvalue 9999999999999999999999999999
start with 261
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_MP_EXCEP_DEMAND
prompt ========================================
prompt
create sequence SEQ_MM_MP_EXCEP_DEMAND
minvalue 1
maxvalue 9999999999999999999999999999
start with 221
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_MP_EXCEP_ORDER_DEMAND
prompt ==============================================
prompt
create sequence SEQ_MM_MP_EXCEP_ORDER_DEMAND
minvalue 1
maxvalue 9999999999999999999999999999
start with 1661
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_MP_EXC_DEMAND_HIS
prompt ==========================================
prompt
create sequence SEQ_MM_MP_EXC_DEMAND_HIS
minvalue 1
maxvalue 9999999999999999999999999999
start with 241
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_MP_PART_SORT
prompt =====================================
prompt
create sequence SEQ_MM_MP_PART_SORT
minvalue 1
maxvalue 9999999999999999999999999999
start with 2181
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_MP_RESIDUAL
prompt ====================================
prompt
create sequence SEQ_MM_MP_RESIDUAL
minvalue 1
maxvalue 9999999999999999999999999999
start with 639
increment by 1
nocache;

prompt
prompt Creating sequence SEQ_MM_MP_TRIAL_DEMAND
prompt ========================================
prompt
create sequence SEQ_MM_MP_TRIAL_DEMAND
minvalue 1
maxvalue 9999999999999999999999999999
start with 181
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_MP_TRIAL_ORDER
prompt =======================================
prompt
create sequence SEQ_MM_MP_TRIAL_ORDER
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_MP_WEEK_PLAN
prompt =====================================
prompt
create sequence SEQ_MM_MP_WEEK_PLAN
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PDA_MAT_ORDER_INFO
prompt ===========================================
prompt
create sequence SEQ_MM_PDA_MAT_ORDER_INFO
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PDA_MENU
prompt =================================
prompt
create sequence SEQ_MM_PDA_MENU
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PDA_TEST
prompt =================================
prompt
create sequence SEQ_MM_PDA_TEST
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PDA_TEST_LOG
prompt =====================================
prompt
create sequence SEQ_MM_PDA_TEST_LOG
minvalue 1
maxvalue 9999999999999999999999999999
start with 81
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PDA_USER
prompt =================================
prompt
create sequence SEQ_MM_PDA_USER
minvalue 1
maxvalue 9999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PKG_BOX
prompt ================================
prompt
create sequence SEQ_MM_PKG_BOX
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PKG_BOX_QTY
prompt ====================================
prompt
create sequence SEQ_MM_PKG_BOX_QTY
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PKG_BOX_QTY_IMP
prompt ========================================
prompt
create sequence SEQ_MM_PKG_BOX_QTY_IMP
minvalue 1
maxvalue 999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PKG_COMPACKGROUPNO
prompt ===========================================
prompt
create sequence SEQ_MM_PKG_COMPACKGROUPNO
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PKG_EXPECT_DETAIL
prompt ==========================================
prompt
create sequence SEQ_MM_PKG_EXPECT_DETAIL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PKG_PART
prompt =================================
prompt
create sequence SEQ_MM_PKG_PART
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PKG_PROPOSAL
prompt =====================================
prompt
create sequence SEQ_MM_PKG_PROPOSAL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PKG_PROPOSAL_DETAIL
prompt ============================================
prompt
create sequence SEQ_MM_PKG_PROPOSAL_DETAIL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PKG_PRO_TROLLEY
prompt ========================================
prompt
create sequence SEQ_MM_PKG_PRO_TROLLEY
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PKG_TRAY_QTY
prompt =====================================
prompt
create sequence SEQ_MM_PKG_TRAY_QTY
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PR_JOB
prompt ===============================
prompt
create sequence SEQ_MM_PR_JOB
minvalue 1
maxvalue 9999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PR_JOB_BUSINESS
prompt ========================================
prompt
create sequence SEQ_MM_PR_JOB_BUSINESS
minvalue 1
maxvalue 9999999999999999999999999999
start with 101
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PR_PRINTER
prompt ===================================
prompt
create sequence SEQ_MM_PR_PRINTER
minvalue 1
maxvalue 9999999999999999999999999999
start with 201
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PUB_CALENDAR_DETAIL
prompt ============================================
prompt
create sequence SEQ_MM_PUB_CALENDAR_DETAIL
minvalue 1
maxvalue 9999999999999999999999999999
start with 581
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PUB_DATA_DICT
prompt ======================================
prompt
create sequence SEQ_MM_PUB_DATA_DICT
minvalue 1
maxvalue 9999999999999999999999999999
start with 613
increment by 1
nocache;

prompt
prompt Creating sequence SEQ_MM_PUB_FILE_INFO
prompt ======================================
prompt
create sequence SEQ_MM_PUB_FILE_INFO
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PUB_FILE_SERVER
prompt ========================================
prompt
create sequence SEQ_MM_PUB_FILE_SERVER
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PUB_IMAGE
prompt ==================================
prompt
create sequence SEQ_MM_PUB_IMAGE
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PUB_IMPORT
prompt ===================================
prompt
create sequence SEQ_MM_PUB_IMPORT
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PUB_KEYPART_BIND
prompt =========================================
prompt
create sequence SEQ_MM_PUB_KEYPART_BIND
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PUB_MODEL_CODE
prompt =======================================
prompt
create sequence SEQ_MM_PUB_MODEL_CODE
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PUB_OPE_LOG_ID
prompt =======================================
prompt
create sequence SEQ_MM_PUB_OPE_LOG_ID
minvalue 1
maxvalue 9999999999999999999999999999
start with 5381
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PUB_ORDER_PART
prompt =======================================
prompt
create sequence SEQ_MM_PUB_ORDER_PART
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PUB_PART
prompt =================================
prompt
create sequence SEQ_MM_PUB_PART
minvalue 1
maxvalue 9999999999999999999999999999
start with 6140
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PUB_PART_UDA
prompt =====================================
prompt
create sequence SEQ_MM_PUB_PART_UDA
minvalue 1
maxvalue 9999999999999999999999999999
start with 2401
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PUB_PART_UNLOAD
prompt ========================================
prompt
create sequence SEQ_MM_PUB_PART_UNLOAD
minvalue 1
maxvalue 9999999999999999999999999999
start with 2540
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PUB_PRO_ERROR
prompt ======================================
prompt
create sequence SEQ_MM_PUB_PRO_ERROR
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PUB_PRO_ROUTE
prompt ======================================
prompt
create sequence SEQ_MM_PUB_PRO_ROUTE
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PUB_SYS_ALERT
prompt ======================================
prompt
create sequence SEQ_MM_PUB_SYS_ALERT
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_PUB_SYS_PARAM
prompt ======================================
prompt
create sequence SEQ_MM_PUB_SYS_PARAM
minvalue 1
maxvalue 9999999999999999999999999999
start with 29
increment by 1
nocache;

prompt
prompt Creating sequence SEQ_MM_PUB_WORK_CALENDAR
prompt ==========================================
prompt
create sequence SEQ_MM_PUB_WORK_CALENDAR
minvalue 1
maxvalue 9999999999999999999999999999
start with 241
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PUB_WORK_CD
prompt ====================================
prompt
create sequence SEQ_MM_PUB_WORK_CD
minvalue 1
maxvalue 9999999999999999999999999999
start with 221
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PUP_FIX_PICKTIME
prompt =========================================
prompt
create sequence SEQ_MM_PUP_FIX_PICKTIME
minvalue 1
maxvalue 9999999999999999999
start with 101
increment by 1
cache 50;

prompt
prompt Creating sequence SEQ_MM_PUP_LOCK_PLAN
prompt ======================================
prompt
create sequence SEQ_MM_PUP_LOCK_PLAN
minvalue 1
maxvalue 9999999999999999999
start with 81
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PUP_ROTE
prompt =================================
prompt
create sequence SEQ_MM_PUP_ROTE
minvalue 1
maxvalue 9999999999999999999
start with 5651
increment by 1
cache 50;

prompt
prompt Creating sequence SEQ_MM_PUP_ROUTE_CAL
prompt ======================================
prompt
create sequence SEQ_MM_PUP_ROUTE_CAL
minvalue 1
maxvalue 9999999999999999999999999999
start with 3381
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_PUP_SCHEDULE
prompt =====================================
prompt
create sequence SEQ_MM_PUP_SCHEDULE
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_SPS_CONFIG
prompt ===================================
prompt
create sequence SEQ_MM_SPS_CONFIG
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_SPS_CONFIG_DETAIL
prompt ==========================================
prompt
create sequence SEQ_MM_SPS_CONFIG_DETAIL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_SPS_CONFIG_DETAIL_IMP
prompt ==============================================
prompt
create sequence SEQ_MM_SPS_CONFIG_DETAIL_IMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_SPS_CONFIG_IMP
prompt =======================================
prompt
create sequence SEQ_MM_SPS_CONFIG_IMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_SPS_MOULD
prompt ==================================
prompt
create sequence SEQ_MM_SPS_MOULD
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_SPS_MOULD_CONFIG
prompt =========================================
prompt
create sequence SEQ_MM_SPS_MOULD_CONFIG
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_SPS_MOULD_CONFIG_IMP
prompt =============================================
prompt
create sequence SEQ_MM_SPS_MOULD_CONFIG_IMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_SPS_SHELF_LABLE
prompt ========================================
prompt
create sequence SEQ_MM_SPS_SHELF_LABLE
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_SW_DEMAND_FORE
prompt =======================================
prompt
create sequence SEQ_MM_SW_DEMAND_FORE
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_SW_DEMAND_FORETEMP
prompt ===========================================
prompt
create sequence SEQ_MM_SW_DEMAND_FORETEMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_SW_FEEDBACK_ZC
prompt =======================================
prompt
create sequence SEQ_MM_SW_FEEDBACK_ZC
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_SW_LONG_ORDER
prompt ======================================
prompt
create sequence SEQ_MM_SW_LONG_ORDER
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_MM_SW_ORDER_DETAIL
prompt ========================================
prompt
create sequence SEQ_MM_SW_ORDER_DETAIL
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MM_SW_PICKUP_PLAN
prompt =======================================
prompt
create sequence SEQ_MM_SW_PICKUP_PLAN
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_MP_GAM_ORDER_LINE_NO
prompt ==========================================
prompt
create sequence SEQ_MP_GAM_ORDER_LINE_NO
minvalue 1
maxvalue 9999999999999999999999999999
start with 681
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_NON_STANDAR_CHECK
prompt =======================================
prompt
create sequence SEQ_NON_STANDAR_CHECK
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_PUB_DATA_PRIVI_BASIC
prompt ==========================================
prompt
create sequence SEQ_PUB_DATA_PRIVI_BASIC
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 100;

prompt
prompt Creating sequence SEQ_PUB_PRO_ERROR
prompt ===================================
prompt
create sequence SEQ_PUB_PRO_ERROR
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_SW_DEMAND_FORECAST_IMP
prompt ============================================
prompt
create sequence SEQ_SW_DEMAND_FORECAST_IMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_SW_NON_STANDARD
prompt =====================================
prompt
create sequence SEQ_SW_NON_STANDARD
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_S_EXCEPTION
prompt =================================
prompt
create sequence SEQ_S_EXCEPTION
minvalue 1
maxvalue 9999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_TEMP_DEMAND_FORECAST_IMP
prompt ==============================================
prompt
create sequence SEQ_TEMP_DEMAND_FORECAST_IMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_TMP
prompt =======================
prompt
create sequence S_TMP
minvalue 1
maxvalue 9999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence TRANSACTION_LOG_SEQ
prompt =====================================
prompt
create sequence TRANSACTION_LOG_SEQ
minvalue 0
maxvalue 9999999999999999999999999999
start with 7800
increment by 1
cache 20;

prompt
prompt Creating view MM_MP_CAL_END
prompt ===========================
prompt
CREATE OR REPLACE FORCE VIEW MM_MP_CAL_END AS
( SELECT MAX(A.REAL_END_SORT_ID) CAL_POINT, A.CAR_TYPE FROM MM_MP_PART_SORT A WHERE A.CAR_TYPE  IS NOT NULL GROUP BY A.CAR_TYPE);
comment on column MM_MP_CAL_END.CAR_TYPE is '??
??';

prompt
prompt Creating view VIEW_SYS_USER_DATA_PERM
prompt =====================================
prompt
CREATE OR REPLACE FORCE VIEW VIEW_SYS_USER_DATA_PERM AS
SELECT DISTINCT UR.USER_ID, U.ACCOUNT_ USER_NAME, B.TYPE_CODE, B.VALUE_CODE
FROM SYS_DP_USER_ROLE UR, SYS_DP_ROLE R, SYS_DP_ROLE_DATA RD, SYS_DP_BASE_DATA B, SYS_USER U
WHERE R.DATA_ROLE_ID = UR.DATA_ROLE_ID
  AND RD.DATA_ROLE_ID = R.DATA_ROLE_ID
  AND B.DP_BASE_ID = RD.DP_BASE_ID
  AND U.ID_ = UR.USER_ID
with read only;
comment on column VIEW_SYS_USER_DATA_PERM.USER_ID is '??ID';
comment on column VIEW_SYS_USER_DATA_PERM.USER_NAME is '?????';
comment on column VIEW_SYS_USER_DATA_PERM.TYPE_CODE is '??????';
comment on column VIEW_SYS_USER_DATA_PERM.VALUE_CODE is '???';

prompt
prompt Creating package PKG_ARCHIVE
prompt ============================
prompt
create or replace package PKG_ARCHIVE is

--函数名  : USP_ARCHIVE
--功能描述: 日志归档
--输入参数说明
--       AC_MAX_TIME 保留最大时间（不包括）
--输出参数说明：
--       ERROR_TAG：返回代码 0：成功，其他：失败
--       ERROR_MESSAGE:返回信息,
--创建人员: lym
--创建时间: 2018-03-14
--****************************************************************************
PROCEDURE USP_ARCHIVE(AC_MAX_TIME        IN  DATE,
                      ERROR_TAG          OUT NUMBER,
                      ERROR_MESSAGE      OUT VARCHAR2);


end PKG_ARCHIVE;
/

prompt
prompt Creating package PKG_IF_REC
prompt ===========================
prompt
create or replace package PKG_IF_REC is

  -- Author  : wxl
  -- Created : 2018/9/20 星期四 上午 11:42:07
  -- Purpose : Definition of if function or procedure for received data

  --****************************************************************************
  --函数  : USF_TRANS_MES_FACTORY
  --功能描述: 转换MES工厂代码为物流系统工厂代码
  --参数说明:
  -- in_mes_factory_code  :MES工厂代码
  --返回值: 物流系统工作中心
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  FUNCTION USF_TRANS_MES_FACTORY(in_mes_factory_code in varchar2)
    RETURN VARCHAR2;

  --****************************************************************************
  --函数  : USF_TRANS_MES_WORKCENTER
  --功能描述: 转换MES工作中心为物流系统工作中心
  --参数说明:
  -- in_mes_workcenter  :MES工作中心
  --返回值: 物流系统工作中心
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  FUNCTION USF_TRANS_MES_WORKCENTER(in_mes_workcenter in varchar2)
    RETURN VARCHAR2;

  --****************************************************************************
  --函数  : USF_TRANS_ERP_FACTORY
  --功能描述: 转换ERP工厂代码为物流系统工厂代码
  --参数说明:
  -- in_erp_factory_code  :MES工厂代码
  --返回值: 物流系统工作中心
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  FUNCTION USF_TRANS_ERP_FACTORY(in_erp_factory_code in varchar2)
    RETURN VARCHAR2;

  --****************************************************************************
  --函数  : USF_TRANS_ERP_WORKCENTER
  --功能描述: 转换MES工作中心为物流系统工作中心
  --参数说明:
  -- in_erp_workcenter  :ERP工作中心
  --返回值: 物流系统工作中心
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  FUNCTION USF_TRANS_ERP_WORKCENTER(in_erp_workcenter in varchar2)
    RETURN VARCHAR2;

  --****************************************************************************
  --过程名  : USP_JIT_VEH_SCRAP_DEAL
  --功能描述: 拉动计算车辆报废重投处理
  --参数说明: 无
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  PROCEDURE USP_JIT_VEH_SCRAP_DEAL(ERROR_TAG     OUT NUMBER,
                                   ERROR_MESSAGE OUT VARCHAR2);

  --****************************************************************************
  --过程名  : USP_PUB_IF_TO_VEH_PASS
  --功能描述: 车辆过点信息到业务表
  --参数说明: 无
  --创建人员: wxl
  --创建时间: 2018-11-27
  --****************************************************************************
  PROCEDURE USP_PUB_VEH_PASS(ERROR_TAG     OUT NUMBER,
                             ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUB_SPS_CONFIG
  --功能描述: 配置项信息接口表数据写入业务表
  --参数说明：
  --创建人员: wxl
  --创建时间： 2018-12-23
  PROCEDURE USP_PUB_SPS_CONFIG;

  --***************************************************************************
  --存储过程名：USP_PUB_FEATURE_GROUP
  --功能描述: 特征码组信息接口表数据写入业务表
  --参数说明：
  --创建人员: wxl
  --创建时间： 2018-12-23
  PROCEDURE USP_PUB_FEATURE_GROUP;

  --***************************************************************************
  --存储过程名：USP_PUB_ASSE_MOULD_CONFIG
  --功能描述: 装车单模板信息接口表数据写入业务表
  --参数说明：无
  --创建人员: wxl
  --创建时间：2018-12-23
  PROCEDURE USP_PUB_ASSE_MOULD_CONFIG(ERROR_TAG     OUT NUMBER,
                                      ERROR_MESSAGE OUT VARCHAR2);

  --****************************************************************************
  --存储名  : USP_PKG_PART_GET_MSG
  --功能描述: 将接口表数据写到业务表
  --参数说明:
  --返回值:
  --创建人员: luoxq
  --创建时间: 2018-12-04

  procedure USP_PKG_PART_GET_MSG;

  --****************************************************************************
  --函数  : USP_PKG_PART_MSG
  --功能描述: 将接口表数据写到业务表（考虑到IF_MODEL_BOM数据会到3月份才能有，所以数据从MM_PUB_ORDER_BOM中获取）
  --参数说明:
  --返回值:
  --创建人员: luoxq
  --创建时间: 2018-12-04
  --****************************************************************************

  procedure USP_PKG_PART_MSG;

  --***************************************************************************
  --存储过程名：USP_MP_GET_ORDER_PLAN
  --功能描述: 获取W+3周车辆计划
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/09/18
  PROCEDURE USP_MP_GET_ORDER_PLAN(ERROR_TAG     OUT NUMBER,
                                  ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_GET_ADJ_PLAN
  --功能描述: 获取调整车辆计划和BOM
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/09/21
  PROCEDURE USP_MP_GET_ADJ_PLAN(ERROR_TAG     OUT NUMBER,
                                ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_GET_ADJ_PLAN
  --功能描述: 单车BOM接口表数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/09/27
  PROCEDURE USP_MP_GET_ORDER_BOM(ERROR_TAG     OUT NUMBER,
                                 ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUB_PART
  --功能描述: 零件基础数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_PUB_PART(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUB_SUPPLIER
  --功能描述: 供应商基础数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_PUB_SUPPLIER(ERROR_TAG     OUT NUMBER,
                             ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUB_PART_SUPPLIER
  --功能描述: 零件供应商关系写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_PUB_PART_SUPPLIER(ERROR_TAG     OUT NUMBER,
                                  ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUB_SUPER_BOM
  --功能描述: 超级BOM写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2019/04/08
  PROCEDURE USP_PUB_SUPER_BOM(ERROR_TAG     OUT NUMBER,
                              ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUB_TACT_TIME
  --功能描述: 车间生产节拍写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_PUB_TACT_TIME(ERROR_TAG     OUT NUMBER,
                              ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUB_WORK_CALENDAR
  --功能描述: 工作日历写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_PUB_WORK_CALENDAR(ERROR_TAG     OUT NUMBER,
                                  ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUB_MODEL_BOM
  --功能描述: 物料与车型关系写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE USP_PUB_MODEL_BOM(ERROR_TAG     OUT NUMBER,
                              ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUB_WAREHOUSE
  --功能描述: 仓库主数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE USP_PUB_WAREHOUSE(ERROR_TAG     OUT NUMBER,
                              ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUB_PRO_ROUTE
  --功能描述: 工艺路线写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE USP_PUB_PRO_ROUTE(ERROR_TAG     OUT NUMBER,
                              ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_KEYPART_BIND
  --功能描述: 关键件批次件处理
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/30
  PROCEDURE USP_KEYPART_BIND(ERROR_TAG     OUT NUMBER,
                             ERROR_MESSAGE OUT VARCHAR2);

  /*--***************************************************************************
  --存储过程名：USP_SW_ORDER
  --功能描述: 采购订单处理
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/11/16
  PROCEDURE USP_SW_ORDER(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2);*/

  --****************************************************************************
  --过程名  : USP_SW_IF_TO_ORDER
  --功能描述: 订单接口数据至业务表
  --参数说明: 工厂代码
  --创建人员: ZHENGWUCHAO
  --创建时间: 2018-10-22
  --****************************************************************************
  PROCEDURE USP_SW_IF_TO_ORDER(ERROR_TAG     OUT NUMBER,
                               ERROR_MESSAGE OUT VARCHAR2);

  --****************************************************************************
  --过程名  : USP_SW_ORDER_DETAIL
  --功能描述: 处理订单表的从表数据
  --参数说明: 主表ID,采购单号，采购单行号
  --创建人员: ZHENGWUCHAO
  --创建时间: 2018-10-22
  --****************************************************************************
  /*PROCEDURE USP_SW_ORDER_DATEIL(IN_VAR_ID     IN NUMBER,
  IN_ORDER_TYPR IN VARCHAR2,
  ERR_NUM       OUT NUMBER,
  ERR_MSG       OUT VARCHAR2);*/

  --****************************************************************************
  --过程名  : USP_SW_IF_TO_ACCOUNT_BILL
  --功能描述: 结算对账数据接口到业务表
  --参数说明: 工厂代码
  --创建人员: ZHENGWUCHAO
  --创建时间: 2018-10-22
  --****************************************************************************
  PROCEDURE USP_SW_IF_TO_ACCOUNT_BILL(ERROR_TAG     OUT NUMBER,
                                      ERROR_MESSAGE OUT VARCHAR2);

  --****************************************************************************
  --过程名  : USP_SW_IF_TO_DEMAND_FORECAST
  --功能描述: 预测接口数据至业务表
  --参数说明: 工厂代码
  --创建人员: ZHENGWUCHAO
  --创建时间: 2018-10-22
  --****************************************************************************
  PROCEDURE USP_SW_IF_TO_DEMAND_FORECAST(ERROR_TAG     OUT NUMBER,
                                         ERROR_MESSAGE OUT VARCHAR2);

  --****************************************************************************
  --过程名  : USP_SW_IF_TO_LONG_ORDER
  --功能描述: 长周期接口数据至业务表
  --参数说明: 工厂代码
  --创建人员: ZHENGWUCHAO
  --创建时间: 2018-10-22
  --****************************************************************************
  PROCEDURE USP_SW_IF_TO_LONG_ORDER(ERROR_TAG     OUT NUMBER,
                                    ERROR_MESSAGE OUT VARCHAR2);

  --****************************************************************************
  --过程名  : USP_SW_IF_TO_LONG_ORDER
  --功能描述: 长周期接口数据(非标件）至业务表
  --参数说明:
  --创建人员: luoxianqin
  --创建时间: 2018-10-22
  --****************************************************************************
  PROCEDURE USP_SW_IF_TO_NON_STANDAR;

  --****************************************************************************
  --过程名  : USP_PUB_SUPPORTING_PART
  --功能描述: 支给件处理到业务表
  --创建人员: wangyu
  --创建时间: 2019-03-01
  --****************************************************************************
  PROCEDURE USP_PUB_SUPPORTING_PART(ERROR_TAG     OUT NUMBER,
                                    ERROR_MESSAGE OUT VARCHAR2);

  --****************************************************************************
  --过程名  : USP_JISO_INS_DETAIL_RECEIVE
  --功能描述: 座椅收货
  --创建人员: wagnyu
  --创建时间: 2018-10-22
  --****************************************************************************
  PROCEDURE USP_JISO_INS_DETAIL_RECEIVE(ERROR_TAG     OUT NUMBER,
                                        ERROR_MESSAGE OUT VARCHAR2);

end PKG_IF_REC;
/

prompt
prompt Creating package PKG_IF_SEND
prompt ============================
prompt
create or replace package PKG_IF_SEND is

  -- Author  : wxl
  -- Created : 2018/9/20 星期四 下午 1:57:12
  -- Purpose : Definition of if function or procedure for sended data

  --****************************************************************************
  --过程名  : USP_JISO_ORDER_SEND
  --功能描述: 厂外同步需结算订单写入接口表
  --参数说明: 无
  --创建人员: wxl
  --创建时间: 2018-09-17
  --****************************************************************************
  PROCEDURE USP_JISO_ORDER_SEND;

  --****************************************************************************
  --过程名  : USP_JIT_ORDER_SEND
  --功能描述: 拉动需结算订单写入接口表
  --参数说明: 无
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  PROCEDURE USP_JIT_ORDER_SEND;

  --****************************************************************************
  --过程名  : USP_MP_ORDER_SEND
  --功能描述: 零件订单写入接口表
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2018-11-23
  PROCEDURE USP_MP_ORDER_SEND;

  --****************************************************************************
  --过程名  : USP_TRIAL_ORDER_SEND
  --功能描述: 新车型订单写入接口表
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2018-11-23
  PROCEDURE USP_TRIAL_ORDER_SEND;

  --****************************************************************************
  --过程名  : USP_EXC_ORDER_SEND
  --功能描述: 例外写入接口表
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2018-11-23
  PROCEDURE USP_EXC_ORDER_SEND;

  --****************************************************************************
  --过程名  : USP_TRIAL_ORDER_SEND
  --功能描述: 例外写入接口表
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2018-11-23
  PROCEDURE USP_MAT_ORDER_SEND;

  --****************************************************************************
  --过程名  : USP_INV_IN
  --功能描述: 收货数据接口表
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2018-11-29
  PROCEDURE USP_INV_IN;

  --****************************************************************************
  --过程名  : USP_TRAN_LMS
  --功能描述: 仓库转移数据接口表
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2018-12-10
  PROCEDURE USP_TRAN_LMS;

  --****************************************************************************
  --过程名  : USP_SW_TO_IF_ACCOUNT_INVOICE
  --功能描述: 结算反馈数据到接口
  --创建人员: ZHENGWUCHAO
  --创建时间: 2018-10-22
  --****************************************************************************
  PROCEDURE USP_SW_TO_IF_ACCOUNT_INVOICE;
  --****************************************************************************
  --过程名  : USP_SW_ZC_REPLY
  --功能描述: 资材反馈写入接口表
  --参数说明: 无
  --创建人员: dtp
  --创建时间: 2019-03-19
  PROCEDURE USP_SW_ZC_REPLY;
  --****************************************************************************

  --****************************************************************************
  --过程名  : USP_JISO_INS_SEND
  --功能描述: 将同步指示票发送延锋
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2019-05-22
  --****************************************************************************
  PROCEDURE USP_JISO_INS_SEND;

  --****************************************************************************
  --过程名  : USP_TRAN_MOVE_LMS
  --功能描述: 仓库转移数据接口表
  --参数说明: 无
  --创建人员: zmj
  --创建时间: 2019-09-04
  PROCEDURE USP_TRAN_MOVE_LMS;

end PKG_IF_SEND;
/

prompt
prompt Creating package PKG_IF_SEND_IN
prompt ===============================
prompt
create or replace package PKG_IF_SEND_IN is

  -- Author  : lbx
  -- Created : 2018/12/27 15:46:34
  -- Purpose : Definition of if function or procedure for sended data

  --****************************************************************************
  --过程名  : USP_MON_KB
  --功能描述: 厂内平台的供应商看板写入信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_MON_KB;

  --****************************************************************************
  --过程名  : USP_JIT_ORDER
  --功能描述: 厂内平台的拉动订单写入信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_JIT_ORDER;

  --****************************************************************************
  --过程名  : USP_JISO_ORDER
  --功能描述: 将厂内平台的厂外同步订单写入信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_JISO_ORDER;

  --****************************************************************************
  --过程名  : USP_JISO_INS
  --功能描述: 将厂内平台的厂外同步指示票写入信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_JISO_INS;

  --****************************************************************************
  --过程名  : USP_PKG_PART
  --功能描述: 将包装零件担当信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_PKG_PART;

  --****************************************************************************
  --过程名  : USP_PKG_BOX
  --功能描述: 将包装箱种信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_PKG_BOX;

  --****************************************************************************
  --过程名  : USP_PKG_PROPOSAL_DETAIL
  --功能描述: 将包装提案明细信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_PKG_PROPOSAL_DETAIL;

  --****************************************************************************
  --过程名  : USP_PKG_PROPOSAL
  --功能描述: 将包装提案信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_PKG_PROPOSAL;

  --****************************************************************************
  --过程名  : USP_PKG_BOX_QTY
  --功能描述: 将包装箱子数量管理同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_PKG_BOX_QTY;

  --****************************************************************************
  --过程名  : USP_PKG_TRAY_QTY
  --功能描述: 将包装托盘数量信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_PKG_TRAY_QTY;

  --****************************************************************************
  --过程名  : USP_PUB_SUPPLIER
  --功能描述: 当厂内供应商数据发生变化时，将信息发布至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_PUB_SUPPLIER;

  --****************************************************************************
  --过程名  : USP_PUB_PART
  --功能描述: 当厂内零件主数数据发生变化时，将信息发布至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_PUB_PART;

  --****************************************************************************
  --过程名  : USP_PUB_PART
  --功能描述: 当厂内零件供应商数据发生变化时，将信息发布至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_PUB_PART_SUPPLIER;

  --****************************************************************************
  --过程名  : USP_SW_ORDER
  --功能描述: 当厂内订单数据发生变化时，将信息发布至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_SW_ORDER;

  --****************************************************************************
  --过程名  : USP_SW_PICK_PLAN
  --功能描述: 将预测数据信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_SW_DEMAND_FORECAST;

  --****************************************************************************
  --过程名  : USP_SW_ACCOUNT_BILL
  --功能描述: 将发票对账信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_SW_ACCOUNT_BILL;

  --****************************************************************************
  --过程名  : USP_SW_ACCOUNT_BILL_DETAIL
  --功能描述: 将发票对账明细信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_SW_ACCOUNT_BILL_DETAIL;

  --****************************************************************************
  --过程名  : USP_SW_LONG_ORDER
  --功能描述: 将长周期订单信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_SW_LONG_ORDER;

  --****************************************************************************
  --过程名  : USP_SW_LONG_ORDER_DETAIL
  --功能描述: 将长周期明细信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_SW_LONG_ORDER_DETAIL;

  --****************************************************************************
  --过程名  : USP_PUB_PART_UDA
  --功能描述: 将订购零件基础信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_PUB_PART_UDA;

  --****************************************************************************
  --过程名  : USP_INV_PART_LOCATION
  --功能描述: 将属地基础信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_INV_PART_LOCATION;

  --****************************************************************************
  --过程名  : USP_SW_PICK_PLAN
  --功能描述: 将取货订单信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_SW_PICK_PLAN;

  --****************************************************************************
  --过程名  : USP_INV_IN
  --功能描述: 将收货数据写入信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_INV_IN;

  --****************************************************************************
  --过程名  : USP_JISO_PART_PLAN
  --功能描述: 将厂内同步零件下线计划写入信息共享平台
  --参数说明: 无
  --创建人员: lxq
  --创建时间: 2019-04-06
  --****************************************************************************
  PROCEDURE USP_JISO_PART_PLAN;

  --****************************************************************************
  --过程名  : USP_JISO_INS_ORDERNO_SY
  --功能描述: 同步厂外同步指示票订单号
  --参数说明: 无
  --创建人员: dtp
  --创建时间: 2019-04-06
  --****************************************************************************
  PROCEDURE USP_JISO_INS_ORDERNO_SY;

end PKG_IF_SEND_IN;
/

prompt
prompt Creating package PKG_INV_CHECK
prompt ==============================
prompt
CREATE OR REPLACE PACKAGE PKG_INV_CHECK IS

  --***************************************************************************
  --存储过程名：INV_STOCKTAK_IMPORT_CHECK
  --功能描述： 盘点信息Excel导入检查校验
  --参数说明：
  --输入：
  --IN_VAR_UUID 导入UUID
  --IN_VAR_USERNAME 操作人名称
  --IN_VAR_OPEIP ip地址
  --输出：
  --OUT_ERROR_FLAG 错误标识
  --OUT_OUT_ERROR_MSG 错误信息
  --创建人员: zmj
  --创建时间： 2018/10/12
  PROCEDURE INV_STOCKTAK_IMPORT_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                      IN_VAR_USERNAME   IN VARCHAR2,
                                      IN_VAR_OPEIP      IN VARCHAR2,
                                      OUT_ERROR_FLAG    OUT VARCHAR2,
                                      OUT_OUT_ERROR_MSG OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：INV_STOCK_IMPORT_CHECK
  --功能描述： 盘点信息Excel导入检查校验
  --参数说明：
  --输入：
  --IN_VAR_UUID 导入UUID
  --IN_VAR_USERNAME 操作人名称
  --IN_VAR_OPEIP ip地址
  --输出：
  --OUT_ERROR_FLAG 错误标识
  --OUT_OUT_ERROR_MSG 错误信息
  --创建人员: zmj
  --创建时间： 2018/10/12
  PROCEDURE INV_STOCK_IMPORT_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                   IN_VAR_USERNAME   IN VARCHAR2,
                                   IN_VAR_OPEIP      IN VARCHAR2,
                                   OUT_ERROR_FLAG    OUT VARCHAR2,
                                   OUT_OUT_ERROR_MSG OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：INV_GET_STOCK_TOTAL
  --功能描述： 获取PC库和线边库的库存总和，写入到库存推移基础表（MM_INV_DEV_BASE）
  --参数说明：
  --输入：
  --IN_VAR_FACTORY 工厂代码
  --IN_VAR_USERNAME 操作人名称
  --输出：
  --OUT_ERROR_FLAG 错误标识
  --OUT_OUT_ERROR_MSG 错误信息
  PROCEDURE INV_GET_STOCK_TOTAL(IN_VAR_FACTORY    IN VARCHAR2,
                                IN_VAR_USERNAME   IN VARCHAR2,
                                OUT_ERROR_FLAG    OUT VARCHAR2,
                                OUT_OUT_ERROR_MSG OUT VARCHAR2);
  --***************************************************************************
  --存储过程名：USP_INV_EMPTY_CHECK
  --功能描述：空容器库存导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: linzhuo
  --创建时间： 2018/09/10
  PROCEDURE USP_INV_EMPTY_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                IN_VAR_USERNAME   IN VARCHAR2,
                                IN_VAR_OPEIP      IN VARCHAR2,
                                OUT_ERROR_FLAG    OUT VARCHAR2,
                                OUT_OUT_ERROR_MSG OUT VARCHAR2);
  /*  -- AUTHOR  : 李兴辉
  -- CREATED : 2018/10/19 21:58:01
  -- PURPOSE :

  -- PUBLIC TYPE DECLARATIONS
  PROCEDURE USP_MM_INV_SHELVES_IMPORT(ERROR_TAG OUT VARCHAR2);*/
  /*  --***************************************************************************
  --存储过程名：USP_MATERIAL_IMPORT_CHECK
  --功能描述：资材订单反馈导入校验
  --参数说明：
  --IN_VAR_UUID
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  PROCEDURE USP_MATERIAL_IMPORT_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                      OUT_ERROR_FLAG    OUT VARCHAR2,
                                      OUT_OUT_ERROR_MSG OUT VARCHAR2);*/

  --***************************************************************************
  --存储过程名：USP_INV_WEEK_CAL_CHECK
  --功能描述：支给件推算周导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: luoxianqin
  --创建时间： 2019-05-28
  PROCEDURE USP_INV_WEEK_CAL_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                   IN_VAR_USERNAME   IN VARCHAR2,
                                   IN_VAR_OPEIP      IN VARCHAR2,
                                   OUT_ERROR_FLAG    OUT VARCHAR2,
                                   OUT_OUT_ERROR_MSG OUT VARCHAR2);

END PKG_INV_CHECK;
/

prompt
prompt Creating package PKG_INV_MAIN
prompt =============================
prompt
create or replace package PKG_INV_MAIN is

  --***************************************************************************
  --存储过程名：USP_INVENTORY_DEAL_MAIN
  --功能描述：库存处理
  --参数说明：
  --in_warehouse_type 仓库类型  0 表示零件仓库   1 表示虚拟仓库   2 表示线边仓库
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_INVENTORY_DEAL_MAIN(in_warehouse_type IN VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_INVENTORY_DEAL_MAIN
  --功能描述：取货订单和拉动订单收货库存处理
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_INVENTORY_DEAL_SH_MAIN;

  --***************************************************************************
  --存储过程名：USP_INVENTORY_CAL_MAIN
  --功能描述：库存推移
  --参数说明：
  --in_factorycode 工厂
  --创建人员: wangyu
  --创建时间： 2018/11/22
  PROCEDURE USP_INVENTORY_CAL_MAIN(in_factorycode IN VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_INIT_BOM
  --功能描述：库存推移BOM初始化
  --参数说明：
  --in_factorycode 工厂
  --创建人员: wangyu
  --创建时间： 2018/11/23
  PROCEDURE USP_INIT_BOM(in_factorycode IN VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_INIT_INV_BASE
  --功能描述：初始化库存
  --参数说明：
  --IN_VAR_FACTORY 工厂
  --IN_VAR_USERNAME 操作用户
  --IN_TYPE         类型
  --创建人员: wangyu
  --创建时间： 2018/12/11
  PROCEDURE USP_INIT_INV_BASE(IN_VAR_FACTORY  IN VARCHAR2,
                              IN_VAR_USERNAME IN VARCHAR2,
                              IN_TYPE         VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_EC_OUT_INS
  --功能描述：空容器出库指示
  --参数说明：
  --in_factorycode 工厂
  --创建人员: wangyu
  --创建时间： 2018/12/06
  PROCEDURE USP_EC_OUT_INS(in_factorycode IN VARCHAR2, out_code OUT NUMBER);

  --***************************************************************************
  --存储过程名：USP_MODIFY_INV_STOCK
  --功能描述：更新库存
  --参数说明：
  --in_warehouse 仓库类型
  --in_partno 零件号
  --in_quantity 数量
  --in_factorycode 工厂
  --创建人员: wangyu
  --创建时间： 2018/11/1
  PROCEDURE USP_MODIFY_INV_STOCK(in_warehouse   IN VARCHAR2,
                                 in_partno      IN VARCHAR2,
                                 in_quantity    IN NUMBER,
                                 in_factorycode IN VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_SUPPORT_PART_DEAL
  --功能描述：支给件库存处理
  --参数说明：
  --in_partno 零件号
  --in_factorycode 工厂
  --in_num 总成件数量
  --创建人员: wangyu
  --创建时间： 2019/04/13
  PROCEDURE USP_SUPPORT_PART_DEAL(in_partno      IN VARCHAR2,
                                  in_factorycode IN VARCHAR2,
                                  in_num         IN NUMBER);

  --***************************************************************************
  --存储过程名：USP_INV_STOCK_GEN
  --功能描述：W-1周库存处理
  --参数说明：
  --in_factorycode 工厂
  --in_caluser 操作人
  --out_code 返回值
  --创建人员: wangyu
  --创建时间： 2019/05/14
  PROCEDURE USP_INV_STOCK_GEN(in_factorycode IN VARCHAR2,
                              in_caluser     IN VARCHAR2,
                              out_code       OUT NUMBER);

  --***************************************************************************
  --存储过程名：USP_INV_GET_DIFFERENCE
  --功能描述：支给获取库存差异
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: luoxq
  --创建时间： 2019/05/30
  PROCEDURE USP_INV_GET_DIFFERENCE(in_arr_factory in VARCHAR2,
                                   in_account     in VARCHAR2,
                                   out_code       out VARCHAR2);
end PKG_INV_MAIN;
/

prompt
prompt Creating package PKG_JISI
prompt =========================
prompt
create or replace package PKG_JISI is

  -- Author  : WXL
  -- Created : 2018/9/29 星期六 上午 10:43:54
  -- Purpose : Definition of jisi function or procedure

  --****************************************************************************
  --过程名  : USP_JISI_GET_PASS_QUEUE
  --功能描述: 厂内同步获取车序队列
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-29
  --****************************************************************************
  PROCEDURE USP_JISI_GET_PASS_QUEUE(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JISI_CREATE_INS
  --功能描述: 计算生成指示票
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-29
  --****************************************************************************
  PROCEDURE USP_JISI_CREATE_INS(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JISI_CAL_EXEC
  --功能描述: 执行厂内同步推算
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-28
  --****************************************************************************
  PROCEDURE USP_JISI_CAL_EXEC(in_plan_code in varchar2);

end PKG_JISI;
/

prompt
prompt Creating package PKG_JISO
prompt =========================
prompt
create or replace package PKG_JISO is

  -- Author  : wxl
  -- Created : 2018/9/11 星期二 上午 9:48:51
  -- Purpose : Definition of jiso function or procedure

  --****************************************************************************
  --过程名  : USP_JISO_GET_PASS_QUEUE
  --功能描述: 厂外同步获取车序队列
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-11
  --****************************************************************************
  PROCEDURE USP_JISO_GET_PASS_QUEUE(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JISO_CAL_NET_REQ
  --功能描述: 计算零件净需求
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-11
  --****************************************************************************
  PROCEDURE USP_JISO_CAL_NET_REQ(in_plan_code in varchar2);

  --****************************************************************************
  --函数名  : USF_JISO_GET_CAR_BATCH
  --功能描述: 获取车次
  --参数说明:
  -- in_car_batch_seqno  :车次流水号
  --返回值  : 车次流水号
  --创建人员: wxl
  --创建时间: 2018-09-14
  --****************************************************************************
  FUNCTION USF_JISO_GET_CAR_BATCH(in_car_batch_seqno in number) RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_JISO_GET_CAR_BATCHSEQNO
  --功能描述: 获取车次信息
  --参数说明:
  -- in_plan_code  :信息点
  -- in_partgroup_no  :零件组代码
  -- in_sup_factory  :供应商出货地
  --返回值  : 车次流水号
  --创建人员: wxl
  --创建时间: 2018-09-14
  --****************************************************************************
  FUNCTION USF_JISO_GET_CAR_BATCHSEQNO(in_plan_code    in varchar2,
                                  in_partgroup_no in varchar2,
                                  in_sup_factory  in varchar2) RETURN NUMBER;

  --****************************************************************************
  --过程名  : USP_JISO_CREATE_INS
  --功能描述: 生成厂外同步指示票
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  PROCEDURE USP_JISO_CREATE_INS(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JISO_CREATE_ORDER
  --功能描述: 生成厂外同步订单
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-13
  --****************************************************************************
  PROCEDURE USP_JISO_CREATE_ORDER(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JISO_CAL_EXEC
  --功能描述: 执行厂外同步推算
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --****************************************************************************
  PROCEDURE USP_JISO_CAL_EXEC(in_plan_code in varchar2);

    --****************************************************************************
  --过程名  : USP_JISO_PART_PLAN
  --功能描述: 计算零件下线计划
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: lxq
  --创建时间: 2019-04-06
  --****************************************************************************
  PROCEDURE USP_JISO_PART_PLAN(in_plan_code in varchar2);
end PKG_JISO;
/

prompt
prompt Creating package PKG_JISO_DTP
prompt =============================
prompt
create or replace package PKG_JISO_DTP is

  -- Author  : wxl
  -- Created : 2018/9/11 星期二 上午 9:48:51
  -- Purpose : Definition of jiso function or procedure

  --****************************************************************************
  --过程名  : USP_JISO_GET_PASS_QUEUE
  --功能描述: 厂外同步获取车序队列
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-11
  --****************************************************************************
  PROCEDURE USP_JISO_GET_PASS_QUEUE(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JISO_CAL_NET_REQ
  --功能描述: 计算零件净需求
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-11
  --****************************************************************************
  PROCEDURE USP_JISO_CAL_NET_REQ(in_plan_code in varchar2);

  --****************************************************************************
  --函数名  : USF_JISO_GET_CAR_BATCH
  --功能描述: 获取车次
  --参数说明:
  -- in_car_batch_seqno  :车次流水号
  --返回值  : 车次流水号
  --创建人员: wxl
  --创建时间: 2018-09-14
  --****************************************************************************
  FUNCTION USF_JISO_GET_CAR_BATCH(in_car_batch_seqno in number) RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_JISO_GET_CAR_BATCHSEQNO
  --功能描述: 获取车次信息
  --参数说明:
  -- in_plan_code  :信息点
  -- in_partgroup_no  :零件组代码
  -- in_sup_factory  :供应商出货地
  --返回值  : 车次流水号
  --创建人员: wxl
  --创建时间: 2018-09-14
  --****************************************************************************
  FUNCTION USF_JISO_GET_CAR_BATCHSEQNO(in_plan_code    in varchar2,
                                  in_partgroup_no in varchar2,
                                  in_sup_factory  in varchar2) RETURN NUMBER;

  --****************************************************************************
  --过程名  : USP_JISO_CREATE_INS
  --功能描述: 生成厂外同步指示票
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  PROCEDURE USP_JISO_CREATE_INS(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JISO_CREATE_ORDER
  --功能描述: 生成厂外同步订单
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-13
  --****************************************************************************
  PROCEDURE USP_JISO_CREATE_ORDER(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JISO_CAL_EXEC
  --功能描述: 执行厂外同步推算
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --****************************************************************************
  PROCEDURE USP_JISO_CAL_EXEC(in_plan_code in varchar2);
end PKG_JISO_DTP;
/

prompt
prompt Creating package PKG_JIT
prompt ========================
prompt
create or replace package PKG_JIT is

  -- Author  : wxl
  -- Created : 2018/9/17 星期一 下午 2:27:14
  -- Purpose : Definition of jit function or procedure

  --****************************************************************************
  --函数  : USF_GET_KBPRODSEQNO
  --功能描述: 根据产品流水号判断是否达到批次条件
  --参数说明:
  -- in_plan_code  :信息点
  -- in_check_prod_seqno  :检查的产品流水号
  -- in_ahead_prod_num    :提前台套数
  --返回值: 检查结果
  --创建人员: wxl
  --创建时间: 2018-11-29
  --****************************************************************************
  FUNCTION USF_GET_KBPRODSEQNO(in_plan_code        in varchar2)
    RETURN NUMBER;

  --****************************************************************************
  --过程名  : USP_JIT_GET_PASS_QUEUE
  --功能描述: 拉动获取车序队列
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --****************************************************************************
  PROCEDURE USP_JIT_GET_PASS_QUEUE(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JITI_CAL_NET_REQ
  --功能描述: 计算零件净需求（厂内）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --****************************************************************************
  PROCEDURE USP_JITI_CAL_NET_REQ(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JITO_CAL_NET_REQ
  --功能描述: 计算零件净需求（厂外）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --****************************************************************************
  PROCEDURE USP_JITO_CAL_NET_REQ(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JITD_CAL_NET_REQ
  --功能描述: 计算零件净需求（厂外->厂内）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2019-06-11
  --****************************************************************************
  PROCEDURE USP_JITD_CAL_NET_REQ(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JITI_DPM_DEAL
  --功能描述: 不良品处理（厂内）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-26
  --****************************************************************************
  PROCEDURE USP_JITI_DPM_DEAL(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JITO_DPM_DEAL
  --功能描述: 不良品处理（厂外）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-26
  --****************************************************************************
  PROCEDURE USP_JITO_DPM_DEAL(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JITI_CAL_PKG_REQ
  --功能描述: 计算零件包装需求（厂内）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --****************************************************************************
  PROCEDURE USP_JITI_CAL_PKG_REQ(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JITO_CAL_PKG_REQ
  --功能描述: 计算零件包装需求（厂外）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --****************************************************************************
  PROCEDURE USP_JITO_CAL_PKG_REQ(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JITD_CAL_LACK_REQ
  --功能描述: 计算零件缺件需求（厂外->厂内）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2019-06-11
  --****************************************************************************
  PROCEDURE USP_JITD_CAL_LACK_REQ(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JIT_CREATE_INS1
  --功能描述: 生成配送单（厂内）-按配送工程
  --参数说明:
  -- in_plan_code  :信息点
  -- in_order_no  :物流单号
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  PROCEDURE USP_JIT_CREATE_INS1(in_order_no in varchar2);

  --****************************************************************************
  --过程名  : USP_JIT_CREATE_INS2
  --功能描述: 生成配送单（厂内）-按拣货工程
  --参数说明:
  -- in_plan_code  :信息点
  -- in_order_no  :物流单号
  --创建人员: wxl
  --创建时间: 2019-02-22
  --****************************************************************************
  PROCEDURE USP_JIT_CREATE_INS2(in_order_no in varchar2);

  --****************************************************************************
  --过程名  : USP_JITI_CREATE_ORDER
  --功能描述: 生成配送单（厂内）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-21
  --****************************************************************************
  PROCEDURE USP_JITI_CREATE_ORDER(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JIT_CREATE_LABEL
  --功能描述: 根据订单号生成拉动零件标签(子过程)
  --参数说明:
  -- in_order_no  :物流单号
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  PROCEDURE USP_JIT_CREATE_LABEL(in_order_no in varchar2);

  --****************************************************************************
  --过程名  : USP_JITO_CREATE_ORDER_SUP
  --功能描述: 生成供应商拉动订单
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-19
  --****************************************************************************
  PROCEDURE USP_JITO_CREATE_ORDER_SUP(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_JIT_CAL_EXEC
  --功能描述: 执行拉动推算
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  PROCEDURE USP_JIT_CAL_EXEC(in_plan_code in varchar2);
end PKG_JIT;
/

prompt
prompt Creating package PKG_JIT_BASIC
prompt ==============================
prompt
create or replace package PKG_JIT_BASIC is

  -- Author  : wxl
  -- Created : 2019/2/25 星期一 下午 2:27:14
  -- Purpose : Definition of jit function or procedure

  --****************************************************************************
  --过程名  : USP_JIT_INVEN_COMP
  --功能描述: 拉动库存对比计算
  --参数说明:
  --in_uuid 导入UUID
  --out_num_result 存储过程执行结果
  --out_err_msg 存储过程执行错误信息
  --创建人员: wxl
  --创建时间: 2019-02-25
  --****************************************************************************
 PROCEDURE USP_JIT_INVEN_COMP(in_uuid          in VARCHAR2,
                              out_num_result   out NUMBER,
                              out_err_msg      out VARCHAR2);
 --****************************************************************************

  --****************************************************************************
  --过程名  : USP_JIT_PART_LACK_QUERY
  --功能描述: 拉动缺件处理查询
  --参数说明:
  --in_uuid 导入UUID
  --out_num_result 存储过程执行结果
  --out_err_msg 存储过程执行错误信息
  --创建人员: wxl
  --创建时间: 2019-04-12
  --****************************************************************************
 PROCEDURE USP_JIT_PART_LACK_QUERY(in_uuid          in VARCHAR2,
                                   in_factory_code  in VARCHAR2,
                                   out_num_result   out NUMBER,
                                   out_err_msg      out VARCHAR2);

end PKG_JIT_BASIC;
/

prompt
prompt Creating package PKG_MON
prompt ========================
prompt
create or replace package PKG_MON is

  -- Author  : wxl
  -- Created : 2018/11/21 星期三 上午 10:04:44
  -- Purpose : Definition of mon function or procedure

  --****************************************************************************
  --过程名  : USP_MON_KB_UPDATE
  --功能描述: 看板更新
  --参数说明:
  --创建人员: wxl
  --创建时间: 2018-11-21
  --****************************************************************************
  PROCEDURE USP_MON_KB_UPDATE;

  --****************************************************************************
  --过程名  : USP_MON_KB_QUERYKB_DETAIL
  --功能描述: 看板显示详情查询
  --参数说明:
  --IN_KB_IP:现场看板IP地址
  --IN_KB_CODE:看板代码
  --IN_DISTRI_PERSON:工程
  --IN_FACTORY_CODE:工厂
  --OUT_CURR_BACTH_NO:当前批次
  --OUT_PROCESS_CYCLE_NUM:进度循环基数
  --OUT_RUN_PROCESS_NO:当前进度
  --OUT_KB_STATUS:看板状态
  --OUT_RUN_DELAY_FLAG:看板延迟状态
  --OUT_CURR_BATCH_SEQNO:当前批次流水号
  --创建人员: zmj
  --创建时间: 2019-02-18
  --****************************************************************************

  PROCEDURE USP_MON_KB_QUERYKB_DETAIL(IN_KB_IP              IN VARCHAR2,
                                      IN_KB_CODE            IN VARCHAR2,
                                      IN_DISTRI_PERSON      IN VARCHAR2,
                                      IN_FACTORY_CODE       IN VARCHAR2,
                                      OUT_CURR_BACTH_NO     OUT VARCHAR2,
                                      OUT_PROCESS_CYCLE_NUM OUT VARCHAR2,
                                      OUT_RUN_PROCESS_NO    OUT VARCHAR2,
                                      OUT_KB_STATUS         OUT VARCHAR2,
                                      OUT_RUN_DELAY_FLAG    OUT VARCHAR2,
                                      OUT_CURR_BATCH_SEQNO  OUT VARCHAR2);
end PKG_MON;
/

prompt
prompt Creating package PKG_MP_CHECK
prompt =============================
prompt
create or replace package PKG_MP_CHECK is

  --存储过程名：USP_MP_RESIDUAL_CHECK
  --功能描述：零件剩余量主数据导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: linzhuo
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_RESIDUAL_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                  IN_VAR_USERNAME   IN VARCHAR2,
                                  IN_VAR_OPEIP      IN VARCHAR2,
                                  OUT_ERROR_FLAG    OUT VARCHAR2,
                                  OUT_OUT_ERROR_MSG OUT VARCHAR2);

  --存储过程名：USP_MP_ORDER_RECORD_CHECK
  --功能描述：订单履历导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: linzhuo
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_ORDER_RECORD_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                      IN_VAR_USERNAME   IN VARCHAR2,
                                      IN_VAR_OPEIP      IN VARCHAR2,
                                      OUT_ERROR_FLAG    OUT VARCHAR2,
                                      OUT_OUT_ERROR_MSG OUT VARCHAR2);

  --存储过程名：USP_MP_TRIAL_PLAN_CHECK
  --功能描述：新车型维护导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: linzhuo
  --创建时间： 2018/09/20
  PROCEDURE USP_MP_TRIAL_PLAN_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                    IN_VAR_USERNAME   IN VARCHAR2,
                                    IN_VAR_OPEIP      IN VARCHAR2,
                                    OUT_ERROR_FLAG    OUT VARCHAR2,
                                    OUT_OUT_ERROR_MSG OUT VARCHAR2);

  --存储过程名：USP_MP_TRIAL_DEMAND_CHECK
  --功能描述：新车型需求计算导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: linzhuo
  --创建时间： 2018/09/20
  PROCEDURE USP_MP_TRIAL_DEMAND_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                      IN_VAR_USERNAME   IN VARCHAR2,
                                      IN_VAR_OPEIP      IN VARCHAR2,
                                      OUT_ERROR_FLAG    OUT VARCHAR2,
                                      OUT_OUT_ERROR_MSG OUT VARCHAR2);

  --存储过程名：USP_MP_EXC_ORDER_CHECK
  --功能描述：例外订单导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: wangyu
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_EXC_ORDER_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                   IN_VAR_USERNAME   IN VARCHAR2,
                                   IN_VAR_OPEIP      IN VARCHAR2,
                                   OUT_ERROR_FLAG    OUT VARCHAR2,
                                   OUT_OUT_ERROR_MSG OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_ADJ_ORDER_CHECK
  --功能描述：导入计划对比调整差异数据校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: wangyu
  --创建时间： 2019/1/26
  PROCEDURE USP_MP_ADJ_ORDER_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                   IN_VAR_USERNAME   IN VARCHAR2,
                                   IN_VAR_OPEIP      IN VARCHAR2,
                                   OUT_ERROR_FLAG    OUT VARCHAR2,
                                   OUT_OUT_ERROR_MSG OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_DEMANDFORCAST_CHECK
  --功能描述：月预测数据导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: wangyu
  --创建时间： 2019/4/20
  PROCEDURE USP_MP_DEMANDFORCAST_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                       IN_VAR_USERNAME   IN VARCHAR2,
                                       IN_VAR_OPEIP      IN VARCHAR2,
                                       OUT_ERROR_FLAG    OUT VARCHAR2,
                                       OUT_OUT_ERROR_MSG OUT VARCHAR2);
end PKG_MP_CHECK;
/

prompt
prompt Creating package PKG_MP_MAIN
prompt ============================
prompt
create or replace package PKG_MP_MAIN is

  --***************************************************************************
  --存储过程名：USP_MP_GEN_ORDER_BOM
  --功能描述：生成订购单车BOM
  --参数说明：
  --in_opeId 操作人
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_GEN_ORDER_BOM(in_arr_factory in VARCHAR2,
                                 in_opeId       in VARCHAR2,
                                 out_code       out VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_ZSB
  --功能描述：净需求总成
  --参数说明：
  --in_uuid
  --in_opeId 操作人
  --in_type 类型 需求计算，采购订单生成
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_ZSB(in_uuid        in VARCHAR2,
                       in_opeId       in VARCHAR2,
                       in_type        in VARCHAR2,
                       in_arr_factory in VARCHAR2,
                       out_code       out number);

  --***************************************************************************
  --存储过程名：USP_MP_WATCH_OPEN
  --功能描述：推算监控开启
  --参数说明：
  --in_uuid
  --in_opeId 操作人
  --in_type 类型 需求计算，采购订单生成
  --in_arr_factory 工厂
  --创建人员: wangyu
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_WATCH_OPEN(in_uuid        varchar2,
                              in_opeid       varchar2,
                              in_type        in VARCHAR2,
                              in_arr_factory in VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_ZSB_MAIN
  --功能描述：净需求主体
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_ZSB_MAIN(in_arr_factory in VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_REQ_ZSB_INIT
  --功能描述：初始化供应商分组，零件分组最大值
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_REQ_ZSB_INIT(in_arr_factory in VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_VEH_STANDARD
  --功能描述：分车型调整
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/12
  PROCEDURE USP_MP_VEH_STANDARD(in_arr_factory in VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_ZSB_MAIN_ORDER
  --功能描述：净需求订单处理
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/14
  PROCEDURE USP_MP_ZSB_MAIN_ORDER(in_arr_factory in VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_ZSB_DEAL_PACK
  --功能描述：包装处理
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/15
  PROCEDURE USP_MP_ZSB_DEAL_PACK(in_arr_factory in VARCHAR2);

  /*--***************************************************************************
  --存储过程名：USP_MP_ZSB_DIFF_PLAN
  --功能描述：生成W+1,W+2计划差异数据
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2019/01/15
  PROCEDURE USP_MP_ZSB_DIFF_PLAN(in_arr_factory in VARCHAR2,
                                 out_code       OUT NUMBER);*/

  --***************************************************************************
  --存储过程名：USP_MP_ZSB_DIFF
  --功能描述：使用差异计划生成计划变更差异
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/16
  PROCEDURE USP_MP_ZSB_DIFF(in_arr_factory in VARCHAR2,
                            out_code       OUT NUMBER);

  --***************************************************************************
  --存储过程名：USP_MP_ZSB_DEAL_STATUS
  --功能描述：订单状态处理
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/16
  PROCEDURE USP_MP_ZSB_DEAL_STATUS(in_arr_factory in VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_WATCH_COLSE
  --功能描述：公共监控日志关闭记录
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/16
  PROCEDURE USP_MP_WATCH_COLSE(in_uuid        varchar2,
                               in_opeid       varchar2,
                               in_type        in VARCHAR2,
                               in_arr_factory in VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_GEN_ORDER_NO
  --功能描述：采购订单号生成
  --参数说明：
  --in_uuid
  --in_opeId 操作人
  --in_type 类型 需求计算，采购订单生成, 采购订单号生成
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2018/09/17
  PROCEDURE USP_MP_GEN_ORDER_NO(in_uuid        in varchar2,
                                in_opeid       in varchar2,
                                in_type        in VARCHAR2,
                                in_arr_factory in VARCHAR2,
                                out_code       out number);

  --***************************************************************************
  --存储过程名：USP_MP_GEN_MAIN
  --功能描述：订单号生成总成
  --参数说明：
  --in_arr_factory 工厂
  --创建人员: wangyu
  --创建时间： 2018/09/17
  PROCEDURE USP_MP_GEN_MAIN(in_arr_factory in VARCHAR2,
                            in_opeid       in varchar2);

  --***************************************************************************
  --存储过程名：USP_MP_PO
  --功能描述：采购订单生成总成
  --参数说明：
  --in_uuid
  --in_opeId 操作人
  --in_type 类型 需求计算，采购订单生成
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2018/09/17
  PROCEDURE USP_MP_PO(in_uuid        in varchar2,
                      in_opeid       in varchar2,
                      in_type        in VARCHAR2,
                      in_arr_factory in VARCHAR2,
                      out_code       out number);

  --***************************************************************************
  --存储过程名：USP_MP_PO_GEN
  --功能描述：采购订单生成
  --参数说明：
  --in_arr_factory 工厂
  --创建人员: wangyu
  --创建时间： 2018/09/17
  PROCEDURE USP_MP_PO_GEN(in_arr_factory in VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_PO_ADJUST
  --功能描述：订购后订单调整
  --参数说明：
  --in_arr_factory 工厂
  --创建人员: wangyu
  --创建时间： 2018/09/17
  PROCEDURE USP_MP_PO_ADJUST(in_arr_factory in VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_PO_GAM_NEW
  --功能描述：订单生成
  --参数说明：
  --in_arr_factory 工厂
  --创建人员: wangyu
  --创建时间： 2018/09/17
  PROCEDURE USP_MP_PO_GAM_NEW(in_arr_factory in VARCHAR2,
                              in_opeid       in varchar2);

  --***************************************************************************
  --存储过程名：USP_MP_GET_ADJ_PLAN
  --功能描述：调整差异计算， 调整计划获取
  --参数说明：
  --in_arr_factory 工厂代码
  --in_start_date 开始日期
  --in_end_date 结束日期
  --创建人员: wangyu
  --创建时间： 2018/09/21
  PROCEDURE USP_MP_GET_ADJ_PLAN(in_arr_factory IN VARCHAR2,
                                in_start_date  IN VARCHAR2,
                                in_end_date    IN VARCHAR2,
                                out_code       OUT NUMBER);

  --***************************************************************************
  --存储过程名：USP_MP_ADJ_DIFF_MAIN
  --功能描述：调整计划差异对比
  --参数说明：
  --in_arr_factory 工厂代码
  --in_opeid 操作人
  --创建人员: wangyu
  --创建时间： 2018/09/25
  PROCEDURE USP_MP_ADJ_DIFF_MAIN(in_arr_factory IN VARCHAR2,
                                 in_opeid       IN VARCHAR2,
                                 out_code       OUT NUMBER);

  --***************************************************************************
  --存储过程名：USP_MP_GET_TRIAL_PLAN
  --功能描述：获取试制计划
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/26
  PROCEDURE USP_MP_GET_TRIAL_PLAN(in_arr_factory IN VARCHAR2,
                                  out_code       OUT NUMBER);

  --***************************************************************************
  --存储过程名：USP_MP_TRIAL_ZSB
  --功能描述：计算试制车计划需求
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/27
  PROCEDURE USP_MP_TRIAL_ZSB(in_arr_factory IN VARCHAR2,
                             out_code       OUT NUMBER);

  --***************************************************************************
  --存储过程名：USP_MP_TRIAL_PO
  --功能描述：试制车订单生成
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/28
  PROCEDURE USP_MP_TRIAL_PO(in_arr_factory IN VARCHAR2,
                            in_opeid       IN VARCHAR2,
                            out_code       OUT NUMBER);

  --***************************************************************************
  --存储过程名：USP_MP_EXC_ZSB
  --功能描述：统计例外订单需求
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/28
  /*  PROCEDURE USP_MP_EXC_ZSB(in_arr_factory IN VARCHAR2,
  out_code       OUT INTEGER);*/

  --***************************************************************************
  --存储过程名：USP_MP_EXC_PO_ZSB
  --功能描述：例外订购组单
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/07
  PROCEDURE USP_MP_EXC_PO(in_arr_factory IN VARCHAR2,
                          in_opeid       IN VARCHAR2,
                          out_code       OUT NUMBER);

  --***************************************************************************
  --存储过程名：USP_GEN_SW_PARTLABEL
  --功能描述：生成协同标签
  --参数说明：
  --in_order 订单号
  --创建人员: wangyu
  --创建时间： 2018/10/16
  PROCEDURE USP_GEN_SW_PARTLABEL(in_order IN VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MM_MP_INIT_WEEK_PLAN
  --功能描述：每个月第一天1点初始化这个月的周计划
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/12/09
  PROCEDURE USP_MM_MP_INIT_WEEK_PLAN(in_arr_factory IN VARCHAR2);

  /*--***************************************************************************
  --存储过程名：USP_MP_GET_PLAN_TEMP
  --功能描述：每天下午4点根据工作日历和周计划获取生产计划到临时表
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/12/09
  PROCEDURE USP_MP_GET_PLAN_TEMP(in_arr_factory IN VARCHAR2);*/

  --***************************************************************************
  --存储过程名：USP_MP_GET_PLAN
  --功能描述：获取W+3周计划
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/19
  PROCEDURE USP_MP_GET_PLAN(in_arr_factory IN VARCHAR2,
                            out_code       OUT NUMBER);

  --***************************************************************************
  --存储过程名：USP_MP_CONFRIM_PLAN
  --功能描述：临时车辆计划的确认导入按钮
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/12/09
  PROCEDURE USP_MP_CONFRIM_PLAN(in_arr_factory IN VARCHAR2,
                                out_code       OUT NUMBER);

  /* --***************************************************************************
  --存储过程名：USP_MP_AUTO_CONFRIM_PLAN
  --功能描述：将临时表车辆计划自动写入车辆计划表
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/12/09
  PROCEDURE USP_MP_AUTO_CONFRIM_PLAN(in_arr_factory IN VARCHAR2,
                                     out_code       OUT NUMBER);*/

  --***************************************************************************
  --存储过程名：USP_MP_DEMAND_FORECAST_GEN
  --功能描述：需求预测
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --version  版本
  --foreType 预测类型
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2019/04/18
  PROCEDURE USP_MP_DEMAND_FORECAST_GEN(in_arr_factory in VARCHAR2,
                                       in_account     in VARCHAR2,
                                       in_version     in VARCHAR2,
                                       in_foreType    in VARCHAR2,
                                       out_code       out VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_DEMAND_FORECAST_RELEASE
  --功能描述：需求预测发布
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --version  版本
  --foreType 预测类型
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2019/04/18
  PROCEDURE USP_MP_DEMAND_FORECAST_RELEASE(in_arr_factory in VARCHAR2,
                                           in_account     in VARCHAR2,
                                           in_version     in VARCHAR2,
                                           in_foreType    in VARCHAR2,
                                           out_code       out VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_DEMAND_PARTIF_GEN
  --功能描述：一级件零件需求预测计算
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --foreType 预测类型
  --out_code 返回代码
  --创建人员: luoxianqin
  --创建时间： 2019/04/28
  PROCEDURE USP_MP_DEMAND_PARTIF_GEN(in_arr_factory in VARCHAR2,
                                     in_account     in VARCHAR2,
                                     in_foreType    in VARCHAR2,
                                     in_startDate   in VARCHAR2,
                                     in_endDate     in VARCHAR2,
                                     out_code       out VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_INV_STOCK_GEN
  --功能描述：支给W-1周库存计算
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2019/04/18
  PROCEDURE USP_INV_STOCK_GEN(in_arr_factory in VARCHAR2,
                              in_account     in VARCHAR2,
                              out_code       out VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_INV_GET_DIFFERENCE
  --功能描述：支给获取库存差异
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: luoxq
  --创建时间： 2019/05/30
  PROCEDURE USP_INV_GET_DIFFERENCE(in_arr_factory in VARCHAR2,
                                   in_account     in VARCHAR2,
                                   out_code       out VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_DEMAND_EFFECT
  --功能描述：在物流系统就是那的周预测数据生效使用并写到业务表中
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --foreType 预测类型
  --out_code 返回代码
  --创建人员: luoxianqin
  --创建时间： 2019/04/28
  PROCEDURE USP_MP_DEMAND_EFFECT(in_arr_factory in VARCHAR2,
                                 in_account     in VARCHAR2,
                                 in_foreType    in VARCHAR2,
                                 out_code       out VARCHAR2);
end PKG_MP_MAIN;
/

prompt
prompt Creating package PKG_PR_ALERT
prompt =============================
prompt
create or replace package PKG_PR_ALERT as

  --****************************************************************************
  --过程名  : USP_PRINT_EXCEP_CHECK
  --功能描述: 自动打印异常检查
  --参数说明:
  --in_arr_factory 工厂
  --创建人员: dtp
  --创建时间: 2019-02-22
  --****************************************************************************
  procedure USP_PRINT_EXCEP_CHECK(in_arr_factory IN VARCHAR2);

  --****************************************************************************
  --过程名  : USP_PRINT_EXCEP_ALERT
  --功能描述: 自动打印异常提醒
  --创建人员: dtp
  --创建时间: 2019-02-22
  --****************************************************************************
  procedure USP_PRINT_EXCEP_ALERT;

end PKG_PR_ALERT;
/

prompt
prompt Creating package PKG_PUB
prompt ========================
prompt
create or replace package PKG_PUB is

  -- Author  : wxl
  -- Created : 2018/9/10 星期一 下午 4:11:12
  -- Purpose : Definition of common methods

  --****************************************************************************
  --函数  : USF_GET_BATCH_CYCLE
  --功能描述: 获取批次循环基数
  --参数说明:
  -- in_plan_code  :信息点
  --返回值: 批次循环基数
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCH_CYCLE(in_plan_code in varchar2) RETURN NUMBER;

  --****************************************************************************
  --函数  : USF_GET_PROCESS_CYCLE
  --功能描述: 获取进度循环基数
  --参数说明:
  -- in_plan_code  :信息点
  --返回值: 进度循环基数
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_PROCESS_CYCLE(in_plan_code in varchar2) RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_BATCH_NO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 批次号
  --创建人员: wxl
  --创建时间: 2018-11-12
  --****************************************************************************
  FUNCTION USF_GET_BATCHNO_BY_PRODSEQNO(in_kb_id         in number,
                                        in_product_seqno in number)
    RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_PROCESSNO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 进度号
  --创建人员: wxl
  --创建时间: 2018-11-12
  --****************************************************************************
  FUNCTION USF_GET_PROCESSNO_BY_PRODSEQNO(in_kb_id         in number,
                                          in_product_seqno in number)
    RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_BATCHNO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCHNO_BY_PRODSEQNO(in_plan_code     in varchar2,
                                        in_product_seqno in number)
    RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_PROCESSNO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 进度号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_PROCESSNO_BY_PRODSEQNO(in_plan_code     in varchar2,
                                          in_product_seqno in number)
    RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_BATCHSEQ_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次流水号
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 批次流水号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCHSEQ_BY_PRODSEQNO(in_kb_id         in number,
                                         in_product_seqno in number)
    RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_BATCHSEQ_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次流水号
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次流水号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCHSEQ_BY_PRODSEQNO(in_plan_code     in varchar2,
                                         in_product_seqno in number)
    RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_PRODSEQNO_BY_BATCH
  --功能描述: 根据批次获取产品流水号
  --参数说明:
  -- in_plan_code  :信息点
  -- in_batch_no  :批次号
  -- in_process_no  :进度号
  --返回值  : 产品流水号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_PRODSEQNO_BY_BATCH(in_plan_code  in varchar2,
                                      in_batch_no   in number,
                                      in_process_no in number) RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_BATCH_NO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次循环流水号
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 批次基数流水号
  --创建人员: wxl
  --创建时间: 2019-06-29
  --****************************************************************************
  FUNCTION USF_GET_BCYCLESEQ_BY_PRODSEQNO(in_kb_id         in number,
                                          in_product_seqno in number)
    RETURN NUMBER;
    
  --****************************************************************************
  --函数名  : USF_GET_BATCH_NO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次循环流水号
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次基数流水号
  --创建人员: wxl
  --创建时间: 2019-06-29
  --****************************************************************************
  FUNCTION USF_GET_BCYCLESEQ_BY_PRODSEQNO(in_plan_code     in varchar2,
                                          in_product_seqno in number)
    RETURN NUMBER;
    
  --****************************************************************************
  --函数名  : USF_GET_WORK_DATE
  --功能描述: 根据输入的时间获取当前工作日期(不包含时分秒)
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_time  :输入时间
  --返回值  : 工作日期(不包含时分秒)
  --创建人员: wxl
  --创建时间: 2018-09-11
  --****************************************************************************
  FUNCTION USF_GET_WORK_DATE(in_factory_code in varchar2,
                             in_workcenter   in varchar2,
                             in_time         in date) RETURN DATE;

  --****************************************************************************
  --函数名  : USF_GET_PRODUCE_TIME
  --功能描述: 获取生产节拍
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  FUNCTION USF_GET_PRODUCE_TIME(in_factory_code    in varchar2,
                                in_workcenter      in varchar2,
                                in_production_line in varchar2) RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_WORKTIME
  --功能描述: 获取工厂车间某一时间点前几秒的工作时间
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  -- in_time  :输入时间
  -- in_num_offset  :  偏移秒数(单位:秒)
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2019-01-20
  --****************************************************************************
  FUNCTION USF_GET_CAL_WORKTIME(in_factory_code in varchar2,
                                in_workcenter   in varchar2,
                                in_time         in date,
                                in_num_offset   in number) RETURN DATE;

  --****************************************************************************
  --函数名  : USF_GET_PRE_WORKTIME
  --功能描述: 获取工厂车间某一时间点前几秒的工作时间
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  -- in_time  :输入时间
  -- in_num_offset  :  偏移秒数(负数，单位:秒)
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  FUNCTION USF_GET_PRE_WORKTIME(in_factory_code in varchar2,
                                in_workcenter   in varchar2,
                                in_time         in date,
                                in_num_offset   in number) RETURN DATE;

  --****************************************************************************
  --函数名  : USF_GET_NEXT_WORKTIME
  --功能描述: 获取工厂车间某一时间点后几秒的工作时间
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  -- in_time  :输入时间
  -- in_num_offset  :  偏移秒数(正数，单位:秒)
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  FUNCTION USF_GET_NEXT_WORKTIME(in_factory_code in varchar2,
                                 in_workcenter   in varchar2,
                                 in_time         in date,
                                 in_num_offset   in number) RETURN DATE;

  --****************************************************************************
  --函数名  : USF_GET_SYS_PARAM
  --功能描述: 获取系统参数
  --参数说明:
  -- in_factory_code  :工厂
  -- in_param_group  :参数组
  -- in_param_code  :参数代码
  --返回值  : 参数值
  --创建人员: wxl
  --创建时间: 2018-09-11
  --****************************************************************************
  FUNCTION USF_GET_SYS_PARAM(in_factory_code in varchar2,
                             in_param_group  in varchar2,
                             in_param_code   in varchar2) RETURN VARCHAR2;

  --****************************************************************************
  --方法名 : USF_GET_DICT
  --功能描述: 拉动计算车辆报废重投处理
  --输入参数:
  -- in_factory_code  :工厂代码
  -- in_code_type  :数据字典类型
  -- in_code_value  :数据字典代码
  --输出参数 : 数据字典名称
  --创建人员: wxl
  --创建时间: 2018-12-04
  --****************************************************************************
  FUNCTION USF_GET_DICT(in_factory_code in varchar2,
                        in_code_type    in varchar2,
                        in_code_value   in varchar2) RETURN VARCHAR2;

  --****************************************************************************
  --函数名  : USF_GET_ORDER_NO
  --功能描述: 获取物流订单号
  --参数说明:
  -- in_plan_code  :信息点
  --返回值  : 物流订单号
  --创建人员: wxl
  --创建时间: 2018-09-13
  --****************************************************************************
  FUNCTION USF_GET_ORDER_NO(in_plan_code in varchar2) RETURN VARCHAR2;

  --****************************************************************************
  --函数名  : USF_GET_ORDER_NO_BY_DATE
  --功能描述: 获取物流订单号
  --参数说明:
  -- in_factory_code  :工厂
  -- in_order_type  :订单类型：
  --SW 取货订单    A
  --EXC 例外订单    B
  --JISO同步订单    C
  --JIT 拉动订单   D-H
  --返回值  : 物流订单号
  --创建人员: wy
  --创建时间: 2018-09-13
  FUNCTION USF_GET_ORDER_NO_BY_DATE(in_factory_code in varchar2,
                                    in_order_type   in varchar2,
                                    in_arrive_date  in date) RETURN VARCHAR2;

  --****************************************************************************
  --函数  : USF_GET_WORKCENTER_PRE
  --功能描述: 获取车间头
  --参数说明:
  -- in_workcenter  :车间
  --返回值: 获取车间头
  --创建人员: wxl
  --创建时间: 2019-01-18
  --****************************************************************************
  FUNCTION USF_GET_WORKCENTER_PRE(in_workcenter in varchar2) RETURN VARCHAR2;

  --****************************************************************************
  --函数名  : USF_GET_SEQUENCE
  --功能描述: 获取数据库序列值
  --参数说明:
  -- in_seq_name    :序列名字
  --返回值  : 下一个序列值
  --创建人员: chenjq
  --创建时间: 2016-11-15
  --****************************************************************************
  FUNCTION USF_GET_SEQUENCE(in_seq_name IN VARCHAR2) RETURN NUMBER;
  --****************************************************************************
  --函数名  : USF_GET_BATCHPROC_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取 批次-进度
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次-进度
  --创建人员: dtp
  --创建时间: 2018-10-20
  --****************************************************************************
  FUNCTION USF_GET_BATCHPROC_BY_PRODSEQNO(in_plan_code     in varchar2,
                                          in_product_seqno in number)
    RETURN VARCHAR2;

end PKG_PUB;
/

prompt
prompt Creating package PKG_PUB_CHECK
prompt ==============================
prompt
create or replace package PKG_PUB_CHECK is

  --***************************************************************************
  --存储过程名：USP_PUB_ORDER_PART_CHECK
  --功能描述：订购零件基础信息导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: wangyu
  --创建时间： 2018/11/04
  PROCEDURE USP_PUB_ORDER_PART_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                     IN_VAR_USERNAME   IN VARCHAR2,
                                     IN_VAR_OPEIP      IN VARCHAR2,
                                     OUT_ERROR_FLAG    OUT VARCHAR2,
                                     OUT_OUT_ERROR_MSG OUT VARCHAR2);
  --***************************************************************************
  --存储过程名：USP_SPSCONFIG_IMPORT_CHECK
  --功能描述：SPS配置项明细导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: zmj
  --创建时间： 2018/11/09
  PROCEDURE USP_SPSCONFIG_IMPORT_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                       OUT_ERROR_FLAG    OUT VARCHAR2,
                                       OUT_OUT_ERROR_MSG OUT VARCHAR2);
  --***************************************************************************
  --存储过程名：USP_JIT_PART_REMAIN_CHECK
  --功能描述：零件余量批量导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: dtp
  --创建时间： 2018/10/12
  PROCEDURE USP_JIT_PART_REMAIN_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                      IN_VAR_USERNAME   IN VARCHAR2,
                                      IN_VAR_OPEIP      IN VARCHAR2,
                                      OUT_ERROR_FLAG    OUT VARCHAR2,
                                      OUT_OUT_ERROR_MSG OUT VARCHAR2);
  --*****************************************************************************
  --存储过程名：USP_SPS_CONFIG_ITEM_CHECK
  --功能描述：SPS配置项维护导入校验
  --参数说明：
  --IN_VAR_UUID
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: dtp
  --创建时间： 2018/12/17
  PROCEDURE USP_SPS_CONFIG_ITEM_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                      OUT_ERROR_FLAG    OUT VARCHAR2,
                                      OUT_OUT_ERROR_MSG OUT VARCHAR2);
  --*****************************************************************************
  --存储过程名：USP_MM_SPS_MOULD_CONFIG_CHECK
  --功能描述：SPS票据模板配置导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: dtp
  --创建时间： 2018/10/12
  PROCEDURE USP_MM_SPS_MOULD_CONFIG_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                          IN_VAR_USERNAME   IN VARCHAR2,
                                          IN_VAR_OPEIP      IN VARCHAR2,
                                          OUT_ERROR_FLAG    OUT VARCHAR2,
                                          OUT_OUT_ERROR_MSG OUT VARCHAR2);
  --*****************************************************************************
  --存储过程名：USP_MM_SPS_SHELF_LABEL_CHECK
  --功能描述：SPS货架标签打印导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: dtp
  --创建时间： 2018/10/12
  PROCEDURE USP_MM_SPS_SHELF_LABEL_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                         IN_VAR_USERNAME   IN VARCHAR2,
                                         IN_VAR_OPEIP      IN VARCHAR2,
                                         OUT_ERROR_FLAG    OUT VARCHAR2,
                                         OUT_OUT_ERROR_MSG OUT VARCHAR2);
  --*****************************************************************************
  --存储过程名：USP_MM_INV_PART_LOCATION_CHECK
  --功能描述：零件属地导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: dtp
  --创建时间： 2019/02/20
  PROCEDURE USP_MM_INV_PART_LOCATION_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                           IN_VAR_USERNAME   IN VARCHAR2,
                                           IN_VAR_OPEIP      IN VARCHAR2,
                                           OUT_ERROR_FLAG    OUT VARCHAR2,
                                           OUT_OUT_ERROR_MSG OUT VARCHAR2);
  --*****************************************************************************
  --****************************************************************************
  --过程名  : PUP_PRO_PLAN_CHECK
  --功能描述: 厂内同步零件组信息导入检查校验
  --参数说明:
  --输入：
  --in_var_uuid                  导入的UUID
  --in_var_username              用户名
  --in_var_opeip                 操作IP
  --输出：
  --out_error_flag              返回结果 0：成功，其他：失败
  --out_error_msg               错误信息
  --out_total_count             导入的数据总量
  --out_exist_count             导入数据中已存在的数据数量
  --out_ok_count                导入数据中检查通过的数量
  --创建人员: luoxq
  --创建时间: 2018-11-10
  --****************************************************************************
  PROCEDURE JISI_PART_GROUP_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                  IN_VAR_USERNAME   IN VARCHAR2,
                                  IN_VAR_OPEIP      IN VARCHAR2,
                                  OUT_ERROR_FLAG    OUT VARCHAR2,
                                  OUT_OUT_ERROR_MSG OUT VARCHAR2);

  --****************************************************************************
  --过程名  : JISI_PART_CHECK
  --功能描述: 厂内同步零件组信息导入检查校验
  --参数说明:
  --输入：
  --in_var_uuid                  导入的UUID
  --in_var_username              用户名
  --in_var_opeip                 操作IP
  --输出：
  --out_error_flag              返回结果 0：成功，其他：失败
  --out_error_msg               错误信息
  --out_total_count             导入的数据总量
  --out_exist_count             导入数据中已存在的数据数量
  --out_ok_count                导入数据中检查通过的数量
  --创建人员: luoxq
  --创建时间: 2018-11-10
  --****************************************************************************
  --**************************************************---
  --存储过程名：USP_MM_PART_IMPORT
  --功能描述：属地零件导入确认
  --参数说明：
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: lxh
  --创建时间： 2018/11/8
  --**************************************************---
  PROCEDURE USP_MM_PART_IMPORT(OUT_ERROR_FLAG    OUT VARCHAR2,
                               OUT_OUT_ERROR_MSG OUT VARCHAR2);
  --****************************************************************************
  --存储过程名：USP_MM_PUB_DELETE_IMP_TABLE
  --功能描述：清除导入临时表数据
  --参数说明：
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: dtp
  --创建时间： 2019/04/22
  --****************************************************************************
  PROCEDURE USP_MM_PUB_DELETE_IMP_TABLE(OUT_ERROR_FLAG    OUT VARCHAR2,
                                        OUT_OUT_ERROR_MSG OUT VARCHAR2);

end PKG_PUB_CHECK;
/

prompt
prompt Creating package PKG_PUB_DTP
prompt ============================
prompt
create or replace package PKG_PUB_DTP is

  -- Author  : wxl
  -- Created : 2018/9/10 星期一 下午 4:11:12
  -- Purpose : Definition of common methods

  --****************************************************************************
  --函数  : USF_GET_BATCH_CYCLE
  --功能描述: 获取批次循环基数
  --参数说明:
  -- in_plan_code  :信息点
  --返回值: 批次循环基数
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCH_CYCLE(in_plan_code in varchar2) RETURN NUMBER;

  --****************************************************************************
  --函数  : USF_GET_PROCESS_CYCLE
  --功能描述: 获取进度循环基数
  --参数说明:
  -- in_plan_code  :信息点
  --返回值: 进度循环基数
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_PROCESS_CYCLE(in_plan_code in varchar2) RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_BATCH_NO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 批次号
  --创建人员: wxl
  --创建时间: 2018-11-12
  --****************************************************************************
  FUNCTION USF_GET_BATCHNO_BY_PRODSEQNO(in_kb_id         in number,
                                        in_product_seqno in number)
    RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_PROCESSNO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 进度号
  --创建人员: wxl
  --创建时间: 2018-11-12
  --****************************************************************************
  FUNCTION USF_GET_PROCESSNO_BY_PRODSEQNO(in_kb_id         in number,
                                          in_product_seqno in number)
    RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_BATCHNO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCHNO_BY_PRODSEQNO(in_plan_code     in varchar2,
                                        in_product_seqno in number)
    RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_PROCESSNO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 进度号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_PROCESSNO_BY_PRODSEQNO(in_plan_code     in varchar2,
                                          in_product_seqno in number)
    RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_BATCHSEQ_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次流水号
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 批次流水号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCHSEQ_BY_PRODSEQNO(in_kb_id         in number,
                                         in_product_seqno in number)
    RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_BATCHSEQ_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次流水号
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次流水号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCHSEQ_BY_PRODSEQNO(in_plan_code     in varchar2,
                                         in_product_seqno in number)
    RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_PRODSEQNO_BY_BATCH
  --功能描述: 根据批次获取产品流水号
  --参数说明:
  -- in_plan_code  :信息点
  -- in_batch_no  :批次号
  -- in_process_no  :进度号
  --返回值  : 产品流水号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_PRODSEQNO_BY_BATCH(in_plan_code  in varchar2,
                                      in_batch_no   in number,
                                      in_process_no in number) RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_WORK_DATE
  --功能描述: 根据输入的时间获取当前工作日期(不包含时分秒)
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_time  :输入时间
  --返回值  : 工作日期(不包含时分秒)
  --创建人员: wxl
  --创建时间: 2018-09-11
  --****************************************************************************
  FUNCTION USF_GET_WORK_DATE(in_factory_code in varchar2,
                             in_workcenter   in varchar2,
                             in_time         in date) RETURN DATE;

  --****************************************************************************
  --函数名  : USF_GET_PRODUCE_TIME
  --功能描述: 获取生产节拍
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  FUNCTION USF_GET_PRODUCE_TIME(in_factory_code    in varchar2,
                                in_workcenter      in varchar2,
                                in_production_line in varchar2) RETURN NUMBER;

  --****************************************************************************
  --函数名  : USF_GET_WORKTIME
  --功能描述: 获取工厂车间某一时间点前几秒的工作时间
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  -- in_time  :输入时间
  -- in_num_offset  :  偏移秒数(单位:秒)
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2019-01-20
  --****************************************************************************
  FUNCTION USF_GET_CAL_WORKTIME(in_factory_code in varchar2,
                                in_workcenter   in varchar2,
                                in_time         in date,
                                in_num_offset   in number) RETURN DATE;

  --****************************************************************************
  --函数名  : USF_GET_PRE_WORKTIME
  --功能描述: 获取工厂车间某一时间点前几秒的工作时间
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  -- in_time  :输入时间
  -- in_num_offset  :  偏移秒数(负数，单位:秒)
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  FUNCTION USF_GET_PRE_WORKTIME(in_factory_code in varchar2,
                                in_workcenter   in varchar2,
                                in_time         in date,
                                in_num_offset   in number) RETURN DATE;

  --****************************************************************************
  --函数名  : USF_GET_NEXT_WORKTIME
  --功能描述: 获取工厂车间某一时间点后几秒的工作时间
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  -- in_time  :输入时间
  -- in_num_offset  :  偏移秒数(正数，单位:秒)
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  FUNCTION USF_GET_NEXT_WORKTIME(in_factory_code in varchar2,
                                 in_workcenter   in varchar2,
                                 in_time         in date,
                                 in_num_offset   in number) RETURN DATE;

  --****************************************************************************
  --函数名  : USF_GET_SYS_PARAM
  --功能描述: 获取系统参数
  --参数说明:
  -- in_factory_code  :工厂
  -- in_param_group  :参数组
  -- in_param_code  :参数代码
  --返回值  : 参数值
  --创建人员: wxl
  --创建时间: 2018-09-11
  --****************************************************************************
  FUNCTION USF_GET_SYS_PARAM(in_factory_code in varchar2,
                             in_param_group  in varchar2,
                             in_param_code   in varchar2) RETURN VARCHAR2;

  --****************************************************************************
  --方法名 : USF_GET_DICT
  --功能描述: 拉动计算车辆报废重投处理
  --输入参数:
  -- in_factory_code  :工厂代码
  -- in_code_type  :数据字典类型
  -- in_code_value  :数据字典代码
  --输出参数 : 数据字典名称
  --创建人员: wxl
  --创建时间: 2018-12-04
  --****************************************************************************
  FUNCTION USF_GET_DICT(in_factory_code in varchar2,
                        in_code_type    in varchar2,
                        in_code_value   in varchar2) RETURN VARCHAR2;

  --****************************************************************************
  --函数名  : USF_GET_ORDER_NO
  --功能描述: 获取物流订单号
  --参数说明:
  -- in_plan_code  :信息点
  --返回值  : 物流订单号
  --创建人员: wxl
  --创建时间: 2018-09-13
  --****************************************************************************
  FUNCTION USF_GET_ORDER_NO(in_plan_code in varchar2) RETURN VARCHAR2;

  --****************************************************************************
  --函数名  : USF_GET_ORDER_NO_BY_DATE
  --功能描述: 获取物流订单号
  --参数说明:
  -- in_factory_code  :工厂
  -- in_order_type  :订单类型：
  --SW 取货订单    A
  --EXC 例外订单    B
  --JISO同步订单    C
  --JIT 拉动订单   D-H
  --返回值  : 物流订单号
  --创建人员: wy
  --创建时间: 2018-09-13
  FUNCTION USF_GET_ORDER_NO_BY_DATE(in_factory_code in varchar2,
                                    in_order_type   in varchar2,
                                    in_arrive_date  in date) RETURN VARCHAR2;

  --****************************************************************************
  --函数  : USF_GET_WORKCENTER_PRE
  --功能描述: 获取车间头
  --参数说明:
  -- in_workcenter  :车间
  --返回值: 获取车间头
  --创建人员: wxl
  --创建时间: 2019-01-18
  --****************************************************************************
  FUNCTION USF_GET_WORKCENTER_PRE(in_workcenter in varchar2) RETURN VARCHAR2;

  --****************************************************************************
  --函数名  : USF_GET_SEQUENCE
  --功能描述: 获取数据库序列值
  --参数说明:
  -- in_seq_name    :序列名字
  --返回值  : 下一个序列值
  --创建人员: chenjq
  --创建时间: 2016-11-15
  --****************************************************************************
  FUNCTION USF_GET_SEQUENCE(in_seq_name IN VARCHAR2) RETURN NUMBER;
  --****************************************************************************
  --函数名  : USF_GET_BATCHPROC_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取 批次-进度
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次-进度
  --创建人员: dtp
  --创建时间: 2018-10-20
  --****************************************************************************
  FUNCTION USF_GET_BATCHPROC_BY_PRODSEQNO(in_plan_code     in varchar2,
                                          in_product_seqno in number)
    RETURN VARCHAR2;

end PKG_PUB_DTP;
/

prompt
prompt Creating package PKG_PUP_CHECK
prompt ==============================
prompt
create or replace package PKG_PUP_CHECK is

  --****************************************************************************
  --过程名  : PUP_PRO_PLAN_CHECK
  --功能描述: 取货计划生产计划据导入检查校验
  --参数说明:
  --输入：
  --in_var_uuid                  导入的UUID
  --in_var_username              用户名
  --in_var_opeip                 操作IP
  --输出：
  --out_error_flag              返回结果 0：成功，其他：失败
  --out_error_msg               错误信息
  --out_total_count             导入的数据总量
  --out_exist_count             导入数据中已存在的数据数量
  --out_ok_count                导入数据中检查通过的数量
  --创建人员: zmj
  --创建时间: 2018-09-17
  --****************************************************************************
  PROCEDURE PUP_PRO_PLAN_CHECK(IN_VAR_UUID       IN VARCHAR2,
                               IN_VAR_USERNAME   IN VARCHAR2,
                               IN_VAR_OPEIP      IN VARCHAR2,
                               OUT_ERROR_FLAG    OUT VARCHAR2,
                               OUT_OUT_ERROR_MSG OUT VARCHAR2);

  --****************************************************************************
  --过程名  : PUP_FIX_TIME_CHECK
  --功能描述: 取货计划固定取货时间数据导入检查校验
  --参数说明:
  --输入：
  --in_var_uuid                  导入的UUID
  --in_var_username              用户名
  --in_var_opeip                 操作IP
  --输出：
  --out_error_flag              返回结果 0：成功，其他：失败
  --out_error_msg               错误信息
  --创建人员: zmj
  --创建时间: 2018-09-17
  --****************************************************************************
  PROCEDURE PUP_FIX_TIME_CHECK(in_var_uuid       IN VARCHAR2,
                               in_var_username   IN VARCHAR2,
                               in_var_opeip      IN VARCHAR2,
                               out_error_flag    OUT VARCHAR2,
                               out_out_error_msg OUT VARCHAR2);

  --****************************************************************************
  --过程名  : PUP_MANUAL_ORDER_CHECK
  --功能描述: 手工调整订单Excel导入检查校验
  --参数说明:
  --输入：
  --in_var_uuid                  导入的UUID
  --in_var_username              用户名
  --in_var_opeip                 操作IP
  --输出：
  --out_error_flag              返回结果 0：成功，其他：失败
  --out_error_msg               错误信息
  --创建人员: zmj
  --创建时间: 2018-09-20
  --****************************************************************************
  PROCEDURE PUP_MANUAL_ORDER_CHECK(in_var_uuid       IN VARCHAR2,
                                   in_var_username   IN VARCHAR2,
                                   in_var_opeip      IN VARCHAR2,
                                   out_error_flag    OUT VARCHAR2,
                                   out_out_error_msg OUT VARCHAR2);

  --****************************************************************************
  --过程名  : PUP_ROUTE_MESSAGE_CHECK
  --功能描述: 路线信息维护Excel导入检查校验
  --参数说明:
  --输入：
  --in_var_uuid                  导入的UUID
  --in_var_username              用户名
  --in_var_opeip                 操作IP
  --输出：
  --out_error_flag              返回结果 0：成功，其他：失败
  --out_error_msg               错误信息
  --创建人员: zmj
  --创建时间: 2018-09-20
  --****************************************************************************
  PROCEDURE PUP_ROUTE_MESSAGE_CHECK(in_var_uuid       IN VARCHAR2,
                                    in_var_username   IN VARCHAR2,
                                    in_var_opeip      IN VARCHAR2,
                                    out_error_flag    OUT VARCHAR2,
                                    out_out_error_msg OUT VARCHAR2);

  --****************************************************************************
  --过程名  : PUP_PICKUP_PLAN_CHECK
  --功能描述: 取货计划查询Excel导入检查校验
  --参数说明:
  --输入：
  --in_var_uuid                  导入的UUID
  --in_var_username              用户名
  --in_var_opeip                 操作IP
  --输出：
  --out_error_flag              返回结果 0：成功，其他：失败
  --out_error_msg               错误信息
  --创建人员: zmj
  --创建时间: 2018-09-30
  --****************************************************************************
  PROCEDURE PUP_PICKUP_PLAN_CHECK(in_var_uuid       IN VARCHAR2,
                                  in_var_username   IN VARCHAR2,
                                  in_var_opeip      IN VARCHAR2,
                                  out_error_flag    OUT VARCHAR2,
                                  out_out_error_msg OUT VARCHAR2);

  --****************************************************************************
  --过程名  : PUP_PICKUP_PLAN_IMPORT
  --功能描述: 取货计划数据确定导入
  --参数说明:
  --输入：
  --in_var_uuid                  导入的UUID
  --in_var_username              用户名
  --in_var_opeip                 操作IP
  --输出：
  --out_error_flag              返回结果 1：成功，其他：失败
  --out_error_msg               错误信息
  --创建人员: zmj
  --创建时间: 2018-09-30
  --****************************************************************************
  PROCEDURE PUP_PICKUP_PLAN_IMPORT(in_var_uuid     IN VARCHAR2,
                                   in_var_username IN VARCHAR2,
                                   in_var_opeip    IN VARCHAR2,
                                   out_error_flag  OUT VARCHAR2,
                                   out_error_msg   OUT VARCHAR2);

  --****************************************************************************
  --过程名  : INV_DEV_BASE_CEHCK
  --功能描述: 库存推移管理EXCEL数据导入校验
  --参数说明:
  --输入：
  --in_var_uuid                  导入的UUID
  --in_var_username              用户名
  --in_var_opeip                 操作IP
  --输出：
  --out_error_flag              返回结果 0：成功，其他：失败
  --out_error_msg               错误信息
  --创建人员: zmj
  --创建时间: 2018-10-16
  --****************************************************************************
  PROCEDURE INV_DEV_BASE_CEHCK(in_var_uuid       IN VARCHAR2,
                               in_var_username   IN VARCHAR2,
                               in_var_opeip      IN VARCHAR2,
                               out_error_flag    OUT VARCHAR2,
                               out_out_error_msg OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUP_DCS_SEAL_CHECK
  --功能描述：DCS封条号导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: wangyu
  --创建时间： 2019/01/07
  PROCEDURE USP_PUP_DCS_SEAL_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                   IN_VAR_USERNAME   IN VARCHAR2,
                                   IN_VAR_OPEIP      IN VARCHAR2,
                                   OUT_ERROR_FLAG    OUT VARCHAR2,
                                   OUT_OUT_ERROR_MSG OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUP_DCS_CHECK
  --功能描述：DCS导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_FACTORY_CODE工厂
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: wangyu
  --创建时间： 2019/01/08
  PROCEDURE USP_PUP_DCS_CHECK(IN_VAR_UUID       IN VARCHAR2,
                              IN_FACTORY_CODE   IN VARCHAR2,
                              IN_VAR_USERNAME   IN VARCHAR2,
                              IN_VAR_OPEIP      IN VARCHAR2,
                              OUT_ERROR_FLAG    OUT VARCHAR2,
                              OUT_OUT_ERROR_MSG OUT VARCHAR2);

end PKG_PUP_CHECK;
/

prompt
prompt Creating package PKG_PUP_MAIN
prompt =============================
prompt
create or replace package PKG_PUP_MAIN is

  --****************************************************************************
  --过程名  : USP_CHECK_WORKDAY
  --功能描述: 判断两个时间排除非工作日后相差天数
  --参数说明：
  --创建人员: wangyu
  --创建时间: 2018/10/10
  FUNCTION USP_PUP_CHECK_WORKDAY(date1 IN DATE, date2 IN DATE) RETURN NUMBER;

  --***************************************************************************
  --存储过程名：USP_PUP_GET_PLAN
  --功能描述：获取生产计划
  --参数说明：
  --in_afoff_time_start 开始时间
  --in_afoff_time_end 结束时间
  --in_week 周次
  --in_arr_factory 工厂代码
  --in_opeid 操作人
  --创建人员: wangyu
  --创建时间： 2018/10/09
  PROCEDURE USP_PUP_GET_PLAN(in_afoff_time_start IN VARCHAR2,
                             in_afoff_time_end   IN VARCHAR2,
                             in_week             IN VARCHAR2,
                             in_arr_factory      IN VARCHAR2,
                             in_opeid            IN VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUP_GEN
  --功能描述：物流计划生成
  --参数说明：
  --in_arr_factory 工厂代码
  --out_code 返回值
  --创建人员: wangyu
  --创建时间： 2018/09/29
  PROCEDURE USP_PUP_GEN(in_arr_factory IN VARCHAR2, out_code OUT INT);

  --***************************************************************************
  --存储过程名：USP_PUP_MOD
  --功能描述：调整计划
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/10/09
  PROCEDURE USP_PUP_MOD(in_arr_factory IN VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_DCS_PLAN_TO_TEMP
  --功能描述：获取DCS任务
  --参数说明：
  --in_arr_factory 工厂代码
  --in_opeId 操作人员
  --out_code 返回代码 0 标识成功， 1 表示失败
  --创建人员: wangyu
  --创建时间： 2018/12/29
  PROCEDURE USP_DCS_PLAN_TO_TEMP(in_opeId         IN VARCHAR2,
                                 in_arr_factory   in VARCHAR2,
                                 in_workday_start in VARCHAR2,
                                 in_workday_end   in VARCHAR2,
                                 out_code         out number);

  --***************************************************************************
  --存储过程名：USP_DCS_IMPORT_PLAN_TO_TEMP
  --功能描述：DCS调整
  --参数说明：
  --in_uuid uuid
  --in_arr_factory 工厂代码
  --in_opeId 操作人员
  --out_code 返回代码 0 标识成功， 1 表示失败
  --创建人员: wangyu
  --创建时间： 2018/12/29
  PROCEDURE USP_DCS_IMPORT_PLAN_TO_TEMP(in_uuid        VARCHAR2,
                                        in_opeId       in VARCHAR2,
                                        in_arr_factory IN VARCHAR2,
                                        out_code       out number);

  --***************************************************************************
  --存储过程名：USP_GEN_DCS
  --功能描述：生成DCS单
  --参数说明：
  --in_arr_factory 工厂代码
  --in_opeId 操作人员
  --创建人员: wangyu
  --创建时间： 2018/12/29
  PROCEDURE USP_GEN_DCS(in_arr_factory IN VARCHAR2, in_opeId in VARCHAR2);

  /*--***************************************************************************
  --存储过程名：USP_PUP_EMPTY_OUT_DIR
  --功能描述：空容器备件出库指示处理
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE USP_PUP_EMPTY_OUT_DIR(in_arr_factory IN VARCHAR2);*/

  --***************************************************************************
  --存储过程名：USP_PUP_VERSION_CLEAR
  --功能描述：每周定时删除上一周之前的物流计划版本数据
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2019/02/19
  PROCEDURE USP_PUP_VERSION_CLEAR;

end PKG_PUP_MAIN;
/

prompt
prompt Creating package PKG_REC_MAIN
prompt =============================
prompt
create or replace package PKG_REC_MAIN is

  --***************************************************************************
  --存储过程名：USP_DEAL_PARTLABEL_SH
  --功能描述：标签扫描收货处理
  --参数说明：
  --in_uuid uuid
  --out_code
  --out_type
  --创建人员: wangyu
  --创建时间： 2018/09/19
  PROCEDURE USP_DEAL_PARTLABEL_SH(in_uuid  IN VARCHAR2,
                                  out_code OUT INT,
                                  out_type OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_DEAL_JISOLABEL_SH
  --功能描述：同步指示票扫描收货
  --参数说明：
  --in_uuid uuid
  --out_code
  --out_type
  --创建人员: wangyu
  --创建时间： 2018/09/21
  PROCEDURE USP_DEAL_JISOLABEL_SH(in_uuid IN VARCHAR2, out_code OUT INT);

end PKG_REC_MAIN;
/

prompt
prompt Creating package PKG_SPS
prompt ========================
prompt
create or replace package PKG_SPS is

  -- Author  : wxl
  -- Created : 2018/9/28 星期五 下午 4:14:43
  -- Purpose : Definition of sps function or procedure

  --****************************************************************************
  --过程名  : USP_SPS_GET_PASS_QUEUE
  --功能描述: SPS获取车序队列
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-28
  --****************************************************************************
  PROCEDURE USP_SPS_GET_PASS_QUEUE(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_SPS_CREATE_INS
  --功能描述: 计算生成分拣单
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-28
  --****************************************************************************
  PROCEDURE USP_SPS_CREATE_INS(in_plan_code in varchar2);

  --****************************************************************************
  --过程名  : USP_SPS_CREATE_TEST_INS
  --功能描述: 计算生成分拣单(试打印)
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: dtp
  --创建时间: 2019-02-22
  --****************************************************************************
  PROCEDURE USP_SPS_CREATE_TEST_INS(in_var_uuid in varchar2);

  --****************************************************************************
  --过程名  : USP_SPS_CAL_EXEC
  --功能描述: 执行SPS推算
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --****************************************************************************
  PROCEDURE USP_SPS_CAL_EXEC(in_plan_code in varchar2);

end PKG_SPS;
/

prompt
prompt Creating package PKG_TEST
prompt =========================
prompt
create or replace package PKG_TEST is

  --***************************************************************************
  --存储过程名：TEST
  --功能描述: 收货数据处理
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：TEST
  --功能描述: 收货数据处理
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST_WE(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：TEST
  --功能描述: 收货数据处理
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST_EXC(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：TEST
  --功能描述: 收货数据处理
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST_EXC_WE(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：TEST
  --功能描述: 收货数据处理
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST_DEAL_RECEIVE_LOG(ERROR_TAG     OUT NUMBER,
                                  ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_PUB_WAREHOUSE
  --功能描述: 仓库主数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST_JISO(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：TEST_AF_JISO
  --功能描述: 收货数据处理
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST_AF_JISO(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2);

  --***************************************************************************
  --存储过程名：USP_MP_DEMAND_PARTIF_GEN
  --功能描述：一级件零件需求预测计算
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --foreType 预测类型
  --out_code 返回代码
  --创建人员: luoxianqin
  --创建时间： 2019/04/28
  PROCEDURE USP_MP_DEMAND_PARTIF_GEN(in_arr_factory in VARCHAR2,
                                     in_account     in VARCHAR2,
                                     in_foreType    in VARCHAR2,
                                     in_startDate   in VARCHAR2,
                                     in_endDate     in VARCHAR2,
                                     out_code       out VARCHAR2);

  --****************************************************************************
  --过程名  : USP_SW_PICK_PLAN
  --功能描述: 将预测数据信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  PROCEDURE USP_SW_DEMAND_FORECAST;

  --***************************************************************************
  --存储过程名：USP_INV_GET_DIFFERENCE
  --功能描述：支给获取库存差异
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: luoxq
  --创建时间： 2019/05/30
  PROCEDURE USP_INV_GET_DIFFERENCE(in_arr_factory in VARCHAR2,
                                   in_account     in VARCHAR2,
                                   out_code       out VARCHAR2);

end PKG_TEST;
/

prompt
prompt Creating type MYARRAY
prompt =====================
prompt
create or replace type MYARRAY as table of VARCHAR(32767)
/

prompt
prompt Creating type MY_WM_CONCAT
prompt ==========================
prompt
CREATE OR REPLACE TYPE "MY_WM_CONCAT"                                                                                                                             authid current_user as object (
    CURRSTR VARCHAR2(32767),
    DELIMITER VARCHAR2(64),
    ORDERBY VARCHAR2(64),
    STRARRAY MYARRAY,
    static Function ODCIAGGREGATEINITIALIZE (INIT IN OUT MY_wm_concat)
       return NUMBER,
    member Function ODCIAGGREGATEITERATE (SELF IN OUT MY_wm_concat,COLVALUE IN VARCHAR2)
       return NUMBER,
    member Function ODCIAGGREGATEMERGE (SELF IN OUT MY_wm_concat,NEXT MY_wm_concat)
       return NUMBER,
    member Function ODCIAGGREGATETERMINATE (SELF IN MY_wm_concat,RETURNVALUE OUT VARCHAR2,FLAGS IN NUMBER)
       return NUMBER
)
/

prompt
prompt Creating type PRO_PLAN_TYPE
prompt ===========================
prompt
create or replace type PRO_PLAN_TYPE as object (
    CAR_TYPE VARCHAR2(255),
    MIX_SORT_ID NUMBER(15),
    AF_OFF_TIME DATE
)
/

prompt
prompt Creating type PRO_PLAN_TAB_TYPE
prompt ===============================
prompt
CREATE OR REPLACE TYPE "PRO_PLAN_TAB_TYPE"                                                                                                                             as table of pro_plan_type
/

prompt
prompt Creating type STRSPLIT_TYPE
prompt ===========================
prompt
CREATE OR REPLACE TYPE "STRSPLIT_TYPE"                                                                                                                             as table of VARCHAR2 (4000)
/

prompt
prompt Creating function MY_CONCAT
prompt ===========================
prompt
create or replace function MY_CONCAT(colValue  VARCHAR2)
RETURN VARCHAR2
  AGGREGATE USING MY_wm_concat;
/

prompt
prompt Creating function MY_EVAL_NUMBER
prompt ================================
prompt
CREATE OR REPLACE FUNCTION MY_EVAL_NUMBER(EXPRESSION IN VARCHAR2)
  RETURN NUMBER AS
  TYPE ARRAYLIST_TYPE IS TABLE OF VARCHAR2(100) INDEX BY BINARY_INTEGER;

  TYPE VARLIST IS VARRAY(100) OF VARCHAR2(100);

  TEMP ARRAYLIST_TYPE;

  ST VARLIST := VARLIST('');

  VALUE VARLIST := VARLIST('');

  N NUMBER;

  CNT NUMBER;

  RESULT NUMBER;

  TEMPRESULT NUMBER;

  INPUTSTR VARCHAR2(100);

  TEMPSTR VARCHAR2(10);

  OPERATORSTR VARCHAR2(10);

  TS VARCHAR2(40);
BEGIN
  INPUTSTR := EXPRESSION;

  TEMPSTR := SUBSTR(INPUTSTR, 1, 1);

  N := 1;

  CNT := 1;

  --??

  LOOP

    <<CONTINUE_LOOP_1>>

    N := N + 1;

    TEMPSTR := TEMPSTR || SUBSTR(INPUTSTR, N, 1);

    IF N > LENGTH(INPUTSTR) THEN

      GOTO EXIT_LOOP_1;

    END IF;

    IF NVL(LENGTH(REPLACE(TRANSLATE(TEMPSTR, '0123456789', '.'), '.')), 0) = 0 THEN

      TEMP(CNT) := TEMPSTR;

      GOTO CONTINUE_LOOP_1;

    ELSE

      IF LENGTH(TEMPSTR) > 1 THEN

        N := N - 1;

        TEMP(CNT) := SUBSTR(TEMPSTR, 1, LENGTH(TEMPSTR) - 1);

      ELSE

        TEMP(CNT) := TEMPSTR;

      END IF;

      CNT := CNT + 1;

      TEMPSTR := '';

    END IF;

  END LOOP;

  <<EXIT_LOOP_1>>

  --????

  N := 0;

  LOOP

    ST.TRIM(1);

    VALUE.TRIM(1);

    <<CONTINUE_LOOP_2>>

    N := N + 1;

    IF N > TEMP.COUNT THEN

      GOTO EXIT_LOOP_2;

    END IF;

    IF TEMP(N) IN ('+', '-', '*', '/', '(', ')') THEN

      --5

      IF ST.COUNT > 0 THEN

        OPERATORSTR := ST(ST.COUNT);

        --4

        IF TEMP(N) IN ('*', '/') THEN

          --3

          IF OPERATORSTR = '(' THEN

            ST.EXTEND(1);

            ST(ST.COUNT) := TEMP(N);

            GOTO CONTINUE_LOOP_2;

          ELSE

            --2

            IF OPERATORSTR IN ('*', '/') THEN

              VALUE.EXTEND(1);

              VALUE(VALUE.COUNT) := ST(ST.COUNT);

              ST(ST.COUNT) := TEMP(N); --??

              GOTO CONTINUE_LOOP_2;

            ELSE

              ST.EXTEND(1);

              ST(ST.COUNT) := TEMP(N);

              GOTO CONTINUE_LOOP_2;

            END IF;

            --2

          END IF;

          --3

        ELSE

          --3

          IF TEMP(N) IN ('+', '-') THEN

            --2

            IF OPERATORSTR = '(' THEN

              ST.EXTEND(1);

              ST(ST.COUNT) := TEMP(N);

              GOTO CONTINUE_LOOP_2;

            ELSE

              VALUE.EXTEND(1);

              VALUE(VALUE.COUNT) := ST(ST.COUNT);

              ST.TRIM(1);

              --1

              IF ST.COUNT > 0 THEN

                IF ST(ST.COUNT) != '(' THEN

                  VALUE.EXTEND(1);

                  VALUE(VALUE.COUNT) := ST(ST.COUNT);

                  ST.TRIM(1);

                END IF;

              END IF;

              --1

              ST.EXTEND(1);

              ST(ST.COUNT) := TEMP(N);

              GOTO CONTINUE_LOOP_2;

            END IF;

            --2

          ELSE

            --2

            IF TEMP(N) = '(' THEN

              ST.EXTEND(1);

              ST(ST.COUNT) := TEMP(N);

              GOTO CONTINUE_LOOP_2;

            ELSE

              --1

              IF N = TEMP.COUNT THEN

                VALUE.EXTEND(1);

                VALUE(VALUE.COUNT) := ST(ST.COUNT);

                ST.TRIM(2);

                WHILE ST.COUNT > 0 LOOP

                  IF ST(ST.COUNT) NOT IN ('(', ')') THEN

                    VALUE.EXTEND(1);

                    VALUE(VALUE.COUNT) := ST(ST.COUNT);

                  END IF;

                  ST.TRIM(1);

                END LOOP;

                GOTO EXIT_LOOP_2;

              ELSE

                VALUE.EXTEND(1);

                VALUE(VALUE.COUNT) := ST(ST.COUNT);

                ST.TRIM(2);

                GOTO CONTINUE_LOOP_2;

              END IF;

              --1

            END IF;

            --2

          END IF;

          --3

        END IF;

        --4

      ELSE

        ST.EXTEND(1);

        ST(ST.COUNT) := TEMP(N);

        GOTO CONTINUE_LOOP_2;

      END IF;

      --5

    ELSE

      --5

      IF N = TEMP.COUNT THEN

        VALUE.EXTEND(1);

        VALUE(VALUE.COUNT) := TEMP(N);

        VALUE.EXTEND(1);

        VALUE(VALUE.COUNT) := ST(ST.COUNT);

        ST.TRIM(1);

        WHILE ST.COUNT > 0 LOOP

          IF ST(ST.COUNT) NOT IN ('(', ')') THEN

            VALUE.EXTEND(1);

            VALUE(VALUE.COUNT) := ST(ST.COUNT);

          END IF;

          ST.TRIM(1);

        END LOOP;

        GOTO EXIT_LOOP_2;

      ELSE

        VALUE.EXTEND(1);

        VALUE(VALUE.COUNT) := TEMP(N);

        GOTO CONTINUE_LOOP_2;

      END IF;

      --5

    END IF;

  END LOOP;

  <<EXIT_LOOP_2>>

  --??

  RESULT := 0;

  TEMPRESULT := 0;

  LOOP

    <<CONTINUE_LOOP_3>>

    IF VALUE.COUNT < 2 THEN

      GOTO EXIT_LOOP_3;

    END IF;

    N := 0;

    LOOP

      <<CONTINUE_LOOP_4>>

      N := N + 1;

      IF N > VALUE.COUNT THEN

        GOTO CONTINUE_LOOP_3;

      END IF;

      IF VALUE(N) = '+' THEN

        TEMPRESULT := TO_NUMBER(VALUE(N - 2)) + TO_NUMBER(VALUE(N - 1));

      ELSE

        IF VALUE(N) = '-' THEN

          TEMPRESULT := TO_NUMBER(VALUE(N - 2)) - TO_NUMBER(VALUE(N - 1));

        ELSE

          IF VALUE(N) = '*' THEN

            TEMPRESULT := TO_NUMBER(VALUE(N - 2)) * TO_NUMBER(VALUE(N - 1));

          ELSE

            IF VALUE(N) = '/' THEN

              TEMPRESULT := TO_NUMBER(VALUE(N - 2)) /
                            TO_NUMBER(VALUE(N - 1));

            ELSE

              GOTO CONTINUE_LOOP_4;

            END IF;

          END IF;

        END IF;

      END IF;

      SELECT CAST(TEMPRESULT AS VARCHAR2(40)) INTO TS FROM DUAL;

      VALUE(N - 2) := TS;

      FOR I IN N - 1 .. VALUE.COUNT - 2 LOOP

        VALUE(I) := VALUE(I + 2);

      END LOOP;

      VALUE.TRIM(2);

      GOTO CONTINUE_LOOP_3;

    END LOOP;

  END LOOP;

  <<EXIT_LOOP_3>>
  RETURN VALUE(1);
END MY_EVAL_NUMBER;
/

prompt
prompt Creating function USF_DELIMITER
prompt ===============================
prompt
create or replace function USF_DELIMITER(colValue  in varchar2,
                                     delimiter in varchar2)
return varchar2 is
  rtnValue varchar2(32767);

begin

  rtnValue := colValue || ' delimiter=>' || delimiter || '; ';

  return rtnValue;

end USF_delimiter;
/

prompt
prompt Creating function USF_MM_MP_FORBAKWORKDATE
prompt ==========================================
prompt
CREATE OR REPLACE FUNCTION USF_MM_MP_FORBAKWORKDATE(in_querydate   IN VARCHAR2, --?????????
                                                    in_infertime   IN NUMBER, --??????[??]
                                                    in_centerid    IN VARCHAR2, --????ID
                                                    in_arr_factory IN VARCHAR2,
                                                    in_inferflg    IN VARCHAR2 --????????:0,????1,???
                                                    ) RETURN varchar2 -- ????????
 AS
  --??[????]
  tymd VARCHAR2(8) := '00000000';
  --????
  relaxdate DATE;
  --?????????????0,?????????
  isworkdate NUMBER := 0;
  --??????????[??]
  inferday NUMBER(8, 0) := 0;
  --????ID
  operatorcenterid VARCHAR2(6);
  --????
  aogFactory VARCHAR(10);

BEGIN
  --?????????
  relaxdate        := to_date(in_querydate, 'YYYY-MM-DD');
  inferday         := in_infertime;

  loop
    IF in_inferflg = 0 THEN
      --??????
      RELAXDATE := RELAXDATE - (INTERVAL '1' DAY);
    ELSE
      --??????
      RELAXDATE := RELAXDATE + (INTERVAL '1' DAY);
    END IF;
    --TYMD??
    tymd := to_char(relaxdate, 'yyyymmdd');
    --???????????????????????????
      SELECT COUNT(C.WORKCENTER)
        INTO isworkdate
        FROM MM_PUB_WORK_CALENDAR C
       WHERE C.WORKCENTER = in_centerid
         AND C.FACTORY_CODE = in_arr_factory
         AND TRUNC(C.WORK_DATE) = TRUNC(relaxdate);

    IF (isworkdate > 0) THEN
      inferday := inferday - 1;
    END IF;
    --????
    EXIT WHEN inferday = 0;
  END LOOP;
  --???
  RETURN to_char(RELAXDATE, 'YYYY-MM-DD');

END;
/

prompt
prompt Creating function USF_ORDERBY
prompt =============================
prompt
create or replace function USF_ORDERBY(colValue in varchar2,
                                   orderby  in varchar2)
return varchar2 is
  rtnValue varchar2(32767);

begin

  rtnValue := colValue || ' orderby=>' || LOWER(orderby) || '; ';

  return rtnValue;

end USF_orderby;
/

prompt
prompt Creating function USF_PROPLAN_SPLIT
prompt ===================================
prompt
create or replace function USF_PROPLAN_SPLIT(p_value       varchar2,
                                    p_af_off_time date,
                                    p_split       varchar2 := ',')
--usage: select * from table(strsplit('1,2,3,4,5'))

 RETURN pro_plan_tab_type IS
  pro_plan_obj  pro_plan_type;
  pro_plans     pro_plan_tab_type := pro_plan_tab_type();
  v_idx         integer;
  v_str         varchar2(500);
  v_car_type    varchar2(20);
  v_strs_last   varchar2(4000) := p_value;
  v_mix_sort_id number(15);

begin
  loop
    v_idx := instr(v_strs_last, p_split);
    exit when v_idx = 0;
    v_str := substr(v_strs_last, 1, v_idx - 1);
    v_strs_last := substr(v_strs_last, v_idx + 1);
    v_car_type := substr(v_str, 0, instr(v_str, ':') - 1);
    v_mix_sort_id := substr(v_str, instr(v_str, ':') + 1);
    pro_plan_obj := pro_plan_type(v_car_type, v_mix_sort_id, p_af_off_time);
    pro_plans.extend;
    pro_plans(pro_plans.count) := pro_plan_obj;
  end loop;
  v_car_type := substr(v_strs_last, 0, instr(v_strs_last, ':') - 1);
  v_mix_sort_id := substr(v_strs_last, instr(v_strs_last, ':') + 1);
  pro_plan_obj := pro_plan_type(v_car_type, v_mix_sort_id, p_af_off_time);
  pro_plans.extend;
  pro_plans(pro_plans.count) := pro_plan_obj;
  RETURN pro_plans;
end USF_ProPlan_Split;
/

prompt
prompt Creating function USF_SPLIT
prompt ===========================
prompt
CREATE OR REPLACE FUNCTION USF_SPLIT(p_list varchar2, p_seperator varchar2) return STRSPLIT_TYPE
PIPELINED IS
l_idx PLS_INTEGER;
v_list varchar2(32767):=p_list;
BEGIN
  LOOP
    l_idx:=instr(v_list,p_seperator);
    IF l_idx>0 THEN
      PIPE ROW(substr(v_list,1,l_idx-1));
      v_list:=substr(v_list,l_idx+length(p_seperator));
      ELSE
        PIPE ROW(v_list);
        EXIT;
    END IF;
  END LOOP;
END;
/

prompt
prompt Creating function USP_MM_MP_CUX_GET_LOG_ORDER
prompt =============================================
prompt
CREATE OR REPLACE FUNCTION USP_MM_MP_CUX_GET_LOG_ORDER(V_SUPPLIER_ID      VARCHAR2,
                                                         V_FACTORY_ID       VARCHAR2,
                                                         V_AOG_FACTORY      VARCHAR2,
                                                         V_UNLOAD_PORT      VARCHAR2,
                                                         V_PLAN_ARRIVE_TIME VARCHAR2 ---- ??? YYYYMMDD
                                                         ) RETURN VARCHAR2 AS
  V_LOGISTICS_ORDER VARCHAR2(12); -- ????????

  NUMBER_COUNT NUMBER(12, 0);
BEGIN

  SELECT COUNT(1)
    INTO NUMBER_COUNT
    FROM (SELECT A.SUPPLIER_NO,
                 A.SUP_FACTORY,
                 A.FACTORY_CODE,
                 A.UNLOAD_PORT,
                 A.LOGISTICS_ORDER
            FROM MM_MP_ORDER_RECORD_HIS A
          UNION
          SELECT B.SUPPLIER_NO,
                 B.SUP_FACTORY,
                 B.FACTORY_CODE,
                 B.UNLOAD_PORT,
                 B.LOGISTICS_ORDER
            FROM MM_MP_ORDER_RECORD_HIS B) C
   WHERE C.SUPPLIER_NO = V_SUPPLIER_ID
     AND C.SUP_FACTORY = V_FACTORY_ID
     AND C.FACTORY_CODE = V_AOG_FACTORY
     AND C.UNLOAD_PORT = V_UNLOAD_PORT
     AND SUBSTR(C.LOGISTICS_ORDER, 0, 8) = V_PLAN_ARRIVE_TIME
     AND LENGTH(C.LOGISTICS_ORDER) = 12;
  IF (NUMBER_COUNT = 0) THEN
    V_LOGISTICS_ORDER := V_PLAN_ARRIVE_TIME || '001';
  ELSE
    SELECT MAX(F.LOGISTICS_ORDER)
      INTO V_LOGISTICS_ORDER
      FROM (SELECT D.SUPPLIER_NO,
                   D.SUP_FACTORY,
                   D.FACTORY_CODE,
                   D.UNLOAD_PORT,
                   D.LOGISTICS_ORDER
              FROM MM_MP_ORDER_RECORD D
            UNION
            SELECT E.SUPPLIER_NO,
                   E.SUP_FACTORY,
                   E.FACTORY_CODE,
                   E.UNLOAD_PORT,
                   E.LOGISTICS_ORDER
              FROM MM_MP_ORDER_RECORD_HIS E) F
     WHERE F.SUPPLIER_NO = V_SUPPLIER_ID
       AND F.SUP_FACTORY = V_FACTORY_ID
       AND F.FACTORY_CODE = V_AOG_FACTORY
       AND F.UNLOAD_PORT = V_UNLOAD_PORT
       AND SUBSTR(F.LOGISTICS_ORDER, 0, 8) = V_PLAN_ARRIVE_TIME
       AND LENGTH(F.LOGISTICS_ORDER) = 12;

    V_LOGISTICS_ORDER := (TO_NUMBER(SUBSTR(V_LOGISTICS_ORDER, 0, 11)) + 1);
  END IF;

  RETURN V_LOGISTICS_ORDER;
END USP_MM_MP_CUX_GET_LOG_ORDER;
/

prompt
prompt Creating procedure PRO_JOB_QUEUE_BAK
prompt ====================================
prompt
create or replace procedure pro_job_queue_bak
as
  cursor cur is
  select job_no, business, job_name, print_type, job_type, classes, status, serial_number, atrow_key,
  parameters, creation_time, last_modified_time, last_modified_user, last_modified_ip
  from mm_pr_job_queue where status='PRINTED' and creation_time <sysdate-7 order by job_no; --????7???
begin
  for raw_row in cur
    loop
    insert into mm_pr_job_queue_bak(job_no, business, job_name, print_type, job_type, classes, status, serial_number, atrow_key,
    parameters, creation_time, last_modified_time, last_modified_user, last_modified_ip)
    values(raw_row.job_no, raw_row.business, raw_row.job_name, raw_row.print_type, raw_row.job_type, raw_row.classes,
    raw_row.status, raw_row.serial_number, raw_row.atrow_key,
    raw_row.parameters, raw_row.creation_time, raw_row.last_modified_time, raw_row.last_modified_user, raw_row.last_modified_ip);
    delete from mm_pr_job_queue where job_no=raw_row.job_no;
    end loop;
commit;
end pro_job_queue_bak;
/

prompt
prompt Creating package body PKG_ARCHIVE
prompt =================================
prompt
create or replace package body PKG_ARCHIVE is

  --消息的最大长度
  C_MESSAGE_MAX_LENGTH       NUMBER := 1000;

  --一次归档的数据量
  C_ARCHIVE_MAX_COUNT        NUMBER := 2000000;

--函数名  : USP_ARCHIVE_QUERY
--功能描述: 接收查询/发送日志归档
--输入参数说明
--       AC_MAX_TIME 保留最大时间（不包括）
--输出参数说明：
--       ERROR_TAG：返回代码 0：成功，其他：失败
--       ERROR_MESSAGE:返回信息,
--创建人员: lym
--创建时间: 2018-03-14
--****************************************************************************
PROCEDURE USP_ARCHIVE_QUERY(AC_MAX_TIME        IN  DATE,
                            ERROR_TAG          OUT NUMBER,
                            ERROR_MESSAGE      OUT VARCHAR2)
AS
  VAR_MIN_DATE      DATE; --归档最小日期
  VAR_AR_DIFFDAY    NUMBER; --归档相差天数
  VAR_AR_START_STP  DATE; --归档当天开始时间戳
  VAR_AR_END_STP    DATE; --归档当天结束时间戳
  VAR_COUNT         NUMBER; --数据量
  VAR_AR_DAYCNT     NUMBER; --当天遍历数
  VAR_AR_DAYINC     NUMBER; --当天的时间递增量
  VAR_AR_STP        DATE; --归档时间戳
BEGIN
  ERROR_TAG := 0;
  ERROR_MESSAGE := '';

  --获取未归档的最小日期、相差天数
  SELECT trunc(MIN(T.CREATE_TIME)) INTO VAR_MIN_DATE
    FROM T_IF_QUERY_LOG T
    WHERE T.CREATE_TIME < AC_MAX_TIME;
  VAR_AR_DIFFDAY := AC_MAX_TIME - VAR_MIN_DATE;

  --遍历每一天
  IF VAR_AR_DIFFDAY IS NOT NULL AND VAR_AR_DIFFDAY > 0 THEN

    --迁移数据每一天的处理
    FOR I IN 1..VAR_AR_DIFFDAY LOOP

      --获取归档当天开始日期和结束日期
      VAR_AR_START_STP := VAR_MIN_DATE + (I - 1);
      VAR_AR_END_STP := VAR_AR_START_STP + 1;

      --获取当天数据量、当天最小时间戳、当天最大时间戳
      SELECT COUNT(1),
             MIN(T.CREATE_TIME),
             MAX(T.CREATE_TIME)
        INTO VAR_COUNT,
             VAR_AR_START_STP,
             VAR_AR_END_STP
        FROM T_IF_QUERY_LOG T
        WHERE T.CREATE_TIME >= VAR_AR_START_STP
          AND T.CREATE_TIME <  VAR_AR_END_STP;
      IF VAR_COUNT > 0 THEN

        --获取当天轮询次数和递增时间量
        VAR_AR_DAYCNT := CEIL(VAR_COUNT * 1.0 / C_ARCHIVE_MAX_COUNT);
        VAR_AR_DAYINC := (VAR_AR_END_STP - VAR_AR_START_STP) / VAR_AR_DAYCNT;

        --轮询当天次数，次数加1是防止递增运算结果小于当天最大时间戳
        FOR K IN 1..(VAR_AR_DAYCNT + 1) LOOP

          --获取归档时间戳（不能超过当天结束日期）
          VAR_AR_STP := LEAST(VAR_AR_END_STP, VAR_AR_START_STP + VAR_AR_DAYINC * K);

          --将数据迁移到历史表
          INSERT INTO T_IF_QUERY_LOG_HIS
            SELECT * FROM T_IF_QUERY_LOG T
              WHERE T.CREATE_TIME <= VAR_AR_STP;

          IF SQL%ROWCOUNT > 0 THEN --有数据插入历史表

            --删除已迁移数据
            DELETE FROM T_IF_QUERY_LOG T
              WHERE T.CREATE_TIME <= VAR_AR_STP;

            COMMIT;
          ELSE --没有数据插入历史表
            ROLLBACK;
          END IF;
        END LOOP; --轮询当天次数
      END IF;--判断当前数据量
    END LOOP; --轮询相差天数
  END IF; --遍历每一天
EXCEPTION
WHEN OTHERS THEN
  ERROR_TAG := 1;
  ERROR_MESSAGE  := SUBSTRB (SQLERRM||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(), 1, C_MESSAGE_MAX_LENGTH);
  ROLLBACK;

END USP_ARCHIVE_QUERY;

--函数名  : USP_ARCHIVE_RECEIVE
--功能描述: 接收日志归档
--输入参数说明
--       AC_MAX_TIME 保留最大时间（不包括）
--输出参数说明：
--       ERROR_TAG：返回代码 0：成功，其他：失败
--       ERROR_MESSAGE:返回信息,
--创建人员: lym
--创建时间: 2018-03-14
--****************************************************************************
PROCEDURE USP_ARCHIVE_RECEIVE(AC_MAX_TIME        IN  DATE,
                              ERROR_TAG          OUT NUMBER,
                              ERROR_MESSAGE      OUT VARCHAR2)
AS
  VAR_MIN_DATE      DATE; --归档最小日期
  VAR_AR_DIFFDAY    NUMBER; --归档相差天数
  VAR_AR_START_STP  DATE; --归档当天开始时间戳
  VAR_AR_END_STP    DATE; --归档当天结束时间戳
  VAR_COUNT         NUMBER; --数据量
  VAR_AR_DAYCNT     NUMBER; --当天遍历数
  VAR_AR_DAYINC     NUMBER; --当天的时间递增量
  VAR_AR_STP        DATE; --归档时间戳
BEGIN
  ERROR_TAG := 0;
  ERROR_MESSAGE := '';

  --获取未归档的最小日期、相差天数
  SELECT trunc(MIN(T.CREATE_TIME)) INTO VAR_MIN_DATE
    FROM T_IF_RECEIVE_LOG T
    WHERE T.CREATE_TIME < AC_MAX_TIME;
  VAR_AR_DIFFDAY := AC_MAX_TIME - VAR_MIN_DATE;

  --遍历每一天
  IF VAR_AR_DIFFDAY IS NOT NULL AND VAR_AR_DIFFDAY > 0 THEN

    --迁移数据每一天的处理
    FOR I IN 1..VAR_AR_DIFFDAY LOOP

      --获取归档当天开始日期和结束日期
      VAR_AR_START_STP := VAR_MIN_DATE + (I - 1);
      VAR_AR_END_STP := VAR_AR_START_STP + 1;

      --获取当天数据量、当天最小时间戳、当天最大时间戳
      SELECT COUNT(1),
             MIN(T.CREATE_TIME),
             MAX(T.CREATE_TIME)
        INTO VAR_COUNT,
             VAR_AR_START_STP,
             VAR_AR_END_STP
        FROM T_IF_RECEIVE_LOG T
        WHERE T.CREATE_TIME >= VAR_AR_START_STP
          AND T.CREATE_TIME <  VAR_AR_END_STP;
      IF VAR_COUNT > 0 THEN

        --获取当天轮询次数和递增时间量
        VAR_AR_DAYCNT := CEIL(VAR_COUNT * 1.0 / C_ARCHIVE_MAX_COUNT);
        VAR_AR_DAYINC := (VAR_AR_END_STP - VAR_AR_START_STP) / VAR_AR_DAYCNT;

        --轮询当天次数，次数加1是防止递增运算结果小于当天最大时间戳
        FOR K IN 1..(VAR_AR_DAYCNT + 1) LOOP

          --获取归档时间戳（不能超过当天结束日期）
          VAR_AR_STP := LEAST(VAR_AR_END_STP, VAR_AR_START_STP + VAR_AR_DAYINC * K);

          --将数据迁移到历史表
          INSERT INTO T_IF_RECEIVE_LOG_HIS
            SELECT * FROM T_IF_RECEIVE_LOG T
              WHERE T.CREATE_TIME <= VAR_AR_STP;

          IF SQL%ROWCOUNT > 0 THEN --有数据插入历史表

            --删除已迁移数据
            DELETE FROM T_IF_RECEIVE_LOG T
              WHERE T.CREATE_TIME <= VAR_AR_STP;

            COMMIT;
          ELSE --没有数据插入历史表
            ROLLBACK;
          END IF;
        END LOOP; --轮询当天次数
      END IF;--判断当前数据量
    END LOOP; --轮询相差天数
  END IF; --遍历每一天
EXCEPTION
WHEN OTHERS THEN
  ERROR_TAG := 1;
  ERROR_MESSAGE  := SUBSTRB (SQLERRM||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(), 1, C_MESSAGE_MAX_LENGTH);
  ROLLBACK;
END USP_ARCHIVE_RECEIVE;

--函数名  : USP_ARCHIVE_ASYNFILE
--功能描述: 异步接收文件归档
--输入参数说明
--       AC_MAX_TIME 保留最大时间（不包括）
--输出参数说明：
--       ERROR_TAG：返回代码 0：成功，其他：失败
--       ERROR_MESSAGE:返回信息,
--创建人员: lym
--创建时间: 2018-12-03
--****************************************************************************
PROCEDURE USP_ARCHIVE_ASYNFILE(AC_MAX_TIME        IN  DATE,
                               ERROR_TAG          OUT NUMBER,
                               ERROR_MESSAGE      OUT VARCHAR2)
AS
  VAR_MIN_DATE      DATE; --归档最小日期
  VAR_AR_DIFFDAY    NUMBER; --归档相差天数
  VAR_AR_START_STP  DATE; --归档当天开始时间戳
  VAR_AR_END_STP    DATE; --归档当天结束时间戳
  VAR_COUNT         NUMBER; --数据量
  VAR_AR_DAYCNT     NUMBER; --当天遍历数
  VAR_AR_DAYINC     NUMBER; --当天的时间递增量
  VAR_AR_STP        DATE; --归档时间戳
BEGIN
  ERROR_TAG := 0;
  ERROR_MESSAGE := '';

  --获取未归档的最小日期、相差天数
  SELECT trunc(MIN(T.CREATE_TIME)) INTO VAR_MIN_DATE
    FROM T_IF_RECEIVE_FILE T
    WHERE T.RECEIVED   <> 1 --不是未解析的数据
      AND T.CREATE_TIME < AC_MAX_TIME;
  VAR_AR_DIFFDAY := AC_MAX_TIME - VAR_MIN_DATE;

  --遍历每一天
  IF VAR_AR_DIFFDAY IS NOT NULL AND VAR_AR_DIFFDAY > 0 THEN

    --迁移数据每一天的处理
    FOR I IN 1..VAR_AR_DIFFDAY LOOP

      --获取归档当天开始日期和结束日期
      VAR_AR_START_STP := VAR_MIN_DATE + (I - 1);
      VAR_AR_END_STP := VAR_AR_START_STP + 1;

      --获取当天数据量、当天最小时间戳、当天最大时间戳
      SELECT COUNT(1),
             MIN(T.CREATE_TIME),
             MAX(T.CREATE_TIME)
        INTO VAR_COUNT,
             VAR_AR_START_STP,
             VAR_AR_END_STP
        FROM T_IF_RECEIVE_FILE T
        WHERE T.RECEIVED    <> 1 --不是未解析的数据
          AND T.CREATE_TIME >= VAR_AR_START_STP
          AND T.CREATE_TIME <  VAR_AR_END_STP;
      IF VAR_COUNT > 0 THEN

        --获取当天轮询次数和递增时间量
        VAR_AR_DAYCNT := CEIL(VAR_COUNT * 1.0 / C_ARCHIVE_MAX_COUNT);
        VAR_AR_DAYINC := (VAR_AR_END_STP - VAR_AR_START_STP) / VAR_AR_DAYCNT;

        --轮询当天次数，次数加1是防止递增运算结果小于当天最大时间戳
        FOR K IN 1..(VAR_AR_DAYCNT + 1) LOOP

          --获取归档时间戳（不能超过当天结束日期）
          VAR_AR_STP := LEAST(VAR_AR_END_STP, VAR_AR_START_STP + VAR_AR_DAYINC * K);

          --将数据迁移到历史表
          INSERT INTO T_IF_RECEIVE_FILE_HIS
            SELECT * FROM T_IF_RECEIVE_FILE T
              WHERE T.RECEIVED   <> 1 --不是未解析的数据
                AND T.CREATE_TIME <= VAR_AR_STP;

          IF SQL%ROWCOUNT > 0 THEN --有数据插入历史表

            --删除已迁移数据
            DELETE FROM T_IF_RECEIVE_FILE T
              WHERE T.RECEIVED   <> 1 --不是未解析的数据
                AND T.CREATE_TIME <= VAR_AR_STP;

            COMMIT;
          ELSE --没有数据插入历史表
            ROLLBACK;
          END IF;
        END LOOP; --轮询当天次数
      END IF;--判断当前数据量
    END LOOP; --轮询相差天数
  END IF; --遍历每一天
EXCEPTION
WHEN OTHERS THEN
  ERROR_TAG := 1;
  ERROR_MESSAGE  := SUBSTRB (SQLERRM||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(), 1, C_MESSAGE_MAX_LENGTH);
  ROLLBACK;
END USP_ARCHIVE_ASYNFILE;

--函数名  : USP_ARCHIVE
--功能描述: 日志归档
--输入参数说明
--       AC_MAX_TIME 保留最大时间（不包括）
--输出参数说明：
--       ERROR_TAG：返回代码 0：成功，其他：失败
--       ERROR_MESSAGE:返回信息,
--创建人员: lym
--创建时间: 2018-03-14
--****************************************************************************
PROCEDURE USP_ARCHIVE(AC_MAX_TIME        IN  DATE,
                      ERROR_TAG          OUT NUMBER,
                      ERROR_MESSAGE      OUT VARCHAR2)
AS
  VAR_ERROR_TAG      NUMBER;
  VAR_ERROR_MESSAGE  VARCHAR2(2000);
BEGIN

  --设置默认返回值
  ERROR_TAG := 0;
  ERROR_MESSAGE := '';

  --接收查询/发送日志归档
  USP_ARCHIVE_QUERY(AC_MAX_TIME, VAR_ERROR_TAG,  VAR_ERROR_MESSAGE);
  IF 0 <> VAR_ERROR_TAG THEN
    ERROR_TAG := 1;
    ERROR_MESSAGE := VAR_ERROR_MESSAGE || ';';
  END IF;

  --接收日志归档
  USP_ARCHIVE_RECEIVE(AC_MAX_TIME, VAR_ERROR_TAG, VAR_ERROR_MESSAGE);
  IF 0 <> VAR_ERROR_TAG THEN
    ERROR_TAG := 1;
    ERROR_MESSAGE := ERROR_MESSAGE || VAR_ERROR_MESSAGE || ';';
  END IF;

  --异步文件归档
  USP_ARCHIVE_ASYNFILE(AC_MAX_TIME, VAR_ERROR_TAG, VAR_ERROR_MESSAGE);
  IF 0 <> VAR_ERROR_TAG THEN
    ERROR_TAG := 1;
    ERROR_MESSAGE := ERROR_MESSAGE || VAR_ERROR_MESSAGE || ';';
  END IF;

  --截断超出字符
  IF length(ERROR_MESSAGE) > C_MESSAGE_MAX_LENGTH THEN
    ERROR_MESSAGE  := SUBSTRB (ERROR_MESSAGE, 1, C_MESSAGE_MAX_LENGTH);
  END IF;

EXCEPTION
WHEN OTHERS THEN
  ERROR_TAG := 1;
END USP_ARCHIVE;


end PKG_ARCHIVE;
/

prompt
prompt Creating package body PKG_IF_REC
prompt ================================
prompt
create or replace package body PKG_IF_REC is

  --****************************************************************************
  --函数  : USF_TRANS_MES_FACTORY
  --功能描述: 转换MES工厂代码为物流系统工厂代码
  --参数说明:
  -- in_mes_factory_code  :MES工厂代码
  --返回值: 物流系统工作中心
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  FUNCTION USF_TRANS_MES_FACTORY(in_mes_factory_code in varchar2)
    RETURN VARCHAR2 AS
    out_factory_code varchar2(10);
  BEGIN
    out_factory_code := in_mes_factory_code;
    RETURN out_factory_code;
  END USF_TRANS_MES_FACTORY;

  --****************************************************************************
  --函数  : USF_TRANS_MES_WORKCENTER
  --功能描述: 转换MES工作中心为物流系统工作中心
  --参数说明:
  -- in_mes_workcenter  :MES工作中心
  --返回值: 物流系统工作中心
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  FUNCTION USF_TRANS_MES_WORKCENTER(in_mes_workcenter in varchar2)
    RETURN VARCHAR2 AS
    out_workcenter varchar2(20);
  BEGIN
    out_workcenter := in_mes_workcenter;
    return out_workcenter;
  END USF_TRANS_MES_WORKCENTER;

  --****************************************************************************
  --函数  : USF_TRANS_ERP_FACTORY
  --功能描述: 转换ERP工厂代码为物流系统工厂代码
  --参数说明:
  -- in_erp_factory_code  :MES工厂代码
  --返回值: 物流系统工作中心
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  FUNCTION USF_TRANS_ERP_FACTORY(in_erp_factory_code in varchar2)
    RETURN VARCHAR2 AS
    out_factory_code varchar2(10);
  BEGIN
    out_factory_code := in_erp_factory_code;
    RETURN out_factory_code;
  END USF_TRANS_ERP_FACTORY;

  --****************************************************************************
  --函数  : USF_TRANS_ERP_WORKCENTER
  --功能描述: 转换MES工作中心为物流系统工作中心
  --参数说明:
  -- in_erp_workcenter  :ERP工作中心
  --返回值: 物流系统工作中心
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  FUNCTION USF_TRANS_ERP_WORKCENTER(in_erp_workcenter in varchar2)
    RETURN VARCHAR2 AS
    out_workcenter varchar2(10);
  BEGIN
    out_workcenter := in_erp_workcenter;
    RETURN out_workcenter;
  END USF_TRANS_ERP_WORKCENTER;

  --****************************************************************************
  --过程名  : USP_JIT_VEH_SCRAP_DEAL
  --功能描述: 拉动计算车辆报废重投处理
  --参数说明: 无
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  PROCEDURE USP_JIT_VEH_SCRAP_DEAL(ERROR_TAG     OUT NUMBER,
                                   ERROR_MESSAGE OUT VARCHAR2) IS
    v_adjust_kb_state mm_jit_veh_scrap.adjust_kb_state%type; --调整看板状态
    v_flag            number(1); --临时标识
    err_num           number(10); --错误代码
    err_msg           varchar2(200); --错误信息
  BEGIN
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
    --获取未处理的报废车信息
    for cur_scarp in (select *
                        from if_veh_scrap a
                       where a.deal_flag = 0
                       order by factory_code, creation_time, id) loop
      if cur_scarp.factory_code is not null and
         length(trim(cur_scarp.factory_code)) > 0 and
         cur_scarp.scrap_workcenter is not null and
         length(trim(cur_scarp.scrap_workcenter)) > 0 and
         cur_scarp.erp_order_no is not null and
         length(trim(cur_scarp.erp_order_no)) > 0 and
         cur_scarp.scrap_time is not null and
         length(trim(cur_scarp.scrap_time)) > 0 then
        /*
          v_last_station_code:='INIT';
          --根据MES接口给过来的车辆报废记录判断拉动推算哪些信息点不需要重新计算需求。
          --备注：报废重投车辆处理只针对总装车间。并且如果车辆过了PAOFF则系统默认实际已消耗安装掉配送的零件，需重新计算出零件需求。
          --报废车辆最后经过信息点检索获取，只取各大车间的上下线信息点判断
          for cur_last_station in(
            select t1.order_no, t1.station_code, m.sort_no
               from (select a.order_no, a.station_code, a.factory_code
                       from mm_pub_veh_pass a
                      where a.order_no = cur_scarp.order_no
                        and a.factory_code = cur_scarp.factory_code
                        and a.station_code in
                            ('WE-ON', 'WE-OFF', 'PA-ON', 'PA-OFF', 'AF-OFF')) t1,
                    mm_pub_data_dict m
              where m.factory_code = t1.factory_code
                and m.code_value = t1.station_code
                and m.code_type = 'MON_KB_STATION'
              order by m.sort_no desc)
          loop
            v_last_station_code := cur_last_station.station_code;
            exit;
          end loop;
        */
        --是否需调整看板
        v_adjust_kb_state := 0;
        --判断是否存在拉动计算队列表，只有拉动计算车辆才需要补看板进度
        select count(1)
          into v_flag
          from mm_jit_veh_queue m, mm_pub_plan_code n
         where m.plan_code = n.plan_code
           and n.plan_code_type in ('JITO', 'JITI')
           and n.factory_code = cur_scarp.factory_code
           and m.order_no = cur_scarp.order_no
           and n.workcenter = cur_scarp.scrap_workcenter;

        /*
        select count(1)
          into v_flag
          from mm_jit_veh_queue m, mm_pub_plan_code n
         where m.plan_code = n.plan_code
           and n.factory_code = cur_scarp.factory_code
           and m.order_no = cur_scarp.order_no
           and (n.workcenter = cur_scarp.scrap_workcenter or (PKG_PUB.USF_GET_WORKCENTER_PRE(n.workcenter) = 'A' and
               PKG_PUB.USF_GET_WORKCENTER_PRE(cur_scarp.scrap_workcenter) in
               ('T')));
        */
        if v_flag = 1 then
          v_adjust_kb_state := 1;
        end if;
        --写入车辆报废信息
        insert into mm_jit_veh_scrap
          (factory_code,
           order_no,
           erp_order_no,
           vin,
           scrap_workcenter,
           scrap_station_code,
           scrap_station_desc,
           scrap_reason,
           scrap_time,
           adjust_kb_state,
           last_modified_time)
        values
          (cur_scarp.factory_code,
           cur_scarp.order_no,
           cur_scarp.erp_order_no,
           cur_scarp.vin,
           cur_scarp.scrap_workcenter,
           cur_scarp.scrap_station_code,
           cur_scarp.scrap_station_desc,
           cur_scarp.scrap_reason,
           to_date(cur_scarp.scrap_time, 'yyyy-mm-dd hh24:mi:ss'),
           v_adjust_kb_state,
           sysdate);
        --更新订单状态为报废状态
        update if_veh_lock_plan a
           set a.order_status = 30
         where a.order_no = cur_scarp.order_no;
        --更新接口临时表处理状态为已更新
        update if_veh_scrap a
           set a.deal_flag = 1, a.deal_time = sysdate
         where a.id = cur_scarp.id
           and a.deal_flag = 0;
      else
        --更新接口临时表处理状态为有误
        update if_veh_scrap a
           set a.deal_flag = 2, a.deal_time = sysdate
         where a.id = cur_scarp.id
           and a.deal_flag = 0;
      end if;
    end loop;

    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_JIT_VEH_SCRAP_DEAL',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_JIT_VEH_SCRAP_DEAL;

  --****************************************************************************
  --过程名  : USP_PUB_IF_TO_VEH_PASS
  --功能描述: 车辆过点信息到业务表
  --参数说明: 无
  --创建人员: wxl
  --创建时间: 2018-11-27
  --修改记录：
  --          定制化订单-新增销售单写入 mod by wxl 20190315
  --          调整销售单号、销售单行号对应接口表字段 mod by wxl 20190521
  --****************************************************************************
  PROCEDURE USP_PUB_VEH_PASS(ERROR_TAG     OUT NUMBER,
                             ERROR_MESSAGE OUT VARCHAR2) AS
    v_flag number;
    excep1 exception; --自定义异常
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
    for cur_veh in (select *
                      from if_veh_pass
                     where deal_flag = 0
                     order by factory_code, creation_time, id) loop
      --数据非空校验
      if cur_veh.factory_code is not null and
         length(trim(cur_veh.factory_code)) > 0 and
         cur_veh.order_no is not null and
         length(trim(cur_veh.order_no)) > 0 and
         cur_veh.erp_order_no is not null and
         length(trim(cur_veh.erp_order_no)) > 0 and
         cur_veh.station_code is not null and
         length(trim(cur_veh.station_code)) > 0 and
         cur_veh.pass_time is not null and
         length(trim(cur_veh.pass_time)) > 0 and cur_veh.vin is not null and
         length(trim(cur_veh.vin)) > 0 and cur_veh.phase is not null and
         length(trim(cur_veh.phase)) > 0 then
        select count(1)
          into v_flag
          from mm_pub_veh_pass
         where factory_code = cur_veh.factory_code
           and order_no = cur_veh.order_no
           and station_code = cur_veh.station_code
           and rownum = 1;
        --记录不存在新增
        if v_flag = 0 then
          insert into mm_pub_veh_pass
            (factory_code,
             order_no,
             erp_order_no,
             sale_no,
             sale_rowno,
             station_code,
             pass_time,
             vin,
             phase,
             mtoc,
             model_code,
             wc_seqno,
             pl_seqno)
          values
            (cur_veh.factory_code,
             cur_veh.order_no,
             cur_veh.erp_order_no,
             cur_veh.uda2,
             to_number(cur_veh.uda1),
             cur_veh.station_code,
             to_date(cur_veh.pass_time, 'YYYY-MM-DD HH24:MI:SS'),
             cur_veh.vin,
             cur_veh.phase,
             cur_veh.mtoc,
             cur_veh.model_code,
             cur_veh.wc_seqno,
             cur_veh.pl_seqno);
          --根据实绩过点的工位判断订单状态，WE-ON代表车辆上线在制,AF-OFF代表车辆下线
          if cur_veh.station_code in ('WE-ON', 'WE-ON-L') then
            update if_veh_lock_plan a
               set a.order_status = 10
             where a.factory_code = cur_veh.factory_code
               and a.order_no = cur_veh.order_no;
          elsif cur_veh.station_code = 'WE-MB-ON' then
            update if_veh_lock_plan a
               set a.order_status = 15
             where a.factory_code = cur_veh.factory_code
               and a.order_no = cur_veh.order_no;
          elsif cur_veh.station_code = 'AF-OFF' then
            update if_veh_lock_plan a
               set a.order_status = 20
             where a.factory_code = cur_veh.factory_code
               and a.order_no = cur_veh.order_no;
          end if;

          --记录存在更新,正常不存在
        else
          update mm_pub_veh_pass
             set erp_order_no       = cur_veh.erp_order_no,
                 sale_no            = cur_veh.uda2,
                 sale_rowno         = to_number(cur_veh.uda1),
                 pass_time          = to_date(cur_veh.pass_time,
                                              'YYYY-MM-DD HH24:MI:SS'),
                 vin                = cur_veh.vin,
                 phase              = cur_veh.phase,
                 mtoc               = cur_veh.mtoc,
                 model_code         = cur_veh.model_code,
                 wc_seqno           = cur_veh.wc_seqno,
                 pl_seqno           = cur_veh.pl_seqno,
                 last_modified_time = sysdate
           where factory_code = cur_veh.factory_code
             and order_no = cur_veh.order_no
             and station_code = cur_veh.station_code;
        end if;
        --更新接口处理标识，正常1
        update if_veh_pass
           set deal_flag = 1, deal_time = sysdate
         where id = cur_veh.id
           and deal_flag = 0;
      else
        raise excep1;
      end if;
    end loop;

    COMMIT;
  EXCEPTION
    WHEN excep1 THEN
      ROLLBACK;
      err_num := 999;
      err_msg := '非空数据异常';
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PUB_VEH_PASS',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PUB_VEH_PASS',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PUB_VEH_PASS;

  --***************************************************************************
  --存储过程名：USP_PUB_SPS_CONFIG
  --功能描述: 配置项信息接口表数据写入业务表
  --参数说明：无
  --创建人员: wxl
  --创建时间：2018-12-23
  PROCEDURE USP_PUB_SPS_CONFIG AS
    v_flag number;
    excep1 exception; --自定义异常
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    for cur_config in (select *
                         from if_sps_config
                        where deal_flag = 0
                        order by creation_time, id) loop
      --非空数据校验
      if cur_config.config_name is not null and
         length(trim(cur_config.config_name)) > 0 and
         cur_config.config_desc is not null and
         length(trim(cur_config.config_desc)) > 0 and
         cur_config.feature_group is not null and
         length(trim(cur_config.feature_group)) > 0 then
        --操作标志不为删除
        if cur_config.do_flag != 'D' then
          select count(1)
            into v_flag
            from mm_pub_sps_config a
           where a.config_name = cur_config.config_name
             and rownum = 1;
          if v_flag = 0 then
            insert into mm_pub_sps_config
              (config_name, config_desc, feature_group)
            values
              (cur_config.config_name,
               cur_config.config_desc,
               cur_config.feature_group);
          else
            update mm_pub_sps_config a
               set a.config_desc        = cur_config.config_desc,
                   a.feature_group      = cur_config.feature_group,
                   a.last_modified_time = cur_config.creation_time
             where a.config_name = cur_config.config_name;
          end if;
        else
          delete from mm_pub_sps_config a
           where a.config_name = cur_config.config_name;
        end if;
        --更新接口处理标识，正常1
        update if_sps_config
           set deal_flag = 1, deal_time = sysdate
         where id = cur_config.id
           and deal_flag = 0;
      else
        --更新接口处理标识，异常2
        update if_sps_config
           set deal_flag = 2, deal_time = sysdate
         where id = cur_config.id
           and deal_flag = 0;
      end if;
    end loop;

    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PUB_SPS_CONFIG',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PUB_SPS_CONFIG;

  --***************************************************************************
  --存储过程名：USP_PUB_FEATURE_GROUP
  --功能描述: 特征码组信息接口表数据写入业务表
  --参数说明：无
  --创建人员: wxl
  --创建时间：2018-12-23
  PROCEDURE USP_PUB_FEATURE_GROUP AS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    for cur_fg in (select *
                     from if_feature_group
                    where deal_flag = 0
                    order by creation_time, id) loop
      --非空数据校验
      if cur_fg.feature_group is not null and
         length(trim(cur_fg.feature_group)) > 0 and
         cur_fg.feature_group_desc is not null and
         length(trim(cur_fg.feature_group_desc)) > 0 then
        --删除已有数据
        delete from mm_pub_feature_group a
         where a.feature_group = cur_fg.feature_group;

        --操作标志不为删除
        if cur_fg.do_flag != 'D' then
          for cur_fg_detail in (select *
                                  from if_feature_group_detail
                                 where id = cur_fg.id) loop
            --校验明细数据是否存在异常,第一个特征代码必填
            if cur_fg_detail.feature_code1 is not null and
               length(trim(cur_fg.feature_group)) > 0 then
              insert into mm_pub_feature_group
                (feature_group,
                 feature_group_desc,
                 feature_code1,
                 feature_value1,
                 feature_code2,
                 feature_value2,
                 feature_code3,
                 feature_value3,
                 feature_code4,
                 feature_value4,
                 display_value)
              values
                (cur_fg.feature_group,
                 cur_fg.feature_group_desc,
                 cur_fg_detail.feature_code1,
                 cur_fg_detail.feature_value1,
                 cur_fg_detail.feature_code2,
                 cur_fg_detail.feature_value2,
                 cur_fg_detail.feature_code3,
                 cur_fg_detail.feature_value3,
                 cur_fg_detail.feature_code4,
                 cur_fg_detail.feature_value4,
                 cur_fg_detail.display_value);
            else
              --更新接口处理标识，异常2
              update if_feature_group_detail
                 set deal_flag = 2, deal_time = sysdate
               where id = cur_fg_detail.id
                 and deal_flag = 0;
            end if;
          end loop;
        end if;
        --更新接口处理标识，正常1
        update if_feature_group
           set deal_flag = 1, deal_time = sysdate
         where id = cur_fg.id
           and deal_flag = 0;
      else
        --更新接口处理标识，异常2
        update if_feature_group
           set deal_flag = 2, deal_time = sysdate
         where id = cur_fg.id
           and deal_flag = 0;
      end if;
    end loop;

    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PUB_FEATURE_GROUP',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PUB_FEATURE_GROUP;

  --***************************************************************************
  --存储过程名：USP_PUB_ASSE_MOULD_CONFIG
  --功能描述: 装车单模板信息接口表数据写入业务表
  --参数说明：无
  --创建人员: wxl
  --创建时间：2018-12-23
  PROCEDURE USP_PUB_ASSE_MOULD_CONFIG(ERROR_TAG     OUT NUMBER,
                                      ERROR_MESSAGE OUT VARCHAR2) AS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    for cur_mould in (select *
                        from if_assembly_mould
                       where deal_flag = 0
                       order by creation_time, id) loop
      --非空数据校验
      if cur_mould.assembly_name is not null and
         length(trim(cur_mould.assembly_name)) > 0 and
         cur_mould.model_code is not null and
         length(trim(cur_mould.model_code)) > 0 then
        --删除已有数据
        delete from mm_pub_assembly_config a
         where a.assembly_name = cur_mould.assembly_name;

        --操作标志不为删除
        if cur_mould.do_flag != 'D' then
          for cur_mould_c in (select *
                                from if_assembly_mould_config
                               where id = cur_mould.id) loop
            --校验明细数据是否存在异常,第一个特征代码必填
            if cur_mould_c.location is not null and
               length(trim(cur_mould_c.location)) > 0 and
               cur_mould_c.config_name is not null and
               length(trim(cur_mould_c.config_name)) > 0 and
               cur_mould_c.area_code is not null and
               length(trim(cur_mould_c.area_code)) > 0 then
              insert into mm_pub_assembly_config
                (assembly_name,
                 model_code,
                 location,
                 config_name,
                 area_code)
              values
                (cur_mould.assembly_name,
                 cur_mould.model_code,
                 cur_mould_c.location,
                 cur_mould_c.config_name,
                 cur_mould_c.area_code);
            else
              --更新接口处理标识，异常2
              update if_assembly_mould_config
                 set deal_flag = 2, deal_time = sysdate
               where id = cur_mould_c.id
                 and deal_flag = 0;
            end if;
          end loop;
        end if;
        --更新接口处理标识，正常1
        update if_assembly_mould
           set deal_flag = 1, deal_time = sysdate
         where id = cur_mould.id
           and deal_flag = 0;
      else
        --更新接口处理标识，异常2
        update if_assembly_mould
           set deal_flag = 2, deal_time = sysdate
         where id = cur_mould.id
           and deal_flag = 0;
      end if;
    end loop;

    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PUB_ASSE_MOULD_CONFIG',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PUB_ASSE_MOULD_CONFIG;

  --****************************************************************************
  --函数  : USP_PKG_PART_GET_MSG
  --功能描述: 将接口表数据写到业务表
  --参数说明:
  --返回值:
  --创建人员: luoxq
  --创建时间: 2018-12-04
  --****************************************************************************
  procedure USP_PKG_PART_GET_MSG as

    PART_COUNT    NUMBER;
    STATUS_COUNT  NUMBER;
    PKG_TRAY      NUMBER;
    STATUS_CODE   NUMBER;
    ERROR_TAG     NUMBER;
    ERROR_MESSAGE VARCHAR2(2000);
  BEGIN

    --处理车型数据到业务表
    INSERT INTO MM_PUB_MODEL_CODE
      (ID, FACTORY_CODE, MODEL_CODE, CREATION_TIME)
      SELECT PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_PUB_MODEL_CODE'),
             B.FACTORY_CODE,
             B.MODEL_CODE,
             SYSDATE
        FROM (SELECT DISTINCT A.MODEL_CODE, A.FACTORY_CODE
                FROM IF_SUPER_BOM A
               WHERE A.CREATION_TIME >= SYSDATE - 100) B
       WHERE NOT EXISTS (SELECT 1
                FROM MM_PUB_MODEL_CODE C
               WHERE B.MODEL_CODE = C.MODEL_CODE
                 AND B.FACTORY_CODE = C.FACTORY_CODE);

    FOR cur_data IN (SELECT A.MODEL_CODE,
                            A.PART_NO,
                            A.PURCHASE_TYPE,
                            A.FACTORY_CODE,
                            B.SUPPLIER_NO,
                            A.PROCESS_TYPE,
                            A.ID,
                            SUBSTR(A.PROCESS_TYPE, 0, 2) WORKCENTER
                       FROM IF_SUPER_BOM A
                       LEFT JOIN MM_PUB_PART_SUPPLIER B
                         ON A.PART_NO = B.PART_NO
                        AND A.FACTORY_CODE = B.FACTORY_CODE
                      WHERE A.DEAL_FLAG = '0'
                        AND B.SUPPLIER_NO IS NOT NULL
                        AND (A.PURCHASE_TYPE = 'AW' OR A.PURCHASE_TYPE = 'W') --采购类型为支给总成和国内外采件
                      ORDER BY A.ID, A.CREATION_TIME) LOOP

      --判断是否存在于PKG_PART
      SELECT COUNT(1)
        INTO PART_COUNT
        FROM MM_PKG_PART C
       WHERE C.CAR_TYPE = cur_data.MODEL_CODE
         AND C.PART_NO = cur_data.PART_NO
         AND C.PURCHASE_TYPE = cur_data.PURCHASE_TYPE
         AND C.SUPPLIER_NO = cur_data.supplier_no;

      --判断是否存在提案表已存在该零件且该零件状态为实物通过(5)，存在设置1：留用
      SELECT COUNT(1)
        INTO STATUS_COUNT
        FROM MM_PKG_PROPOSAL C
       WHERE C.PART_NO = cur_data.PART_NO
         AND C.SUPPLIER_NO = cur_data.SUPPLIER_NO
         AND C.PROPOSAL_STATUS = '5'
         AND C.FACTORY_CODE = cur_data.FACTORY_CODE;

      IF (PART_COUNT = 0) THEN
        IF (STATUS_COUNT > 0) THEN
          STATUS_CODE := 1; --根据零件号和供应商判断是否在业务表已存在该零件，存在设为1：留用
        ELSE
          STATUS_CODE := 0; --否则设为0：新设
        END IF;
        --数据写入到零件担当维护表中
        INSERT INTO MM_PKG_PART
          (ID,
           CAR_TYPE,
           PART_NO,
           SUPPLIER_NO,
           STATUS,
           CREATION_TIME,
           FACTORY_CODE,
           PROJECT,
           PURCHASE_TYPE)
        VALUES
          (SEQ_MM_PKG_PART.NEXTVAL,
           cur_data.MODEL_CODE,
           cur_data.PART_NO,
           cur_data.SUPPLIER_NO,
           STATUS_CODE,
           sysdate,
           cur_data.FACTORY_CODE,
           cur_data.workcenter,
           cur_data.PURCHASE_TYPE);

      END IF;

      --数据写入到托盘数量维护表中
      IF (cur_data.SUPPLIER_NO IS NOT NULL AND
         cur_data.FACTORY_CODE IS NOT NULL) THEN
        SELECT COUNT(1)
          INTO PKG_TRAY
          FROM MM_PKG_TRAY_QTY PQT
         WHERE PQT.CAR_TYPE = cur_data.MODEL_CODE
           AND PQT.SUPPLIER_NO = cur_data.SUPPLIER_NO; ---如果车型和供应商在业务表中存在则不把数据写入到业务表中
        IF (PKG_TRAY = 0) THEN
          INSERT INTO MM_PKG_TRAY_QTY
            (ID, CAR_TYPE, SUPPLIER_NO, CREATION_TIME, FACTORY_CODE)
          VALUES
            (SEQ_MM_PKG_TRAY_QTY.NEXTVAL,
             cur_data.MODEL_CODE,
             cur_data.SUPPLIER_NO,
             sysdate,
             cur_data.FACTORY_CODE);
        END IF;
      END IF;

      --更新超级BOM的处理标识
      UPDATE IF_SUPER_BOM A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_data.ID;

    END LOOP;
    COMMIT;
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
  EXCEPTION
    WHEN OTHERS THEN

      ERROR_TAG     := SQLCODE;
      ERROR_MESSAGE := SUBSTR(SQLERRM ||
                              DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(),
                              1,
                              200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_PKG_PART_GET_MSG',
         ERROR_TAG,
         ERROR_MESSAGE,
         SYSDATE,
         '包装数据处理');
      COMMIT;
      ROLLBACK;
  END USP_PKG_PART_GET_MSG;

  procedure USP_PKG_PART_MSG as
    --****************************************************************************
    --函数  : USP_PKG_PART_MSG
    --功能描述: 将接口表数据写到业务表（考虑到IF_MODEL_BOM数据会到3月份才能有，所以数据从MM_PUB_ORDER_BOM中获取）
    --参数说明:
    --返回值:
    --创建人员: luoxq
    --创建时间: 2018-12-04
    --****************************************************************************

    USER_COUNT  NUMBER;
    STATUS_CODE NUMBER;
    PKG_TRAY    NUMBER;
  BEGIN

    FOR I IN (SELECT ODB.FACTORY_CODE,
                     ODB.VEHICLE_PART_NO,
                     ODB.PART_NO,
                     ODB.WORKCENTER,
                     ODB.PURCHASE_TYPE,
                     SUP.SUPPLIER_NO
                FROM MM_PUB_ORDER_BOM ODB
                LEFT JOIN MM_PUB_PART_SUPPLIER SUP
                  ON ODB.PART_NO = SUP.PART_NO
               WHERE ODB.VEHICLE_PART_NO = 'A26') LOOP
      SELECT COUNT(1)
        INTO USER_COUNT
        FROM MM_PKG_PART PT
       WHERE PT.CAR_TYPE = I.VEHICLE_PART_NO
         AND PT.PART_NO = I.PART_NO
         AND PT.PURCHASE_TYPE = I.PURCHASE_TYPE
         AND PT.FACTORY_CODE = I.FACTORY_CODE;
      SELECT COUNT(1)
        INTO STATUS_CODE
        FROM MM_PKG_PART PT
       WHERE PT.PART_NO = I.PART_NO
         AND PT.SUPPLIER_NO = I.SUPPLIER_NO;
      IF (USER_COUNT = 0) THEN
        IF (STATUS_CODE > 0) THEN
          STATUS_CODE := 1; --根据零件号和供应商判断是否在业务表已存在该零件，存在设为1：留用
        ELSE
          STATUS_CODE := 0; --否则设为0：新设
        END IF;
        --数据写入到零件担当维护表中
        INSERT INTO MM_PKG_PART
          (ID,
           CAR_TYPE,
           PART_NO,
           SUPPLIER_NO,
           STATUS,
           CREATION_TIME,
           FACTORY_CODE,
           PURCHASE_TYPE,
           PROJECT)
        VALUES
          (SEQ_MM_PKG_PART.NEXTVAL,
           I.VEHICLE_PART_NO,
           I.PART_NO,
           I.SUPPLIER_NO,
           STATUS_CODE,
           sysdate,
           I.FACTORY_CODE,
           I.PURCHASE_TYPE,
           I.WORKCENTER);

        --数据写入到托盘数量维护表中
        IF (I.SUPPLIER_NO IS NOT NULL AND I.FACTORY_CODE IS NOT NULL) THEN
          SELECT COUNT(1)
            INTO PKG_TRAY
            FROM MM_PKG_TRAY_QTY PQT
           WHERE PQT.CAR_TYPE = I.VEHICLE_PART_NO
             AND PQT.SUPPLIER_NO = I.SUPPLIER_NO
             AND PQT.FACTORY_CODE = I.FACTORY_CODE; ---如果车型和供应商在业务表中存在则不把数据写入到业务表中
          IF (PKG_TRAY = 0) THEN
            INSERT INTO MM_PKG_TRAY_QTY
              (ID, CAR_TYPE, SUPPLIER_NO, CREATION_TIME, FACTORY_CODE)
            VALUES
              (SEQ_MM_PKG_TRAY_QTY.NEXTVAL,
               I.VEHICLE_PART_NO,
               I.SUPPLIER_NO,
               sysdate,
               I.FACTORY_CODE);
          END IF;
        END IF;
      END IF;
    END LOOP;
    COMMIT;
  END USP_PKG_PART_MSG;

  --***************************************************************************
  --存储过程名：USP_MP_GET_ORDER_PLAN
  --功能描述: 获取W+3周车辆计划
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/18
  PROCEDURE USP_MP_GET_ORDER_PLAN(ERROR_TAG     OUT NUMBER,
                                  ERROR_MESSAGE OUT VARCHAR2) AS

  BEGIN
    FOR PLAN IN (SELECT *
                   FROM IF_VEH_PRO_PLAN A
                  WHERE A.DEAL_FLAG = 0
                  ORDER BY A.ID, A.CREATION_TIME ASC) LOOP
      --如果为删除标志,则删除该条记录
      IF PLAN.DO_FLAG = 'D' THEN
        DELETE FROM MM_PUB_PRO_PLAN B
         WHERE B.FACTORY_CODE = PLAN.FACTORY_CODE
           AND B.ORDER_NO = PLAN.ERP_ORDER_NO;

        --同时删除信息共享平台的数据
        DELETE FROM ilmsportal.MM_PUB_PRO_PLAN@mm_if_in B
         WHERE B.FACTORY_CODE = PLAN.FACTORY_CODE
           AND B.ORDER_NO = PLAN.ERP_ORDER_NO;
        --如果为新增标志，则新增记录
      ELSE
        MERGE INTO MM_PUB_PRO_PLAN B
        USING (SELECT 1 FROM DUAL) C
        ON (B.FACTORY_CODE = PLAN.FACTORY_CODE AND B.ORDER_NO = PLAN.ERP_ORDER_NO)
        WHEN MATCHED THEN
          UPDATE
             SET B.ORDER_TYPE         = PLAN.ORDER_TYPE,
                 B.WEON_TIME          = TO_DATE(PLAN.WEON_TIME,
                                                'YYYY-MM-DD HH24:MI:SS'),
                 B.SORT_ID            = PLAN.SORT_ID,
                 B.AFOFF_TIME         = TO_DATE(PLAN.AF_OFF_TIME,
                                                'YYYY-MM-DD HH24:MI:SS'),
                 B.MTOC               = PLAN.MTOC,
                 B.MODEL_CODE         = PLAN.CAR_TYPE,
                 B.PHASE              = PLAN.PHASE,
                 B.LAST_MODIFIED_TIME = SYSDATE,
                 B.DMS_ORDER_NO       = PLAN.UDA2,
                 B.DMS_ORDER_ROW_NO   = PLAN.UDA1
        WHEN NOT MATCHED THEN
          INSERT
            (FACTORY_CODE,
             ORDER_NO,
             ORDER_TYPE,
             DMS_ORDER_NO,
             DMS_ORDER_ROW_NO,
             MTOC,
             WEON_TIME,
             AFOFF_TIME,
             SORT_ID,
             MODEL_CODE,
             PHASE,
             CREATION_TIME,
             LAST_MODIFIED_TIME)
          VALUES
            (PLAN.FACTORY_CODE,
             PLAN.ERP_ORDER_NO,
             PLAN.ORDER_TYPE,
             PLAN.UDA2,
             PLAN.UDA1,
             PLAN.MTOC,
             TO_DATE(PLAN.WEON_TIME, 'YYYY-MM-DD HH24:MI:SS'),
             TO_DATE(PLAN.AF_OFF_TIME, 'YYYY-MM-DD HH24:MI:SS'),
             PLAN.SORT_ID,
             PLAN.CAR_TYPE,
             PLAN.PHASE,
             SYSDATE,
             SYSDATE);

        --更新信息共享平台数据
        MERGE INTO ilmsportal.MM_PUB_PRO_PLAN@mm_if_in B
        USING (SELECT 1 FROM DUAL) C
        ON (B.FACTORY_CODE = PLAN.FACTORY_CODE AND B.ORDER_NO = PLAN.ERP_ORDER_NO)
        WHEN MATCHED THEN
          UPDATE
             SET B.ORDER_TYPE         = PLAN.ORDER_TYPE,
                 B.WEON_TIME          = TO_DATE(PLAN.WEON_TIME,
                                                'YYYY-MM-DD HH24:MI:SS'),
                 B.SORT_ID            = PLAN.SORT_ID,
                 B.AFOFF_TIME         = TO_DATE(PLAN.AF_OFF_TIME,
                                                'YYYY-MM-DD HH24:MI:SS'),
                 B.MTOC               = PLAN.MTOC,
                 B.MODEL_CODE         = PLAN.CAR_TYPE,
                 B.PHASE              = PLAN.PHASE,
                 B.LAST_MODIFIED_TIME = SYSDATE,
                 B.DMS_ORDER_NO       = PLAN.UDA2,
                 B.DMS_ORDER_ROW_NO   = PLAN.UDA1
        WHEN NOT MATCHED THEN
          INSERT
            (FACTORY_CODE,
             ORDER_NO,
             ORDER_TYPE,
             DMS_ORDER_NO,
             DMS_ORDER_ROW_NO,
             MTOC,
             WEON_TIME,
             AFOFF_TIME,
             SORT_ID,
             MODEL_CODE,
             PHASE,
             CREATION_TIME,
             LAST_MODIFIED_TIME)
          VALUES
            (PLAN.FACTORY_CODE,
             PLAN.ERP_ORDER_NO,
             PLAN.ORDER_TYPE,
             PLAN.UDA2,
             PLAN.UDA1,
             PLAN.MTOC,
             TO_DATE(PLAN.WEON_TIME, 'YYYY-MM-DD HH24:MI:SS'),
             TO_DATE(PLAN.AF_OFF_TIME, 'YYYY-MM-DD HH24:MI:SS'),
             PLAN.SORT_ID,
             PLAN.CAR_TYPE,
             PLAN.PHASE,
             SYSDATE,
             SYSDATE);
      END IF;

      --更新处理状态为已处理
      UPDATE IF_VEH_PRO_PLAN B
         SET B.DEAL_FLAG = 1, B.DEAL_TIME = SYSDATE
       WHERE B.ID = PLAN.ID;
    END LOOP;
    COMMIT;

    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := sqlcode;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_GET_ORDER_PLAN',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '获取W+3周车辆计划');
        COMMIT;

        ROLLBACK;
      END;
  END USP_MP_GET_ORDER_PLAN;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_GET_ADJ_PLAN
  --功能描述: 获取调整计划
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/18
  PROCEDURE USP_MP_GET_ADJ_PLAN(ERROR_TAG     OUT NUMBER,
                                ERROR_MESSAGE OUT VARCHAR2) AS

  BEGIN
    --处理计划和计划对应的BOM
    FOR PLAN IN (SELECT *
                   FROM IF_MP_ADJUST_PLAN A
                  WHERE A.DEAL_FLAG = 0
                  ORDER BY A.ID, A.CREATION_TIME) LOOP

      --并且删除该计划下对应的BOM
      DELETE FROM MM_MP_ADJ_BOM B
       WHERE B.COMP = PKG_IF_REC.USF_TRANS_ERP_FACTORY(PLAN.COMP)
         AND TO_CHAR(B.ADJ_DATE, 'YYYY-MM-DD HH24:MI:SS') = PLAN.ADJ_DATE
         AND B.CAR_TYPE = PLAN.CAR_TYPE;

      --存在更新不存在新增
      MERGE INTO MM_MP_ADJ_PLAN_HIS C
      USING (SELECT 1 FROM DUAL) B
      ON (C.FACTORY_CODE = PKG_IF_REC.USF_TRANS_ERP_FACTORY(PLAN.COMP) AND TO_CHAR(C.ADJ_DATE, 'YYYY-MM-DD HH24:MI:SS') = PLAN.ADJ_DATE AND C.CAR_TYPE = PLAN.CAR_TYPE)
      WHEN MATCHED THEN
        UPDATE
           SET C.DIFF_NUM           = PLAN.ADJ_NUM,
               C.LAST_MODIFIED_USER = 'SYSTEM',
               C.LAST_MODIFIED_TIME = SYSDATE
      WHEN NOT MATCHED THEN
        INSERT
          (ID,
           FACTORY_CODE,
           CAR_TYPE,
           DIFF_NUM,
           ADJ_DATE,
           CREATION_USER,
           CREATION_TIME)
        VALUES
          (PLAN.ID,
           PKG_IF_REC.USF_TRANS_ERP_FACTORY(PLAN.COMP),
           PLAN.CAR_TYPE,
           PLAN.ADJ_NUM,
           TO_DATE(PLAN.ADJ_DATE, 'YYYY-MM-DD HH24:MI:SS'),
           'SYSTEM',
           SYSDATE);

      --之前已经将该计划下的所有BOM删除，所以现在将该计划下的BOM写入
      INSERT INTO MM_MP_ADJ_BOM
        (ID,
         COMP,
         CAR_TYPE,
         ADJ_DATE,
         PART_ROW_NO,
         PART_ID,
         LINE_STATION,
         NUM,
         USAGE_AMOUNT_UNIT,
         PURCHASE_TYPE,
         CREATION_USER,
         CREATION_TIME)
        SELECT SEQ_MM_MP_ADJ_BOM.NEXTVAL,
               PKG_IF_REC.USF_TRANS_ERP_FACTORY(PLAN.COMP),
               A.CAR_TYPE,
               TO_DATE(A.ADJ_DATE, 'YYYY-MM-DD HH24:MI:SS'),
               A.PART_ROW_NO,
               A.PART_ID,
               A.LINE_STATION,
               A.NUM,
               A.USAGE_AMOUNT_UNIT,
               A.PURCHASE_TYPE,
               'SYSTEM',
               SYSDATE
          FROM IF_MP_ADJUST_BOM A
         WHERE A.COMP = PLAN.COMP
           AND A.ADJ_DATE = PLAN.ADJ_DATE
           AND A.CAR_TYPE = PLAN.CAR_TYPE;

      --更新处理状态为已处理
      UPDATE IF_MP_ADJUST_PLAN A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = PLAN.ID;
    END LOOP;
    COMMIT;

    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := sqlcode;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_GET_ADJ_PLAN',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '获取调整计划');
        COMMIT;

        ROLLBACK;
      END;
  END USP_MP_GET_ADJ_PLAN;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_GET_ORDER_BOM
  --功能描述: 单车BOM接口表数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/09/27
  PROCEDURE USP_MP_GET_ORDER_BOM(ERROR_TAG     OUT NUMBER,
                                 ERROR_MESSAGE OUT VARCHAR2) AS

  BEGIN
    FOR BOM IN (SELECT *
                  FROM IF_ORDER_BOM A
                 WHERE A.DEAL_FLAG = 0
                 AND ROWNUM < 10
                 ORDER BY A.ID, A.CREATION_TIME ASC) LOOP

      --如果操作标志位为D，则删除
      DELETE FROM MM_PUB_ORDER_BOM B
       WHERE B.ORDER_NO = BOM.ORDER_NO
         AND B.FACTORY_CODE = PKG_IF_REC.USF_TRANS_ERP_FACTORY(BOM.COMP);

      --操作标志不为删除
      IF BOM.DO_FLAG != 'D' THEN
        INSERT INTO MM_PUB_ORDER_BOM
          (FACTORY_CODE,
           ORDER_NO,
           MODEL_CODE,
           PART_ROWNO,
           VEHICLE_PART_NO,
           PART_NO,
           WORKCENTER,
           STATION_CODE,
           NUM,
           USAGE_AMOUNT_UNIT,
           PURCHASE_TYPE,
           CREATION_TIME)
          SELECT PKG_IF_REC.USF_TRANS_ERP_FACTORY(BOM.COMP),
                 BOM.ORDER_NO,
                 BOM.MODEL_CODE,
                 C.PART_ROW_NO,
                 C.VEHICLE_PART_NO,
                 C.PART_ID,
                 /*PKG_IF_REC.USF_TRANS_ERP_WORKCENTER(C.WORK_CENTER),*/
                 C.WORK_CENTER,
                 C.LINE_STATION,
                 C.NUM,
                 C.USAGE_AMOUNT_UNIT,
                 C.PURCHASE_TYPE,
                 SYSDATE
            FROM IF_ORDER_BOM_DETAIL C
           WHERE C.ID = BOM.ID;

        --更新单车BOM的处理状态
        UPDATE IF_ORDER_BOM B
           SET B.DEAL_FLAG = 1, B.DEAL_TIME = SYSDATE
         WHERE B.ID = BOM.ID;
      END IF;
      COMMIT;
    END LOOP;

    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := 1;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_GET_ORDER_BOM',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '单车BOM接口表数据写入业务表');
        COMMIT;

        ROLLBACK;
      END;
  END USP_MP_GET_ORDER_BOM;

  --***************************************************************************
  --存储过程名：USP_PUB_PART
  --功能描述: 零件基础数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_PUB_PART(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2) AS

  BEGIN
    --循环接口表
    FOR cur_part IN (SELECT *
                       FROM IF_PART A
                      WHERE A.DEAL_FLAG = 0
                      AND 1=1--A.COMP = '2000'
                      ORDER BY A.ID, A.CREATION_TIME) LOOP
      IF cur_part.PART_ID IS NOT NULL AND
         LENGTH(TRIM(cur_part.PART_ID)) > 0 THEN
        --如果零件不为空，并且零件号长度大于0
        --存在更新，不存在新增
        MERGE INTO MM_PUB_PART C
        USING (SELECT 1 FROM DUAL) B
        ON (C.PART_NO = cur_part.PART_ID AND C.FACTORY_CODE = PKG_IF_REC.USF_TRANS_ERP_FACTORY(cur_part.COMP))
        WHEN MATCHED THEN
          UPDATE
             SET C.PART_NAME_CN       = cur_part.PART_NAME_CN,
                 C.PART_NAME_EN       = cur_part.PART_NAME_EN,
                 C.PART_SPEC          = cur_part.PART_SPEC,
                 C.PURCHASE_TYPE      = cur_part.PURCHASE_TYPE,
                 C.PART_UNIT          = cur_part.PART_UNIT,
                 C.LAST_MODIFIED_TIME = SYSDATE,
                 C.DEAL_FLAG          = 0
        WHEN NOT MATCHED THEN
          INSERT
            (C.PART_NO,
             C.PART_SHORT_NO,
             C.PART_NAME_CN,
             C.PART_NAME_EN,
             C.PART_SPEC,
             C.PURCHASE_TYPE,
             C.PART_UNIT,
             C.CREATION_TIME,
             C.FACTORY_CODE)
          VALUES
            (cur_part.PART_ID,
             cur_part.PART_SHORT_NO,
             cur_part.PART_NAME_CN,
             cur_part.PART_NAME_EN,
             cur_part.PART_SPEC,
             cur_part.PURCHASE_TYPE,
             cur_part.PART_UNIT,
             SYSDATE,
             PKG_IF_REC.USF_TRANS_ERP_FACTORY(cur_part.COMP));

        --判断MM_PUB_PART_UDA 是否存在，不存在新增，存在修改
        MERGE INTO MM_PUB_PART_UDA B
        USING (SELECT cur_part.PART_ID PART_NO,
                      PKG_IF_REC.USF_TRANS_ERP_FACTORY(cur_part.COMP) FACTORY_CODE,
                      cur_part.PART_NAME_CN PART_NAME_CN
                 FROM DUAL) C
        ON (B.PART_NO = C.PART_NO AND B.FACTORY_CODE = C.FACTORY_CODE)
        WHEN MATCHED THEN
          UPDATE
             SET B.PART_NAME_CN       = C.PART_NAME_CN,
                 B.LAST_MODIFIED_TIME = SYSDATE
        WHEN NOT MATCHED THEN
          INSERT
            (B.ID,
             B.PART_NO,
             B.PART_NAME_CN,
             B.FACTORY_CODE,
             B.CREATION_TIME)
          VALUES
            (SEQ_MM_PUB_PART_UDA.NEXTVAL,
             C.PART_NO,
             C.PART_NAME_CN,
             C.FACTORY_CODE,
             SYSDATE);

      END IF;
      --操作完成，更新处理状态
      UPDATE IF_PART A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_part.ID;
    END LOOP;

    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := 1;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);

        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_PART',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '零件基础数据写入业务表');
        COMMIT;

        ROLLBACK;
      END;
  END USP_PUB_PART;

  --***************************************************************************
  --存储过程名：USP_PUB_SUPPLIER
  --功能描述: 供应商基础数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_PUB_SUPPLIER(ERROR_TAG     OUT NUMBER,
                             ERROR_MESSAGE OUT VARCHAR2) AS

  BEGIN
    --循环接口表
    FOR cur_supplier IN (SELECT *
                           FROM IF_SUPPLIER A
                          WHERE A.DEAL_FLAG = 0
                            AND A.SUPPLIER_NO IS NOT NULL
                          ORDER BY A.ID, A.CREATION_TIME) LOOP
      IF cur_supplier.SUPPLIER_NO IS NOT NULL AND
         LENGTH(TRIM(cur_supplier.SUPPLIER_NO)) > 0 THEN
        --如果供应商不为空，并且供应商代码长度大于0
        --存在更新，不存在新增
        MERGE INTO MM_PUB_SUPPLIER C
        USING (SELECT 1 FROM DUAL) B
        ON (C.SUPPLIER_NO = cur_supplier.Supplier_No)
        WHEN MATCHED THEN
          UPDATE
             SET C.SUPPLIER_NAME      = cur_supplier.CHINESE_NAME,
                 C.DETAIL_ADDR        = cur_supplier.DETAIL_ADDR,
                 C.SUP_FACTORY        = cur_supplier.sup_factory_id,
                 C.SUP_STATUS         = cur_supplier.SUP_STATUS,
                 C.EMAIL              = cur_supplier.EMAIL,
                 C.CONTACT            = cur_supplier.CONTACT,
                 C.MOBILE_NO          = cur_supplier.MOBILE_NO,
                 C.TEL_NO             = cur_supplier.TEL_NO,
                 C.LAST_MODIFIED_TIME = SYSDATE,
                 C.DEAL_FLAG          = 0
        WHEN NOT MATCHED THEN
          INSERT
            (C.SUPPLIER_NO,
             C.SUP_FACTORY,
             C.SUPPLIER_NAME,
             C.DETAIL_ADDR,
             C.SUP_STATUS,
             C.EMAIL,
             C.CONTACT,
             C.MOBILE_NO,
             C.TEL_NO,
             C.CREATION_TIME)
          VALUES
            (cur_supplier.SUPPLIER_NO,
             cur_supplier.SUP_FACTORY_ID,
             cur_supplier.CHINESE_NAME,
             cur_supplier.DETAIL_ADDR,
             cur_supplier.SUP_STATUS,
             cur_supplier.EMAIL,
             cur_supplier.CONTACT,
             cur_supplier.MOBILE_NO,
             cur_supplier.TEL_NO,
             SYSDATE);

      END IF;
      --操作完成，更新处理状态
      UPDATE IF_SUPPLIER A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_supplier.ID;
    END LOOP;
    COMMIT;

    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := sqlcode;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_SUPPLIER',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '供应商基础数据写入业务表');
        COMMIT;

        ROLLBACK;
      END;
  END USP_PUB_SUPPLIER;

  --***************************************************************************
  --存储过程名：USP_PUB_PART_SUPPLIER
  --功能描述: 零件供应商关系数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_PUB_PART_SUPPLIER(ERROR_TAG     OUT NUMBER,
                                  ERROR_MESSAGE OUT VARCHAR2) AS

    v_factory_code MM_PUB_PART_SUPPLIER.FACTORY_CODE%type; --工厂
  BEGIN
    --循环接口表
    FOR cur_part_supplier IN (SELECT *
                                FROM IF_PART_SUPPLIER A
                               WHERE A.DEAL_FLAG = 0
                               ORDER BY A.ID, A.CREATION_TIME, A.COMP) LOOP
      --如果供应商不为空，并且供应商代码长度大于0,且零件号不为空，并且零件号长度大于0
      IF cur_part_supplier.SUPPLIER_ID IS NOT NULL AND
         LENGTH(TRIM(cur_part_supplier.SUPPLIER_ID)) > 0 AND
         cur_part_supplier.PART_ID IS NOT NULL AND
         LENGTH(TRIM(cur_part_supplier.PART_ID)) > 0 THEN
        --将ERP工厂转换为物流系统工厂
        v_factory_code := PKG_IF_REC.USF_TRANS_ERP_FACTORY(cur_part_supplier.COMP);
        --判断操作类型
        IF cur_part_supplier.DO_FLAG = 'D' THEN
          --如果为删除标识
          UPDATE MM_PUB_PART_SUPPLIER_HIS C
             SET C.EFF_END = SYSDATE - 1, C.DEAL_FLAG = 0
           WHERE C.PART_NO = cur_part_supplier.PART_ID
             AND C.SUPPLIER_NO = cur_part_supplier.SUPPLIER_ID
             AND C.FACTORY_CODE = v_factory_code;
        ELSE
          --存在更新，不存在新增
          MERGE INTO MM_PUB_PART_SUPPLIER_HIS C
          USING (SELECT 1 FROM DUAL) B
          ON (C.PART_NO = cur_part_supplier.PART_ID AND C.SUPPLIER_NO = cur_part_supplier.Supplier_Id AND C.FACTORY_CODE = v_factory_code)
          WHEN MATCHED THEN
            UPDATE
               SET C.EFF_START          = TO_DATE(cur_part_supplier.EFF_START,
                                                  'YYYY-MM-DD HH24:MI:SS'),
                   C.SUP_FACTORY        = cur_part_supplier.FACTORY_ID,
                   C.EFF_END            = TO_DATE(cur_part_supplier.EFF_END,
                                                  'YYYY-MM-DD HH24:MI:SS'),
                   C.DEAL_FLAG          = 0,
                   C.LAST_MODIFIED_TIME = SYSDATE
          WHEN NOT MATCHED THEN
            INSERT
              (C.FACTORY_CODE,
               C.SUPPLIER_NO,
               C.SUP_FACTORY,
               C.PART_NO,
               C.MIN_ORDER_NUM,
               C.STANDARD_PACKAGE,
               C.IN_PLAN_FORWARD_TIME,
               C.EFF_START,
               C.EFF_END,
               C.CREATION_TIME)
            VALUES
              (v_factory_code,
               cur_part_supplier.SUPPLIER_ID,
               cur_part_supplier.FACTORY_ID,
               cur_part_supplier.PART_ID,
               cur_part_supplier.MIN_NUM,
               cur_part_supplier.STANDARD_PACKAGE,
               cur_part_supplier.IN_PLAN_FORWARD_TIME,
               TO_DATE(cur_part_supplier.EFF_START, 'YYYY-MM-DD HH24:MI:SS'),
               TO_DATE(cur_part_supplier.EFF_END, 'YYYY-MM-DD HH24:MI:SS'),
               SYSDATE);
        END IF;

      END IF;
      --操作完成，更新处理状态
      UPDATE IF_PART_SUPPLIER A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_part_supplier.ID;
    END LOOP;

    COMMIT;
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := sqlcode;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_PART_SUPPLIER',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '零件供应商关系数据写入业务表');
        COMMIT;

        ROLLBACK;
      END;
  END USP_PUB_PART_SUPPLIER;

  --***************************************************************************
  --存储过程名：USP_PUB_SUPER_BOM
  --功能描述: 超级BOM写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2019/04/08
  PROCEDURE USP_PUB_SUPER_BOM(ERROR_TAG     OUT NUMBER,
                              ERROR_MESSAGE OUT VARCHAR2) AS

  BEGIN
    --循环接口表
    FOR cur_super_bom IN (SELECT *
                            FROM IF_SUPER_BOM A
                           WHERE A.DEAL_FLAG = 0
                           ORDER BY A.ID, A.CREATION_TIME, A.FACTORY_CODE) LOOP
      --主键字段不为空
      IF cur_super_bom.FACTORY_CODE IS NOT NULL AND
         LENGTH(TRIM(cur_super_bom.FACTORY_CODE)) > 0 AND
         cur_super_bom.parent_part_code IS NOT NULL AND
         LENGTH(TRIM(cur_super_bom.parent_part_code)) > 0 AND
         cur_super_bom.Line_No IS NOT NULL AND
         LENGTH(TRIM(cur_super_bom.Line_No)) > 0 THEN
        --判断操作类型
        IF cur_super_bom.DO_FLAG = 'D' THEN
          DELETE FROM MM_PUB_SUPER_BOM B
           WHERE B.FACTORY_CODE = cur_super_bom.Factory_Code
             AND B.PARENT_PART_CODE = cur_super_bom.Parent_Part_Code
             AND B.LINE_NO = cur_super_bom.LINE_NO;
        ELSE
          --存在更新，不存在新增
          MERGE INTO MM_PUB_SUPER_BOM C
          USING (SELECT 1 FROM DUAL) B
          ON (C.FACTORY_CODE = cur_super_bom.Factory_Code AND C.PARENT_PART_CODE = cur_super_bom.PARENT_PART_CODE AND C.LINE_NO = cur_super_bom.LINE_NO)
          WHEN MATCHED THEN
            UPDATE
               SET C.MODEL_CODE         = cur_super_bom.Model_Code,
                   C.PART_NO            = cur_super_bom.PART_NO,
                   C.PART_NAME_CN       = cur_super_bom.Part_Name_Cn,
                   C.PART_NAME_EN       = cur_super_bom.Part_Name_En,
                   C.PART_VERSION       = cur_super_bom.Part_Version,
                   C.UC                 = cur_super_bom.UC,
                   C.AMOUNT             = cur_super_bom.Amount,
                   C.UNIT_CODE          = cur_super_bom.Unit_Code,
                   C.PLATE_CODE         = cur_super_bom.Plate_Code,
                   C.PURCHASE_TYPE      = cur_super_bom.purchase_type,
                   C.NEXT_PLACEMENT     = cur_super_bom.Next_Placement,
                   C.PROCESS_TYPE       = cur_super_bom.Process_Type,
                   C.PLAN_EFF_START     = cur_super_bom.Plan_Eff_Start,
                   C.PLAN_EFF_END       = cur_super_bom.Plan_Eff_End,
                   C.ACTUAL_EFF_START   = cur_super_bom.Actual_Eff_Start,
                   C.ACTUAL_EFF_END     = cur_super_bom.Actual_Eff_End,
                   C.PCO                = cur_super_bom.PCO,
                   C.RAW_NUM            = cur_super_bom.Raw_Num,
                   C.GACNE_KEY_PART     = cur_super_bom.Gacne_Key_Part,
                   C.INTER_CHANGE_GROUP = cur_super_bom.Inter_Change_Group,
                   C.AFTER_SALE_FLAG    = cur_super_bom.After_Sale_Flag,
                   C.LAST_MODIFIED_TIME = SYSDATE
          WHEN NOT MATCHED THEN
            INSERT
              (C.MODEL_CODE,
               C.FACTORY_CODE,
               C.PART_NO,
               C.PARENT_PART_CODE,
               C.PART_NAME_CN,
               C.PART_NAME_EN,
               C.PART_VERSION,
               C.LINE_NO,
               C.UC,
               C.AMOUNT,
               C.UNIT_CODE,
               C.PLATE_CODE,
               C.PURCHASE_TYPE,
               C.NEXT_PLACEMENT,
               C.PROCESS_TYPE,
               C.PLAN_EFF_START,
               C.PLAN_EFF_END,
               C.ACTUAL_EFF_START,
               C.ACTUAL_EFF_END,
               C.PCO,
               C.RAW_NUM,
               C.GACNE_KEY_PART,
               C.INTER_CHANGE_GROUP,
               C.AFTER_SALE_FLAG,
               C.CREATION_TIME,
               C.CREATION_USER)
            VALUES
              (cur_super_bom.Model_Code,
               cur_super_bom.Factory_Code,
               cur_super_bom.Part_No,
               cur_super_bom.Parent_Part_Code,
               cur_super_bom.Part_Name_Cn,
               cur_super_bom.Part_Name_En,
               cur_super_bom.Part_Version,
               cur_super_bom.Line_No,
               cur_super_bom.Uc,
               cur_super_bom.Amount,
               cur_super_bom.Unit_Code,
               cur_super_bom.Plate_Code,
               cur_super_bom.Purchase_Type,
               cur_super_bom.Next_Placement,
               cur_super_bom.Process_Type,
               cur_super_bom.Plan_Eff_Start,
               cur_super_bom.Plan_Eff_End,
               cur_super_bom.Actual_Eff_Start,
               cur_super_bom.Actual_Eff_End,
               cur_super_bom.Pco,
               cur_super_bom.Raw_Num,
               cur_super_bom.Gacne_Key_Part,
               cur_super_bom.Inter_Change_Group,
               cur_super_bom.After_Sale_Flag,
               SYSDATE,
               'SYSTEM');
        END IF;

      END IF;
      --操作完成，更新处理状态
      UPDATE IF_SUPER_BOM A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_super_bom.ID;
    END LOOP;

    COMMIT;
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := sqlcode;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_SUPER_BOM',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '超级BOM写入业务表');
        COMMIT;

        ROLLBACK;
      END;
  END USP_PUB_SUPER_BOM;

  --***************************************************************************
  --存储过程名：USP_PUB_TACT_TIME
  --功能描述: 车间生产节拍写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_PUB_TACT_TIME(ERROR_TAG     OUT NUMBER,
                              ERROR_MESSAGE OUT VARCHAR2) AS

  BEGIN
    --循环接口表
    FOR cur_tact IN (SELECT *
                       FROM IF_TACT_TIME A
                      WHERE A.DEAL_FLAG = 0
                      ORDER BY A.ID, A.CREATION_TIME, A.FACTORY_CODE) LOOP
      IF cur_tact.DOFLAG = 'D' THEN
        --根据主键删除车间生产节拍数据
        DELETE FROM MM_PUB_TACT_TIME C
         WHERE C.FACTORY_CODE =
               PKG_IF_REC.USF_TRANS_MES_FACTORY(cur_tact.FACTORY_CODE)
           AND C.WORKCENTER = cur_tact.WORK_CENTER
           AND C.PRODUCTION_LINE = cur_tact.PRO_LINE;
      ELSE
        --如果存在更新数据，不存在新增数据
        MERGE INTO MM_PUB_TACT_TIME C
        USING (SELECT 1 FROM DUAL) B
        ON (C.FACTORY_CODE = PKG_IF_REC.USF_TRANS_MES_FACTORY(cur_tact.FACTORY_CODE) AND C.WORKCENTER = cur_tact.WORK_CENTER AND C.PRODUCTION_LINE = cur_tact.PRO_LINE)
        WHEN MATCHED THEN
          UPDATE
             SET C.JPH                = cur_tact.JPH,
                 C.OEE                = cur_tact.OEE,
                 C.PRODUCE_TIME       = cur_tact.PRODUCE_TIME,
                 C.PRO_CAPACITY       = cur_tact.PRO_CAPACITY,
                 C.REMARK             = cur_tact.REMARK,
                 C.LAST_MODIFIED_TIME = SYSDATE
        WHEN NOT MATCHED THEN
          INSERT
            (C.FACTORY_CODE,
             C.WORKCENTER,
             C.PRODUCTION_LINE,
             C.EFF_DATE,
             C.JPH,
             C.OEE,
             C.PRODUCE_TIME,
             C.PRO_CAPACITY,
             C.REMARK,
             C.CREATION_TIME)
          VALUES
            (PKG_IF_REC.USF_TRANS_MES_FACTORY(cur_tact.FACTORY_CODE),
             cur_tact.WORK_CENTER,
             cur_tact.PRO_LINE,
             TO_DATE(cur_tact.EFF_DATE, 'YYYY-MM-DD'),
             cur_tact.JPH,
             cur_tact.OEE,
             cur_tact.PRODUCE_TIME,
             cur_tact.PRO_CAPACITY,
             cur_tact.REMARK,
             SYSDATE);

      END IF;
      --操作完成，更新处理状态
      UPDATE IF_TACT_TIME A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_tact.ID;
    END LOOP;

    COMMIT;

    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := sqlcode;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_TACT_TIME',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '车间生产节拍写入业务表');
        COMMIT;

        ROLLBACK;
      END;
  END USP_PUB_TACT_TIME;

  --***************************************************************************
  --存储过程名：USP_PUB_WORK_CALENDAR
  --功能描述: 工作日历写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_PUB_WORK_CALENDAR(ERROR_TAG     OUT NUMBER,
                                  ERROR_MESSAGE OUT VARCHAR2) AS
    v_count NUMBER(10);
  BEGIN
    --循环接口表
    FOR cur_calendar IN (SELECT A.ID_CALENDAR,
                                A.FACTORY_CODE,
                                A.WORK_CENTER,
                                A.SHIFT_CODE,
                                A.WORK_DATE,
                                A.WORK_START_TIME,
                                A.WORK_END_TIME,
                                A.DO_FLAG,
                                A.ID
                           FROM IF_WORK_CALENDAR A
                          WHERE A.DEAL_FLAG = 0
                          ORDER BY A.ID, A.CREATION_TIME) LOOP

      --删除工作日历明细表
      DELETE FROM MM_PUB_WORK_CALENDAR_DETAIL C
       WHERE C.WORK_CALENDAR_ID = cur_calendar.ID_CALENDAR;

      --判断处理标识
      IF cur_calendar.DO_FLAG = 'D' THEN
        --如果为删除标志,删除工作日历头表
        DELETE FROM MM_PUB_WORK_CALENDAR C
         WHERE C.ID = cur_calendar.ID_CALENDAR
           AND C.FACTORY_CODE =
               PKG_IF_REC.USF_TRANS_MES_FACTORY(cur_calendar.FACTORY_CODE);

      ELSE
        SELECT COUNT(1)
          INTO v_count
          FROM MM_PUB_WORK_CALENDAR B
         WHERE B.WORKCENTER = cur_calendar.Work_Center
           AND B.SHIFT_CODE = cur_calendar.Shift_Code
           AND B.WORK_DATE = TO_DATE(cur_calendar.WORK_DATE, 'YYYY-MM-DD')
           AND B.FACTORY_CODE =
               PKG_IF_REC.USF_TRANS_MES_FACTORY(cur_calendar.FACTORY_CODE);

        IF v_count > 0 THEN
          UPDATE MM_PUB_WORK_CALENDAR B
             SET B.WORK_START_TIME    = TO_DATE(cur_calendar.WORK_START_TIME,
                                                'YYYY-MM-DD HH24:MI:SS'),
                 B.WORK_END_TIME      = TO_DATE(cur_calendar.WORK_END_TIME,
                                                'YYYY-MM-DD HH24:MI:SS'),
                 B.LAST_MODIFIED_TIME = SYSDATE
           WHERE B.ID = cur_calendar.ID;
        ELSE
          INSERT INTO MM_PUB_WORK_CALENDAR
            (ID,
             FACTORY_CODE,
             WORKCENTER,
             SHIFT_CODE,
             WORK_DATE,
             WORK_START_TIME,
             WORK_END_TIME,
             CREATION_TIME)
          VALUES
            (cur_calendar.ID_CALENDAR,
             PKG_IF_REC.USF_TRANS_MES_FACTORY(cur_calendar.FACTORY_CODE),
             PKG_IF_REC.USF_TRANS_MES_WORKCENTER(cur_calendar.WORK_CENTER),
             cur_calendar.SHIFT_CODE,
             TO_DATE(cur_calendar.WORK_DATE, 'YYYY-MM-DD'),
             TO_DATE(cur_calendar.WORK_START_TIME, 'YYYY-MM-DD HH24:MI:SS'),
             TO_DATE(cur_calendar.WORK_END_TIME, 'YYYY-MM-DD HH24:MI:SS'),
             SYSDATE);
        END IF;
        /*        --判断存在更新，不存在新增
                MERGE INTO MM_PUB_WORK_CALENDAR B
                USING (SELECT *
                         FROM IF_WORK_CALENDAR C
                        WHERE C.ID = cur_calendar.id_calendar
                          AND C.FACTORY_CODE =
                              PKG_IF_REC.USF_TRANS_MES_FACTORY(cur_calendar.FACTORY_CODE)) D
                ON (B.WORKCENTER = D.WORK_CENTER AND B.FACTORY_CODE = D.FACTORY_CODE AND B.SHIFT_CODE = D.SHIFT_CODE AND B.WORK_DATE = TO_CHAR(D.WORK_DATE, 'YYYY-MM-DD'))
                WHEN MATCHED THEN
                  UPDATE
                     SET B.WORK_START_TIME    = TO_DATE(cur_calendar.WORK_START_TIME,
                                                        'YYYY-MM-DD HH24:MI:SS'),
                         B.WORK_END_TIME      = TO_DATE(cur_calendar.WORK_END_TIME,
                                                        'YYYY-MM-DD HH24:MI:SS'),
                         B.LAST_MODIFIED_TIME = SYSDATE
                WHEN NOT MATCHED THEN
                  INSERT
                    (ID,
                     FACTORY_CODE,
                     WORKCENTER,
                     SHIFT_CODE,
                     WORK_DATE,
                     WORK_START_TIME,
                     WORK_END_TIME,
                     CREATION_TIME)
                  VALUES
                    (cur_calendar.ID_CALENDAR,
                     PKG_IF_REC.USF_TRANS_MES_FACTORY(cur_calendar.FACTORY_CODE),
                     PKG_IF_REC.USF_TRANS_MES_WORKCENTER(cur_calendar.WORK_CENTER),
                     cur_calendar.SHIFT_CODE,
                     TO_DATE(cur_calendar.WORK_DATE, 'YYYY-MM-DD'),
                     TO_DATE(cur_calendar.WORK_START_TIME, 'YYYY-MM-DD HH24:MI:SS'),
                     TO_DATE(cur_calendar.WORK_END_TIME, 'YYYY-MM-DD HH24:MI:SS'),
                     SYSDATE);
        */
        FOR cur_calendar_detail IN (SELECT *
                                      FROM IF_WORK_CALENDAR_DETAIL B
                                     WHERE B.ID = cur_calendar.ID) LOOP
          --新增工作日历数据
          INSERT INTO MM_PUB_WORK_CALENDAR_DETAIL
            (WORK_CALENDAR_ID, ID, START_TIME, END_TIME, TIME_TYPE)
          VALUES
            (cur_calendar.ID_CALENDAR,
             SEQ_MM_PUB_CALENDAR_DETAIL.NEXTVAL,
             TO_DATE(cur_calendar_detail.START_TIME,
                     'YYYY-MM-DD HH24:MI:SS'),
             TO_DATE(cur_calendar_detail.END_TIME, 'YYYY-MM-DD HH24:MI:SS'),
             cur_calendar_detail.Time_Type);
        END LOOP;

      END IF;
      --操作完成，更新处理状态
      UPDATE IF_WORK_CALENDAR A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_calendar.ID;
    END LOOP;

    COMMIT;
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := sqlcode;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_WORK_CALENDAR',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '工作日历写入业务表');
        COMMIT;

        ROLLBACK;
      END;
  END USP_PUB_WORK_CALENDAR;

  --***************************************************************************
  --存储过程名：USP_PUB_MODEL_BOM
  --功能描述: 物料与车型关系写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE USP_PUB_MODEL_BOM(ERROR_TAG     OUT NUMBER,
                              ERROR_MESSAGE OUT VARCHAR2) AS
  BEGIN
    --循环接口表
    FOR cur_mto IN (SELECT *
                      FROM IF_MODEL_BOM A
                     WHERE A.DEAL_FLAG = 0
                     ORDER BY A.ID, A.CREATION_TIME, A.FACTORY_CODE) LOOP
      --判断操作标识
      IF cur_mto.DO_FLAG = 'D' THEN
        --如果为删除标识
        DELETE FROM MM_PUB_MODEL_BOM B
         WHERE B.MTO = cur_mto.MTO
           AND B.FACTORY_CODE =
               PKG_IF_REC.USF_TRANS_ERP_FACTORY(cur_mto.FACTORY_CODE)
           AND B.PART_NO = cur_mto.PART_ID
           AND B.STATION_CODE = cur_mto.LINE_STATION;
      ELSE
        --存在更新，否则新增
        MERGE INTO MM_PUB_MODEL_BOM B
        USING (SELECT 1 FROM DUAL) C
        ON (B.MTO = cur_mto.MTO AND B.FACTORY_CODE = PKG_IF_REC.USF_TRANS_ERP_FACTORY(cur_mto.FACTORY_CODE) AND B.PART_NO = cur_mto.PART_ID AND B.STATION_CODE = cur_mto.LINE_STATION)
        WHEN MATCHED THEN
          UPDATE
             SET B.STAGE              = cur_mto.STAGE,
                 B.VERSION            = cur_mto.VERSION,
                 B.PURCHASE_TYPE      = cur_mto.PURCHASE_TYPE,
                 B.FEATURE            = cur_mto.FEATURE,
                 B.NUM                = cur_mto.NUM,
                 B.PART_UNIT          = cur_mto.PART_UNIT,
                 B.SUPPLIER_NO        = cur_mto.SUPPLIER_NO,
                 B.NEXT_PLACEMENT     = cur_mto.NEXT_PLACEMENT,
                 B.PROCESS            = cur_mto.PROCESS,
                 B.A                  = cur_mto.A,
                 B.B                  = cur_mto.B,
                 B.C                  = cur_mto.C,
                 B.EFF_START          = TO_DATE(cur_mto.EFF_START,
                                                'YYYY-MM-DD'),
                 B.EFF_END            = TO_DATE(cur_mto.EFF_END,
                                                'YYYY-MM-DD'),
                 B.LAST_MODIFIED_TIME = SYSDATE
        WHEN NOT MATCHED THEN
          INSERT
            (B.FACTORY_CODE,
             B.MTO,
             B.PART_NO,
             B.MODEL_CODE,
             B.STATION_CODE,
             B.STAGE,
             B.VERSION,
             B.PURCHASE_TYPE,
             B.FEATURE,
             B.NUM,
             B.PART_UNIT,
             B.SUPPLIER_NO,
             B.NEXT_PLACEMENT,
             B.PROCESS,
             B.A,
             B.B,
             B.C,
             B.EFF_START,
             B.EFF_END,
             B.CREATION_TIME)
          VALUES
            (PKG_IF_REC.USF_TRANS_ERP_FACTORY(cur_mto.FACTORY_CODE),
             cur_mto.MTO,
             cur_mto.PART_ID,
             cur_mto.VEHICLE_TYPE,
             cur_mto.LINE_STATION,
             cur_mto.STAGE,
             cur_mto.VERSION,
             cur_mto.PURCHASE_TYPE,
             cur_mto.FEATURE,
             cur_mto.NUM,
             cur_mto.PART_UNIT,
             cur_mto.SUPPLIER_NO,
             cur_mto.NEXT_PLACEMENT,
             cur_mto.PROCESS,
             cur_mto.A,
             cur_mto.B,
             cur_mto.C,
             TO_DATE(cur_mto.EFF_START, 'YYYY-MM-DD'),
             TO_DATE(cur_mto.EFF_END, 'YYYY-MM-DD'),
             SYSDATE);

      END IF;
      --操作完成，更新处理状态
      UPDATE IF_MODEL_BOM A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_mto.ID;
    END LOOP;
    COMMIT;

    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := sqlcode;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_MODEL_BOM',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '物料与车型关系写入业务表');
        COMMIT;

        ROLLBACK;
      END;
  END USP_PUB_MODEL_BOM;

  --***************************************************************************
  --存储过程名：USP_PUB_WAREHOUSE
  --功能描述: 仓库主数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE USP_PUB_WAREHOUSE(ERROR_TAG     OUT NUMBER,
                              ERROR_MESSAGE OUT VARCHAR2) AS

  BEGIN
    --循环接口表
    FOR cur_warehouse IN (SELECT *
                            FROM IF_INV_WAREHOUSE A
                           WHERE A.DEAL_FLAG = 0
                           ORDER BY A.ID, A.CREATION_TIME, A.COMP) LOOP
      --存在更新，不存在新增
      MERGE INTO MM_PUB_WAREHOUSE B
      USING (SELECT 1 FROM DUAL) C
      ON (B.FACTORY_CODE = PKG_IF_REC.USF_TRANS_ERP_FACTORY(cur_warehouse.COMP) AND B.WAREHOUSE_ID = cur_warehouse.WAREHOUSE_ID)
      WHEN MATCHED THEN
        UPDATE
           SET B.WAREHOUSE_NAME     = cur_warehouse.WAREHOUSE_NAME,
               B.LAST_MODIFIED_TIME = SYSDATE
      WHEN NOT MATCHED THEN
        INSERT
          (B.FACTORY_CODE,
           B.WAREHOUSE_ID,
           B.WAREHOUSE_NAME,
           B.CREATION_TIME)
        VALUES
          (PKG_IF_REC.USF_TRANS_ERP_FACTORY(cur_warehouse.COMP),
           cur_warehouse.WAREHOUSE_ID,
           cur_warehouse.WAREHOUSE_NAME,
           SYSDATE);

      --操作完成，更新处理状态
      UPDATE IF_INV_WAREHOUSE A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_warehouse.ID;
    END LOOP;

    COMMIT;
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := 1;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_WAREHOUSE',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '仓库主数据写入业务表');
        COMMIT;

        ROLLBACK;
      END;
  END USP_PUB_WAREHOUSE;

  --***************************************************************************
  --存储过程名：USP_PUB_PRO_ROUTE
  --功能描述: 工艺路线写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE USP_PUB_PRO_ROUTE(ERROR_TAG     OUT NUMBER,
                              ERROR_MESSAGE OUT VARCHAR2) AS
    v_id       MM_PUB_PRO_ROUTE.ID%type;
    v_count    number;
    id_nextval number;
  BEGIN
    --循环接口表
    FOR cur_pro_route IN (SELECT *
                            FROM IF_PRO_ROUTE A
                           WHERE A.DEAL_FLAG = 0
                           ORDER BY A.ID, A.CREATION_TIME, A.FACTORY_CODE) LOOP
      --查询该条记录对应的ID
      SELECT C.ID
        INTO v_id
        FROM MM_PUB_PRO_ROUTE C
       WHERE C.FACTORY_CODE = cur_pro_route.FACTORY_CODE
         AND C.ROUTE_CODE = cur_pro_route.ROUTE_CODE;
      --如果能查到这条记录，删除这条记录下对应的明细数据
      DELETE FROM MM_PUB_PRO_ROUTE_DETAIL C WHERE C.ROUTE_ID = v_id;
      IF cur_pro_route.DO_FLAG = 'D' THEN
        --如果操作标识为删除
        --根据主键删除头表数据
        DELETE FROM MM_PUB_PRO_ROUTE C
         WHERE C.FACTORY_CODE = cur_pro_route.FACTORY_CODE
           AND C.ROUTE_CODE = cur_pro_route.ROUTE_CODE;
      ELSE
        SELECT COUNT(C.ID)
          INTO v_count
          FROM MM_PUB_PRO_ROUTE C
         WHERE C.FACTORY_CODE = cur_pro_route.FACTORY_CODE
           AND C.ROUTE_CODE = cur_pro_route.ROUTE_CODE;

        --表明存在
        IF v_count > 0 THEN
          --更新工艺路线头表
          UPDATE MM_PUB_PRO_ROUTE C
             SET C.ROUTE_NAME         = cur_pro_route.ROUTE_NAME,
                 C.LAST_MODIFIED_TIME = SYSDATE
           WHERE C.ID = v_id;
          --新增工艺路线明细
          INSERT INTO MM_PUB_PRO_ROUTE_DETAIL
            (ROUTE_ID,
             WORK_CENTER,
             STATION_CODE,
             STATION_NAME,
             STATION_ORDER_BY)
            SELECT v_id,
                   C.WORK_CENTER,
                   C.STATION_CODE,
                   C.STATION_NAME,
                   C.STATION_ORDER_BY
              FROM IF_PRO_ROUTE_DETAIL C
             WHERE C.ID = cur_pro_route.ID;
        ELSE
          id_nextval := SEQ_MM_PUB_PRO_ROUTE.NEXTVAL;
          --新增工艺路线头表
          INSERT INTO MM_PUB_PRO_ROUTE
            (ID, FACTORY_CODE, ROUTE_CODE, ROUTE_NAME, CREATION_TIME)
          VALUES
            (id_nextval,
             cur_pro_route.FACTORY_CODE,
             cur_pro_route.ROUTE_CODE,
             cur_pro_route.ROUTE_NAME,
             SYSDATE);

          --新增工艺路线明细
          INSERT INTO MM_PUB_PRO_ROUTE_DETAIL
            (ROUTE_ID,
             WORK_CENTER,
             STATION_CODE,
             STATION_NAME,
             STATION_ORDER_BY)
            SELECT id_nextval,
                   C.WORK_CENTER,
                   C.STATION_CODE,
                   C.STATION_NAME,
                   C.STATION_ORDER_BY
              FROM IF_PRO_ROUTE_DETAIL C
             WHERE C.ID = id_nextval;

        END IF;
      END IF;
      --操作完成，更新处理状态
      UPDATE IF_PRO_ROUTE A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_pro_route.ID;
    END LOOP;

    COMMIT;
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := sqlcode;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_PRO_ROUTE',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '工艺路线写入业务表');
        COMMIT;

        ROLLBACK;
      END;
  END USP_PUB_PRO_ROUTE;

  --***************************************************************************
  --存储过程名：USP_KEYPART_BIND
  --功能描述: 关键件批次件处理
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/30
  PROCEDURE USP_KEYPART_BIND(ERROR_TAG     OUT NUMBER,
                             ERROR_MESSAGE OUT VARCHAR2) AS

  BEGIN
    FOR cur_keypart IN (SELECT *
                          FROM IF_KEYPART_BIND A
                         WHERE A.DEAL_FLAG = 0
                         ORDER BY A.ID, A.CREATION_TIME, A.FACTORY_CODE) LOOP
      --写入业务表
      INSERT INTO MM_PUB_KEYPART_BIND
        (ID,
         FACTORY_CODE,
         ORDER_NO,
         STATION_CODE,
         PART_BAR_CODE,
         PART_NO,
         BIND_NUM,
         VIN,
         KEY_PART_TYPE,
         CREATION_TIME)
      VALUES
        (SEQ_MM_PUB_KEYPART_BIND.NEXTVAL,
         cur_keypart.FACTORY_CODE,
         cur_keypart.ORDER_NO,
         cur_keypart.STATION_CODE,
         cur_keypart.PART_BAR_CODE,
         cur_keypart.PART_NO,
         cur_keypart.BIND_NUM,
         cur_keypart.VIN,
         cur_keypart.KEY_PART_TYPE,
         SYSDATE);

      --更新成功，更新导入状态
      UPDATE IF_KEYPART_BIND A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_keypart.ID;
    END LOOP;
    COMMIT;
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := sqlcode;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_KEYPART_BIND',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '关键件批次件处理');
        COMMIT;

        ROLLBACK;
      END;
  END USP_KEYPART_BIND;

  /*--***************************************************************************
  --存储过程名：USP_SW_ORDER
  --功能描述: 采购订单处理
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/11/16
  PROCEDURE USP_SW_ORDER(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2) AS

  BEGIN
    FOR cur_order IN (SELECT *
                        FROM IF_SW_ORDER A
                       WHERE A.DEAL_FLAG = 0
                       ORDER BY A.ID, A.CREATION_TIME, A.COMP) LOOP

      MERGE INTO MM_SW_ORDER B
      USING (SELECT 1 FROM DUAL) C
      ON (B.PURCHASE_NO = cur_order.PURCHASE_ORDER_NO AND B.FACTORY_CODE = cur_order.COMP)
      WHEN MATCHED THEN
        UPDATE
           SET B.ORDER_NO           = cur_order.LOGISTICS_ORDERNO,
               B.SUPPLIER_NO        = cur_order.SUPPLIER_NO,
               B.SUP_FACTORY        = cur_order.SUP_SHIPMENT_PLACE_NO,
               B.ORDER_TYPE         = cur_order.ORDER_TYPE,
               B.ORDER_DATE         = TO_DATE(cur_order.ORDER_ISSUE_DATE,
                                              'YYYY-MM-DD HH24:MI:SS'),
               B.ARRIVE_DATE        = TO_DATE(cur_order.DAO_HUO_TIME,
                                              'YYYY-MM-DD HH24:MI:SS'),
               B.LAST_MODIFIED_USER = 'ADMIN',
               B.LAST_MODIFIED_TIME = SYSDATE,
               B.DEPOT_NO           = cur_order.DEPOT_NO,
               B.SP_TYPE            = cur_order.SP_TYPE;

      --循环当前订单头下的明细数据
      FOR cur_detail IN (SELECT *
                           FROM IF_SW_ORDER_DETAIL A
                          WHERE A.ID = cur_order.ID) LOOP
        IF cur_detail.DO_FLAG = 'U' THEN
          DELETE FROM MM_DPM_AREA;
        ELSE
          DELETE FROM MM_DPM_AREA;
        END IF;
      END LOOP;

      --更新成功，更新导入状态
      UPDATE IF_SW_ORDER A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_order.ID;
    END LOOP;

    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := sqlcode;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_SW_ORDER',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '采购订单写入业务表');
        COMMIT;

        ROLLBACK;
      END;
  END USP_SW_ORDER;*/

  --****************************************************************************
  --过程名  : USP_SW_IF_TO_ORDER
  --功能描述: 订单接口数据至业务表
  --参数说明: 工厂代码
  --创建人员: ZHENGWUCHAO
  --创建时间: 2018-10-22
  --****************************************************************************
  PROCEDURE USP_SW_IF_TO_ORDER(ERROR_TAG     OUT NUMBER,
                               ERROR_MESSAGE OUT VARCHAR2) AS
    V_ORDER_NO           VARCHAR2(50);
    V_NUM                VARCHAR2(5);
    V_SP_TYPE            VARCHAR2(5); --售后件类型（内制件，外采件，直供件）
    V_DEPOT_NO           VARCHAR2(100);
    V_ORDER_NO_DATEIL    VARCHAR2(50);
    V_ORDER_ROWNO_DATEIL NUMBER(20);
    V_DEPOT_DETAIL       VARCHAR2(100);
    V_FLAG               NUMBER(1); --临时标识 mod by wxl 20190418
  BEGIN
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
    FOR SUB_ORDER IN (SELECT O.ID,
                             O.COMP,
                             O.PURCHASE_ORDER_NO,
                             O.LOGISTICS_ORDERNO,
                             O.SUPPLIER_NO,
                             O.SUP_SHIPMENT_PLACE_NO,
                             DECODE(O.ORDER_TYPE,
                                    'Z009',
                                    '09',
                                    'Z014',
                                    '01',
                                    'Z007',
                                    '02',
                                    'Z006',
                                    '03',
                                    'Z005',
                                    '04',
                                    'Z012',
                                    '05',
                                    'Z010',
                                    '10',
                                    'Z004',
                                    '11',
                                    'Z008',
                                    '12',
                                    'Z013',
                                    '14') ORDER_TYPE,
                             O.ORDER_PLACE,
                             O.ORDER_ISSUE_DATE,
                             O.DAO_HUO_TIME,
                             O.DEPOT_NO,
                             O.SP_TYPE,
                             O.HMS_ORDER_NO,
                             O.REC_ADDRESS,
                             O.REC_USER,
                             O.PLANNER,
                             O.REC_TEL,
                             O.UDA1,
                             O.UDA2,
                             O.UDA3,
                             O.UDA4,
                             O.UDA5
                        FROM IF_SW_ORDER O
                       WHERE O.DEAL_FLAG = 0
                            --不写入零件订单，拉动订单，同步订单，例外，试制
                         AND O.ORDER_TYPE NOT IN
                             ('Z014', 'Z006', 'Z005', 'Z007', 'Z012')
                       ORDER BY O.ID, O.CREATION_TIME ASC) LOOP
      V_SP_TYPE      := '';
      V_DEPOT_DETAIL := '';
      IF SUB_ORDER.ORDER_TYPE = '12' THEN
        V_SP_TYPE := SUB_ORDER.SP_TYPE;
      END IF;

      IF SUB_ORDER.ORDER_TYPE = '11' OR SUB_ORDER.ORDER_TYPE = '12' OR
         SUB_ORDER.ORDER_TYPE = '14' OR SUB_ORDER.ORDER_TYPE = '10' THEN
        V_ORDER_NO := SUB_ORDER.PURCHASE_ORDER_NO;
      ELSE
        V_ORDER_NO := SUB_ORDER.LOGISTICS_ORDERNO;
      END IF;

      BEGIN
        SELECT A.DEPOT_NO
          INTO V_DEPOT_DETAIL
          FROM IF_SW_ORDER_DETAIL A
         WHERE A.ID = SUB_ORDER.ID
           AND A.DEPOT_NO IS NOT NULL
           AND ROWNUM = 1;
      EXCEPTION
        WHEN OTHERS THEN
          V_DEPOT_DETAIL := NULL;
      END;
      SELECT COUNT(1)
        INTO V_NUM
        FROM MM_SW_ORDER T
       WHERE T.PURCHASE_NO = SUB_ORDER.PURCHASE_ORDER_NO;

      IF V_NUM > 0 THEN
        UPDATE MM_SW_ORDER T
           SET T.ORDER_NO           = V_ORDER_NO,
               T.ORDER_TYPE         = SUB_ORDER.ORDER_TYPE,
               T.FACTORY_CODE       = SUB_ORDER.COMP,
               T.SUPPLIER_NO        = SUB_ORDER.SUPPLIER_NO,
               T.ORDER_DATE         = TO_DATE(SUB_ORDER.ORDER_ISSUE_DATE,
                                              'YYYY-MM-DD HH24:MI:SS'),
               T.LAST_MODIFIED_TIME = SYSDATE,
               T.DEPOT_NO           = NVL(SUB_ORDER.DEPOT_NO, V_DEPOT_DETAIL),
               T.SP_TYPE            = SP_TYPE,
               T.ARRIVE_DATE        = TO_DATE(SUB_ORDER.DAO_HUO_TIME,
                                              'YYYY-MM-DD HH24:MI:SS'),
               T.DEAL_FLAG          = '0',
               T.SUP_FACTORY        = SUB_ORDER.SUP_SHIPMENT_PLACE_NO
         WHERE T.PURCHASE_NO = SUB_ORDER.PURCHASE_ORDER_NO;
      ELSE
        INSERT INTO MM_SW_ORDER
          (PURCHASE_NO,
           ORDER_NO,
           ORDER_TYPE,
           FACTORY_CODE,
           SUPPLIER_NO,
           ORDER_DATE,
           PRINT_STATUS,
           LABEL_PRINT_STATUS,
           DELIVERY_STATUS,
           DOWNLOAD_STATUS,
           CREATION_TIME,
           LAST_MODIFIED_TIME,
           DEPOT_NO,
           PREPARE_STATUS,
           SP_TYPE,
           ARRIVE_DATE,
           REC_USER,
           REC_TEL,
           PLANNER,
           SUP_FACTORY)
        VALUES
          (SUB_ORDER.PURCHASE_ORDER_NO,
           V_ORDER_NO,
           SUB_ORDER.ORDER_TYPE,
           SUB_ORDER.COMP,
           SUB_ORDER.SUPPLIER_NO,
           TO_DATE(SUB_ORDER.ORDER_ISSUE_DATE, 'YYYY-MM-DD HH24:MI:SS'),
           0,
           0,
           0,
           0,
           SYSDATE,
           SYSDATE,
           NVL(SUB_ORDER.DEPOT_NO, V_DEPOT_DETAIL),
           0,
           V_SP_TYPE,
           TO_DATE(SUB_ORDER.DAO_HUO_TIME, 'YYYY-MM-DD HH24:MI:SS'),
           SUB_ORDER.Rec_User,
           SUB_ORDER.Rec_Tel,
           SUB_ORDER.Planner,
           SUB_ORDER.SUP_SHIPMENT_PLACE_NO);
      END IF;

      FOR SUB_ORDER_DETAIL IN (SELECT *
                                 FROM IF_SW_ORDER_DETAIL T
                                WHERE T.ID = SUB_ORDER.ID) LOOP

        IF SUB_ORDER.ORDER_TYPE = '11' OR SUB_ORDER.ORDER_TYPE = '12' OR
           SUB_ORDER.ORDER_TYPE = '14' OR SUB_ORDER.ORDER_TYPE = '10' THEN
          V_ORDER_NO_DATEIL    := SUB_ORDER_DETAIL.PURCHASE_ORDER_NO;
          V_ORDER_ROWNO_DATEIL := SUB_ORDER_DETAIL.PURCHASE_ROW_NO;
        ELSE
          V_ORDER_NO_DATEIL    := SUB_ORDER_DETAIL.LOGISTICS_ORDERNO;
          V_ORDER_ROWNO_DATEIL := SUB_ORDER_DETAIL.LOGISTICS_ORDER_ROW_NO;
        END IF;

        IF SUB_ORDER.ORDER_TYPE = '14' THEN
          V_DEPOT_NO := SUB_ORDER_DETAIL.LGPBE;
        ELSE
          V_DEPOT_NO := SUB_ORDER_DETAIL.DEPOT_NO;
        END IF;

        SELECT COUNT(1)
          INTO V_NUM
          FROM MM_SW_ORDER_DETAIL M
         WHERE M.PURCHASE_NO = SUB_ORDER_DETAIL.PURCHASE_ORDER_NO
           AND M.PURCHASE_ROWNO = SUB_ORDER_DETAIL.PURCHASE_ROW_NO;

        IF V_NUM > 0 THEN
          IF SUB_ORDER_DETAIL.DO_FLAG = 'D' THEN
            UPDATE MM_SW_ORDER_DETAIL D
               SET D.CANCEL_NUM = D.ORDER_QTY - D.ARRIVE_NUM, D.LAST_MODIFIED_TIME = SYSDATE
             WHERE D.PURCHASE_NO = SUB_ORDER_DETAIL.PURCHASE_ORDER_NO
               AND D.PURCHASE_ROWNO = SUB_ORDER_DETAIL.PURCHASE_ROW_NO;
          ELSE
            UPDATE MM_SW_ORDER_DETAIL D
               SET D.DEPOT_NO           = V_DEPOT_NO,
                   D.DEPOT_ADDRESS      = V_DEPOT_NO,
                   D.ORDER_QTY          = SUB_ORDER_DETAIL.ORDER_NUM,
                   D.CANCEL_NUM         = SUB_ORDER_DETAIL.CANCEL_NUM,
                   D.ORDER_UNIT         = SUB_ORDER_DETAIL.ORDER_UNIT,
                   D.PART_NO            = SUB_ORDER_DETAIL.PART_ID,
                   D.STANDARD_PACKAGE   = SUB_ORDER_DETAIL.PACKAGE_NUM,
                   D.COST_CENTER        = SUB_ORDER_DETAIL.KTEXT,
                   D.ZK_FLAG            = SUB_ORDER_DETAIL.ZK_FLAG,
                   D.INV_TYPE           = SUB_ORDER_DETAIL.ZSTOCK,
                   D.COST_CODE          = SUB_ORDER_DETAIL.ZKOSTL,
                   D.LAST_MODIFIED_TIME = SYSDATE
             WHERE D.PURCHASE_NO = SUB_ORDER_DETAIL.PURCHASE_ORDER_NO
               AND D.PURCHASE_ROWNO = SUB_ORDER_DETAIL.PURCHASE_ROW_NO;
          END IF;
        ELSE
          IF SUB_ORDER_DETAIL.DO_FLAG = 'U' THEN
            UPDATE MM_SW_ORDER_DETAIL D
               SET D.DEPOT_NO           = V_DEPOT_NO,
                   D.DEPOT_ADDRESS      = V_DEPOT_NO,
                   D.ORDER_QTY          = SUB_ORDER_DETAIL.ORDER_NUM,
                   D.CANCEL_NUM         = SUB_ORDER_DETAIL.CANCEL_NUM,
                   D.ORDER_UNIT         = SUB_ORDER_DETAIL.ORDER_UNIT,
                   D.PART_NO            = SUB_ORDER_DETAIL.PART_ID,
                   D.STANDARD_PACKAGE   = SUB_ORDER_DETAIL.PACKAGE_NUM,
                   D.COST_CENTER        = SUB_ORDER_DETAIL.KTEXT,
                   D.ZK_FLAG            = SUB_ORDER_DETAIL.ZK_FLAG,
                   D.INV_TYPE           = SUB_ORDER_DETAIL.ZSTOCK,
                   D.COST_CODE          = SUB_ORDER_DETAIL.ZKOSTL,
                   D.LAST_MODIFIED_TIME = SYSDATE
             WHERE D.PURCHASE_NO = SUB_ORDER_DETAIL.PURCHASE_ORDER_NO
               AND D.PURCHASE_ROWNO = SUB_ORDER_DETAIL.PURCHASE_ROW_NO;
          ELSIF SUB_ORDER_DETAIL.DO_FLAG = 'I' THEN
            INSERT INTO MM_SW_ORDER_DETAIL
              (ID,
               PURCHASE_NO,
               PURCHASE_ROWNO,
               ORDER_NO,
               ORDER_ROWNO,
               DEPOT_NO,
               DEPOT_ADDRESS,
               ORDER_QTY,
               CANCEL_NUM,
               ORDER_UNIT,
               PART_NO,
               STANDARD_PACKAGE,
               COST_CENTER,
               ZK_FLAG,
               INV_TYPE,
               COST_CODE,
               CREATION_TIME,
               LAST_MODIFIED_TIME)
            VALUES
              (SEQ_MM_SW_ORDER_DETAIL.NEXTVAL,
               SUB_ORDER_DETAIL.PURCHASE_ORDER_NO,
               SUB_ORDER_DETAIL.PURCHASE_ROW_NO,
               V_ORDER_NO_DATEIL,
               V_ORDER_ROWNO_DATEIL,
               V_DEPOT_NO,
               V_DEPOT_NO,
               SUB_ORDER_DETAIL.ORDER_NUM,
               SUB_ORDER_DETAIL.CANCEL_NUM,
               SUB_ORDER_DETAIL.ORDER_UNIT,
               SUB_ORDER_DETAIL.PART_ID,
               SUB_ORDER_DETAIL.PACKAGE_NUM,
               SUB_ORDER_DETAIL.KTEXT,
               SUB_ORDER_DETAIL.ZK_FLAG,
               SUB_ORDER_DETAIL.ZSTOCK,
               SUB_ORDER_DETAIL.ZKOSTL,
               SYSDATE,
               SYSDATE);
          ELSIF SUB_ORDER_DETAIL.DO_FLAG = 'D' THEN
            UPDATE MM_SW_ORDER_DETAIL D
               SET D.CANCEL_NUM = NULL, D.LAST_MODIFIED_TIME = SYSDATE
             WHERE D.PURCHASE_NO = SUB_ORDER_DETAIL.PURCHASE_ORDER_NO
               AND D.PURCHASE_ROWNO = SUB_ORDER_DETAIL.PURCHASE_ROW_NO;
          END IF;
        END IF;
      END LOOP;
      UPDATE IF_SW_ORDER T
         SET T.DEAL_FLAG = 1, T.DEAL_TIME = SYSDATE
       WHERE T.ID = SUB_ORDER.ID
         AND T.DEAL_FLAG = 0;
    END LOOP;

    --mod by wxl 20190418
    --量产订单、例外订单处理
    FOR SUB_ORDER IN (SELECT O.ID,
                             O.PURCHASE_ORDER_NO,
                             DECODE(O.ORDER_TYPE,
                                    'Z009',
                                    '09',
                                    'Z014',
                                    '01',
                                    'Z007',
                                    '02',
                                    'Z006',
                                    '03',
                                    'Z005',
                                    '04',
                                    'Z012',
                                    '05',
                                    'Z010',
                                    '10',
                                    'Z004',
                                    '11',
                                    'Z008',
                                    '12',
                                    'Z013',
                                    '14') ORDER_TYPE
                        FROM IF_SW_ORDER O
                       WHERE O.DEAL_FLAG = 0
                            --写入零件订单，例外
                         AND O.ORDER_TYPE IN ('Z014', 'Z007')
                       ORDER BY O.ID, O.CREATION_TIME ASC) LOOP
      V_FLAG := 0;
      FOR SUB_ORDER_DETAIL IN (SELECT *
                                 FROM IF_SW_ORDER_DETAIL T
                                WHERE T.ID = SUB_ORDER.ID) LOOP
        IF NVL(TO_NUMBER(SUB_ORDER_DETAIL.CANCEL_NUM),0) != 0 then
          V_FLAG := 1;
          SELECT COUNT(1)
            INTO V_NUM
            FROM MM_SW_ORDER_DETAIL M
           WHERE M.PURCHASE_NO = SUB_ORDER_DETAIL.PURCHASE_ORDER_NO
             AND M.PURCHASE_ROWNO = SUB_ORDER_DETAIL.PURCHASE_ROW_NO;
          IF V_NUM > 0 THEN
            --取消数量等于订购量则删除，其它修改
            UPDATE MM_SW_ORDER_DETAIL D
               SET D.ORDER_QTY          = TO_NUMBER(SUB_ORDER_DETAIL.ORDER_NUM) - TO_NUMBER(SUB_ORDER_DETAIL.CANCEL_NUM),
                   D.LAST_MODIFIED_TIME = SYSDATE
             WHERE D.PURCHASE_NO = SUB_ORDER_DETAIL.PURCHASE_ORDER_NO
               AND D.PURCHASE_ROWNO = SUB_ORDER_DETAIL.PURCHASE_ROW_NO;
          END IF;
        END IF;
      END LOOP;
      --如果订单存在调整，则更新内部接口处理标识为未处理
      IF V_FLAG > 0 THEN
        UPDATE MM_SW_ORDER A
           SET A.DEAL_FLAG = 0
         WHERE A.PURCHASE_NO = SUB_ORDER.PURCHASE_ORDER_NO;
      END IF;
      --更新接口处理标识
      UPDATE IF_SW_ORDER T
         SET T.DEAL_FLAG = 1, T.DEAL_TIME = SYSDATE
       WHERE T.ID = SUB_ORDER.ID
         AND T.DEAL_FLAG = 0;
    END LOOP;

    --拉动、同步、新车型的处理
    UPDATE IF_SW_ORDER T
       SET T.DEAL_FLAG = 1, T.DEAL_TIME = SYSDATE
     WHERE T.ORDER_TYPE IN ('Z006',  'Z005', 'Z012')
       AND T.DEAL_FLAG = 0;

    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        ERROR_TAG     := sqlcode;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_SW_IF_TO_ORDER',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '订单接口数据至业务表');
        COMMIT;
      END;
  END USP_SW_IF_TO_ORDER;
  --****************************************************************************

  --****************************************************************************
  --过程名  : USP_SW_ORDER_DATEIL
  --功能描述: 处理订单表的从表数据
  --参数说明: 主表ID
  --创建人员: ZHENGWUCHAO
  --创建时间: 2018-10-22
  --****************************************************************************
  /*PROCEDURE USP_SW_ORDER_DATEIL(IN_VAR_ID     NUMBER,
                                IN_ORDER_TYPR VARCHAR2,
                                ERR_NUM       OUT NUMBER,
                                ERR_MSG       OUT VARCHAR2) AS
    V_NUM         VARCHAR2(10);
    V_ORDER_NO    VARCHAR2(50);
    V_ORDER_ROWNO NUMBER(20);
    V_DEPOT_NO    VARCHAR2(100);
    SEQ_NUM       NUMBER(20);
  BEGIN
    FOR SUB_ORDER_DETAIL IN (SELECT T.PURCHASE_ORDER_NO,
                                    T.PURCHASE_ROW_NO,
                                    T.LOGISTICS_ORDERNO,
                                    T.LOGISTICS_ORDER_ROW_NO,
                                    T.ZG_FLAG,
                                    T.PART_ID,
                                    T.ORDER_NUM,
                                    T.ORDER_UNIT,
                                    T.DAOHUO_TIME,
                                    T.DEPOT_NO,
                                    T.PACKAGE_NUM,
                                    T.ZK_FLAG,
                                    T.ZBZGG,
                                    T.ZSTOCK,
                                    T.LGPBE,
                                    T.ZKOSTL,
                                    T.KTEXT,
                                    T.DO_FLAG
                               FROM IF_SW_ORDER_DETAIL T
                              WHERE T.ID = IN_VAR_ID) LOOP

      IF IN_ORDER_TYPR = '11' OR IN_ORDER_TYPR = '12' OR
         IN_ORDER_TYPR = '14' THEN
        V_ORDER_NO    := SUB_ORDER_DETAIL.PURCHASE_ORDER_NO;
        V_ORDER_ROWNO := SUB_ORDER_DETAIL.PURCHASE_ROW_NO;
      ELSE
        V_ORDER_NO    := SUB_ORDER_DETAIL.LOGISTICS_ORDERNO;
        V_ORDER_ROWNO := SUB_ORDER_DETAIL.LOGISTICS_ORDER_ROW_NO;
      END IF;

      IF IN_ORDER_TYPR = '14' THEN
        V_DEPOT_NO := SUB_ORDER_DETAIL.LGPBE;
      ELSE
        V_DEPOT_NO := SUB_ORDER_DETAIL.DEPOT_NO;
      END IF;

      SELECT COUNT(1)
        INTO V_NUM
        FROM MM_SW_ORDER_DETAIL@MM_IF_IN M
       WHERE M.PURCHASE_NO = SUB_ORDER_DETAIL.PURCHASE_ORDER_NO
         AND M.PURCHASE_ROWNO = SUB_ORDER_DETAIL.PURCHASE_ROW_NO;

      SELECT SEQ_MM_SW_ORDER_DETAIL.nextval INTO SEQ_NUM FROM DUAL;

      IF V_NUM > 0 THEN
        IF SUB_ORDER_DETAIL.DO_FLAG = 'U' THEN
          UPDATE MM_SW_ORDER_DETAIL@PMCTEST D
             SET D.DEPOT_NO           = V_DEPOT_NO,
                 D.ORDER_QTY          = SUB_ORDER_DETAIL.ORDER_NUM,
                 D.ORDER_UNIT         = SUB_ORDER_DETAIL.ORDER_UNIT,
                 D.PART_NO            = SUB_ORDER_DETAIL.PART_ID,
                 D.STANDARD_PACKAGE   = SUB_ORDER_DETAIL.ZBZGG,
                 D.COST_CENTER        = SUB_ORDER_DETAIL.KTEXT,
                 D.ZK_FLAG            = SUB_ORDER_DETAIL.ZK_FLAG,
                 D.INV_TYPE           = SUB_ORDER_DETAIL.ZSTOCK,
                 D.COST_CODE          = SUB_ORDER_DETAIL.ZKOSTL,
                 D.LAST_MODIFIED_TIME = SYSDATE
           WHERE D.PURCHASE_NO = SUB_ORDER_DETAIL.PURCHASE_ORDER_NO
             AND D.PURCHASE_ROWNO = SUB_ORDER_DETAIL.PURCHASE_ROW_NO;
        ELSIF SUB_ORDER_DETAIL.DO_FLAG = 'I' THEN
          INSERT INTO MM_SW_ORDER_DETAIL@PMCTEST
            (ID,
             PURCHASE_NO,
             PURCHASE_ROWNO,
             ORDER_NO,
             ORDER_ROWNO,
             DEPOT_NO,
             ORDER_QTY,
             ORDER_UNIT,
             PART_NO,
             STANDARD_PACKAGE,
             COST_CENTER,
             ZK_FLAG,
             INV_TYPE,
             COST_CODE,
             CREATION_TIME,
             LAST_MODIFIED_TIME)
          VALUES
            (SEQ_NUM,
             SUB_ORDER_DETAIL.PURCHASE_ORDER_NO,
             SUB_ORDER_DETAIL.PURCHASE_ROW_NO,
             V_ORDER_NO,
             V_ORDER_ROWNO,
             V_DEPOT_NO,
             SUB_ORDER_DETAIL.ORDER_NUM,
             SUB_ORDER_DETAIL.ORDER_UNIT,
             SUB_ORDER_DETAIL.PART_ID,
             SUB_ORDER_DETAIL.ZBZGG,
             SUB_ORDER_DETAIL.KTEXT,
             SUB_ORDER_DETAIL.ZK_FLAG,
             SUB_ORDER_DETAIL.ZSTOCK,
             SUB_ORDER_DETAIL.ZKOSTL,
             SYSDATE,
             SYSDATE);
        ELSIF SUB_ORDER_DETAIL.DO_FLAG = 'D' THEN
          UPDATE MM_SW_ORDER_DETAIL@PMCTEST D
             SET D.CANCEL_NUM         = SUB_ORDER_DETAIL.ORDER_NUM,
                 D.LAST_MODIFIED_TIME = SYSDATE
           WHERE D.PURCHASE_NO = SUB_ORDER_DETAIL.PURCHASE_ORDER_NO
             AND D.PURCHASE_ROWNO = SUB_ORDER_DETAIL.PURCHASE_ROW_NO;
        END IF;

      ELSE
        IF SUB_ORDER_DETAIL.DO_FLAG = 'U' THEN
          UPDATE MM_SW_ORDER_DETAIL@PMCTEST D
             SET D.DEPOT_NO           = V_DEPOT_NO,
                 D.ORDER_QTY          = SUB_ORDER_DETAIL.ORDER_NUM,
                 D.ORDER_UNIT         = SUB_ORDER_DETAIL.ORDER_UNIT,
                 D.PART_NO            = SUB_ORDER_DETAIL.PART_ID,
                 D.STANDARD_PACKAGE   = SUB_ORDER_DETAIL.ZBZGG,
                 D.COST_CENTER        = SUB_ORDER_DETAIL.KTEXT,
                 D.ZK_FLAG            = SUB_ORDER_DETAIL.ZK_FLAG,
                 D.INV_TYPE           = SUB_ORDER_DETAIL.ZSTOCK,
                 D.COST_CODE          = SUB_ORDER_DETAIL.ZKOSTL,
                 D.LAST_MODIFIED_TIME = SYSDATE
           WHERE D.PURCHASE_NO = SUB_ORDER_DETAIL.PURCHASE_ORDER_NO
             AND D.PURCHASE_ROWNO = SUB_ORDER_DETAIL.PURCHASE_ROW_NO;
        ELSIF SUB_ORDER_DETAIL.DO_FLAG = 'I' THEN
          INSERT INTO MM_SW_ORDER_DETAIL@PMCTEST
            (ID,
             PURCHASE_NO,
             PURCHASE_ROWNO,
             ORDER_NO,
             ORDER_ROWNO,
             DEPOT_NO,
             ORDER_QTY,
             ORDER_UNIT,
             PART_NO,
             STANDARD_PACKAGE,
             COST_CENTER,
             ZK_FLAG,
             INV_TYPE,
             COST_CODE,
             CREATION_TIME,
             LAST_MODIFIED_TIME)
          VALUES
            (SEQ_NUM,
             SUB_ORDER_DETAIL.PURCHASE_ORDER_NO,
             SUB_ORDER_DETAIL.PURCHASE_ROW_NO,
             V_ORDER_NO,
             V_ORDER_ROWNO,
             V_DEPOT_NO,
             SUB_ORDER_DETAIL.ORDER_NUM,
             SUB_ORDER_DETAIL.ORDER_UNIT,
             SUB_ORDER_DETAIL.PART_ID,
             SUB_ORDER_DETAIL.ZBZGG,
             SUB_ORDER_DETAIL.KTEXT,
             SUB_ORDER_DETAIL.ZK_FLAG,
             SUB_ORDER_DETAIL.ZSTOCK,
             SUB_ORDER_DETAIL.ZKOSTL,
             SYSDATE,
             SYSDATE);
        ELSIF SUB_ORDER_DETAIL.DO_FLAG = 'D' THEN
          UPDATE MM_SW_ORDER_DETAIL@PMCTEST D
             SET D.CANCEL_NUM         = SUB_ORDER_DETAIL.ORDER_NUM,
                 D.LAST_MODIFIED_TIME = SYSDATE
           WHERE D.PURCHASE_NO = SUB_ORDER_DETAIL.PURCHASE_ORDER_NO
             AND D.PURCHASE_ROWNO = SUB_ORDER_DETAIL.PURCHASE_ROW_NO;
        END IF;
      END IF;
    END LOOP;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      ERR_NUM := SQLCODE;
      ERR_MSG := SUBSTR(SQLERRM || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(),
                        1,
                        200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_SW_ORDER_DATEIL',
         ERR_NUM,
         ERR_MSG,
         SYSDATE,
         '处理订单表的从表数据');
      COMMIT;
  END USP_SW_ORDER_DATEIL;*/

  --****************************************************************************
  --过程名  : USP_SW_IF_TO_ACCOUNT_BILL
  --功能描述: 结算对账数据接口到业务表
  --参数说明: 工厂代码
  --创建人员: ZHENGWUCHAO
  --创建时间: 2018-10-22
  --****************************************************************************
  PROCEDURE USP_SW_IF_TO_ACCOUNT_BILL(ERROR_TAG     OUT NUMBER,
                                      ERROR_MESSAGE OUT VARCHAR2) AS
  BEGIN
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
    FOR SUB_ACCOUNT IN (SELECT T.ID,
                               T.COMP,
                               T.ACCOUNT_BILL_NO,
                               T.SUPPLIER_NO,
                               T.FREE_TAX_AMOUNT,
                               T.TOTAL_AMOUNT,
                               T.TOTAL_TAX,
                               T.ACCOUNT_DATE,
                               T.CURRENCY_TYPE,
                               T.REBATE,
                               T.REBATE_DESC,
                               T.DEDUCT_MONEY,
                               T.DEDUCT_MONEY_DESC,
                               T.YEAR_ADJUST,
                               T.YEAR_ADJUST_DESC,
                               T.MOULD_AMOUNT,
                               T.MOULD_AMOUNT_DESC,
                               T.PAY_TERM,
                               T.REMARK,
                               T.DO_FLAG
                          FROM IF_SW_ACCOUNT_BILL T
                         WHERE T.DEAL_FLAG = 0
                         ORDER BY T.ID, T.CREATION_TIME ASC) LOOP
      IF SUB_ACCOUNT.DO_FLAG = 'D' THEN
        DELETE MM_SW_ACCOUNT_BILL T
         WHERE T.BILL_NO = SUB_ACCOUNT.ACCOUNT_BILL_NO;
        DELETE MM_SW_ACCOUNT_BILL_DETAIL T
         WHERE T.BILL_NO = SUB_ACCOUNT.ACCOUNT_BILL_NO;
      ELSE
        INSERT INTO MM_SW_ACCOUNT_BILL
          (BILL_NO,
           FACTORY_CODE,
           SUPPLIER_NO,
           TAX_EXCLUDED,
           TAX_INCLUSIVE,
           TOTAL_TAX,
           MAKE_DATE,
           CURRENCY_TYPE,
           REBATE,
           REBATE_DESC,
           DEDUCT_MONEY,
           DEDUCT_MONEY_DESC,
           YEAR_ADJUST,
           YEAR_ADJUST_DESC,
           MOULD_AMOUNT,
           MOULD_AMOUNT_DESC,
           PAY_TERM,
           INVOICE_STATUS,
           REMARK,
           ACCOUNT_STATUS,
           DEAL_FLAG2,
           DO_FLAG)
        VALUES
          (SUB_ACCOUNT.ACCOUNT_BILL_NO,
           SUB_ACCOUNT.COMP,
           SUB_ACCOUNT.SUPPLIER_NO,
           SUB_ACCOUNT.FREE_TAX_AMOUNT,
           SUB_ACCOUNT.TOTAL_AMOUNT,
           SUB_ACCOUNT.TOTAL_TAX,
           TO_DATE(SUB_ACCOUNT.ACCOUNT_DATE, 'YYYY-MM-DD HH24:MI:SS'),
           SUB_ACCOUNT.CURRENCY_TYPE,
           SUB_ACCOUNT.REBATE,
           SUB_ACCOUNT.REBATE_DESC,
           SUB_ACCOUNT.DEDUCT_MONEY,
           SUB_ACCOUNT.DEDUCT_MONEY_DESC,
           SUB_ACCOUNT.YEAR_ADJUST,
           SUB_ACCOUNT.YEAR_ADJUST_DESC,
           SUB_ACCOUNT.MOULD_AMOUNT,
           SUB_ACCOUNT.MOULD_AMOUNT_DESC,
           SUB_ACCOUNT.PAY_TERM,
           0,
           SUB_ACCOUNT.REMARK,
           SUB_ACCOUNT.DO_FLAG,
           '0',
           'I');
        FOR SUB_ACCOUNT_DATEIL IN (SELECT *
                                     FROM IF_SW_ACCOUNT_BILL_DETAIL D
                                    WHERE D.ACCOUNT_BILL_NO =
                                          SUB_ACCOUNT.ACCOUNT_BILL_NO) LOOP
          INSERT INTO MM_SW_ACCOUNT_BILL_DETAIL
            (BILL_NO,
             BILL_ROW_NO,
             PURCHASE_NO,
             PURCHASE_ROW_NO,
             REC_VOUCHER_YEAR,
             REC_VOUCHER_BILLNO,
             REC_VOUCHER_ROWNO,
             REF_REC_VOUCHER_BILL,
             REF_REC_VOUCHER_ROWNO,
             REC_DATE,
             LOAN_FLAG,
             PRICE_STATUS,
             EVA_PRICE,
             OFFICIAL_PRICE,
             ADJUST_DIFF_PRICE,
             EVA_PRICE_PERCENT,
             EVA_SETTLE_PRICE,
             ERP_FACTORY_CODE,
             PART_NO,
             SUPPLIER_NO,
             REC_NUM,
             PAY_AMOUNT,
             TAX_RATE,
             TAX_AMOUNT,
             CURRENCY_TYPE,
             PART_UNIT,
             DEAL_FLAG,
             DO_FLAG)
          VALUES
            (SUB_ACCOUNT_DATEIL.ACCOUNT_BILL_NO,
             SUB_ACCOUNT_DATEIL.ACCOUNT_BILL_ROW_NO,
             SUB_ACCOUNT_DATEIL.PURCHASE_ORDER_NO,
             SUB_ACCOUNT_DATEIL.PURCHASE_ROW_NO,
             SUB_ACCOUNT_DATEIL.REC_VOUCHER_YEAR,
             SUB_ACCOUNT_DATEIL.REC_VOUCHER_BILL_NO,
             SUB_ACCOUNT_DATEIL.REC_VOUCHER_ROW_NO,
             SUB_ACCOUNT_DATEIL.REF_REC_VOUCHER_BILL,
             SUB_ACCOUNT_DATEIL.REF_REC_VOUCHER_ROW_NO,
             TO_DATE(SUB_ACCOUNT_DATEIL.REC_DATE, 'YYYY-MM-DD HH24:MI:SS'),
             SUB_ACCOUNT_DATEIL.LOAN_FLAG,
             SUB_ACCOUNT_DATEIL.PRICE_STATUS,
             SUB_ACCOUNT_DATEIL.EVA_PRICE *
             SUB_ACCOUNT_DATEIL.EVA_PRICE_UNIT,
             SUB_ACCOUNT_DATEIL.OFFICIAL_PRICE *
             SUB_ACCOUNT_DATEIL.OFFICIAL_PRICE_UNIT,
             SUB_ACCOUNT_DATEIL.ADJUST_DIFF_PRICE,
             SUB_ACCOUNT_DATEIL.EVA_PRICE_PERCENT,
             SUB_ACCOUNT_DATEIL.EVA_SETTLE_PRICE,
             SUB_ACCOUNT_DATEIL.ERP_FACTORY_CODE,
             SUB_ACCOUNT_DATEIL.PART_NO,
             SUB_ACCOUNT_DATEIL.SUPPLIER_NO,
             SUB_ACCOUNT_DATEIL.REC_NUM,
             SUB_ACCOUNT_DATEIL.PAY_AMOUNT,
             SUB_ACCOUNT_DATEIL.TAX_RATE,
             SUB_ACCOUNT_DATEIL.TAX_AMOUNT,
             SUB_ACCOUNT_DATEIL.CURRENCY_TYPE,
             SUB_ACCOUNT_DATEIL.PART_UNIT,
             '0',
             'I');
        END LOOP;
      END IF;
      UPDATE IF_SW_ACCOUNT_BILL T
         SET T.DEAL_FLAG = 1
       WHERE T.ID = SUB_ACCOUNT.ID;
    END LOOP;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      ERROR_TAG     := SQLCODE;
      ERROR_MESSAGE := SUBSTR(SQLERRM ||
                              DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(),
                              1,
                              200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_SW_IF_TO_ACCOUNT_BILL',
         ERROR_TAG,
         ERROR_MESSAGE,
         SYSDATE,
         '结算对账数据接口到业务表');
      COMMIT;
  END USP_SW_IF_TO_ACCOUNT_BILL;
  --****************************************************************************

  --****************************************************************************
  --过程名  : USP_SW_IF_TO_DEMAND_FORECAST
  --功能描述: 预测接口数据至业务表
  --参数说明: 工厂代码
  --创建人员: ZHENGWUCHAO
  --创建时间: 2018-10-22
  --****************************************************************************
  /*PROCEDURE USP_SW_IF_TO_DEMAND_FORECAST(ERROR_TAG     OUT NUMBER,
                                         ERROR_MESSAGE OUT VARCHAR2) AS
    V_NUM         NUMBER(5);
    V_UNLOAD_PORT VARCHAR2(100);
    V_MM_MODEL    VARCHAR2(100);
    --ERROR_TAG          NUMBER(10);
    --ERROR_MESSAGE      VARCHAR2(1000);
    V_AREA             VARCHAR2(20); --区域
    V_OUT_TIME         NUMBER(10); --生产节拍
    V_ADVANCE_TIME     NUMBER(10); --提前取货时间
    V_TRANS_TIME       NUMBER(10); --运输时长
    v_loc_num          number(10); --落点车体流动数
    v_use_location_num VARCHAR2(30);
    v_location         VARCHAR2(20);
    V_TIME             DATE; --厂内装配时间
    V_TIME1            NUMBER(10); --厂内提前时间
    V_ENDTIME          NUMBER(10); --提前取货时间
    V_WORKCENTER       VARCHAR2(30); --车间
    V_VERSION_EXIST    NUMBER(10); --判断版本是否存在
  BEGIN

    FOR VERSION_FORECASE IN (SELECT COUNT(1) NUM, A.VERSION_NO, A.FORE_TYPE
                               from IF_SW_DEMAND_FORECAST A
                              WHERE A.DEAL_FLAG = 0
                              GROUP BY A.VERSION_NO, A.FORE_TYPE
                              ORDER BY A.VERSION_NO) LOOP

      IF VERSION_FORECASE.NUM > 0 THEN
        SELECT COUNT(1)
          INTO V_VERSION_EXIST
          FROM MM_SW_DEMAND_FORECAST A
         WHERE A.VERSION = VERSION_FORECASE.VERSION_NO; --判断下发下来的版本是否已存在
        IF V_VERSION_EXIST > 0 THEN
          UPDATE IF_SW_DEMAND_FORECAST A
             SET A.DEAL_FLAG = 1
           WHERE A.DEAL_FLAG = 0
             AND A.VERSION_NO = VERSION_FORECASE.VERSION_NO; --如果存在则直接将该版本修改为已处理
        ELSE
          DELETE MM_SW_DEMAND_FORECAST A
           WHERE A.FORE_TYPE = VERSION_FORECASE.FORE_TYPE; --如果不存在则删除上一个版本的数据，区分周预测和月预测
        END IF;
      END IF;
    END LOOP;

    FOR SUB_FORECAST IN (SELECT F.*
                           FROM IF_SW_DEMAND_FORECAST F
                          WHERE F.DEAL_FLAG = 0
                         --WHERE F.PART_ID = '3410010ARD0000M10'
                          ORDER BY F.ID ASC) LOOP
      --计算提前取货时间
      IF SUB_FORECAST.FORE_TYPE = '2' THEN
        FOR CUR_ADVAN IN (

                          SELECT ACC.WORKCENTER,
                                  ACC.ARRIVE_NUM,
                                  ACC.DISTRIBUTION_NUM
                            FROM (SELECT C.ARRIVE_NUM,
                                          C.DISTRIBUTION_NUM,
                                          C.PART_NO,
                                          C.WORKCENTER
                                     FROM MM_MP_PART C
                                   UNION
                                   SELECT D.ARRIVE_NUM,
                                          D.DISTRIBUTION_NUM,
                                          D.PART_NO,
                                          CD.WORKCENTER
                                     FROM MM_JIT_PART D
                                     LEFT JOIN MM_PUB_PLAN_CODE CD
                                       ON D.PLAN_CODE = CD.PLAN_CODE
                                   UNION
                                   SELECT PP.ARRIVE_NUM,
                                          PP.DISTRIBUTION_NUM,
                                          JI.PART_NO,
                                          CDD.WORKCENTER
                                     FROM MM_JISO_PARTGROUP PP
                                     LEFT JOIN MM_JISO_PART JI
                                       ON PP.ID = JI.PARTGROUP_ID
                                     LEFT JOIN MM_PUB_PLAN_CODE CDD
                                       ON PP.PLAN_CODE = CDD.PLAN_CODE) ACC
                           WHERE ACC.PART_NO = SUB_FORECAST.PART_ID) LOOP

          --获取属地信息
          v_location := null;
          v_loc_num  := 0;
          --v_distri_person := null;
          --1、根据零件获取属地信息中任一落点信息
          for cur_loc in (select a.location, a.location_num, a.distri_person
                            from mm_inv_part_location a
                           where a.factory_code = SUB_FORECAST.COMP
                             and a.workcenter = CUR_ADVAN.workcenter
                             and a.part_no = SUB_FORECAST.part_id
                             and a.eff_start <= sysdate
                             and a.eff_end > sysdate
                           order by a.location_num desc) loop
            v_location := cur_loc.location;
            v_loc_num  := cur_loc.location_num;
            --v_distri_person := cur_loc.distri_person;
            v_use_location_num := 'LOC';
            exit;
          end loop;
          --2、获取属地信息中车间最大工深
          if v_location is null then
            select decode(max(a.location_num), null, 0, max(a.location_num))
              into v_loc_num
              from mm_inv_part_location a
             where a.factory_code = SUB_FORECAST.COMP
                  --and a.workcenter = SUB_FORECAST.workcenter
               and a.eff_start <= sysdate
               and a.eff_end > sysdate;
            v_use_location_num := 'WC';
          end if;
          --3、获取系统参数中车间最大工深
          if v_location is null then
            if CUR_ADVAN.WORKCENTER = 'A1' THEN
              V_WORKCENTER := 'AF';
            END IF;
            IF CUR_ADVAN.WORKCENTER = 'W1' THEN
              V_WORKCENTER := 'WE';
            END IF;
            IF CUR_ADVAN.WORKCENTER = 'T1' THEN
              V_WORKCENTER := 'PA';
            END IF;
            v_loc_num          := to_number(PKG_PUB.USF_GET_SYS_PARAM(SUB_FORECAST.Comp,
                                                                      'MAX_LOC',
                                                                      V_WORKCENTER ||
                                                                      'TOTAL_PRO_NUM'));
            v_use_location_num := 'SYS';
          end if;
          if v_loc_num is null then
            v_loc_num          := 0;
            v_use_location_num := null;
          end if;
          --台套数对应时间
          V_OUT_TIME := PKG_PUB.USF_GET_PRODUCE_TIME(SUB_FORECAST.COMP,
                                                     CUR_ADVAN.WORKCENTER,
                                                     NULL) *
                        (nvl(v_loc_num,0) + nvl(CUR_ADVAN.ARRIVE_NUM,0) +
                         nvl(CUR_ADVAN.DISTRIBUTION_NUM,0));
          --厂内装配时间
          V_TIME := PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                 CUR_ADVAN.WORKCENTER,
                                                 TO_DATE(SUB_FORECAST.REC_DATE,
                                                         'YYYY-MM-DD HH24:MI:SS'),
                                                 -V_OUT_TIME);

          --DBMS_OUTPUT.put_line(TO_CHAR(V_TIME,'YYYY-MM-DD HH24:mi:ss'));
          V_TIME1   := V_TIME - TO_DATE(SUB_FORECAST.REC_DATE,
                                        'YYYY-MM-DD HH24:MI:SS');
          V_ENDTIME := 0;
          IF V_ENDTIME < V_TIME1 THEN
            V_ENDTIME := V_TIME1;
          END IF;
          --从路线中获取省内省外和运输时长
          SELECT MAX(A.AREA), MAX(A.TRANS_TIME)
            INTO V_AREA, V_TRANS_TIME
            FROM MM_PUP_ROUTE A
           WHERE A.FACTORY_CODE = SUB_FORECAST.COMP
             AND A.SUPPLIER_NO = SUB_FORECAST.SUPPLIER_NO
             AND A.SUP_FACTORY = (SELECT UDA.SUP_FACTORY FROM MM_PUB_PART_UDA UDA WHERE UDA.PART_NO = SUB_FORECAST.PART_ID)
             AND A.CAR_TYPE = SUB_FORECAST.MODEL_CODE;
          V_ADVANCE_TIME := '';

          IF V_AREA IS NOT NULL AND V_TRANS_TIME IS NOT NULL THEN
            IF V_TRANS_TIME = 0 THEN
              V_TRANS_TIME := 1;
            END IF;
            IF V_AREA = '省内' THEN
              --V_ADVANCE_TIME := CEIL(V_ENDTIME - V_TRANS_TIME/24);
              V_ADVANCE_TIME := TO_DATE(SUB_FORECAST.REC_DATE,
                                        'YYYY-MM-DD HH24:MI:SS') -
                                PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                             CUR_ADVAN.WORKCENTER,
                                                             V_TIME,
                                                             -V_TRANS_TIME);
            END IF;
            --SELECT ceil(V_OUT_TIME + V_TRANS_TIME) INTO V_ADVANCE_TIME FROM DUAL;
            IF V_AREA = '省外' THEN
              --SELECT ceil(V_OUT_TIME + V_TRANS_TIME) / 24 INTO V_ADVANCE_TIME FROM DUAL;
              --V_ADVANCE_TIME := CEIL(V_ENDTIME + V_TRANS_TIME/24);
              V_ADVANCE_TIME := TO_DATE(SUB_FORECAST.REC_DATE,
                                        'YYYY-MM-DD HH24:MI:SS') -
                                TO_DATE(USF_MM_MP_FORBAKWORKDATE(to_char(V_TIME,'yyyy-mm-dd'),
                                                                 CEIL(NVL(V_TRANS_TIME,
                                                                          0) / 24),
                                                                 CUR_ADVAN.WORKCENTER,
                                                                 SUB_FORECAST.COMP,
                                                                 0) ||
                                        TO_CHAR(V_TIME, 'HH24:MI:SS'),
                                        'YYYY-MM-DD HH24:MI:SS');

                                       \* DBMS_OUTPUT.put_line(USF_MM_MP_FORBAKWORKDATE(V_TIME,
                                                                 CEIL(NVL(V_TRANS_TIME,
                                                                          0) / 24),
                                                                 CUR_ADVAN.WORKCENTER,
                                                                 SUB_FORECAST.COMP,
                                                                 0));

                                         DBMS_OUTPUT.put_line(TO_CHAR(V_TIME, 'HH24:MI:SS'));    *\
            END IF;
          END IF;

        END LOOP;
      END IF;

      --V_NUM := 0;
      SELECT COUNT(1)
        INTO V_NUM
        FROM MM_SW_DEMAND_FORECAST T
       WHERE T.FACTORY_CODE = SUB_FORECAST.COMP
         AND T.VERSION = SUB_FORECAST.VERSION_NO
         AND T.PART_NO = SUB_FORECAST.PART_ID
         AND NVL(T.SUPPLIER_NO, '#') = NVL(SUB_FORECAST.SUPPLIER_NO, '#')
         AND T.FORE_TYPE = SUB_FORECAST.FORE_TYPE

         AND T.START_DATE =
             TO_DATE(SUB_FORECAST.END_DATE, 'yyyy-MM-dd HH24:mi:ss')
         AND T.END_DATE =
             TO_DATE(SUB_FORECAST.START_DATE, 'yyyy-MM-dd HH24:mi:ss')
         AND NVL(T.WORKCENTER, '#') = NVL(SUB_FORECAST.WORKCENTER, '#');
      IF V_NUM > 0 THEN

        DELETE MM_SW_DEMAND_FORECAST T
         WHERE T.FACTORY_CODE = SUB_FORECAST.COMP
           AND T.VERSION = SUB_FORECAST.VERSION_NO
           AND T.PART_NO = SUB_FORECAST.PART_ID
           AND NVL(T.SUPPLIER_NO, '#') = NVL(SUB_FORECAST.SUPPLIER_NO, '#')
           AND T.FORE_TYPE = SUB_FORECAST.FORE_TYPE
           AND T.START_DATE =
               TO_DATE(SUB_FORECAST.END_DATE, 'yyyy-MM-dd HH24:mi:ss')
           AND T.END_DATE =
               TO_DATE(SUB_FORECAST.START_DATE, 'yyyy-MM-dd HH24:mi:ss')
           AND NVL(T.WORKCENTER, '#') = NVL(SUB_FORECAST.WORKCENTER, '#');

        BEGIN
          SELECT WM_CONCAT(UNLOAD_PORT)
            INTO V_UNLOAD_PORT
            FROM (SELECT *
                    FROM MM_PUB_PART_UNLOAD OAD
                   WHERE OAD.PART_NO = SUB_FORECAST.PART_ID
                     AND OAD.WORKCENTER = SUB_FORECAST.WORKCENTER);

        EXCEPTION
          WHEN OTHERS THEN
            V_UNLOAD_PORT := '';
        END;

        BEGIN
          SELECT Max(OAD.LOGISTICS_MODEL)
            INTO V_MM_MODEL --获取物流模式
            FROM MM_PUB_PART_UNLOAD OAD
           WHERE OAD.PART_NO = SUB_FORECAST.PART_ID;

        EXCEPTION
          WHEN OTHERS THEN
            V_MM_MODEL := '';
        END;

        \*          FOR SUB_UNLOAD_PORT IN (
         SELECT T.UNLOAD_PORT
          V_UNLOAD_PORT
         FROM MM_INV_PART_LOCATION T
        WHERE T.PART_NO = SUB_FORECAST.PART_ID
              AND T.FACTORY_CODE = SUB_FORECAST.COMP)LOOP*\
        \**
        SELECT M.SUP_FACTORY
          INTO V_SUP_FACTORY
          FROM MM_PUB_PART_SUPPLIER M
         WHERE M.SUPPLIER_NO = SUB_FORECAST.SUPPLIER_NO;**\

        \*                 SELECT TO_CHAR(WMSYS.WM_CONCAT( T.LOGISTICS_MODE))
        INTO V_MM_MODEL
        FROM MM_INV_UNLOAD T
        WHERE  T.UNLOAD_PORT = SUB_UNLOAD_PORT.V_UNLOAD_PORT;*\
        INSERT INTO MM_SW_DEMAND_FORECAST
          (ID,
           FACTORY_CODE,
           FORE_TYPE,
           VERSION,
           PLAN_DELIVERY,
           START_DATE,
           MODEL_CODE,
           END_DATE,
           PHASE,
           UNLOAD_PORT,
           PART_NO,
           PART_UNIT,
           ORDER_QTY,
           SUPPLIER_NO,
           LOGISTICS_MODE,
           DOWNLOAD_STATUS,
           CREATION_TIME,
           LAST_MODIFIED_TIME,
           RELEASE_STATUS,
           FEEDBACK_STATUS,
           PUBLISH_MONTH,
           OBJ_MONTH,
           OBJ_WEEK,
           PUBLISH_WEEK,
           ADVANCE_TIME,
           DEAL_FLAG,
           DO_FLAG)
        VALUES
          (SEQ_MM_SW_DEMAND_FORE.NEXTVAL,
           SUB_FORECAST.COMP,
           TO_NUMBER(SUB_FORECAST.FORE_TYPE, 0),
           SUB_FORECAST.VERSION_NO,
           TO_DATE(SUB_FORECAST.REC_DATE, 'yyyy-MM-dd HH24:mi:ss'),
           TO_DATE(SUB_FORECAST.START_DATE, 'yyyy-MM-dd HH24:mi:ss'),
           SUB_FORECAST.MODEL_CODE,
           TO_DATE(SUB_FORECAST.END_DATE, 'yyyy-MM-dd HH24:mi:ss'),
           SUB_FORECAST.PHASE,
           V_UNLOAD_PORT,
           SUB_FORECAST.PART_ID,
           SUB_FORECAST.PART_UNIT,
           SUB_FORECAST.ORDER_NUM,
           SUB_FORECAST.SUPPLIER_NO,
           V_MM_MODEL,
           0,
           SYSDATE,
           SYSDATE,
           1,
           0,
           SUB_FORECAST.PUBLISH_MONTH,
           SUB_FORECAST.OBJ_MONTH,
           SUBSTR(SUB_FORECAST.OBJ_WEEK, 0, 10),
           SUBSTR(SUB_FORECAST.PUBLISH_WEEK, 0, 10),
           V_ADVANCE_TIME,
           '0',
           'U');
        --END LOOP;
      ELSE

        BEGIN
          SELECT MAX(UNLOAD_PORT) --获取卸货口
            INTO V_UNLOAD_PORT
            FROM (SELECT DISTINCT SD.UNLOAD_PORT
                    FROM MM_INV_PART_LOCATION SD
                   WHERE SD.PART_NO = SUB_FORECAST.PART_ID
                     AND SUB_FORECAST.COMP = SD.FACTORY_CODE
                     AND SD.EFF_START <= SYSDATE
                     AND SYSDATE <= SD.EFF_END);
        EXCEPTION
          WHEN OTHERS THEN
            V_UNLOAD_PORT := '';
        END;

        BEGIN
          SELECT MAX(UDA.LOGISTICS_MODEL)
            INTO V_MM_MODEL --获取物流模式
            FROM MM_PUB_PART_UNLOAD UDA
           WHERE UDA.PART_NO = SUB_FORECAST.PART_ID;
        EXCEPTION
          WHEN OTHERS THEN
            V_MM_MODEL := '';
        END;

        \*           FOR SUB_UNLOAD_PORT IN (
         SELECT T.UNLOAD_PORT
         INTO V_UNLOAD_PORT
         FROM MM_INV_PART_LOCATION T
        WHERE T.PART_NO = SUB_FORECAST.PART_ID)LOOP*\

        --SELECT DISTINCT M.SUP_FACTORY
        -- INTO V_SUP_FACTORY
        -- FROM MM_PUB_PART_SUPPLIER M
        -- WHERE M.SUPPLIER_NO = SUB_FORECAST.SUPPLIER_NO;

        \*          SELECT TO_CHAR(WMSYS.WM_CONCAT( T.LOGISTICS_MODE))
         INTO V_MM_MODEL
         FROM MM_INV_UNLOAD T
        WHERE  T.UNLOAD_PORT = SUB_UNLOAD_PORT.UNLOAD_PORT;*\

        INSERT INTO MM_SW_DEMAND_FORECAST
          (ID,
           FACTORY_CODE,
           FORE_TYPE,
           VERSION,
           PLAN_DELIVERY,
           START_DATE,
           MODEL_CODE,
           END_DATE,
           PHASE,
           UNLOAD_PORT,
           PART_NO,
           PART_UNIT,
           ORDER_QTY,
           SUPPLIER_NO,
           LOGISTICS_MODE,
           DOWNLOAD_STATUS,
           CREATION_TIME,
           LAST_MODIFIED_TIME,
           RELEASE_STATUS,
           FEEDBACK_STATUS,
           PUBLISH_MONTH,
           OBJ_MONTH,
           OBJ_WEEK,
           PUBLISH_WEEK,
           ADVANCE_TIME,
           DEAL_FLAG,
           DO_FLAG)
        VALUES
          (SEQ_MM_SW_DEMAND_FORE.NEXTVAL,
           SUB_FORECAST.COMP,
           TO_NUMBER(SUB_FORECAST.FORE_TYPE, 0),
           SUB_FORECAST.VERSION_NO,
           TO_DATE(SUB_FORECAST.REC_DATE, 'yyyy-MM-dd HH24:mi:ss'),
           TO_DATE(SUB_FORECAST.START_DATE, 'yyyy-MM-dd HH24:mi:ss'),
           SUB_FORECAST.MODEL_CODE,
           TO_DATE(SUB_FORECAST.END_DATE, 'yyyy-MM-dd HH24:mi:ss'),
           SUB_FORECAST.PHASE,
           V_UNLOAD_PORT,
           SUB_FORECAST.PART_ID,
           SUB_FORECAST.PART_UNIT,
           SUB_FORECAST.ORDER_NUM,
           SUB_FORECAST.SUPPLIER_NO,
           V_MM_MODEL,
           0,
           SYSDATE,
           SYSDATE,
           1,
           0,
           SUB_FORECAST.PUBLISH_MONTH,
           SUB_FORECAST.OBJ_MONTH,
           SUBSTR(SUB_FORECAST.OBJ_WEEK, 0, 10),
           substr(SUB_FORECAST.PUBLISH_WEEK, 0, 10),
           V_ADVANCE_TIME,
           '0',
           'I');

        --END LOOP;
      END IF;
      UPDATE IF_SW_DEMAND_FORECAST T
         SET T.DEAL_FLAG = 1
       WHERE T.ID = SUB_FORECAST.ID;
    END LOOP;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      ERROR_TAG     := SQLCODE;
      ERROR_MESSAGE := SUBSTR(SQLERRM ||
                              DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(),
                              1,
                              200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_SW_IF_TO_DEMAND_FORECAST',
         ERROR_TAG,
         ERROR_MESSAGE,
         SYSDATE,
         '预测接口数据至业务表');
      COMMIT;
  END USP_SW_IF_TO_DEMAND_FORECAST;*/

  PROCEDURE USP_SW_IF_TO_DEMAND_FORECAST(ERROR_TAG     OUT NUMBER,
                                         ERROR_MESSAGE OUT VARCHAR2) AS

    V_NUM         NUMBER(5);
    V_UNLOAD_PORT VARCHAR2(100);
    V_MM_MODEL    VARCHAR2(100);
    --ERROR_TAG          NUMBER(10);
    --ERROR_MESSAGE      VARCHAR2(1000);
    V_AREA             VARCHAR2(20); --区域
    V_OUT_TIME         NUMBER(10); --生产节拍
    V_ADVANCE_TIME     NUMBER(10); --提前取货时间
    V_TRANS_TIME       NUMBER(10); --运输时长
    v_loc_num          number(10); --落点车体流动数
    v_use_location_num VARCHAR2(30);
    v_location         VARCHAR2(20);
    V_TIME             DATE; --厂内装配时间
    V_TIME1            NUMBER(10); --厂内提前时间
    V_WORKCENTER       VARCHAR2(30); --车间
    v_af_max_loc       NUMBER;
    v_pa_max_loc       NUMBER;
    v_we_max_loc       NUMBER;
    v_wbs_max_loc      NUMBER;
    v_pbs_max_loc      NUMBER;
    V_VERSION_EXIST    NUMBER(10); --判断版本是否存在
  BEGIN

    /*    FOR VERSION_FORECASE IN (SELECT COUNT(1) NUM, A.VERSION_NO, A.FORE_TYPE
                               from IF_SW_DEMAND_FORECAST A
                              WHERE A.DEAL_FLAG = 0
                              GROUP BY A.VERSION_NO, A.FORE_TYPE
                              ORDER BY A.VERSION_NO) LOOP

      IF VERSION_FORECASE.NUM > 0 THEN
        SELECT COUNT(1)
          INTO V_VERSION_EXIST
          FROM MM_SW_DEMAND_FORECAST A
         WHERE A.VERSION = VERSION_FORECASE.VERSION_NO; --判断下发下来的版本是否已存在
        IF V_VERSION_EXIST > 0 THEN
          UPDATE IF_SW_DEMAND_FORECAST A
             SET A.DEAL_FLAG = 1
           WHERE A.DEAL_FLAG = 0
             AND A.VERSION_NO = VERSION_FORECASE.VERSION_NO; --如果存在则直接将该版本修改为已处理
        ELSE
          DELETE MM_SW_DEMAND_FORECAST A
           WHERE A.FORE_TYPE = VERSION_FORECASE.FORE_TYPE; --如果不存在则删除上一个版本的数据，区分周预测和月预测
        END IF;
      END IF;
    END LOOP;*/

    FOR SUB_FORECAST IN (SELECT * FROM IF_SW_DEMAND_FORECAST A
                                WHERE A.DEAL_FLAG = 0
                                ORDER BY A.CREATION_TIME DESC) LOOP
      --计算提前取货时间
      IF SUB_FORECAST.FORE_TYPE = '2' THEN
        FOR CUR_ADVAN IN (

                          SELECT ACC.WORKCENTER,
                                  ACC.ARRIVE_NUM,
                                  ACC.DISTRIBUTION_NUM
                            FROM (SELECT C.ARRIVE_NUM,
                                          C.DISTRIBUTION_NUM,
                                          C.PART_NO,
                                          C.WORKCENTER
                                     FROM MM_MP_PART C
                                   UNION
                                   SELECT D.ARRIVE_NUM,
                                          D.DISTRIBUTION_NUM,
                                          D.PART_NO,
                                          CD.WORKCENTER
                                     FROM MM_JIT_PART D
                                     LEFT JOIN MM_PUB_PLAN_CODE CD
                                       ON D.PLAN_CODE = CD.PLAN_CODE
                                   UNION
                                   SELECT PP.ARRIVE_NUM,
                                          PP.DISTRIBUTION_NUM,
                                          JI.PART_NO,
                                          CDD.WORKCENTER
                                     FROM MM_JISO_PARTGROUP PP
                                     LEFT JOIN MM_JISO_PART JI
                                       ON PP.ID = JI.PARTGROUP_ID
                                     LEFT JOIN MM_PUB_PLAN_CODE CDD
                                       ON PP.PLAN_CODE = CDD.PLAN_CODE) ACC
                           WHERE ACC.PART_NO = SUB_FORECAST.PART_ID) LOOP

          --获取属地信息
          v_location := null;
          v_loc_num  := 0;
          --v_distri_person := null;
          --1、根据零件获取属地信息中任一落点信息
          for cur_loc in (select a.location, a.location_num, a.distri_person
                            from mm_inv_part_location a
                           where a.factory_code = SUB_FORECAST.COMP
                             and a.workcenter = CUR_ADVAN.workcenter
                             and a.part_no = SUB_FORECAST.part_id
                             and a.eff_start <= sysdate
                             and a.eff_end > sysdate
                           order by a.location_num desc) loop
            v_location := cur_loc.location;
            v_loc_num  := cur_loc.location_num;
            --v_distri_person := cur_loc.distri_person;
            v_use_location_num := 'LOC';
            exit;
          end loop;
          --2、获取属地信息中车间最大工深
          if v_location is null then
            select decode(max(a.location_num), null, 0, max(a.location_num))
              into v_loc_num
              from mm_inv_part_location a
             where a.factory_code = SUB_FORECAST.COMP
                  --and a.workcenter = SUB_FORECAST.workcenter
               and a.eff_start <= sysdate
               and a.eff_end > sysdate;
            v_use_location_num := 'WC';
          end if;
          --3、获取系统参数中车间最大工深
          --if v_location is null then
            if CUR_ADVAN.WORKCENTER = 'A1' THEN
              V_WORKCENTER := 'AF';
            ELSIF CUR_ADVAN.WORKCENTER = 'W1' THEN
              V_WORKCENTER := 'WE';
            ELSIF CUR_ADVAN.WORKCENTER = 'T1' THEN
              V_WORKCENTER := 'PA';
            ELSE
              V_WORKCENTER := 'AF';
            END IF;

            ----最大工深获取方式修改为如下-------------------------------------------------------------------
            BEGIN
              --判断如果是总装
              SELECT NVL(A.PARAM_VAL, 0)
                INTO v_af_max_loc
                FROM MM_PUB_SYS_PARAM A
               WHERE A.PARAM_GROUP = 'MAX_LOC'
                 AND A.FACTORY_CODE = SUB_FORECAST.COMP
                 AND A.PARAM_CODE = 'AF_TOTAL_PRO_NUM';

              --判断如果是焊装
              SELECT NVL(A.PARAM_VAL, 0)
                INTO v_we_max_loc
                FROM MM_PUB_SYS_PARAM A
               WHERE A.PARAM_GROUP = 'MAX_LOC'
                 AND A.FACTORY_CODE = SUB_FORECAST.COMP
                 AND A.PARAM_CODE = 'WE_TOTAL_PRO_NUM';

              --判断如果是涂装
              SELECT NVL(A.PARAM_VAL, 0)
                INTO v_pa_max_loc
                FROM MM_PUB_SYS_PARAM A
               WHERE A.PARAM_GROUP = 'MAX_LOC'
                 AND A.FACTORY_CODE = SUB_FORECAST.COMP
                 AND A.PARAM_CODE = 'PA_TOTAL_PRO_NUM';
              --判断如果是涂装
              SELECT NVL(A.PARAM_VAL, 0)
                INTO v_wbs_max_loc
                FROM MM_PUB_SYS_PARAM A
               WHERE A.PARAM_GROUP = 'MAX_LOC'
                 AND A.FACTORY_CODE = SUB_FORECAST.COMP
                 AND A.PARAM_CODE = 'WBS_TOTAL_PRO_NUM';

              --判断如果是涂装
              SELECT NVL(A.PARAM_VAL, 0)
                INTO v_pbs_max_loc
                FROM MM_PUB_SYS_PARAM A
               WHERE A.PARAM_GROUP = 'MAX_LOC'
                 AND A.FACTORY_CODE = SUB_FORECAST.COMP
                 AND A.PARAM_CODE = 'PBS_TOTAL_PRO_NUM';
            END;

            IF CUR_ADVAN.WORKCENTER = 'A1' AND NVL(v_loc_num, 0) = 0 THEN
              v_loc_num := v_af_max_loc;
            ELSIF CUR_ADVAN.WORKCENTER = 'A1' AND NVL(v_loc_num, 0) != 0 THEN
              v_loc_num := NVL(v_loc_num, 0);
            ELSIF CUR_ADVAN.WORKCENTER = 'T1' AND NVL(v_loc_num, 0) = 0 THEN
              v_loc_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc;
            ELSIF CUR_ADVAN.WORKCENTER = 'T1' AND NVL(v_loc_num, 0) != 0 THEN
              v_loc_num := v_af_max_loc + v_pbs_max_loc + NVL(v_loc_num, 0);
            ELSIF CUR_ADVAN.WORKCENTER = 'W1' AND NVL(v_loc_num, 0) = 0 THEN
              v_loc_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc +
                           v_wbs_max_loc + v_we_max_loc;
            ELSIF CUR_ADVAN.WORKCENTER = 'W1' AND NVL(v_loc_num, 0) != 0 THEN
              v_loc_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc +
                           v_wbs_max_loc + NVL(v_loc_num, 0);
            END IF;

            ------------------------------------------------------------------------

            /*            v_loc_num          := to_number(PKG_PUB.USF_GET_SYS_PARAM(SUB_FORECAST.Comp,
            'MAX_LOC',
            V_WORKCENTER ||
            'TOTAL_PRO_NUM'));*/
            v_use_location_num := 'SYS';
          --end if;
          if v_loc_num is null then
            v_loc_num          := 0;
            v_use_location_num := null;
          end if;
          IF CUR_ADVAN.WORKCENTER IN ('W1', 'A1', 'T1') THEN

            --台套数对应时间
            V_OUT_TIME := PKG_PUB.USF_GET_PRODUCE_TIME(SUB_FORECAST.COMP,
                                                       CUR_ADVAN.WORKCENTER,
                                                       NULL) *
                          (nvl(v_loc_num, 0) + nvl(CUR_ADVAN.ARRIVE_NUM, 0) +
                           nvl(CUR_ADVAN.DISTRIBUTION_NUM, 0));

            --厂内装配时间
            V_TIME := PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                   CUR_ADVAN.WORKCENTER,
                                                   TO_DATE(SUB_FORECAST.REC_DATE,
                                                           'YYYY-MM-DD HH24:MI:SS'),
                                                   -V_OUT_TIME);

          ELSE
            --台套数对应时间
            --如果车间不是总装焊装涂装，使用总装计算
            V_OUT_TIME := PKG_PUB.USF_GET_PRODUCE_TIME(SUB_FORECAST.COMP,
                                                       'A1',
                                                       NULL) *
                          (v_loc_num + CUR_ADVAN.ARRIVE_NUM +
                           CUR_ADVAN.DISTRIBUTION_NUM);

            --厂内装配时间
            --如果车间不是总装焊装涂装，使用总装计算
            V_TIME := PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                   'A1',
                                                   TO_DATE(SUB_FORECAST.REC_DATE,
                                                           'YYYY-MM-DD HH24:MI:SS'),
                                                   -V_OUT_TIME);

          END IF;

          --DBMS_OUTPUT.put_line(TO_CHAR(V_TIME, 'YYYY-MM-DD HH24:mi:ss'));
          V_TIME1 := V_TIME -
                     TO_DATE(SUB_FORECAST.REC_DATE, 'YYYY-MM-DD HH24:MI:SS');
          /*    V_ENDTIME := 0;
          IF V_ENDTIME > V_TIME1 THEN
            V_ENDTIME := V_TIME1;
            END IF;*/
          --从路线中获取省内省外和运输时长
          SELECT MAX(A.AREA), MAX(A.TRANS_TIME)
            INTO V_AREA, V_TRANS_TIME
            FROM MM_PUP_ROUTE A
           WHERE A.FACTORY_CODE = SUB_FORECAST.COMP
             AND A.SUPPLIER_NO = SUB_FORECAST.SUPPLIER_NO
             AND A.SUP_FACTORY =
                 (SELECT UDA.SUP_FACTORY
                    FROM MM_PUB_PART_UDA UDA
                   WHERE UDA.PART_NO = SUB_FORECAST.PART_ID)
             AND A.CAR_TYPE = SUB_FORECAST.MODEL_CODE;

          V_ADVANCE_TIME := 0;

          IF V_AREA IS NOT NULL AND V_TRANS_TIME IS NOT NULL THEN
            IF V_TRANS_TIME = 0 THEN
              V_TRANS_TIME := 1;
            END IF;
            IF V_AREA = '省内' THEN
              --V_ADVANCE_TIME := CEIL(V_ENDTIME - V_TRANS_TIME/24);
              IF CUR_ADVAN.WORKCENTER IN ('A1', 'W1', 'T1') THEN

                V_ADVANCE_TIME := TO_DATE(SUB_FORECAST.REC_DATE,
                                          'YYYY-MM-DD HH24:MI:SS') -
                                  PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                               CUR_ADVAN.WORKCENTER,
                                                               V_TIME,
                                                               -V_TRANS_TIME);
              ELSE
                V_ADVANCE_TIME := TO_DATE(SUB_FORECAST.REC_DATE,
                                          'YYYY-MM-DD HH24:MI:SS') -
                                  PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                               'A1',
                                                               V_TIME,
                                                               -V_TRANS_TIME);
              END IF;
            END IF;
            --SELECT ceil(V_OUT_TIME + V_TRANS_TIME) INTO V_ADVANCE_TIME FROM DUAL;
            IF V_AREA = '省外' THEN
              --SELECT ceil(V_OUT_TIME + V_TRANS_TIME) / 24 INTO V_ADVANCE_TIME FROM DUAL;
              --V_ADVANCE_TIME := CEIL(V_ENDTIME + V_TRANS_TIME/24);

              IF CUR_ADVAN.WORKCENTER IN ('A1', 'W1', 'T1') THEN

                V_ADVANCE_TIME := TO_DATE(SUB_FORECAST.REC_DATE,
                                          'YYYY-MM-DD HH24:MI:SS') -
                                  TO_DATE(USF_MM_MP_FORBAKWORKDATE(TO_CHAR(V_TIME,
                                                                           'YYYY-MM-DD'),
                                                                   CEIL(NVL(V_TRANS_TIME,
                                                                            0) / 24),
                                                                   CUR_ADVAN.WORKCENTER,
                                                                   SUB_FORECAST.COMP,
                                                                   0) ||
                                          TO_CHAR(V_TIME, 'HH24:MI:SS'),
                                          'YYYY-MM-DD HH24:MI:SS');
              ELSE
                V_ADVANCE_TIME := TO_DATE(SUB_FORECAST.REC_DATE,
                                          'YYYY-MM-DD HH24:MI:SS') -
                                  TO_DATE(USF_MM_MP_FORBAKWORKDATE(TO_CHAR(V_TIME,
                                                                           'YYYY-MM-DD'),
                                                                   CEIL(NVL(V_TRANS_TIME,
                                                                            0) / 24),
                                                                   'A1',
                                                                   SUB_FORECAST.COMP,
                                                                   0) ||
                                          TO_CHAR(V_TIME, 'HH24:MI:SS'),
                                          'YYYY-MM-DD HH24:MI:SS');
              END IF;
            END IF;
          END IF;

        END LOOP;
      END IF;

      --V_NUM := 0;
      SELECT COUNT(1)
        INTO V_NUM
        FROM MM_SW_DEMAND_FORECAST T
       WHERE T.FACTORY_CODE = SUB_FORECAST.COMP
         AND T.VERSION = SUB_FORECAST.VERSION_NO
         AND T.PART_NO = SUB_FORECAST.PART_ID
         AND T.SUPPLIER_NO = SUB_FORECAST.SUPPLIER_NO
         AND T.FORE_TYPE = SUB_FORECAST.FORE_TYPE
         AND NVL(T.SEQ, '#') = NVL(SUB_FORECAST.SEQ, '#')

         AND T.START_DATE =
             TO_DATE(SUB_FORECAST.END_DATE, 'yyyy-MM-dd HH24:mi:ss')
         AND T.END_DATE =
             TO_DATE(SUB_FORECAST.START_DATE, 'yyyy-MM-dd HH24:mi:ss')
         AND NVL(T.WORKCENTER, '#') = NVL(SUB_FORECAST.WORKCENTER, '#');
      IF V_NUM > 0 THEN

        DELETE MM_SW_DEMAND_FORECAST T
         WHERE T.FACTORY_CODE = SUB_FORECAST.COMP
           AND T.VERSION = SUB_FORECAST.VERSION_NO
           AND T.PART_NO = SUB_FORECAST.PART_ID
           AND T.SUPPLIER_NO = SUB_FORECAST.SUPPLIER_NO
           AND T.FORE_TYPE = SUB_FORECAST.FORE_TYPE
           AND NVL(T.SEQ, '#') = NVL(SUB_FORECAST.SEQ, '#')
           AND T.START_DATE =
               TO_DATE(SUB_FORECAST.END_DATE, 'yyyy-MM-dd HH24:mi:ss')
           AND T.END_DATE =
               TO_DATE(SUB_FORECAST.START_DATE, 'yyyy-MM-dd HH24:mi:ss')
           AND NVL(T.WORKCENTER, '#') = NVL(SUB_FORECAST.WORKCENTER, '#');

        BEGIN
           SELECT MAX(UNLOAD_PORT) --获取卸货口
            INTO V_UNLOAD_PORT
            FROM (SELECT DISTINCT SD.UNLOAD_PORT
                    FROM MM_INV_PART_LOCATION SD
                   WHERE SD.PART_NO = SUB_FORECAST.PART_ID
                     AND SUB_FORECAST.COMP = SD.FACTORY_CODE
                     AND SD.EFF_START <= SYSDATE
                     AND SYSDATE <= SD.EFF_END);

        EXCEPTION
          WHEN OTHERS THEN
            V_UNLOAD_PORT := '';
        END;

        BEGIN
          SELECT Max(OAD.LOGISTICS_MODEL)
            INTO V_MM_MODEL --获取物流模式
            FROM MM_PUB_PART_UNLOAD OAD
           WHERE OAD.PART_NO = SUB_FORECAST.PART_ID;

        EXCEPTION
          WHEN OTHERS THEN
            V_MM_MODEL := '';
        END;

        /*          FOR SUB_UNLOAD_PORT IN (
         SELECT T.UNLOAD_PORT
          V_UNLOAD_PORT
         FROM MM_INV_PART_LOCATION T
        WHERE T.PART_NO = SUB_FORECAST.PART_ID
              AND T.FACTORY_CODE = SUB_FORECAST.COMP)LOOP*/
        /**
        SELECT M.SUP_FACTORY
          INTO V_SUP_FACTORY
          FROM MM_PUB_PART_SUPPLIER M
         WHERE M.SUPPLIER_NO = SUB_FORECAST.SUPPLIER_NO;**/

        /*                 SELECT TO_CHAR(WMSYS.WM_CONCAT( T.LOGISTICS_MODE))
        INTO V_MM_MODEL
        FROM MM_INV_UNLOAD T
        WHERE  T.UNLOAD_PORT = SUB_UNLOAD_PORT.V_UNLOAD_PORT;*/
        INSERT INTO MM_SW_DEMAND_FORECAST
          (ID,
           FACTORY_CODE,
           FORE_TYPE,
           VERSION,
           PLAN_DELIVERY,
           START_DATE,
           MODEL_CODE,
           END_DATE,
           PHASE,
           UNLOAD_PORT,
           PART_NO,
           PART_UNIT,
           ORDER_QTY,
           SUPPLIER_NO,
           LOGISTICS_MODE,
           DOWNLOAD_STATUS,
           CREATION_TIME,
           LAST_MODIFIED_TIME,
           RELEASE_STATUS,
           FEEDBACK_STATUS,
           PUBLISH_MONTH,
           OBJ_MONTH,
           OBJ_WEEK,
           PUBLISH_WEEK,
           ADVANCE_TIME,
           DEAL_FLAG,
           DO_FLAG,
           SEQ)
        VALUES
          (SEQ_MM_SW_DEMAND_FORE.NEXTVAL,
           SUB_FORECAST.COMP,
           TO_NUMBER(SUB_FORECAST.FORE_TYPE, 0),
           SUB_FORECAST.VERSION_NO || SUB_FORECAST.SEQ,
           TO_DATE(SUB_FORECAST.REC_DATE, 'yyyy-MM-dd HH24:mi:ss'),
           TO_DATE(SUB_FORECAST.START_DATE, 'yyyy-MM-dd HH24:mi:ss'),
           SUB_FORECAST.MODEL_CODE,
           TO_DATE(SUB_FORECAST.END_DATE, 'yyyy-MM-dd HH24:mi:ss'),
           SUB_FORECAST.PHASE,
           V_UNLOAD_PORT,
           SUB_FORECAST.PART_ID,
           SUB_FORECAST.PART_UNIT,
           SUB_FORECAST.ORDER_NUM,
           SUB_FORECAST.SUPPLIER_NO,
           V_MM_MODEL,
           0,
           SYSDATE,
           SYSDATE,
           1,
           0,
           SUB_FORECAST.PUBLISH_MONTH,
           SUB_FORECAST.OBJ_MONTH,
           SUB_FORECAST.OBJ_WEEK,
           SUB_FORECAST.PUBLISH_WEEK,
           V_ADVANCE_TIME,
           '0',
           'U',
           SUB_FORECAST.SEQ);
        --END LOOP;
      ELSE

        BEGIN
          SELECT MAX(UNLOAD_PORT) --获取卸货口
            INTO V_UNLOAD_PORT
            FROM (SELECT DISTINCT SD.UNLOAD_PORT
                    FROM MM_INV_PART_LOCATION SD
                   WHERE SD.PART_NO = SUB_FORECAST.PART_ID
                     AND SUB_FORECAST.COMP = SD.FACTORY_CODE
                     AND SD.EFF_START <= SYSDATE
                     AND SYSDATE <= SD.EFF_END);
        EXCEPTION
          WHEN OTHERS THEN
            V_UNLOAD_PORT := '';
        END;

        BEGIN
          SELECT MAX(UDA.LOGISTICS_MODEL)
            INTO V_MM_MODEL --获取物流模式
            FROM MM_PUB_PART_UNLOAD UDA
           WHERE UDA.PART_NO = SUB_FORECAST.PART_ID;
        EXCEPTION
          WHEN OTHERS THEN
            V_MM_MODEL := '';
        END;

        /*           FOR SUB_UNLOAD_PORT IN (
         SELECT T.UNLOAD_PORT
         INTO V_UNLOAD_PORT
         FROM MM_INV_PART_LOCATION T
        WHERE T.PART_NO = SUB_FORECAST.PART_ID)LOOP*/

        --SELECT DISTINCT M.SUP_FACTORY
        -- INTO V_SUP_FACTORY
        -- FROM MM_PUB_PART_SUPPLIER M
        -- WHERE M.SUPPLIER_NO = SUB_FORECAST.SUPPLIER_NO;

        /*          SELECT TO_CHAR(WMSYS.WM_CONCAT( T.LOGISTICS_MODE))
         INTO V_MM_MODEL
         FROM MM_INV_UNLOAD T
        WHERE  T.UNLOAD_PORT = SUB_UNLOAD_PORT.UNLOAD_PORT;*/

        INSERT INTO MM_SW_DEMAND_FORECAST
          (ID,
           FACTORY_CODE,
           FORE_TYPE,
           VERSION,
           PLAN_DELIVERY,
           START_DATE,
           MODEL_CODE,
           END_DATE,
           PHASE,
           UNLOAD_PORT,
           PART_NO,
           PART_UNIT,
           ORDER_QTY,
           SUPPLIER_NO,
           LOGISTICS_MODE,
           DOWNLOAD_STATUS,
           CREATION_TIME,
           LAST_MODIFIED_TIME,
           RELEASE_STATUS,
           FEEDBACK_STATUS,
           PUBLISH_MONTH,
           OBJ_MONTH,
           OBJ_WEEK,
           PUBLISH_WEEK,
           ADVANCE_TIME,
           DEAL_FLAG,
           DO_FLAG,
           SEQ)
        VALUES
          (SEQ_MM_SW_DEMAND_FORE.NEXTVAL,
           SUB_FORECAST.COMP,
           TO_NUMBER(SUB_FORECAST.FORE_TYPE, 0),
           SUB_FORECAST.VERSION_NO || SUB_FORECAST.SEQ,
           TO_DATE(SUB_FORECAST.REC_DATE, 'yyyy-MM-dd HH24:mi:ss'),
           TO_DATE(SUB_FORECAST.START_DATE, 'yyyy-MM-dd HH24:mi:ss'),
           SUB_FORECAST.MODEL_CODE,
           TO_DATE(SUB_FORECAST.END_DATE, 'yyyy-MM-dd HH24:mi:ss'),
           SUB_FORECAST.PHASE,
           V_UNLOAD_PORT,
           SUB_FORECAST.PART_ID,
           SUB_FORECAST.PART_UNIT,
           SUB_FORECAST.ORDER_NUM,
           SUB_FORECAST.SUPPLIER_NO,
           V_MM_MODEL,
           0,
           SYSDATE,
           SYSDATE,
           1,
           0,
           SUB_FORECAST.PUBLISH_MONTH,
           SUB_FORECAST.OBJ_MONTH,
           SUB_FORECAST.OBJ_WEEK,
           SUB_FORECAST.PUBLISH_WEEK,
           V_ADVANCE_TIME,
           '0',
           'I',
           SUB_FORECAST.SEQ);

        --END LOOP;
      END IF;
      --如果ID不为空更新处理标识
      IF SUB_FORECAST.ID IS NOT NULL THEN
        UPDATE IF_SW_DEMAND_FORECAST T
           SET T.DEAL_FLAG = 1
         WHERE T.ID = SUB_FORECAST.ID;
      END IF;
    END LOOP;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      ERROR_TAG     := SQLCODE;
      ERROR_MESSAGE := SUBSTR(SQLERRM ||
                              DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(),
                              1,
                              200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_SW_IF_TO_DEMAND_FORECAST',
         ERROR_TAG,
         ERROR_MESSAGE,
         SYSDATE,
         '预测接口数据至业务表');
      COMMIT;
  END USP_SW_IF_TO_DEMAND_FORECAST;

  --****************************************************************************
  --过程名  : USP_SW_IF_TO_LONG_ORDER
  --功能描述: 长周期接口数据至业务表
  --参数说明: 工厂代码
  --创建人员: ZHENGWUCHAO
  --创建时间: 2018-10-22
  --****************************************************************************
  PROCEDURE USP_SW_IF_TO_LONG_ORDER(ERROR_TAG     OUT NUMBER,
                                    ERROR_MESSAGE OUT VARCHAR2) AS
    V_NUM    NUMBER(19);
    V_DETIAL NUMBER(19);
  BEGIN
    FOR LONG_ORDER IN (SELECT F.*
                         FROM IF_LONG_CYCLE_ORDER F
                        WHERE F.DEAL_FLAG = 0
                          AND F.UDA1 = 'NOR'
                        ORDER BY F.ID ASC) LOOP
      --V_NUM := 0;
      SELECT COUNT(1)
        INTO V_NUM
        FROM MM_SW_LONG_ORDER T
       WHERE T.VERSION = LONG_ORDER.VERSION_NO
         AND T.ORDER_NO = LONG_ORDER.ORDER_NO;

      SELECT COUNT(1)
        INTO V_DETIAL
        FROM MM_SW_LONG_ORDER_DETAIL D
       WHERE D.VERSION = LONG_ORDER.VERSION_NO
         AND D.ORDER_NO = LONG_ORDER.ORDER_NO
         AND D.PART_NO = LONG_ORDER.PART_NO;

      IF V_NUM > 0 THEN
        /*        --如存在则先删除在插入
        DELETE MM_SW_LONG_ORDER T
         WHERE T.VERSION = LONG_ORDER.VERSION_NO
           AND T.ORDER_NO = LONG_ORDER.ORDER_NO;*/

        --数据写入主表中
        INSERT INTO MM_SW_LONG_ORDER
          (ID,
           VERSION,
           ORDER_NO,
           CURRENT_MONTH,
           OBJ_MONTH,
           ORDER_PERIOD,
           FORECAST_PERIOD,
           FORECAST_FIRST,
           --FORECAST_FIRST_NUM,
           FORECAST_SECOND,
           --FORECAST_SECOND_NUM,
           FORECAST_THIRD,
           --FORECAST_THIRD_NUM,
           CREATION_TIME,
           PRINT_STATUS,
           DEAL_FLAG,
           DO_FLAG)

        VALUES
          (SEQ_MM_SW_LONG_ORDER.NEXTVAL,
           LONG_ORDER.VERSION_NO,
           LONG_ORDER.ORDER_NO,
           LONG_ORDER.CURR_MONTH,
           LONG_ORDER.OBJ_MONTH,
           LONG_ORDER.ORDER_PERIOD,
           LONG_ORDER.OBJ_PERIOD,
           LONG_ORDER.OBJ_FIRST,
           --LONG_ORDER.OBJ_FIRST_NUM,
           LONG_ORDER.OJB_SECOND,
           --LONG_ORDER.OJB_SECOND_NUM,
           LONG_ORDER.OJB_THIRD,
           --LONG_ORDER.OJB_THIRD_NUM,
           SYSDATE,
           '0',
           '0',
           'U');
      ELSE
        --数据写入主表中
        INSERT INTO MM_SW_LONG_ORDER
          (ID,
           VERSION,
           ORDER_NO,
           CURRENT_MONTH,
           OBJ_MONTH,
           ORDER_PERIOD,
           FORECAST_PERIOD,
           FORECAST_FIRST,
           --FORECAST_FIRST_NUM,
           FORECAST_SECOND,
           --FORECAST_SECOND_NUM,
           FORECAST_THIRD,
           --FORECAST_THIRD_NUM,
           CREATION_TIME,
           PRINT_STATUS,
           DEAL_FLAG,
           DO_FLAG)

        VALUES
          (SEQ_MM_SW_LONG_ORDER.NEXTVAL,
           LONG_ORDER.VERSION_NO,
           LONG_ORDER.ORDER_NO,
           LONG_ORDER.CURR_MONTH,
           LONG_ORDER.OBJ_MONTH,
           LONG_ORDER.ORDER_PERIOD,
           LONG_ORDER.OBJ_PERIOD,
           LONG_ORDER.OBJ_FIRST,
           --LONG_ORDER.OBJ_FIRST_NUM,
           LONG_ORDER.OJB_SECOND,
           --LONG_ORDER.OJB_SECOND_NUM,
           LONG_ORDER.OJB_THIRD,
           --LONG_ORDER.OJB_THIRD_NUM,
           SYSDATE,
           '0',
           '0',
           'I');
      END IF;

      IF V_DETIAL > 0 THEN
        /*
        DELETE MM_SW_LONG_ORDER_DETAIL TD
         WHERE TD.VERSION = LONG_ORDER.VERSION_NO
           AND TD.ORDER_NO = LONG_ORDER.ORDER_NO
           AND TD.PART_NO = LONG_ORDER.PART_NO;*/
        --数据写入明细表
        INSERT INTO MM_SW_LONG_ORDER_DETAIL
          (VERSION,
           ORDER_NO,
           PART_NO,
           CAR_TYPE,
           SUPPLIER_NO,
           SUP_FACTORY,
           REQUIRE_NUM,
           ORDER_REQUIRE_NUM,
           PART_UNIT,
           ORDER_NUM,
           ORDER_BOX,
           DEAL_FLAG,
           DO_FLAG,
           FORECAST_FIRST_NUM,
           FORECAST_SECOND_NUM,
           FORECAST_THIRD_NUM)
        VALUES
          (LONG_ORDER.VERSION_NO,
           LONG_ORDER.ORDER_NO,
           LONG_ORDER.PART_NO,
           LONG_ORDER.CAR_TYPE,
           LONG_ORDER.SUPPLIER_NO,
           LONG_ORDER.SUP_FACTORY,
           LONG_ORDER.REUIRE_NUM,
           LONG_ORDER.ORDER_REQUIRE_NUM,
           LONG_ORDER.PART_UNIT,
           LONG_ORDER.ORDER_NUM,
           LONG_ORDER.ORDER_BOX,
           '0',
           'U',
           LONG_ORDER.OBJ_FIRST_NUM,
           LONG_ORDER.OJB_SECOND_NUM,
           LONG_ORDER.OJB_THIRD_NUM);

      ELSE
        --数据写入明细表
        INSERT INTO MM_SW_LONG_ORDER_DETAIL
          (VERSION,
           ORDER_NO,
           PART_NO,
           CAR_TYPE,
           SUPPLIER_NO,
           SUP_FACTORY,
           REQUIRE_NUM,
           ORDER_REQUIRE_NUM,
           PART_UNIT,
           ORDER_NUM,
           ORDER_BOX,
           DEAL_FLAG,
           DO_FLAG,
           FORECAST_FIRST_NUM,
           FORECAST_SECOND_NUM,
           FORECAST_THIRD_NUM)
        VALUES
          (LONG_ORDER.VERSION_NO,
           LONG_ORDER.ORDER_NO,
           LONG_ORDER.PART_NO,
           LONG_ORDER.CAR_TYPE,
           LONG_ORDER.SUPPLIER_NO,
           LONG_ORDER.SUP_FACTORY,
           LONG_ORDER.REUIRE_NUM,
           LONG_ORDER.ORDER_REQUIRE_NUM,
           LONG_ORDER.PART_UNIT,
           LONG_ORDER.ORDER_NUM,
           LONG_ORDER.ORDER_BOX,
           '0',
           'I',
           LONG_ORDER.OBJ_FIRST_NUM,
           LONG_ORDER.OJB_SECOND_NUM,
           LONG_ORDER.OJB_THIRD_NUM);
      END IF;

      UPDATE IF_LONG_CYCLE_ORDER T
         SET T.DEAL_FLAG = 1, T.DEAL_TIME = SYSDATE
       WHERE T.ID = LONG_ORDER.ID
         AND T.UDA1 = 'NOR';
    END LOOP;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      ERROR_TAG     := SQLCODE;
      ERROR_MESSAGE := SUBSTR(SQLERRM ||
                              DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(),
                              1,
                              200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_SW_IF_TO_LONG_ORDER',
         ERROR_TAG,
         ERROR_MESSAGE,
         SYSDATE,
         '长周期接口数据至业务表');
      COMMIT;
  END USP_SW_IF_TO_LONG_ORDER;

  --****************************************************************************
  --过程名  : USP_SW_IF_TO_LONG_ORDER
  --功能描述: 长周期接口数据(非标件）至业务表
  --参数说明:
  --创建人员: luoxianqin
  --创建时间: 2018-10-22
   ---modefied by luoxianqin 定制化订单明细表添加工厂
  --****************************************************************************
  PROCEDURE USP_SW_IF_TO_NON_STANDAR AS
    V_NUM         NUMBER(19);
    V_DETIAL      NUMBER(19);
    ERROR_TAG     NUMBER(19);
    ERROR_MESSAGE VARCHAR2(1000);
  BEGIN
    FOR LONG_ORDER IN (SELECT F.*,
                              D.FEATURE,
                              D.FEATURE_VALUE,
                              D.FEATURE_TYPE,
                              D.SORT_NO
                         FROM IF_LONG_CYCLE_ORDER F
                         LEFT JOIN IF_LONG_CYCLE_ORDER_DETAIL D
                           ON F.SALE_NO = D.SALE_NO
                          AND F.SALE_ROW_NO = D.SALE_ROW_NO
                          AND F.PART_NO = D.PART_NO
                        WHERE F.DEAL_FLAG = 0
                          AND F.UDA1 = 'SPE'
                        ORDER BY F.ID ASC) LOOP

      --判断数据是否已经在主表中存在
      SELECT COUNT(1)
        INTO V_NUM
        FROM MM_SW_NON_STANDARD T
       WHERE T.SALE_NO = LONG_ORDER.SALE_NO
         AND T.SALE_ROW_NO = LONG_ORDER.SALE_ROW_NO
         AND T.PART_NO = LONG_ORDER.PART_NO;

      --判断数据是否已经在明细表中存在
      SELECT COUNT(1)
        INTO V_DETIAL
        FROM MM_SW_NON_STANDARD_DETAIL D
       WHERE D.SALE_NO = LONG_ORDER.SALE_NO
         AND D.SALE_ROW_NO = LONG_ORDER.SALE_ROW_NO
         AND D.PART_NO = LONG_ORDER.PART_NO
         AND D.FEATURE = LONG_ORDER.FEATURE
         AND D.FEATURE_TYPE = LONG_ORDER.FEATURE_TYPE
         AND D.FEATURE_VALUE = LONG_ORDER.FEATURE_VALUE;
         --AND D.FACTORY_CODE = LONG_ORDER.FACTORY_CODE;

      --存在则更新
      IF V_NUM > 0 THEN
        UPDATE MM_SW_NON_STANDARD T
           SET T.FACTORY_CODE = LONG_ORDER.FACTORY_CODE,
               T.SALE_NO      = LONG_ORDER.SALE_NO,
               ORDER_NO       = LONG_ORDER.ORDER_NO,
               SALE_NO        = LONG_ORDER.SALE_NO,
               SALE_ROW_NO    = LONG_ORDER.SALE_ROW_NO,
               SUPPLIER_NO    = LONG_ORDER.SUPPLIER_NO,
               SUP_FACTORY    = LONG_ORDER.SUP_FACTORY,
               PART_NO        = LONG_ORDER.PART_NO,
               ORDER_NUM      = LONG_ORDER.ORDER_NUM,
               LAST_CHECK_ID  = '',
               DEAL_FLAG      = '0',
               DO_FLAG        = 'U'
         WHERE T.SALE_NO = LONG_ORDER.SALE_NO
           AND T.SALE_ROW_NO = LONG_ORDER.SALE_ROW_NO
           AND T.PART_NO = LONG_ORDER.PART_NO;

        --不存在则写入
      ELSE
        --数据写入主表中
        INSERT INTO MM_SW_NON_STANDARD
          (ID,
           FACTORY_CODE,
           ORDER_NO,
           SALE_NO,
           SALE_ROW_NO,
           SUPPLIER_NO,
           SUP_FACTORY,
           PART_NO,
           ORDER_NUM,
           CREATION_TIME,
           DEAL_FLAG,
           DO_FLAG)
        VALUES
          (SEQ_SW_NON_STANDARD.NEXTVAL,
           LONG_ORDER.FACTORY_CODE,
           LONG_ORDER.ORDER_NO,
           LONG_ORDER.SALE_NO,
           LONG_ORDER.SALE_ROW_NO,
           LONG_ORDER.SUPPLIER_NO,
           LONG_ORDER.SUP_FACTORY,
           LONG_ORDER.PART_NO,
           LONG_ORDER.ORDER_NUM,
           SYSDATE,
           '0',
           'I');
      END IF;

      --明细如已存在则修改
      IF V_DETIAL > 0 THEN
        UPDATE MM_SW_NON_STANDARD_DETAIL D
           SET SALE_NO       = LONG_ORDER.SALE_NO,
               SALE_ROW_NO   = LONG_ORDER.SALE_ROW_NO,
               PART_NO       = LONG_ORDER.PART_NO,
               FEATURE       = LONG_ORDER.FEATURE,
               FEATURE_TYPE  = LONG_ORDER.FEATURE_TYPE,
               FEATURE_VALUE = LONG_ORDER.FEATURE_VALUE,
               SORT_NO       = LONG_ORDER.SORT_NO,
               DEAL_FLAG     = '0',
               DO_FLAG       = 'U'
         WHERE D.SALE_NO = LONG_ORDER.SALE_NO
           AND D.SALE_ROW_NO = LONG_ORDER.SALE_ROW_NO
           AND D.PART_NO = LONG_ORDER.PART_NO
           AND D.FEATURE = LONG_ORDER.FEATURE
           AND D.FEATURE_TYPE = LONG_ORDER.FEATURE_TYPE
           AND D.FEATURE_VALUE = LONG_ORDER.FEATURE_VALUE;

        --不存在则写入
      ELSE
        --数据写入明细表
        INSERT INTO MM_SW_NON_STANDARD_DETAIL
          (SALE_NO,
           SALE_ROW_NO,
           PART_NO,
           FEATURE,
           FEATURE_TYPE,
           FEATURE_VALUE,
           SORT_NO,
           CREATION_TIME,
           DEAL_FLAG,
           DO_FLAG)
           --FACTORY_CODE)
        VALUES
          (LONG_ORDER.SALE_NO,
           LONG_ORDER.SALE_ROW_NO,
           LONG_ORDER.PART_NO,
           LONG_ORDER.FEATURE,
           LONG_ORDER.FEATURE_TYPE,
           LONG_ORDER.FEATURE_VALUE,
           LONG_ORDER.SORT_NO,
           SYSDATE,
           '0',
           'I');
           --LONG_ORDER.FACTORY_CODE
      END IF;

      UPDATE IF_LONG_CYCLE_ORDER T
         SET T.DEAL_FLAG = 1, T.DEAL_TIME = SYSDATE
       WHERE T.ID = LONG_ORDER.ID
         AND T.UDA1 = 'SPE';
    END LOOP;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      ERROR_TAG     := SQLCODE;
      ERROR_MESSAGE := SUBSTR(SQLERRM ||
                              DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(),
                              1,
                              200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_SW_IF_TO_LONG_ORDER',
         ERROR_TAG,
         ERROR_MESSAGE,
         SYSDATE,
         '长周期接口数(非标件)至业务表');
      COMMIT;
  END USP_SW_IF_TO_NON_STANDAR;

  --****************************************************************************
  --过程名  : USP_PUB_SUPPORTING_PART
  --功能描述: 支给件处理到业务表
  --创建人员: wangyu
  --创建时间: 2019-03-01
  --****************************************************************************
  PROCEDURE USP_PUB_SUPPORTING_PART(ERROR_TAG     OUT NUMBER,
                                    ERROR_MESSAGE OUT VARCHAR2) AS

  BEGIN
    --根据工厂删除之前数据
    DELETE FROM MM_PUB_SUPPORTING_PART A
     WHERE A.FACTORY_CODE IN (SELECT B.FACTORY_CODE
                                FROM IF_SUPPORTING_PART B
                               WHERE B.DEAL_FLAG = 0);

    --删除不存在于未处理的支给BOM中的支给仓库数据
/*    DELETE FROM MM_INV_WAREHOUSE A
     WHERE A.WARE_TYPE = 3
       AND NOT EXISTS (SELECT 1
              FROM MM_PUB_SUPPORTING_PART B
             WHERE A.WARE_CODE = B.NEXT_PLACEMENT
               AND A.FACTORY_CODE = B.FACTORY_CODE);*/

    --循环接口表
    FOR cur_sup_part IN (SELECT *
                           FROM IF_SUPPORTING_PART A
                          WHERE A.DEAL_FLAG = 0
                          ORDER BY A.ID, A.CREATION_TIME) LOOP
      /*IF cur_sup_part.Do_Flag = 'D' THEN
        --如果处理标识为D，则删除业务表数据
        DELETE FROM MM_PUB_SUPPORTING_PART B
         WHERE B.FACTORY_CODE =
               PKG_IF_REC.USF_TRANS_ERP_FACTORY(cur_sup_part.FACTORY_CODE)
           AND B.PARTF_ID = cur_sup_part.PARTF_ID
           AND B.PART_ROW_NO = cur_sup_part.PART_ROW_NO;
      ELSE
        --存在更新，不存在新增
        MERGE INTO MM_PUB_SUPPORTING_PART C
        USING (SELECT 1 FROM DUAL) B
        ON (C.PARTF_ID = cur_sup_part.Partf_Id AND C.FACTORY_CODE = PKG_IF_REC.USF_TRANS_ERP_FACTORY(cur_sup_part.FACTORY_CODE) AND C.PART_ROW_NO = cur_sup_part.PART_ROW_NO)
        WHEN MATCHED THEN
          UPDATE
             SET C.PART_NO             = cur_sup_part.PART_NO,
                 C.NUM                 = cur_sup_part.NUM,
                 C.USE_AGE_AMOUNT_UNIT = cur_sup_part.Use_Age_Amount_Unit,
                 C.LINE_STATION        = cur_sup_part.LINE_STATION,
                 C.NEXT_PLACEMENT      = cur_sup_part.NEXT_PLACEMENT,
                 C.PURCHASE_TYPE       = cur_sup_part.PURCHASE_TYPE,
                 C.LAST_MODIFIED_TIME  = SYSDATE
        WHEN NOT MATCHED THEN
          INSERT
            (C.FACTORY_CODE,
             C.PARTF_ID,
             C.PART_ROW_NO,
             C.PART_NO,
             C.NUM,
             C.USE_AGE_AMOUNT_UNIT,
             C.LINE_STATION,
             C.NEXT_PLACEMENT,
             C.PURCHASE_TYPE,
             C.CREATION_TIME)
          VALUES
            (cur_sup_part.FACTORY_CODE,
             cur_sup_part.PARTF_ID,
             cur_sup_part.PART_ROW_NO,
             cur_sup_part.PART_NO,
             cur_sup_part.NUM,
             cur_sup_part.USE_AGE_AMOUNT_UNIT,
             cur_sup_part.LINE_STATION,
             cur_sup_part.NEXT_PLACEMENT,
             cur_sup_part.PURCHASE_TYPE,
             SYSDATE);*/

      --写入支给BOM数据
      INSERT INTO MM_PUB_SUPPORTING_PART C
        (C.FACTORY_CODE,
         C.PARTF_ID,
         C.PART_ROW_NO,
         C.PART_NO,
         C.NUM,
         C.USE_AGE_AMOUNT_UNIT,
         C.LINE_STATION,
         C.NEXT_PLACEMENT,
         C.PURCHASE_TYPE,
         C.CREATION_TIME)
      VALUES
        (cur_sup_part.FACTORY_CODE,
         cur_sup_part.PARTF_ID,
         cur_sup_part.PART_ROW_NO,
         cur_sup_part.PART_NO,
         cur_sup_part.NUM,
         cur_sup_part.USE_AGE_AMOUNT_UNIT,
         cur_sup_part.LINE_STATION,
         cur_sup_part.NEXT_PLACEMENT,
         cur_sup_part.PURCHASE_TYPE,
         SYSDATE);

      --写入支给件仓库数据
      INSERT INTO MM_INV_WAREHOUSE
        (ID,
         FACTORY_CODE,
         WARE_CODE,
         ERP_WARE_CODE,
         WARE_NAME,
         WARE_TYPE,
         CREATION_USER,
         CREATION_TIME)
        SELECT SEQ_MM_INV_WARE.NEXTVAL,
               cur_sup_part.Factory_Code,
               cur_sup_part.Next_Placement,
               cur_sup_part.Next_Placement,
               cur_sup_part.Next_Placement || '供应商仓库',
               '3',
               'SYSTEM',
               SYSDATE
          FROM DUAL
         WHERE NOT EXISTS
         (SELECT 1
                  FROM MM_INV_WAREHOUSE B
                 WHERE cur_sup_part.Next_Placement = B.WARE_CODE);

      --操作完成，更新处理状态
      UPDATE IF_SUPPORTING_PART A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_sup_part.ID;
    END LOOP;

    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := 1;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);

        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_SUPPORTING_PART',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '支给件处理到业务表');
        COMMIT;

        ROLLBACK;
      END;
  END USP_PUB_SUPPORTING_PART;

  --****************************************************************************
  --过程名  : USP_JISO_INS_DETAIL_RECEIVE
  --功能描述: 座椅收货
  --创建人员: wagnyu
  --创建时间: 2019-04-13
  --****************************************************************************
  PROCEDURE USP_JISO_INS_DETAIL_RECEIVE(ERROR_TAG     OUT NUMBER,
                                        ERROR_MESSAGE OUT VARCHAR2) AS

  BEGIN
    --循环接口表
    FOR cur_rgv_receive IN (SELECT *
                              FROM IF_RGV_RECEIVE A
                             WHERE A.DEAL_FLAG = 0
                             ORDER BY A.ID, A.CREATION_TIME) LOOP

      --判断这条记录在MM_JISO_INS_DETAIL_RECEIVE是否存在
      --不存在新增
      MERGE INTO MM_JISO_INS_DETAIL_RECEIVE B
      USING (SELECT 1 FROM DUAL) C
      ON (B.FACTORY_CODE = cur_rgv_receive.Factory_Code AND B.INS_NO = cur_rgv_receive.Ins_No AND B.VIN = cur_rgv_receive.Vin AND B.PART_NO = cur_rgv_receive.Part_No)
      WHEN NOT MATCHED THEN
        INSERT
          (B.FACTORY_CODE,
           B.INS_NO,
           B.VIN,
           B.PART_NO,
           B.NUM,
           B.CREATION_TIME)
        VALUES
          (cur_rgv_receive.Factory_Code,
           cur_rgv_receive.Ins_No,
           cur_rgv_receive.Vin,
           cur_rgv_receive.Part_No,
           cur_rgv_receive.Num,
           SYSDATE);

      --操作完成，更新处理状态
      UPDATE IF_RGV_RECEIVE A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = cur_rgv_receive.ID;
    END LOOP;
    COMMIT;

    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN

        ERROR_TAG     := 1;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);

        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_JISO_INS_DETAIL_RECEIVE',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '座椅收货');
        COMMIT;

        ROLLBACK;
      END;
  END USP_JISO_INS_DETAIL_RECEIVE;

end PKG_IF_REC;
/

prompt
prompt Creating package body PKG_IF_SEND
prompt =================================
prompt
create or replace package body PKG_IF_SEND is

  --****************************************************************************
  --过程名  : USP_JISO_ORDER_SEND
  --功能描述: 厂外同步需结算订单写入接口表
  --参数说明: 无
  --创建人员: wxl
  --创建时间: 2018-09-17
  --****************************************************************************
  PROCEDURE USP_JISO_ORDER_SEND IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --更新处理标识为待处理
    update mm_jiso_order a
       set a.deal_flag = 2
     where a.deal_flag = 0
       and a.arr_depot in
           (select w.ware_code
              from mm_pub_plan_code p, mm_inv_warehouse w
             where p.plan_code = a.plan_code
               and w.factory_code = p.factory_code);
    commit;
    --写入物流订单中间表
    insert into if_logistics_order
      (logistics_orderno,
       comp,
       purchase_orderno,
       order_type,
       supplier_id,
       factory_id,
       orderissue_date,
       issue_user)
      select a.order_no,
             b.factory_code,
             a.purchase_orderno,
             '04', --同步订单
             a.supplier_no,
             a.sup_factory,
             a.creation_time,
             null --订单发布人
        from mm_jiso_order a, mm_pub_plan_code b
       where a.plan_code = b.plan_code
         and a.deal_flag = 2;
    --写入物流订单中间表
    insert into if_logistics_order_detail
      (logistics_orderno,
       logistics_rowno,
       purchase_orderno,
       purchase_row_no,
       plan_arrive_time,
       order_depot,
       part_id,
       order_num,
       part_unit,
       assembly_flag)
      select b.order_no,
             b.order_rowno,
             a.purchase_orderno,
             b.order_rowno,
             a.arrive_time,
             d.erp_ware_code,
             b.part_no,
             b.require_num,
             c.part_unit,
             decode(c.purchase_type, 'AW', '1', '0') --AW支给总成件标识1、其它普通件标识0
        from mm_jiso_order        a,
             mm_jiso_order_detail b,
             mm_pub_part          c,
             mm_inv_warehouse     d,
             --i-LMS2019053001 mod by wangyu
             --增加工厂
             mm_pub_plan_code e
       where a.order_no = b.order_no
         and b.part_no = c.part_no
            --i-LMS2019053001 mod by wangyu
            --增加工厂
         and a.plan_code = e.plan_code
         and e.factory_code = c.factory_code
         and a.arr_depot = d.ware_code
         and a.deal_flag = 2;
    --更新处理标识
    update mm_jiso_order a
       set a.deal_flag = 1, a.deal_time = sysdate
     where a.deal_flag = 2;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_JISO_ORDER_SEND',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_JISO_ORDER_SEND;

  --****************************************************************************
  --过程名  : USP_JIT_ORDER_SEND
  --功能描述: 拉动需结算订单写入接口表
  --参数说明: 无
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  PROCEDURE USP_JIT_ORDER_SEND IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --更新结算屏蔽的订单处理标识
    update mm_jit_order a
       set a.deal_flag = 3, a.deal_time = sysdate
     where a.deal_flag = 0
       and exists
     (select 1
              from mm_jit_account_filter t
             where t.plan_code = a.plan_code
               and t.order_type = a.ship_depot_type
               and ((t.filter_by = 'DEPOT' and t.filter_data = a.ship_depot) or
                   (t.filter_by = 'SUP' and t.filter_data = a.supplier_no)));
    --更新需结算订单处理标识为待处理
    update mm_jit_order a
       set a.deal_flag = 2
     where a.deal_flag = 0
       and a.arr_depot in
           (select w.ware_code
              from mm_pub_plan_code p, mm_inv_warehouse w
             where p.plan_code = a.plan_code
               and w.factory_code = p.factory_code);
    commit;
    --写入物流订单中间表
    insert into if_logistics_order
      (logistics_orderno,
       comp,
       purchase_orderno,
       order_type,
       supplier_id,
       factory_id,
       orderissue_date,
       issue_user)
      select a.order_no,
             b.factory_code,
             a.purchase_orderno,
             '03', --拉动订单
             a.supplier_no,
             a.sup_factory,
             a.creation_time,
             null --订单发布人
        from mm_jit_order a, mm_pub_plan_code b
       where a.plan_code = b.plan_code
         and a.deal_flag = 2;
    --写入物流订单中间表
    insert into if_logistics_order_detail
      (logistics_orderno,
       logistics_rowno,
       purchase_orderno,
       purchase_row_no,
       plan_arrive_time,
       order_depot,
       part_id,
       order_num,
       part_unit,
       assembly_flag)
      select b.order_no,
             b.order_rowno,
             a.purchase_orderno,
             b.order_rowno,
             a.arrive_time,
             d.erp_ware_code,
             b.part_no,
             b.require_num,
             c.part_unit,
             decode(c.purchase_type, 'AW', '1', '0') --AW支给总成件标识1、其它普通件标识0
        from mm_jit_order        a,
             mm_jit_order_detail b,
             mm_pub_part         c,
             mm_inv_warehouse    d,
             --i-LMS2019053001 mod by wangyu
             mm_pub_plan_code e
       where a.order_no = b.order_no
         and b.part_no = c.part_no
            --i-LMS2019053001 mod by wangyu
         and a.plan_code = e.plan_code
         and e.factory_code = c.factory_code
         and a.arr_depot = d.ware_code
         and a.deal_flag = 2;
    --更新处理标识
    update mm_jit_order a
       set a.deal_flag = 1, a.deal_time = sysdate
     where a.deal_flag = 2;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_JIT_ORDER_SEND',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_JIT_ORDER_SEND;

  --****************************************************************************
  --过程名  : USP_MP_ORDER_SEND
  --功能描述: 零件订单写入接口表
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2018-11-23
  PROCEDURE USP_MP_ORDER_SEND IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
  
    --更新处理标识为待处理
    UPDATE MM_MP_PUR_ORDER A SET A.DEAL_FLAG = 2 WHERE A.DEAL_FLAG = 0;
  
    COMMIT;
    --写入订单头表
    INSERT INTO IF_LOGISTICS_ORDER
      (LOGISTICS_ORDERNO,
       COMP,
       PURCHASE_ORDERNO,
       ORDER_TYPE,
       SUPPLIER_ID,
       FACTORY_ID,
       ORDERISSUE_DATE,
       ISSUE_USER,
       ASSEMBLY_SUP,
       SYSTEM_FLAG)
      SELECT B.ORDER_NO,
             B.FACTORY_CODE,
             B.PURCHASE_NO,
             '01',
             B.SUPPLIER_NO,
             B.SUP_FACTORY,
             B.ISSUE_DATE,
             '',
             (SELECT DISTINCT C.ORDER_DEPOT
                FROM MM_MP_PUR_ORDER_DETAIL C
                LEFT JOIN MM_INV_WAREHOUSE D
                  ON C.ORDER_DEPOT = D.WARE_CODE
               WHERE C.ORDER_NO = B.ORDER_NO
                 AND D.WARE_TYPE = '3'),
             1
        FROM MM_MP_PUR_ORDER B
       WHERE B.DEAL_FLAG = 2
       ORDER BY B.CREATION_TIME;
  
    COMMIT;
  
    --写入订单明细表
    INSERT INTO IF_LOGISTICS_ORDER_DETAIL
      (LOGISTICS_ORDERNO,
       LOGISTICS_ROWNO,
       PURCHASE_ORDERNO,
       PURCHASE_ROW_NO,
       PLAN_ARRIVE_TIME,
       ORDER_DEPOT,
       PART_ID,
       ORDER_NUM,
       PART_UNIT,
       ASSEMBLY_FLAG)
      SELECT C.ORDER_NO,
             C.ROW_NO,
             C.PURCHASE_NO,
             C.ROW_NO,
             C.ARRIVE_TIME,
             E.ERP_WARE_CODE,
             C.PART_NO,
             C.TOTAL_ORDER_NUM,
             NVL(C.PART_UNIT, 'PCS'),
             DECODE(D.PURCHASE_TYPE, 'AW', '1', 0)
        FROM MM_MP_PUR_ORDER        B,
             MM_MP_PUR_ORDER_DETAIL C,
             MM_PUB_PART            D,
             MM_INV_WAREHOUSE       E
       WHERE B.ORDER_NO = C.ORDER_NO
         AND C.PART_NO = D.PART_NO
         AND D.FACTORY_CODE = B.FACTORY_CODE
         AND C.ORDER_DEPOT = E.WARE_CODE
         AND B.DEAL_FLAG = 2;
  
    COMMIT;
  
    --写入SW_ORDER表
    INSERT INTO MM_SW_ORDER
      (PURCHASE_NO,
       ORDER_NO,
       ORDER_TYPE,
       FACTORY_CODE,
       SUPPLIER_NO,
       ORDER_DATE,
       ARRIVE_DATE,
       PLAN_PREPARE_TIME,
       SUP_FACTORY,
       CREATION_TIME,
       DEPOT_NO,
       ZG_FLAG)
      SELECT A.PURCHASE_NO,
             A.ORDER_NO,
             '01',
             A.FACTORY_CODE,
             A.SUPPLIER_NO,
             A.ISSUE_DATE,
             A.ARRIVE_DATE,
             A.PREPARE_TIME,
             A.SUP_FACTORY,
             SYSDATE,
             C.ORDER_DEPOT,
             CASE
               WHEN C.WARE_TYPE = '3' THEN
                1
               ELSE
                0
             END
        FROM MM_MP_PUR_ORDER A
        LEFT JOIN (SELECT B.ORDER_DEPOT, B.ORDER_NO, D.WARE_TYPE
                     FROM MM_MP_PUR_ORDER_DETAIL B
                     LEFT JOIN MM_INV_WAREHOUSE D
                       ON B.ORDER_DEPOT = D.WARE_CODE
                    WHERE B.ROW_NO = 10) C
          ON A.ORDER_NO = C.ORDER_NO
       WHERE A.DEAL_FLAG = 2
       ORDER BY A.CREATION_TIME;
  
    COMMIT;
  
    --写入订单明细表
    INSERT INTO MM_SW_ORDER_DETAIL
      (ID,
       PURCHASE_NO,
       PURCHASE_ROWNO,
       ORDER_ROWNO,
       DEPOT_NO,
       ORDER_QTY,
       ORDER_UNIT,
       PART_NO,
       STANDARD_PACKAGE,
       CREATION_TIME,
       ORDER_NO)
      SELECT PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_SW_ORDER_DETAIL'),
             A.PURCHASE_NO,
             B.ROW_NO,
             B.ROW_NO,
             B.ORDER_DEPOT,
             B.TOTAL_ORDER_NUM,
             B.PART_UNIT,
             B.PART_NO,
             B.STANDARD_PACKAGE,
             SYSDATE,
             B.ORDER_NO
        FROM MM_MP_PUR_ORDER A
        LEFT JOIN MM_MP_PUR_ORDER_DETAIL B
          ON A.PURCHASE_NO = B.PURCHASE_NO
       WHERE A.DEAL_FLAG = 2
       ORDER BY A.CREATION_TIME;
  
    COMMIT;
  
    --写入SW_ORDER门户表
    INSERT INTO ilmsportal.MM_SW_ORDER@MM_IF_IN
      (PURCHASE_NO,
       ORDER_NO,
       ORDER_TYPE,
       FACTORY_CODE,
       SUPPLIER_NO,
       ORDER_DATE,
       ARRIVE_DATE,
       SUP_FACTORY,
       CREATION_TIME,
       DEPOT_NO,
       ZG_FLAG)
      SELECT A.PURCHASE_NO,
             A.ORDER_NO,
             '01',
             A.FACTORY_CODE,
             A.SUPPLIER_NO,
             A.ISSUE_DATE,
             A.ARRIVE_DATE,
             A.SUP_FACTORY,
             SYSDATE,
             C.ORDER_DEPOT,
             CASE
               WHEN C.WARE_TYPE = '3' THEN
                1
               ELSE
                0
             END
        FROM MM_MP_PUR_ORDER A
        LEFT JOIN (SELECT B.ORDER_DEPOT, B.ORDER_NO, D.WARE_TYPE
                     FROM MM_MP_PUR_ORDER_DETAIL B
                     LEFT JOIN MM_INV_WAREHOUSE D
                       ON B.ORDER_DEPOT = D.WARE_CODE
                    WHERE B.ROW_NO = 10) C
          ON A.ORDER_NO = C.ORDER_NO
       WHERE A.DEAL_FLAG = 2
       ORDER BY A.CREATION_TIME;
  
    FOR cur_order IN (SELECT A.PURCHASE_NO,
                             B.ROW_NO,
                             B.ORDER_DEPOT,
                             B.TOTAL_ORDER_NUM,
                             B.PART_UNIT,
                             B.PART_NO,
                             B.STANDARD_PACKAGE,
                             B.ORDER_NO
                        FROM MM_MP_PUR_ORDER A
                        LEFT JOIN MM_MP_PUR_ORDER_DETAIL B
                          ON A.PURCHASE_NO = B.PURCHASE_NO
                       WHERE A.DEAL_FLAG = 2
                       ORDER BY A.CREATION_TIME) LOOP
      --将订单数据写入门户订单明细表
      INSERT INTO ilmsportal.MM_SW_ORDER_DETAIL@MM_IF_IN
        (ID,
         PURCHASE_NO,
         PURCHASE_ROWNO,
         ORDER_ROWNO,
         DEPOT_NO,
         ORDER_QTY,
         ORDER_UNIT,
         PART_NO,
         STANDARD_PACKAGE,
         CREATION_TIME,
         ORDER_NO)
      VALUES
        (ilmsportal.SEQ_MM_SW_ORDER_DETAIL.NEXTVAL@MM_IF_IN,
         cur_order.Purchase_No,
         cur_order.Row_No,
         cur_order.Row_No,
         cur_order.Order_Depot,
         cur_order.Total_Order_Num,
         cur_order.Part_Unit,
         cur_order.Part_No,
         cur_order.Standard_Package,
         SYSDATE,
         cur_order.Order_No);
    END LOOP;
  
    --写入SW_ORDER门户表
    /*INSERT INTO ilmsportal.MM_SW_ORDER@MM_IF_IN
      (PURCHASE_NO,
       ORDER_NO,
       ORDER_TYPE,
       FACTORY_CODE,
       SUPPLIER_NO,
       ORDER_DATE,
       ARRIVE_DATE,
       SUP_FACTORY,
       CREATION_TIME,
       DEPOT_NO)
      SELECT A.PURCHASE_NO,
             A.ORDER_NO,
             '01',
             A.FACTORY_CODE,
             A.SUPPLIER_NO,
             A.ISSUE_DATE,
             A.ARRIVE_DATE,
             A.SUP_FACTORY,
             SYSDATE,
             C.ORDER_DEPOT
        FROM MM_MP_PUR_ORDER A
        LEFT JOIN (SELECT B.ORDER_DEPOT, B.ORDER_NO
                     FROM MM_MP_PUR_ORDER_DETAIL B
                    WHERE B.ROW_NO = 10) C
          ON A.ORDER_NO = C.ORDER_NO
       WHERE A.DEAL_FLAG = 2
       ORDER BY A.CREATION_TIME;
    
    FOR cur_order IN (SELECT A.PURCHASE_NO,
                             B.ROW_NO,
                             B.ORDER_DEPOT,
                             B.TOTAL_ORDER_NUM,
                             B.PART_UNIT,
                             B.PART_NO,
                             B.STANDARD_PACKAGE,
                             B.ORDER_NO
                        FROM MM_MP_PUR_ORDER A
                        LEFT JOIN MM_MP_PUR_ORDER_DETAIL B
                          ON A.PURCHASE_NO = B.PURCHASE_NO
                       WHERE A.DEAL_FLAG = 2
                       ORDER BY A.CREATION_TIME) LOOP
      --将订单数据写入门户订单明细表
      INSERT INTO ilmsportal.MM_SW_ORDER_DETAIL@MM_IF_IN
        (ID,
         PURCHASE_NO,
         PURCHASE_ROWNO,
         ORDER_ROWNO,
         DEPOT_NO,
         ORDER_QTY,
         ORDER_UNIT,
         PART_NO,
         STANDARD_PACKAGE,
         CREATION_TIME,
         ORDER_NO)
      VALUES
        (ilmsportal.SEQ_MM_SW_ORDER_DETAIL.NEXTVAL@MM_IF_IN,
         cur_order.Purchase_No,
         cur_order.Row_No,
         cur_order.Row_No,
         cur_order.Order_Depot,
         cur_order.Total_Order_Num,
         cur_order.Part_Unit,
         cur_order.Part_No,
         cur_order.Standard_Package,
         SYSDATE,
         cur_order.Order_No);
    END LOOP;*/
  
    /*--写入订单明细表门户
    INSERT INTO ilmsportalTEST.MM_SW_ORDER_DETAIL@MM_IF_IN
    (ID,
     PURCHASE_NO,
     PURCHASE_ROWNO,
     ORDER_ROWNO,
     DEPOT_NO,
     ORDER_QTY,
     ORDER_UNIT,
     PART_NO,
     STANDARD_PACKAGE,
     CREATION_TIME,
     ORDER_NO)
    SELECT SEQ_MM_SW_ORDER_DETAIL.NEXTVAL@MM_IF_IN,
           A.PURCHASE_NO,
           B.ROW_NO,
           B.ROW_NO,
           B.ORDER_DEPOT,
           B.TOTAL_ORDER_NUM,
           B.PART_UNIT,
           B.PART_NO,
           B.STANDARD_PACKAGE,
           SYSDATE,
           B.ORDER_NO
      FROM MM_MP_PUR_ORDER A
      LEFT JOIN MM_MP_PUR_ORDER_DETAIL B
        ON A.PURCHASE_NO = B.PURCHASE_NO
     WHERE A.DEAL_FLAG = 2
     ORDER BY A.CREATION_TIME;*/
  
    --更新待处理的数据为已处理
    UPDATE MM_MP_PUR_ORDER A
       SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
     WHERE A.DEAL_FLAG = 2;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_ORDER_SEND',
           err_num,
           err_msg,
           sysdate,
           '零件订单写入接口表');
        COMMIT;
      END;
  END USP_MP_ORDER_SEND;

  --****************************************************************************
  --过程名  : USP_TRIAL_ORDER_SEND
  --功能描述: 新车型订单写入接口表
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2018-11-23
  PROCEDURE USP_TRIAL_ORDER_SEND IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
  
    --更新处理标识为待处理
    UPDATE MM_MP_TRIAL_ORDER A SET A.DEAL_FLAG = 2 WHERE A.DEAL_FLAG = 0;
    COMMIT;
  
    --写入订单头表
    INSERT INTO IF_LOGISTICS_ORDER
      (LOGISTICS_ORDERNO,
       COMP,
       PURCHASE_ORDERNO,
       ORDER_TYPE,
       SUPPLIER_ID,
       FACTORY_ID,
       ORDERISSUE_DATE,
       ISSUE_USER,
       SYSTEM_FLAG)
      SELECT B.ORDER_NO,
             B.FACTORY_CODE,
             B.PURCHASE_NO,
             '05',
             B.SUPPLIER_NO,
             B.SUP_FACTORY,
             B.CREATION_TIME,
             '',
             1
        FROM MM_MP_TRIAL_ORDER B
       WHERE B.DEAL_FLAG = 2
       ORDER BY B.CREATION_TIME;
  
    --写入订单明细表
    INSERT INTO IF_LOGISTICS_ORDER_DETAIL
      (LOGISTICS_ORDERNO,
       LOGISTICS_ROWNO,
       PURCHASE_ORDERNO,
       PURCHASE_ROW_NO,
       PLAN_ARRIVE_TIME,
       ORDER_DEPOT,
       PART_ID,
       ORDER_NUM,
       PART_UNIT,
       ASSEMBLY_FLAG)
      SELECT C.ORDER_NO,
             C.ROW_NO,
             C.ORDER_NO,
             C.ROW_NO,
             B.ARRIVE_DATE,
             E.ERP_WARE_CODE,
             C.PART_NO,
             C.ORDER_NUM,
             D.PART_UNIT,
             DECODE(D.PURCHASE_TYPE, 'AW', '1', 0)
        FROM MM_MP_TRIAL_ORDER        B,
             MM_MP_TRIAL_ORDER_DETAIL C,
             MM_PUB_PART              D,
             MM_INV_WAREHOUSE         E
       WHERE B.ORDER_NO = C.ORDER_NO
         AND C.PART_NO = D.PART_NO
            --i-LMS2019053001 mod by wangyu
            --新增工厂
         AND B.FACTORY_CODE = D.FACTORY_CODE
         AND C.ORDER_DEPOT = E.WARE_CODE
         AND B.DEAL_FLAG = 2;
  
    --更新待处理的数据为已处理
    UPDATE MM_MP_TRIAL_ORDER A
       SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
     WHERE A.DEAL_FLAG = 2;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_TRIAL_ORDER_SEND',
           err_num,
           err_msg,
           sysdate,
           '新车型订单写入接口表');
        COMMIT;
      END;
  END USP_TRIAL_ORDER_SEND;

  --****************************************************************************
  --过程名  : USP_EXC_ORDER_SEND
  --功能描述: 例外订购订单写入接口表
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2018-11-23
  PROCEDURE USP_EXC_ORDER_SEND IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
  
    --更新处理标识为待处理
    UPDATE MM_MP_EXCEP_ORDER A SET A.DEAL_FLAG = 2 WHERE A.DEAL_FLAG = 0;
    COMMIT;
  
    --写入订单头表
    INSERT INTO IF_LOGISTICS_ORDER
      (LOGISTICS_ORDERNO,
       COMP,
       PURCHASE_ORDERNO,
       ORDER_TYPE,
       SUPPLIER_ID,
       FACTORY_ID,
       ORDERISSUE_DATE,
       ISSUE_USER,
       --2019-05-14修改加入支给标识
       SYSTEM_FLAG,
       ASSEMBLY_SUP)
      SELECT B.ORDER_NO,
             B.FACTORY_CODE,
             B.PURCHASE_NO,
             '02',
             B.SUPPLIER_NO,
             B.SUP_FACTORY,
             B.CREATION_TIME,
             '',
             1,
             --2019-05-14修改加入支给件标识
             --从订单明细表里面找到到货仓库类型为3的仓库代码
             (SELECT MIN(C.ORDER_DEPOT)
                FROM MM_MP_EXCEP_ORDER_DETAIL C, MM_INV_WAREHOUSE D
               WHERE B.ORDER_NO = C.ORDER_NO
                 AND C.ORDER_DEPOT = D.WARE_CODE
                 AND D.WARE_TYPE = 3)
        FROM MM_MP_EXCEP_ORDER B
       WHERE B.DEAL_FLAG = 2
       ORDER BY B.CREATION_TIME;
  
    --写入订单明细表
    INSERT INTO IF_LOGISTICS_ORDER_DETAIL
      (LOGISTICS_ORDERNO,
       LOGISTICS_ROWNO,
       PURCHASE_ORDERNO,
       PURCHASE_ROW_NO,
       PLAN_ARRIVE_TIME,
       ORDER_DEPOT,
       PART_ID,
       ORDER_NUM,
       PART_UNIT,
       ASSEMBLY_FLAG)
      SELECT C.ORDER_NO,
             C.ROW_NO,
             B.PURCHASE_NO,
             C.ROW_NO,
             B.ARRIVE_DATE,
             E.ERP_WARE_CODE,
             C.PART_NO,
             C.ORDER_NUM,
             D.PART_UNIT,
             DECODE(D.PURCHASE_TYPE, 'AW', '1', 0)
        FROM MM_MP_EXCEP_ORDER        B,
             MM_MP_EXCEP_ORDER_DETAIL C,
             MM_PUB_PART              D,
             MM_INV_WAREHOUSE         E
       WHERE B.ORDER_NO = C.ORDER_NO
         AND C.PART_NO = D.PART_NO
            --i-LMS2019053001 mod by wangyu
            --新增工厂
         AND B.FACTORY_CODE = D.FACTORY_CODE
         AND C.ORDER_DEPOT = E.WARE_CODE
         AND B.DEAL_FLAG = 2;
  
    --写入SW_ORDER表
    INSERT INTO MM_SW_ORDER
      (PURCHASE_NO,
       ORDER_NO,
       ORDER_TYPE,
       FACTORY_CODE,
       SUPPLIER_NO,
       ORDER_DATE,
       ARRIVE_DATE,
       PLAN_PREPARE_TIME,
       SUP_FACTORY,
       CREATION_TIME,
       DEPOT_NO)
      SELECT A.PURCHASE_NO,
             A.ORDER_NO,
             '02',
             A.FACTORY_CODE,
             A.SUPPLIER_NO,
             A.CREATION_TIME,
             A.ARRIVE_DATE,
             NULL,
             A.SUP_FACTORY,
             SYSDATE,
             C.ORDER_DEPOT
        FROM MM_MP_EXCEP_ORDER A
        LEFT JOIN (SELECT B.ORDER_DEPOT, B.ORDER_NO
                     FROM MM_MP_EXCEP_ORDER_DETAIL B
                    WHERE B.ROW_NO = 10) C
          ON A.ORDER_NO = C.ORDER_NO
       WHERE A.DEAL_FLAG = 2
       ORDER BY A.CREATION_TIME;
  
    COMMIT;
  
    --写入订单明细表
    INSERT INTO MM_SW_ORDER_DETAIL
      (ID,
       PURCHASE_NO,
       PURCHASE_ROWNO,
       ORDER_ROWNO,
       DEPOT_NO,
       ORDER_QTY,
       ORDER_UNIT,
       PART_NO,
       STANDARD_PACKAGE,
       CREATION_TIME,
       ORDER_NO,
       USE,
       DEMAND_DEPARTMENT,
       DEMANDER,
       CON_NUMBER)
      SELECT PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_SW_ORDER_DETAIL'),
             A.PURCHASE_NO,
             B.ROW_NO,
             B.ROW_NO,
             B.ORDER_DEPOT,
             B.ORDER_NUM,
             C.PART_UNIT,
             B.PART_NO,
             NVL(F.STANDARD_PACKAGE, B.ORDER_NUM),
             SYSDATE,
             B.ORDER_NO,
             B.USE,
             B.DEMAND_DEPARTMENT,
             B.DEMANDER,
             B.CON_NUMBER
        FROM MM_MP_EXCEP_ORDER A
        LEFT JOIN MM_MP_EXCEP_ORDER_DETAIL B
          ON A.PURCHASE_NO = B.ORDER_NO
        LEFT JOIN MM_PUB_PART C
          ON B.PART_NO = C.PART_NO
         AND A.FACTORY_CODE = C.FACTORY_CODE
        LEFT JOIN MM_PUB_PART_UDA F
          ON F.PART_NO = B.PART_NO
         AND F.FACTORY_CODE = A.FACTORY_CODE
       WHERE A.DEAL_FLAG = 2
       ORDER BY A.CREATION_TIME;
  
    --更新待处理的数据为已处理
    UPDATE MM_MP_EXCEP_ORDER A
       SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
     WHERE A.DEAL_FLAG = 2;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_EXC_ORDER_SEND',
           err_num,
           err_msg,
           sysdate,
           '例外订购订单写入接口表');
        COMMIT;
      END;
  END USP_EXC_ORDER_SEND;

  --****************************************************************************
  --过程名  : USP_MAT_ORDER_SEND
  --功能描述: 资材订单写入接口表
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2018-11-23
  PROCEDURE USP_MAT_ORDER_SEND IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
  
    --更新处理标识为待处理
    UPDATE MM_PDA_MAT_ORDER_INFO A
       SET A.DEAL_FLAG = 2
     WHERE A.DEAL_FLAG = 0;
  
    COMMIT;
  
    --写入订单头表
    INSERT INTO IF_LOGISTICS_ORDER
      (LOGISTICS_ORDERNO,
       COMP,
       PURCHASE_ORDERNO,
       ORDER_TYPE,
       SUPPLIER_ID,
       FACTORY_ID,
       ORDERISSUE_DATE,
       ISSUE_USER,
       SYSTEM_FLAG)
      SELECT B.ORDER_NO,
             B.FACTORY_CODE,
             NULL,
             '14',
             B.SUPPLIER_NO,
             NULL,
             B.CREATE_TIME,
             U.FULLNAME_,
             1
        FROM MM_PDA_MAT_ORDER_INFO B
        LEFT JOIN SYS_USER U
          ON U.ACCOUNT_ = B.CREATE_USER
       WHERE B.DEAL_FLAG = 2
       ORDER BY B.CREATE_TIME;
  
    --写入订单明细表
    INSERT INTO IF_LOGISTICS_ORDER_DETAIL
      (LOGISTICS_ORDERNO,
       LOGISTICS_ROWNO,
       PURCHASE_ORDERNO,
       PURCHASE_ROW_NO,
       PLAN_ARRIVE_TIME,
       ORDER_DEPOT,
       PART_ID,
       ORDER_NUM,
       PART_UNIT,
       ASSEMBLY_FLAG,
       LGPBE,
       ZKOSTL,
       ZBZGG,
       ZSTOCK,
       UDA1)
      SELECT B.ORDER_NO,
             '10',
             NULL,
             '10',
             NULL,
             B.INV_CODE,
             B.PART_NO,
             B.ORDER_NUM,
             D.PART_UNIT,
             0,
             B.WARE_ADDRESS,
             B.COST_CENTER,
             B.MIN_ORDER_NUM,
             B.INV_DIS,
             B.COST_CODE
        FROM MM_PDA_MAT_ORDER_INFO B, MM_PUB_PART D
       WHERE B.PART_NO = D.PART_NO
            --i-LMS2019053001 mod by wangyu
            --新增工厂
         AND B.FACTORY_CODE = D.FACTORY_CODE
         AND B.DEAL_FLAG = 2;
  
    --更新待处理的数据为已处理
    UPDATE MM_PDA_MAT_ORDER_INFO A
       SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
     WHERE A.DEAL_FLAG = 2;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MAT_ORDER_SEND',
           err_num,
           err_msg,
           sysdate,
           '资材订单写入接口表');
        COMMIT;
      END;
  END USP_MAT_ORDER_SEND;

  --****************************************************************************
  --过程名  : USP_INV_IN
  --功能描述: 收货数据写入接口表
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2018-11-29
  PROCEDURE USP_INV_IN IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
  
    --更新处理标识为待处理
    UPDATE MM_INV_IN A SET A.DEAL_FLAG = 2 WHERE A.DEAL_FLAG = 0;
  
    /*    UPDATE MM_INV_IN A
      SET A.DEAL_FLAG = 2
    WHERE A.DEAL_FLAG = 0
      AND EXISTS (SELECT 1
             FROM (
             SELECT B.ORDER_NO
                     FROM MM_SW_ORDER B
                    WHERE B.ORDER_TYPE = '01'
                      AND TO_CHAR(B.CREATION_TIME, 'YYYY-MM-DD') =
                          '2019-03-26'
                   UNION ALL
                   SELECT C.ORDER_NO
                     FROM MM_SW_ORDER C
                    WHERE C.ORDER_TYPE = '02'
                   UNION ALL
                   SELECT D.ORDER_NO
                     FROM MM_JIT_ORDER D
                    WHERE D.CREATION_TIME < SYSDATE - 20
                   UNION ALL
                   SELECT E.ORDER_NO FROM MM_JISO_ORDER E) F
            WHERE A.ORDER_NO = F.ORDER_NO);*/
    COMMIT;
  
    --写入收货明细头信息先处理不是拉动订单的收货数据
    INSERT INTO IF_INV_REC
      (LOGISTICS_REC_ORDER,
       COMP,
       PURCHASE_ORDER_NO,
       USER_ID,
       REC_DATE,
       CREATION_TIME)
      SELECT A.REC_NO,
             A.FACTORY_CODE,
             A.ORDER_NO,
             A.CREATION_USER,
             A.CREATION_TIME,
             SYSDATE
        FROM MM_INV_IN A
       WHERE EXISTS (SELECT 1
                FROM MM_INV_IN_DETAIL B
               WHERE A.REC_NO = B.REC_NO
                 AND B.REC_QTY > 0)
         AND A.DEAL_FLAG = 2
         AND A.ORDER_TYPE != 'JIT';
  
    --写入收货明细表      
    INSERT INTO IF_INV_REC_DETAIL
      (LOGISTICS_REC_ORDER,
       REC_ROW_NO,
       LOGISTICS_ORDER_ROW_NO,
       PURCHASE_ORDER_NO,
       PURCHASE_ORDER_ROW_NO,
       DEPOT_NO,
       PART_ID,
       REC_NUM)
      SELECT C.REC_NO,
             ROW_NUMBER() OVER(PARTITION BY C.REC_NO ORDER BY C.ROW_NO) * 10,
             C.ROW_NO,
             B.ORDER_NO,
             C.ROW_NO,
             NVL(D.ERP_WARE_CODE, B.DEPOT_NO),
             C.PART_NO,
             C.REC_QTY
        FROM MM_INV_IN_DETAIL C
        LEFT JOIN MM_INV_IN B
          ON C.REC_NO = B.REC_NO
        LEFT JOIN MM_INV_WAREHOUSE D
          ON B.DEPOT_NO = D.WARE_CODE
         AND B.FACTORY_CODE = D.FACTORY_CODE
       WHERE B.REC_NO = C.REC_NO
         AND B.ORDER_TYPE != 'JIT'
         AND B.DEAL_FLAG = 2
         AND C.REC_QTY > 0;
  
    --先从收货记录里面查询拉动订单未处理的收货数据
    FOR cur_rec_order IN (SELECT *
                            FROM MM_INV_IN A
                          --找到库存处理标识为未处理的数据
                           WHERE A.DEAL_FLAG = 2
                             AND A.ORDER_TYPE = 'JIT'
                             AND EXISTS (SELECT 1
                                    FROM MM_INV_IN_DETAIL B
                                   WHERE A.REC_NO = B.REC_NO
                                     AND B.REC_QTY > 0)) LOOP
    
      --写入收货日志头表
      INSERT INTO IF_INV_REC
        (LOGISTICS_REC_ORDER,
         COMP,
         PURCHASE_ORDER_NO,
         USER_ID,
         REC_DATE,
         CREATION_TIME)
      VALUES
        (cur_rec_order.REC_NO,
         cur_rec_order.FACTORY_CODE,
         cur_rec_order.ORDER_NO,
         cur_rec_order.CREATION_USER,
         cur_rec_order.CREATION_TIME,
         SYSDATE);
    
      --循环拉动收货明细数据
      FOR cur_rec_detail IN (SELECT ROW_NUMBER() OVER(PARTITION BY C.REC_NO ORDER BY C.ROW_NO) * 10 REC_ROW_NO,
                                    C.*,
                                    G.WARE_CODE
                               FROM MM_INV_IN_DETAIL C
                               LEFT JOIN (SELECT E.PART_NO,
                                                E.ORDER_NO,
                                                NVL(H.ERP_WARE_CODE,
                                                    F.WARE_CODE) WARE_CODE
                                           FROM (SELECT D.ORDER_NO,
                                                        D.PART_NO,
                                                        H.FACTORY_CODE,
                                                        MIN(D.UNLOAD_PORT) UNLOAD_PORT
                                                   FROM MM_JIT_LABEL D
                                                   LEFT JOIN MM_PUB_PLAN_CODE H
                                                     ON D.PLAN_CODE =
                                                        H.PLAN_CODE
                                                  WHERE D.ORDER_NO =
                                                        cur_rec_order.ORDER_NO
                                                    AND H.FACTORY_CODE =
                                                        cur_rec_order.FACTORY_CODE
                                                  GROUP BY D.ORDER_NO,
                                                           D.PART_NO,
                                                           H.FACTORY_CODE) E
                                           LEFT JOIN MM_INV_UNLOAD F
                                             ON E.UNLOAD_PORT =
                                                F.UNLOAD_PORT
                                            AND F.FACTORY_CODE =
                                                E.FACTORY_CODE
                                           LEFT JOIN MM_INV_WAREHOUSE H
                                             ON F.WARE_CODE = H.WARE_CODE
                                            AND H.FACTORY_CODE =
                                                H.FACTORY_CODE) G
                                 ON C.PART_NO = G.PART_NO
                                AND G.ORDER_NO = cur_rec_order.ORDER_NO
                              WHERE C.REC_NO = cur_rec_order.REC_NO
                                AND C.REC_QTY > 0) LOOP
      
        --写入收货明细表      
        INSERT INTO IF_INV_REC_DETAIL
          (LOGISTICS_REC_ORDER,
           REC_ROW_NO,
           LOGISTICS_ORDER_ROW_NO,
           PURCHASE_ORDER_NO,
           PURCHASE_ORDER_ROW_NO,
           DEPOT_NO,
           PART_ID,
           REC_NUM)
        VALUES
          (cur_rec_detail.REC_NO,
           cur_rec_detail.REC_ROW_NO,
           cur_rec_detail.ROW_NO,
           cur_rec_order.ORDER_NO,
           cur_rec_detail.ROW_NO,
           cur_rec_detail.WARE_CODE,
           cur_rec_detail.PART_NO,
           cur_rec_detail.REC_QTY);
      
      END LOOP;
    
    END LOOP;
  
    --更新待处理的数据为已处理
    UPDATE MM_INV_IN A
       SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
     WHERE A.DEAL_FLAG = 2;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_INV_IN',
           err_num,
           err_msg,
           sysdate,
           '收货数据写入接口表');
        COMMIT;
      END;
  END USP_INV_IN;

  --****************************************************************************
  --过程名  : USP_TRAN_LMS
  --功能描述: 仓库转移数据接口表
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2018-12-10
  PROCEDURE USP_TRAN_LMS IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
  
    --更新处理标识为待处理
    UPDATE MM_INV_OUT A SET A.DEAL_FLAG = 2 WHERE A.DEAL_FLAG = 0;
    COMMIT;
  
    --写入转仓头信息
    INSERT INTO IF_INV_TRAN_LMS
      (BUSINESS_NO, COMP, TRAN_TYPE, USER_ID, CREATE_DATE)
      SELECT A.INV_OUT_NO, A.FACTORY_CODE, '311', A.CREATION_USER, SYSDATE
        FROM MM_INV_OUT A
       WHERE A.DEAL_FLAG = 2
         AND EXISTS (SELECT 1
                FROM MM_INV_OUT_DETAIL B
               WHERE A.INV_OUT_NO = B.INV_OUT_NO
                 AND B.REC_QTY > 0);
  
    --写入收货明细表      
    INSERT INTO IF_INV_TRAN_LMS_DETAIL
      (COMP,
       BUSINESS_NO,
       BUSINESS_ROW_NO,
       FROM_DEPOT_NO,
       TO_DEPOT_NO,
       PART_ID,
       PART_NUM)
      SELECT B.FACTORY_CODE,
             A.INV_OUT_NO,
             ROW_NUMBER() OVER(PARTITION BY B.INV_OUT_NO ORDER BY A.PART_NO) * 10,
             NVL(C.ERP_WARE_CODE, C.WARE_CODE),
             NVL(D.ERP_WARE_CODE, D.WARE_CODE),
             A.PART_NO,
             A.REC_QTY
        FROM MM_INV_OUT_DETAIL A
        LEFT JOIN MM_INV_OUT B
          ON A.INV_OUT_NO = B.INV_OUT_NO
        LEFT JOIN MM_INV_WAREHOUSE C
          ON B.FROM_DEPOT_NO = C.WARE_CODE
         AND B.FACTORY_CODE = C.FACTORY_CODE
        LEFT JOIN MM_INV_WAREHOUSE D
          ON B.TO_DEPOT_NO = D.WARE_CODE
         AND B.FACTORY_CODE = D.FACTORY_CODE
       WHERE B.DEAL_FLAG = '2'
         AND A.REC_QTY > 0;
  
    --更新待处理的数据为已处理
    UPDATE MM_INV_OUT A
       SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
     WHERE A.DEAL_FLAG = 2;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_TRAN_LMS',
           err_num,
           err_msg,
           sysdate,
           '仓库转移数据接口表');
        COMMIT;
      END;
  END USP_TRAN_LMS;

  --****************************************************************************
  --过程名  : USP_SW_TO_IF_ACCOUNT_INVOICE
  --功能描述: 结算反馈数据到接口
  --创建人员: ZHENGWUCHAO
  --创建时间: 2018-10-22
  --****************************************************************************
  PROCEDURE USP_SW_TO_IF_ACCOUNT_INVOICE AS
    V_NUM   VARCHAR2(5); --误信息
    ERR_NUM NUMBER(10);
    ERR_MSG VARCHAR2(500);
  BEGIN
    FOR SUB_IF_ACCOUNT_INVOICE IN (SELECT T.BILL_NO,
                                          T.INVOICE_NO,
                                          T.INVOICE_CODE,
                                          T.INVOICE_AMOUNT,
                                          T.TAX_AMOUNT,
                                          T.INVOICE_DATE DAT,
                                          T.CHECK_CODE,
                                          T.INVOICE_NET_PRICE,
                                          
                                          B.REBATE,
                                          B.REBATE_DESC,
                                          B.DEDUCT_MONEY,
                                          B.DEDUCT_MONEY_DESC,
                                          B.YEAR_ADJUST,
                                          B.YEAR_ADJUST_DESC,
                                          B.MOULD_AMOUNT,
                                          B.MOULD_AMOUNT_DESC,
                                          B.PAY_TERM,
                                          T.INVOICE_DATE,
                                          B.SUPPLIER_NO,
                                          B.CURRENCY_TYPE,
                                          B.FACTORY_CODE
                                     FROM MM_SW_ACCOUNT_INVOICE T
                                     LEFT JOIN MM_SW_ACCOUNT_BILL B
                                       ON T.BILL_NO = B.BILL_NO
                                    WHERE T.DEAL_FLAG = 0
                                      AND B.SUBMIT_STATUS = 1) LOOP
      SELECT COUNT(1)
        INTO V_NUM
        FROM IF_SW_ACCOUNT_INVOICE
       WHERE ACCOUNT_BILL_NO = SUB_IF_ACCOUNT_INVOICE.BILL_NO;
    
      IF V_NUM > 0 THEN
        UPDATE IF_SW_ACCOUNT_INVOICE
           SET COMP              = SUB_IF_ACCOUNT_INVOICE.FACTORY_CODE,
               INVOICE_DATE      = SUB_IF_ACCOUNT_INVOICE.INVOICE_DATE,
               SUPPLIER_NO       = SUB_IF_ACCOUNT_INVOICE.SUPPLIER_NO,
               INVOICE_AMOUNT    = SUB_IF_ACCOUNT_INVOICE.INVOICE_AMOUNT,
               TAX_AMOUNT        = SUB_IF_ACCOUNT_INVOICE.TAX_AMOUNT,
               REBATE            = SUB_IF_ACCOUNT_INVOICE.REBATE,
               REBATE_DESC       = SUB_IF_ACCOUNT_INVOICE.REBATE_DESC,
               DEDUCT_MONEY      = SUB_IF_ACCOUNT_INVOICE.DEDUCT_MONEY,
               DEDUCT_MONEY_DESC = SUB_IF_ACCOUNT_INVOICE.DEDUCT_MONEY_DESC,
               YEAR_ADJUST       = SUB_IF_ACCOUNT_INVOICE.YEAR_ADJUST,
               YEAR_ADJUST_DESC  = SUB_IF_ACCOUNT_INVOICE.YEAR_ADJUST_DESC,
               MOULD_AMOUNT      = SUB_IF_ACCOUNT_INVOICE.MOULD_AMOUNT,
               MOULD_AMOUNT_DESC = SUB_IF_ACCOUNT_INVOICE.MOULD_AMOUNT_DESC,
               CURRENCY_TYPE     = SUB_IF_ACCOUNT_INVOICE.CURRENCY_TYPE,
               PAY_TERM          = SUB_IF_ACCOUNT_INVOICE.PAY_TERM,
               
               DEAL_FLAG = 0
         WHERE ACCOUNT_BILL_NO = SUB_IF_ACCOUNT_INVOICE.BILL_NO;
      ELSE
        INSERT INTO IF_SW_ACCOUNT_INVOICE
          (ACCOUNT_BILL_NO,
           COMP,
           INVOICE_DATE,
           SUPPLIER_NO,
           INVOICE_AMOUNT,
           TAX_AMOUNT,
           REBATE,
           REBATE_DESC,
           DEDUCT_MONEY,
           DEDUCT_MONEY_DESC,
           YEAR_ADJUST,
           YEAR_ADJUST_DESC,
           MOULD_AMOUNT,
           MOULD_AMOUNT_DESC,
           CURRENCY_TYPE,
           PAY_TERM,
           
           DEAL_FLAG)
        VALUES
          (SUB_IF_ACCOUNT_INVOICE.BILL_NO,
           SUB_IF_ACCOUNT_INVOICE.FACTORY_CODE,
           SUB_IF_ACCOUNT_INVOICE.INVOICE_DATE,
           SUB_IF_ACCOUNT_INVOICE.SUPPLIER_NO,
           SUB_IF_ACCOUNT_INVOICE.INVOICE_AMOUNT,
           SUB_IF_ACCOUNT_INVOICE.TAX_AMOUNT,
           SUB_IF_ACCOUNT_INVOICE.REBATE,
           SUB_IF_ACCOUNT_INVOICE.REBATE_DESC,
           SUB_IF_ACCOUNT_INVOICE.DEDUCT_MONEY,
           SUB_IF_ACCOUNT_INVOICE.DEDUCT_MONEY_DESC,
           SUB_IF_ACCOUNT_INVOICE.YEAR_ADJUST,
           SUB_IF_ACCOUNT_INVOICE.YEAR_ADJUST_DESC,
           SUB_IF_ACCOUNT_INVOICE.MOULD_AMOUNT,
           SUB_IF_ACCOUNT_INVOICE.MOULD_AMOUNT_DESC,
           SUB_IF_ACCOUNT_INVOICE.CURRENCY_TYPE,
           SUB_IF_ACCOUNT_INVOICE.PAY_TERM,
           
           0);
      END IF;
    
      INSERT INTO IF_SW_ACCOUNT_INVOICE_DETAIL
        (ACCOUNT_BILL_NO,
         INVOICE_NO,
         INVOICE_CODE,
         SINGLE_INVOICE_AMOUNT,
         SINGLE_TAX_AMOUNT,
         CHECK_CODE,
         INVOICE_NET_PRICE,
         INVOICE_DATE)
      VALUES
        (SUB_IF_ACCOUNT_INVOICE.BILL_NO,
         SUB_IF_ACCOUNT_INVOICE.INVOICE_NO,
         SUB_IF_ACCOUNT_INVOICE.INVOICE_CODE,
         SUB_IF_ACCOUNT_INVOICE.INVOICE_AMOUNT,
         SUB_IF_ACCOUNT_INVOICE.TAX_AMOUNT,
         SUB_IF_ACCOUNT_INVOICE.CHECK_CODE,
         SUB_IF_ACCOUNT_INVOICE.INVOICE_NET_PRICE,
         SUB_IF_ACCOUNT_INVOICE.DAT);
    
      UPDATE MM_SW_ACCOUNT_INVOICE A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.BILL_NO = SUB_IF_ACCOUNT_INVOICE.BILL_NO
         AND A.INVOICE_NO = SUB_IF_ACCOUNT_INVOICE.INVOICE_NO
         AND A.INVOICE_CODE = SUB_IF_ACCOUNT_INVOICE.INVOICE_CODE;
    END LOOP;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      ERR_NUM := SQLCODE;
      ERR_MSG := SUBSTR(SQLERRM || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(),
                        1,
                        200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_SW_TO_IF_ACCOUNT_INVOICE',
         ERR_NUM,
         ERR_MSG,
         SYSDATE,
         '结算反馈数据到接口');
      COMMIT;
  END USP_SW_TO_IF_ACCOUNT_INVOICE;
  --****************************************************************************
  --过程名  : USP_SW_ZC_REPLY
  --功能描述: 资材反馈写入接口表
  --参数说明: 无
  --创建人员: dtp
  --创建时间: 2019-03-19
  PROCEDURE USP_SW_ZC_REPLY IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    INSERT INTO IF_SW_MATERIAL_ORDER_REPLY T
      (T.COMP,
       T.PURCHASE_ORDER_NO,
       T.REPLY_SEQ_NO,
       T.PURCHASE_ROW_NO,
       T.PLAN_DELIVERY_DATE,
       T.PLAN_DELIVERY_NUM,
       T.REPLY_MSG,
       T.REPLY_DATE,
       T.DEAL_FLAG,
       T.CREATION_TIME)
      SELECT Z.FACTORY_CODE,
             Z.PURCHASE_NO,
             Z.REPLY_SEQ_NO,
             Z.PURCHASE_ROW_NO,
             Z.PLAN_TIME,
             Z.PLAN_NUM,
             Z.RETURN_MSG,
             Z.RETURN_TIME,
             '0',
             SYSDATE
        FROM MM_SW_FEEDBACK_ZC Z
       WHERE Z.DEAL_FLAG = 0
       ORDER BY Z.CREATION_TIME DESC;
    UPDATE MM_SW_FEEDBACK_ZC C
       SET C.DEAL_FLAG = '1', C.DEAL_TIME = SYSDATE
     WHERE C.DEAL_FLAG = '0';
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_SW_ZC_REPLY',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_SW_ZC_REPLY;
  --****************************************************************************

  --****************************************************************************
  --过程名  : USP_JISO_INS_SEND
  --功能描述: 将同步指示票发送延锋
  --参数说明: 无
  --创建人员: wangyu
  --创建时间: 2019-05-22
  --****************************************************************************
  PROCEDURE USP_JISO_INS_SEND IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
  
    --更新处理标识为待处理
    UPDATE MM_JISO_INS A
       SET A.DEAL_FLAG = 2
     WHERE A.DEAL_FLAG = 0
       AND EXISTS (SELECT 1
              FROM MM_IF_CONFIG B
             WHERE A.SUPPLIER_NO = B.SUPPLIER_NO
               AND A.SUP_FACTORY = B.SUP_FACTORY
            --AND A.ROUTE_CODE = B.ROUTE_CODE
            --AND B.IF_CODE = 'AM1C'
            );
  
    COMMIT;
  
    --写入收货明细头信息先处理不是拉动订单的收货数据
    INSERT INTO IF_MM_JISO_INS
      (INS_NO,
       PLAN_CODE,
       PARTGROUP_NO,
       ARR_DEPOT,
       SUP_FACTORY,
       INS_PARTGROUP_SEQNO,
       INS_SUPFACTORY_SEQNO,
       PARTGROUP_NAME,
       ORDER_FLG,
       GEN_INS_WAY,
       SUPPLIER_NO,
       SUPPLIER_NAME,
       ROUTE_CODE,
       ROUTE_DESC,
       CAR_BATCH,
       CAR_BATCH_SEQNO,
       LOCATION,
       DISTRI_PERSON,
       PREPARE_PRODUCT_SEQNO,
       DISPATCH_PRODUCT_SEQNO,
       ARRIVE_PRODUCT_SEQNO,
       DISTRI_PRODUCT_SEQNO,
       PREPARE_TIME,
       DISPATCH_TIME,
       DELIVERY_TIME,
       ARRIVE_TIME,
       DISTRI_TIME,
       USE_LOCATION_NUM,
       ARRIVE_BATCH_NO,
       IS_MANU_DEAL,
       MANU_REQ_TIME,
       MANU_REQ_USER,
       MANU_REQ_IP,
       PRINT_STATUS,
       PRINT_TIME,
       PRINT_USER,
       PRINT_USER_IP,
       CREATION_TIME,
       ORDER_NO,
       ORDER_DEAL_FLAG,
       ORDER_DEAL_TIME,
       IF_CODE)
      SELECT A.INS_NO,
             A.PLAN_CODE,
             A.PARTGROUP_NO,
             A.ARR_DEPOT,
             A.SUP_FACTORY,
             A.INS_PARTGROUP_SEQNO,
             A.INS_SUPFACTORY_SEQNO,
             A.PARTGROUP_NAME,
             A.ORDER_FLG,
             A.GEN_INS_WAY,
             A.SUPPLIER_NO,
             A.SUPPLIER_NAME,
             A.ROUTE_CODE,
             A.ROUTE_DESC,
             A.CAR_BATCH,
             A.CAR_BATCH_SEQNO,
             A.LOCATION,
             A.DISTRI_PERSON,
             A.PREPARE_PRODUCT_SEQNO,
             A.DISPATCH_PRODUCT_SEQNO,
             A.ARRIVE_PRODUCT_SEQNO,
             A.DISTRI_PRODUCT_SEQNO,
             A.PREPARE_TIME,
             A.DISPATCH_TIME,
             A.DELIVERY_TIME,
             A.ARRIVE_TIME,
             A.DISTRI_TIME,
             A.USE_LOCATION_NUM,
             A.ARRIVE_BATCH_NO,
             A.IS_MANU_DEAL,
             A.MANU_REQ_TIME,
             A.MANU_REQ_USER,
             A.MANU_REQ_IP,
             A.PRINT_STATUS,
             A.PRINT_TIME,
             A.PRINT_USER,
             A.PRINT_USER_IP,
             A.CREATION_TIME,
             A.ORDER_NO,
             A.ORDER_DEAL_FLAG,
             A.ORDER_DEAL_TIME,
             B.IF_CODE
        FROM MM_JISO_INS A
      /*
      update by luoxianqin
      延锋内饰和外饰（SG502,SG504）都写到一个接口表在根据接口代码分别发送到内饰和外饰
      */
        LEFT JOIN MM_IF_CONFIG B
          ON A.SUPPLIER_NO = B.SUPPLIER_NO
         AND A.SUP_FACTORY = B.SUP_FACTORY
       WHERE A.DEAL_FLAG = 2;
  
    --写入收货明细表      
    INSERT INTO IF_MM_JISO_INS_DETAIL
      (INS_NO,
       ORDER_NO,
       SALE_NO,
       SALE_ROWNO,
       PART_NO,
       REQUIRE_NUM,
       PART_SHORT_NO,
       PART_NAME,
       PART_MARK,
       REMARK_FLAG,
       VIN,
       MODEL_CODE,
       PHASE,
       PASS_TIME,
       WC_SEQNO,
       PL_SEQNO,
       KB_PRODUCT_SEQNO,
       KB_TIME,
       CREATION_TIME)
      SELECT C.INS_NO,
             C.ORDER_NO,
             C.SALE_NO,
             C.SALE_ROWNO,
             C.PART_NO,
             C.REQUIRE_NUM,
             C.PART_SHORT_NO,
             C.PART_NAME,
             C.PART_MARK,
             C.REMARK_FLAG,
             C.VIN,
             C.MODEL_CODE,
             C.PHASE,
             C.PASS_TIME,
             C.WC_SEQNO,
             C.PL_SEQNO,
             C.KB_PRODUCT_SEQNO,
             C.KB_TIME,
             SYSDATE
        FROM MM_JISO_INS B
        LEFT JOIN MM_JISO_INS_DETAIL C
          ON B.INS_NO = C.INS_NO
       WHERE B.DEAL_FLAG = 2;
  
    --更新待处理的数据为已处理
    UPDATE MM_JISO_INS A
       SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
     WHERE A.DEAL_FLAG = 2;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_JISO_INS_SEND',
           err_num,
           err_msg,
           sysdate,
           '将同步指示票发送延锋');
        COMMIT;
      END;
  END USP_JISO_INS_SEND;

  --****************************************************************************
  --过程名  : USP_TRAN_MOVE_LMS
  --功能描述: 仓库转移数据接口表
  --参数说明: 无
  --创建人员: zmj
  --创建时间: 2019-08-04
  PROCEDURE USP_TRAN_MOVE_LMS IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
  
    --更新处理标识为待处理
    UPDATE MM_INV_CONFIRM A SET A.DEAL_FLAG = 2 WHERE A.DEAL_FLAG = 0;
    COMMIT;
  
    --写入移库接口头信息
    INSERT INTO IF_INV_TRAN_LMS
      (BUSINESS_NO, COMP, TRAN_TYPE, USER_ID, CREATE_DATE)
      SELECT A.CONFIRM_NO, A.FACTORY_CODE, '311', A.CREATION_USER, SYSDATE
        FROM MM_INV_CONFIRM A
       WHERE A.DEAL_FLAG = 2
         AND EXISTS (SELECT 1
                FROM MM_INV_CONFIRM_DETAIL B
               WHERE A.CONFIRM_NO = B.CONFIRM_NO
                 AND B.REC_QTY > 0);
  
    --写入移库接口表明细表
    INSERT INTO IF_INV_TRAN_LMS_DETAIL
      (COMP,
       BUSINESS_NO,
       BUSINESS_ROW_NO,
       FROM_DEPOT_NO,
       TO_DEPOT_NO,
       PART_ID,
       PART_NUM)
      SELECT B.FACTORY_CODE,
             A.CONFIRM_NO,
             ROW_NUMBER() OVER(PARTITION BY B.CONFIRM_NO ORDER BY A.PART_NO) * 10,
             --根据各工作中心从物流库转移到对应的线边
             DECODE(B.WORK_CENTER, 'A1', 'AA11', 'W1', 'WA11', NULL),
             DECODE(B.WORK_CENTER, 'A1', 'AW11', 'W1', 'WW11', NULL),
             A.PART_NO,
             A.REC_QTY
        FROM MM_INV_CONFIRM_DETAIL A
        LEFT JOIN MM_INV_CONFIRM B
          ON A.CONFIRM_NO = B.CONFIRM_NO
       WHERE B.DEAL_FLAG = 2
         AND A.REC_QTY > 0;
  
    --更新待处理的数据为已处理
    UPDATE MM_INV_CONFIRM A
       SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
     WHERE A.DEAL_FLAG = 2;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_TRAN_MOVE_LMS',
           err_num,
           err_msg,
           sysdate,
           '仓库转移数据接口表');
        COMMIT;
      END;
  END USP_TRAN_MOVE_LMS;

end PKG_IF_SEND;
/

prompt
prompt Creating package body PKG_IF_SEND_IN
prompt ====================================
prompt
create or replace package body PKG_IF_SEND_IN is

  --****************************************************************************
  --过程名  : USP_MON_KB
  --功能描述: 厂内平台的供应商看板写入信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_MON_KB IS
    v_flag  number(1); --临时标识
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ID IN (SELECT *
                     FROM MM_MON_KB T
                    WHERE T.IS_EDIT = 0
                    ORDER BY T.ID) LOOP
      --写入信息共享平台看板信息维护
      SELECT COUNT(1)
        INTO V_FLAG
        FROM ilmsportal.MM_MON_KB@MM_IF_IN T
       WHERE T.KB_CODE = CUR_ID.KB_CODE
         AND T.FACTORY_CODE = CUR_ID.FACTORY_CODE
         AND ROWNUM = 1;
      IF V_FLAG <= 0 THEN
        INSERT INTO ilmsportal.MM_MON_KB@MM_IF_IN
          SELECT ilmsportal.SEQ_MM_MON_KB.NEXTVAL@MM_IF_IN,
                 FACTORY_CODE,
                 KB_CODE,
                 PRODUCTION_LINE,
                 WORKCENTER,
                 STATION_CODE,
                 KB_NAME,
                 KB_TYPE,
                 BATCH_CYCLE_NUM,
                 PROCESS_CYCLE_NUM,
                 CURR_BATCH_NO,
                 CURR_PROCESS_NO,
                 CURR_BATCH_SEQNO,
                 PRODUCT_SEQNO,
                 IS_EDIT,
                 REMARK,
                 MAX_PASS_TIME,
                 CREATION_USER,
                 CREATION_TIME,
                 LAST_MODIFIED_USER,
                 LAST_MODIFIED_TIME,
                 LAST_MODIFIED_IP
            FROM MM_MON_KB A
           WHERE A.KB_CODE = CUR_ID.KB_CODE
             AND A.FACTORY_CODE = CUR_ID.FACTORY_CODE;
      ELSE
        UPDATE ilmsportal.MM_MON_KB@MM_IF_IN T
           SET T.PRODUCTION_LINE    = CUR_ID.PRODUCTION_LINE,
               T.WORKCENTER         = CUR_ID.WORKCENTER,
               T.STATION_CODE       = CUR_ID.STATION_CODE,
               T.KB_NAME            = CUR_ID.KB_NAME,
               T.KB_TYPE            = CUR_ID.KB_TYPE,
               T.BATCH_CYCLE_NUM    = CUR_ID.BATCH_CYCLE_NUM,
               T.PROCESS_CYCLE_NUM  = CUR_ID.PROCESS_CYCLE_NUM,
               T.CURR_BATCH_NO      = CUR_ID.CURR_BATCH_NO,
               T.CURR_PROCESS_NO    = CUR_ID.Curr_Process_No,
               T.CURR_BATCH_SEQNO   = CUR_ID.CURR_BATCH_SEQNO,
               T.PRODUCT_SEQNO      = CUR_ID.PRODUCT_SEQNO,
               T.IS_EDIT            = CUR_ID.IS_EDIT,
               T.REMARK             = CUR_ID.REMARK,
               T.MAX_PASS_TIME      = CUR_ID.MAX_PASS_TIME,
               T.CREATION_USER      = CUR_ID.CREATION_USER,
               T.CREATION_TIME      = CUR_ID.CREATION_TIME,
               T.LAST_MODIFIED_USER = CUR_ID.LAST_MODIFIED_USER,
               T.LAST_MODIFIED_TIME = CUR_ID.LAST_MODIFIED_TIME,
               T.LAST_MODIFIED_IP   = CUR_ID.LAST_MODIFIED_IP
         WHERE T.FACTORY_CODE = CUR_ID.FACTORY_CODE
           AND T.KB_CODE = CUR_ID.KB_CODE;
      END IF;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_MON_KB',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_MON_KB;

  --****************************************************************************
  --过程名  : USP_JIT_ORDER
  --功能描述: 将厂内平台的拉动订单写入信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --修改记录：
  --         不写入打印信息 mod by wxl 20190328
  --****************************************************************************
  PROCEDURE USP_JIT_ORDER IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER IN (SELECT T.ORDER_NO
                        FROM MM_JIT_ORDER T
                       WHERE T.DEAL_FLAG_IN = 0
                       ORDER BY T.CREATION_TIME) LOOP
      --写入信息共享平台拉动订单主信息
      INSERT INTO ilmsportal.MM_JIT_ORDER@MM_IF_IN
        (ORDER_NO,
         PLAN_CODE,
         SHIP_DEPOT,
         ARR_DEPOT,
         SHIP_DEPOT_TYPE,
         SUP_FACTORY,
         SUPPLIER_NO,
         SUPPLIER_NAME,
         S_PREPARE_PRODUCT_SEQNO,
         E_PREPARE_PRODUCT_SEQNO,
         DISPATCH_PRODUCT_SEQNO,
         DELIVERY_PRODUCT_SEQNO,
         ARRIVE_PRODUCT_SEQNO,
         PREPARE_TIME,
         DISPATCH_TIME,
         DELIVERY_TIME,
         ARRIVE_TIME,
         S_PREPARE_BATCH_NO,
         E_PREPARE_BATCH_NO,
         DELIVERY_BATCH_NO,
         --PRINT_STATUS,
         --PRINT_TIME,
         --PRINT_USER,
         --PRINT_USER_IP,
         ORDER_NO_BATCH,
         ORDER_NO_DIFFSEQ,
         PURCHASE_ORDERNO,
         CREATION_TIME,
         PREPARE_STATUS,
         PREPARE_COUNT,
         ACTUAL_PRE_PRODUCT_SEQNO,
         DELIVERY_STATUS,
         DELIVERY_COUNT,
         ACTUAL_DELI_PRODUCT_SEQNO,
         ARRIVE_STATUS,
         ARRIVE_COUNT,
         ACTUAL_ARR_PRODUCT_SEQNO)
        SELECT ORDER_NO,
               PLAN_CODE,
               SHIP_DEPOT,
               ARR_DEPOT,
               SHIP_DEPOT_TYPE,
               SUP_FACTORY,
               SUPPLIER_NO,
               SUPPLIER_NAME,
               S_PREPARE_PRODUCT_SEQNO,
               E_PREPARE_PRODUCT_SEQNO,
               DISPATCH_PRODUCT_SEQNO,
               DELIVERY_PRODUCT_SEQNO,
               ARRIVE_PRODUCT_SEQNO,
               PREPARE_TIME,
               DISPATCH_TIME,
               DELIVERY_TIME,
               ARRIVE_TIME,
               S_PREPARE_BATCH_NO,
               E_PREPARE_BATCH_NO,
               DELIVERY_BATCH_NO,
               --PRINT_STATUS,
               --PRINT_TIME,
               --PRINT_USER,
               --PRINT_USER_IP,
               ORDER_NO_BATCH,
               ORDER_NO_DIFFSEQ,
               PURCHASE_ORDERNO,
               CREATION_TIME,
               PREPARE_STATUS,
               PREPARE_COUNT,
               ACTUAL_PRE_PRODUCT_SEQNO,
               DELIVERY_STATUS,
               DELIVERY_COUNT,
               ACTUAL_DELI_PRODUCT_SEQNO,
               ARRIVE_STATUS,
               ARRIVE_COUNT,
               ACTUAL_ARR_PRODUCT_SEQNO
          FROM MM_JIT_ORDER A
         WHERE A.ORDER_NO = CUR_ORDER.ORDER_NO;

      --写入信息共享平台拉动订单明细
      INSERT INTO ilmsportal.MM_JIT_ORDER_DETAIL@MM_IF_IN
        (ORDER_NO,
         ORDER_ROWNO,
         PART_NO,
         LOCATION,
         REQUIRE_NUM,
         PART_SHORT_NO,
         PART_NAME,
         STANDARD_PACKAGE,
         BOX_NUM,
         SUPPLIER_NO,
         SUPPLIER_NAME,
         PURCHASE_ORDERNO,
         PREPARE_STATUS,
         PREPARE_COUNT,
         ACTUAL_PRE_PRODUCT_SEQNO,
         PREPARE_NUM,
         DELIVERY_STATUS,
         DELIVERY_COUNT,
         ACTUAL_DELI_PRODUCT_SEQNO,
         DELIVERY_NUM,
         ARRIVE_STATUS,
         ARRIVE_COUNT,
         ACTUAL_ARR_PRODUCT_SEQNO,
         ARRIVE_NUM,
         CREATION_TIME,
         LAST_MODIFIED_TIME)
        SELECT ORDER_NO,
               ORDER_ROWNO,
               PART_NO,
               LOCATION,
               REQUIRE_NUM,
               PART_SHORT_NO,
               PART_NAME,
               STANDARD_PACKAGE,
               BOX_NUM,
               SUPPLIER_NO,
               SUPPLIER_NAME,
               PURCHASE_ORDERNO,
               PREPARE_STATUS,
               PREPARE_COUNT,
               ACTUAL_PRE_PRODUCT_SEQNO,
               PREPARE_NUM,
               DELIVERY_STATUS,
               DELIVERY_COUNT,
               ACTUAL_DELI_PRODUCT_SEQNO,
               DELIVERY_NUM,
               ARRIVE_STATUS,
               ARRIVE_COUNT,
               ACTUAL_ARR_PRODUCT_SEQNO,
               ARRIVE_NUM,
               CREATION_TIME,
               LAST_MODIFIED_TIME
          FROM MM_JIT_ORDER_DETAIL DETAIL
         WHERE DETAIL.ORDER_NO = CUR_ORDER.ORDER_NO;

      --写入信息共享平台拉动零件标签信息
      INSERT INTO ilmsportal.MM_JIT_LABEL@MM_IF_IN
        (ORDER_NO,
         LABEL_ROWNO,
         PLAN_CODE,
         PART_NO,
         LOCATION,
         REQUIRE_NUM,
         PART_SHORT_NO,
         PART_NAME,
         SUPPLIER_NO,
         SUPPLIER_NAME,
         SHIP_DEPOT,
         ARR_DEPOT,
         STANDARD_PACKAGE,
         DISTRI_PACKAGE,
         UNLOAD_PORT,
         PREPARE_PERSON,
         STORAGE,
         DISTRI_PERSON,
         KB_PRODUCT_SEQNO,
         PREPARE_PRODUCT_SEQNO,
         DISPATCH_PRODUCT_SEQNO,
         DELIVERY_PRODUCT_SEQNO,
         ARRIVE_PRODUCT_SEQNO,
         DISTRI_PRODUCT_SEQNO,
         ASSEMBLE_PRODUCT_SEQNO,
         KB_TIME,
         PREPARE_TIME,
         DISPATCH_TIME,
         DELIVERY_TIME,
         ARRIVE_TIME,
         DISTRI_TIME,
         ASSEMBLE_TIME,
         PREPARE_BATCH_NO,
         KB_BATCH_NO,
         LABEL_PART_ROWNO,
         --PRINT_STATUS,
         --PRINT_TIME,
         --PRINT_USER,
         --PRINT_USER_IP,
         CREATION_TIME)
        SELECT ORDER_NO,
               LABEL_ROWNO,
               PLAN_CODE,
               PART_NO,
               LOCATION,
               REQUIRE_NUM,
               PART_SHORT_NO,
               PART_NAME,
               SUPPLIER_NO,
               SUPPLIER_NAME,
               SHIP_DEPOT,
               ARR_DEPOT,
               STANDARD_PACKAGE,
               DISTRI_PACKAGE,
               UNLOAD_PORT,
               PREPARE_PERSON,
               STORAGE,
               DISTRI_PERSON,
               KB_PRODUCT_SEQNO,
               PREPARE_PRODUCT_SEQNO,
               DISPATCH_PRODUCT_SEQNO,
               DELIVERY_PRODUCT_SEQNO,
               ARRIVE_PRODUCT_SEQNO,
               DISTRI_PRODUCT_SEQNO,
               ASSEMBLE_PRODUCT_SEQNO,
               KB_TIME,
               PREPARE_TIME,
               DISPATCH_TIME,
               DELIVERY_TIME,
               ARRIVE_TIME,
               DISTRI_TIME,
               ASSEMBLE_TIME,
               PREPARE_BATCH_NO,
               KB_BATCH_NO,
               LABEL_PART_ROWNO,
               --PRINT_STATUS,
               --PRINT_TIME,
               --PRINT_USER,
               --PRINT_USER_IP,
               CREATION_TIME
          FROM MM_JIT_LABEL LABEL
         WHERE LABEL.ORDER_NO = CUR_ORDER.ORDER_NO;

      --更新接口处理标识
      UPDATE MM_JIT_ORDER T
         SET T.DEAL_FLAG_IN = 1, T.DEAL_TIME_IN = SYSDATE
       WHERE ORDER_NO = CUR_ORDER.ORDER_NO;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_JIT_ORDER',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_JIT_ORDER;

  --****************************************************************************
  --过程名  : USP_JISO_ORDER
  --功能描述: 将厂内平台的厂外同步订单写入信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --修改记录：
  --         不写入打印信息 mod by wxl 20190328
  --****************************************************************************
  PROCEDURE USP_JISO_ORDER IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER IN (SELECT T.ORDER_NO
                        FROM MM_JISO_ORDER T
                       WHERE T.DEAL_FLAG_IN = 0
                       ORDER BY T.CREATION_TIME) LOOP
      --写入信息共享平台拉动订单主信息
      INSERT INTO ilmsportal.MM_JISO_ORDER@MM_IF_IN
        (ORDER_NO,
         PLAN_CODE,
         ARR_DEPOT,
         SUP_FACTORY,
         ROUTE_CODE,
         CAR_BATCH_SEQNO,
         SUPPLIER_NO,
         SUPPLIER_NAME,
         ROUTE_DESC,
         CAR_BATCH,
         PREPARE_PRODUCT_SEQNO,
         DISPATCH_PRODUCT_SEQNO,
         DELIVERY_PRODUCT_SEQNO,
         ARRIVE_PRODUCT_SEQNO,
         DISTRI_PRODUCT_SEQNO,
         PREPARE_TIME,
         DISPATCH_TIME,
         DELIVERY_TIME,
         ARRIVE_TIME,
         DISTRI_TIME,
         ARRIVE_BATCH_NO,
         IS_MANU_DEAL,
         MANU_REQ_TIME,
         MANU_REQ_USER,
         MANU_REQ_IP,
         --PRINT_STATUS,
         --PRINT_TIME,
         --PRINT_USER,
         --PRINT_USER_IP,
         PURCHASE_ORDERNO,
         CREATION_TIME,
         ARRIVE_STATUS,
         ARRIVE_COUNT,
         ACTUAL_ARR_PRODUCT_SEQNO)
        SELECT ORDER_NO,
               PLAN_CODE,
               ARR_DEPOT,
               SUP_FACTORY,
               ROUTE_CODE,
               CAR_BATCH_SEQNO,
               SUPPLIER_NO,
               SUPPLIER_NAME,
               ROUTE_DESC,
               CAR_BATCH,
               PREPARE_PRODUCT_SEQNO,
               DISPATCH_PRODUCT_SEQNO,
               DELIVERY_PRODUCT_SEQNO,
               ARRIVE_PRODUCT_SEQNO,
               DISTRI_PRODUCT_SEQNO,
               PREPARE_TIME,
               DISPATCH_TIME,
               DELIVERY_TIME,
               ARRIVE_TIME,
               DISTRI_TIME,
               ARRIVE_BATCH_NO,
               IS_MANU_DEAL,
               MANU_REQ_TIME,
               MANU_REQ_USER,
               MANU_REQ_IP,
               --PRINT_STATUS,
               --PRINT_TIME,
               --PRINT_USER,
               --PRINT_USER_IP,
               PURCHASE_ORDERNO,
               CREATION_TIME,
               ARRIVE_STATUS,
               ARRIVE_COUNT,
               ACTUAL_ARR_PRODUCT_SEQNO
          FROM MM_JISO_ORDER A
         WHERE A.ORDER_NO = CUR_ORDER.ORDER_NO;

      --写入信息共享平台厂外同步订单明细
      INSERT INTO ilmsportal.MM_JISO_ORDER_DETAIL@MM_IF_IN
        (ORDER_NO,
         ORDER_ROWNO,
         PART_NO,
         REQUIRE_NUM,
         PART_SHORT_NO,
         PART_NAME,
         STANDARD_PACKAGE,
         CREATION_TIME,
         LAST_MODIFIED_TIME,
         ARRIVE_STATUS,
         ARRIVE_COUNT,
         ACTUAL_ARR_PRODUCT_SEQNO,
         ARRIVE_NUM)
        SELECT ORDER_NO,
               ORDER_ROWNO,
               PART_NO,
               REQUIRE_NUM,
               PART_SHORT_NO,
               PART_NAME,
               STANDARD_PACKAGE,
               CREATION_TIME,
               LAST_MODIFIED_TIME,
               ARRIVE_STATUS,
               ARRIVE_COUNT,
               ACTUAL_ARR_PRODUCT_SEQNO,
               ARRIVE_NUM
          FROM MM_JISO_ORDER_DETAIL DETAIL
         WHERE DETAIL.ORDER_NO = CUR_ORDER.ORDER_NO;

      --更新接口处理标识
      UPDATE MM_JISO_ORDER T
         SET T.DEAL_FLAG_IN = 1, T.DEAL_TIME_IN = SYSDATE
       WHERE ORDER_NO = CUR_ORDER.ORDER_NO;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_JISO_ORDER',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_JISO_ORDER;

  --****************************************************************************
  --过程名  : USP_JISO_INS
  --功能描述: 将厂内平台的厂外同步指示票写入信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --修改记录：
  --         不写入打印信息 mod by wxl 20190328
  --         定制化订单-新增销售单写入 mod by wxl 20190315
  --****************************************************************************
  PROCEDURE USP_JISO_INS IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER IN (SELECT T.INS_NO
                        FROM MM_JISO_INS T
                       WHERE T.DEAL_FLAG_IN = 0
                       ORDER BY T.CREATION_TIME) LOOP
      --写入信息共享平台厂外同步指示票主信息
      INSERT INTO ilmsportal.MM_JISO_INS@MM_IF_IN
        (INS_NO,
         PLAN_CODE,
         PARTGROUP_NO,
         ARR_DEPOT,
         SUP_FACTORY,
         INS_PARTGROUP_SEQNO,
         INS_SUPFACTORY_SEQNO,
         PARTGROUP_NAME,
         ORDER_FLG,
         GEN_INS_WAY,
         SUPPLIER_NO,
         SUPPLIER_NAME,
         ROUTE_CODE,
         ROUTE_DESC,
         CAR_BATCH,
         CAR_BATCH_SEQNO,
         LOCATION,
         DISTRI_PERSON,
         PREPARE_PRODUCT_SEQNO,
         DISPATCH_PRODUCT_SEQNO,
         DELIVERY_PRODUCT_SEQNO,
         ARRIVE_PRODUCT_SEQNO,
         DISTRI_PRODUCT_SEQNO,
         PREPARE_TIME,
         DISPATCH_TIME,
         DELIVERY_TIME,
         ARRIVE_TIME,
         DISTRI_TIME,
         USE_LOCATION_NUM,
         ARRIVE_BATCH_NO,
         IS_MANU_DEAL,
         MANU_REQ_TIME,
         MANU_REQ_USER,
         MANU_REQ_IP,
         --PRINT_STATUS,
         --PRINT_TIME,
         --PRINT_USER,
         --PRINT_USER_IP,
         CREATION_TIME,
         ORDER_NO,
         ORDER_DEAL_FLAG,
         ORDER_DEAL_TIME)
        SELECT INS_NO,
               PLAN_CODE,
               PARTGROUP_NO,
               ARR_DEPOT,
               SUP_FACTORY,
               INS_PARTGROUP_SEQNO,
               INS_SUPFACTORY_SEQNO,
               PARTGROUP_NAME,
               ORDER_FLG,
               GEN_INS_WAY,
               SUPPLIER_NO,
               SUPPLIER_NAME,
               ROUTE_CODE,
               ROUTE_DESC,
               CAR_BATCH,
               CAR_BATCH_SEQNO,
               LOCATION,
               DISTRI_PERSON,
               PREPARE_PRODUCT_SEQNO,
               DISPATCH_PRODUCT_SEQNO,
               DELIVERY_PRODUCT_SEQNO,
               ARRIVE_PRODUCT_SEQNO,
               DISTRI_PRODUCT_SEQNO,
               PREPARE_TIME,
               DISPATCH_TIME,
               DELIVERY_TIME,
               ARRIVE_TIME,
               DISTRI_TIME,
               USE_LOCATION_NUM,
               ARRIVE_BATCH_NO,
               IS_MANU_DEAL,
               MANU_REQ_TIME,
               MANU_REQ_USER,
               MANU_REQ_IP,
               --PRINT_STATUS,
               --PRINT_TIME,
               --PRINT_USER,
               --PRINT_USER_IP,
               CREATION_TIME,
               ORDER_NO,
               ORDER_DEAL_FLAG,
               ORDER_DEAL_TIME
          FROM MM_JISO_INS A
         WHERE A.INS_NO = CUR_ORDER.INS_NO;

      --写入信息共享平台厂外同步指示票明细
      INSERT INTO ilmsportal.MM_JISO_INS_DETAIL@MM_IF_IN
        (INS_NO,
         ORDER_NO,
         SALE_NO,
         SALE_ROWNO,
         PART_NO,
         REQUIRE_NUM,
         PART_SHORT_NO,
         PART_NAME,
         PART_MARK,
         REMARK_FLAG,
         VIN,
         MODEL_CODE,
         PHASE,
         PASS_TIME,
         WC_SEQNO,
         PL_SEQNO,
         KB_PRODUCT_SEQNO,
         KB_TIME,
         CREATION_TIME,
         LAST_MODIFIED_TIME)
        SELECT INS_NO,
               ORDER_NO,
               SALE_NO,
               SALE_ROWNO,
               PART_NO,
               REQUIRE_NUM,
               PART_SHORT_NO,
               PART_NAME,
               PART_MARK,
               REMARK_FLAG,
               VIN,
               MODEL_CODE,
               PHASE,
               PASS_TIME,
               WC_SEQNO,
               PL_SEQNO,
               KB_PRODUCT_SEQNO,
               KB_TIME,
               CREATION_TIME,
               LAST_MODIFIED_TIME
          FROM MM_JISO_INS_DETAIL DETAIL
         WHERE DETAIL.INS_NO = CUR_ORDER.INS_NO;

      --更新接口处理标识
      UPDATE MM_JISO_INS T
         SET T.DEAL_FLAG_IN = 1, T.DEAL_TIME_IN = SYSDATE
       WHERE INS_NO = CUR_ORDER.INS_NO;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_JISO_INS',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_JISO_INS;

  --****************************************************************************
  --过程名  : USP_PKG_PART
  --功能描述: 将包装零件担当信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_PKG_PART IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER_NO IN (SELECT T.*
                           FROM IF_MM_PKG_PART T
                          WHERE T.DEAL_FLAG = 0
                          ORDER BY T.CREATION_TIME) LOOP

      IF CUR_ORDER_NO.DO_FLAG = 'I' THEN
        insert into ilmsportal.MM_PKG_PART@MM_IF_IN
          (Id,
           CAR_TYPE,
           PROJECT,
           PART_NO,
           PART_RESP_USER,
           SUPPLIER_NO,
           STATUS,
           CREATION_USER,
           CREATION_TIME,
           LAST_MODIFIED_USER,
           LAST_MODIFIED_TIME,
           FACTORY_CODE,
           PURCHASE_TYPE)
        values
          (ilmsportal.SEQ_MM_PKG_PART.NEXTVAL@mm_if_in,
           CUR_ORDER_NO.CAR_TYPE,
           CUR_ORDER_NO.PROJECT,
           CUR_ORDER_NO.PART_NO,
           CUR_ORDER_NO.PART_RESP_USER,
           CUR_ORDER_NO.SUPPLIER_NO,
           CUR_ORDER_NO.STATUS,
           CUR_ORDER_NO.CREATION_USER,
           SYSDATE,
           CUR_ORDER_NO.LAST_MODIFIED_USER,
           CUR_ORDER_NO.LAST_MODIFIED_TIME,
           CUR_ORDER_NO.FACTORY_CODE,
           CUR_ORDER_NO.PURCHASE_TYPE);

      ELSIF CUR_ORDER_NO.DO_FLAG = 'U' THEN
        update ilmsportal.MM_PKG_PART@mm_if_in a
           set a.PROJECT            = CUR_ORDER_NO.PROJECT,
               a.PART_RESP_USER     = CUR_ORDER_NO.PART_RESP_USER,
               a.SUPPLIER_NO        = CUR_ORDER_NO.SUPPLIER_NO,
               a.STATUS             = CUR_ORDER_NO.STATUS,
               a.CREATION_USER      = CUR_ORDER_NO.CREATION_USER,
               a.LAST_MODIFIED_USER = CUR_ORDER_NO.LAST_MODIFIED_USER,
               a.LAST_MODIFIED_TIME = CUR_ORDER_NO.LAST_MODIFIED_TIME
         where a.CAR_TYPE = CUR_ORDER_NO.CAR_TYPE
           and a.PART_NO = CUR_ORDER_NO.PART_NO
           and a.SUPPLIER_NO = CUR_ORDER_NO.SUPPLIER_NO
           and a.PURCHASE_TYPE = CUR_ORDER_NO.PURCHASE_TYPE
           and a.FACTORY_CODE = CUR_ORDER_NO.FACTORY_CODE;

      ELSIF CUR_ORDER_NO.DO_FLAG = 'D' THEN
        delete from ilmsportal.MM_PKG_PART@mm_if_in a
         where a.CAR_TYPE = CUR_ORDER_NO.CAR_TYPE
           and a.PART_NO = CUR_ORDER_NO.PART_NO
           and a.SUPPLIER_NO = CUR_ORDER_NO.SUPPLIER_NO
           and a.PURCHASE_TYPE = CUR_ORDER_NO.PURCHASE_TYPE
           and a.FACTORY_CODE = CUR_ORDER_NO.FACTORY_CODE;

      END IF;
      --更新中间表处理标记位为已处理
      update IF_MM_PKG_PART a
         set a.deal_flag = 1, a.deal_time = sysdate
       where a.id = CUR_ORDER_NO.Id
         and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PKG_PART',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PKG_PART;

  --****************************************************************************
  --过程名  : USP_PKG_BOX
  --功能描述: 将包装箱种信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_PKG_BOX IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER_NO IN (SELECT T.*
                           FROM IF_MM_PKG_BOX T
                          WHERE T.DEAL_FLAG = 0
                          ORDER BY T.CREATION_TIME) LOOP

      IF CUR_ORDER_NO.DO_FLAG = 'I' THEN

        insert into ilmsportal.MM_PKG_BOX@mm_if_in
          (ID,
           BOX_CODE,
           BOX_TYPE,
           PACK_LENGTH,
           PACK_WIDTH,
           PACK_HEIGHT,
           STATUS,
           CREATION_USER,
           CREATION_TIME,
           LAST_MODIFIED_USER,
           LAST_MODIFIED_TIME,
           FACTORY_CODE)
        values
          (ilmsportal.SEQ_MM_PKG_BOX.NEXTVAL@mm_if_in,
           CUR_ORDER_NO.BOX_CODE,
           CUR_ORDER_NO.BOX_TYPE,
           CUR_ORDER_NO.PACK_LENGTH,
           CUR_ORDER_NO.PACK_WIDTH,
           CUR_ORDER_NO.PACK_HEIGHT,
           CUR_ORDER_NO.STATUS,
           CUR_ORDER_NO.CREATION_USER,
           SYSDATE,
           CUR_ORDER_NO.LAST_MODIFIED_USER,
           CUR_ORDER_NO.LAST_MODIFIED_TIME,
           CUR_ORDER_NO.FACTORY_CODE);

      ELSIF CUR_ORDER_NO.DO_FLAG = 'U' THEN
        update ilmsportal.MM_PKG_BOX@mm_if_in a
           set a.BOX_TYPE           = CUR_ORDER_NO.BOX_TYPE,
               a.PACK_LENGTH        = CUR_ORDER_NO.PACK_LENGTH,
               a.PACK_WIDTH         = CUR_ORDER_NO.PACK_WIDTH,
               a.PACK_HEIGHT        = CUR_ORDER_NO.PACK_HEIGHT,
               a.STATUS             = CUR_ORDER_NO.STATUS,
               a.CREATION_USER      = CUR_ORDER_NO.CREATION_USER,
               a.CREATION_TIME      = SYSDATE,
               a.LAST_MODIFIED_USER = CUR_ORDER_NO.LAST_MODIFIED_USER,
               a.LAST_MODIFIED_TIME = CUR_ORDER_NO.LAST_MODIFIED_TIME
         where a.BOX_CODE = CUR_ORDER_NO.BOX_CODE
           and a.FACTORY_CODE = CUR_ORDER_NO.FACTORY_CODE;

      ELSIF CUR_ORDER_NO.DO_FLAG = 'D' THEN
        delete from ilmsportal.MM_PKG_BOX@mm_if_in a
         where a.BOX_CODE = CUR_ORDER_NO.BOX_CODE
           and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;

      END IF;
      --更新中间表处理标记位为已处理
      update IF_MM_PKG_BOX a
         set a.deal_flag = 1, a.deal_time = sysdate
       where a.id = CUR_ORDER_NO.Id
         and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PKG_BOX',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PKG_BOX;

  --****************************************************************************
  --过程名  : USP_PKG_PROPOSAL_DETAIL
  --功能描述: 将包装提案明细信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_PKG_PROPOSAL_DETAIL IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER_NO IN (SELECT T.*
                           FROM IF_MM_PKG_PROPOSAL_DETAIL T
                          WHERE T.DEAL_FLAG = 0
                          ORDER BY T.CREATION_TIME) LOOP

      IF CUR_ORDER_NO.DO_FLAG = 'I' THEN
        insert into ilmsportal.MM_PKG_PROPOSAL_DETAIL@mm_if_in
          (ID,
           Proposal_Id,
           GROUP_NO,
           MAX_PACKAGE_NUM,
           STANDARD_PACKAGE,
           PART_WEIGHT,
           PART_TOTAL_WEIGHT,
           PACK_WEIGHT,
           PART_LENGTH,
           PART_WIDTH,
           PART_HEIGHT,
           EMPTY_TROLLEY_LENGTH,
           EMPTY_TROLLEY_WIDTH,
           EMPTY_TROLLEY_HEIGHT,
           Real_Trolley_Length,
           Real_Trolley_Width,
           Real_Trolley_Height,
           TROLLEY_WEIGHT,
           Total_Weight,
           IS_TROLLEY_CODE,
           Is_Positioner,
           DUST_COVER,
           One_By_Package,
           BOARD_LOCATION,
           Wheel_Diameter,
           WORD_DESC,
           Traction_Rod_Height,
           IMPORTANT_POSTION_PIC,
           EMPTY_TRO_FRONT_PIC,
           Empty_Tro_Side_Pic,
           REAL_TRO_PIC,
           BOX_CODE,
           PACK_LENGTH,
           Pack_Width,
           pack_height,
           TRAY_LENGTH,
           Tray_Width,
           Tray_Height,
           WORK_REQUIRE,
           Single_Part_Pic,
           Single_Part_Put_Pic,
           PACK_OVER_LOOK_PIC,
           Pack_Side_Look_Pic,
           CREATION_USER,
           Creation_Time,
           LAST_MODIFIED_USER,
           Last_Modified_Time,
           Factory_Code)
        values
          (CUR_ORDER_NO.ID,
           CUR_ORDER_NO.Proposal_Id,
           CUR_ORDER_NO.GROUP_NO,
           CUR_ORDER_NO.MAX_PACKAGE_NUM,
           CUR_ORDER_NO.STANDARD_PACKAGE,
           CUR_ORDER_NO.PART_WEIGHT,
           CUR_ORDER_NO.PART_TOTAL_WEIGHT,
           CUR_ORDER_NO.PACK_WEIGHT,
           CUR_ORDER_NO.PART_LENGTH,
           CUR_ORDER_NO.PART_WIDTH,
           CUR_ORDER_NO.PART_HEIGHT,
           CUR_ORDER_NO.EMPTY_TROLLEY_LENGTH,
           CUR_ORDER_NO.EMPTY_TROLLEY_WIDTH,
           CUR_ORDER_NO.EMPTY_TROLLEY_HEIGHT,
           CUR_ORDER_NO.Real_Trolley_Length,
           CUR_ORDER_NO.Real_Trolley_Width,
           CUR_ORDER_NO.Real_Trolley_Height,
           CUR_ORDER_NO.TROLLEY_WEIGHT,
           CUR_ORDER_NO.Total_Weight,
           CUR_ORDER_NO.IS_TROLLEY_CODE,
           CUR_ORDER_NO.Is_Positioner,
           CUR_ORDER_NO.DUST_COVER,
           CUR_ORDER_NO.One_By_Package,
           CUR_ORDER_NO.BOARD_LOCATION,
           CUR_ORDER_NO.Wheel_Diameter,
           CUR_ORDER_NO.WORD_DESC,
           CUR_ORDER_NO.Traction_Rod_Height,
           CUR_ORDER_NO.IMPORTANT_POSTION_PIC,
           CUR_ORDER_NO.EMPTY_TRO_FRONT_PIC,
           CUR_ORDER_NO.Empty_Tro_Side_Pic,
           CUR_ORDER_NO.REAL_TRO_PIC,
           CUR_ORDER_NO.BOX_CODE,
           CUR_ORDER_NO.PACK_LENGTH,
           CUR_ORDER_NO.Pack_Width,
           CUR_ORDER_NO.pack_height,
           CUR_ORDER_NO.TRAY_LENGTH,
           CUR_ORDER_NO.Tray_Width,
           CUR_ORDER_NO.Tray_Height,
           CUR_ORDER_NO.WORK_REQUIRE,
           CUR_ORDER_NO.Single_Part_Pic,
           CUR_ORDER_NO.Single_Part_Put_Pic,
           CUR_ORDER_NO.PACK_OVER_LOOK_PIC,
           CUR_ORDER_NO.Pack_Side_Look_Pic,
           CUR_ORDER_NO.CREATION_USER,
           SYSDATE,
           CUR_ORDER_NO.LAST_MODIFIED_USER,
           CUR_ORDER_NO.Last_Modified_Time,
           CUR_ORDER_NO.Factory_Code);

      ELSIF CUR_ORDER_NO.DO_FLAG = 'U' THEN
        update ilmsportal.MM_PKG_PROPOSAL_DETAIL@mm_if_in a
           set a.GROUP_NO              = CUR_ORDER_NO.GROUP_NO,
               a.MAX_PACKAGE_NUM       = CUR_ORDER_NO.MAX_PACKAGE_NUM,
               a.STANDARD_PACKAGE      = CUR_ORDER_NO.STANDARD_PACKAGE,
               a.PART_WEIGHT           = CUR_ORDER_NO.PART_WEIGHT,
               a.PART_TOTAL_WEIGHT     = CUR_ORDER_NO.PART_TOTAL_WEIGHT,
               a.PACK_WEIGHT           = CUR_ORDER_NO.PART_TOTAL_WEIGHT,
               a.PART_LENGTH           = CUR_ORDER_NO.PART_LENGTH,
               a.PART_WIDTH            = CUR_ORDER_NO.PART_WIDTH,
               a.PART_HEIGHT           = CUR_ORDER_NO.PART_HEIGHT,
               a.EMPTY_TROLLEY_LENGTH  = CUR_ORDER_NO.EMPTY_TROLLEY_LENGTH,
               a.EMPTY_TROLLEY_WIDTH   = CUR_ORDER_NO.EMPTY_TROLLEY_WIDTH,
               a.EMPTY_TROLLEY_HEIGHT  = CUR_ORDER_NO.EMPTY_TROLLEY_HEIGHT,
               a.Real_Trolley_Length   = CUR_ORDER_NO.Real_Trolley_Length,
               a.Real_Trolley_Width    = CUR_ORDER_NO.Real_Trolley_Width,
               a.Real_Trolley_Height   = CUR_ORDER_NO.Real_Trolley_Height,
               a.TROLLEY_WEIGHT        = CUR_ORDER_NO.TROLLEY_WEIGHT,
               a.Total_Weight          = CUR_ORDER_NO.Total_Weight,
               a.IS_TROLLEY_CODE       = CUR_ORDER_NO.IS_TROLLEY_CODE,
               a.Is_Positioner         = CUR_ORDER_NO.Is_Positioner,
               a.DUST_COVER            = CUR_ORDER_NO.DUST_COVER,
               a.One_By_Package        = CUR_ORDER_NO.One_By_Package,
               a.BOARD_LOCATION        = CUR_ORDER_NO.BOARD_LOCATION,
               a.Wheel_Diameter        = CUR_ORDER_NO.Wheel_Diameter,
               a.WORD_DESC             = CUR_ORDER_NO.WORD_DESC,
               a.Traction_Rod_Height   = CUR_ORDER_NO.Traction_Rod_Height,
               a.IMPORTANT_POSTION_PIC = CUR_ORDER_NO.IMPORTANT_POSTION_PIC,
               a.EMPTY_TRO_FRONT_PIC   = CUR_ORDER_NO.EMPTY_TRO_FRONT_PIC,
               a.Empty_Tro_Side_Pic    = CUR_ORDER_NO.Empty_Tro_Side_Pic,
               a.REAL_TRO_PIC          = CUR_ORDER_NO.REAL_TRO_PIC,
               a.BOX_CODE              = CUR_ORDER_NO.BOX_CODE,
               a.PACK_LENGTH           = CUR_ORDER_NO.PACK_LENGTH,
               a.Pack_Width            = CUR_ORDER_NO.Pack_Width,
               a.pack_height           = CUR_ORDER_NO.pack_height,
               a.TRAY_LENGTH           = CUR_ORDER_NO.TRAY_LENGTH,
               a.Tray_Width            = CUR_ORDER_NO.Tray_Width,
               a.Tray_Height           = CUR_ORDER_NO.Tray_Height,
               a.WORK_REQUIRE          = CUR_ORDER_NO.WORK_REQUIRE,
               a.Single_Part_Pic       = CUR_ORDER_NO.Single_Part_Pic,
               a.Single_Part_Put_Pic   = CUR_ORDER_NO.Single_Part_Put_Pic,
               a.PACK_OVER_LOOK_PIC    = CUR_ORDER_NO.PACK_OVER_LOOK_PIC,
               a.Pack_Side_Look_Pic    = CUR_ORDER_NO.Pack_Side_Look_Pic,
               a.LAST_MODIFIED_USER    = CUR_ORDER_NO.LAST_MODIFIED_USER,
               a.Last_Modified_Time    = CUR_ORDER_NO.Last_Modified_Time,
               a.Factory_Code          = CUR_ORDER_NO.Factory_Code

         where a.Proposal_Id = CUR_ORDER_NO.Proposal_Id;

      ELSIF CUR_ORDER_NO.DO_FLAG = 'D' THEN
        delete from ilmsportal.MM_PKG_PROPOSAL_DETAIL@mm_if_in a
         where a.Proposal_Id = CUR_ORDER_NO.Proposal_Id;

      END IF;
      --更新中间表处理标记位为已处理
      update IF_MM_PKG_PROPOSAL_DETAIL a
         set a.deal_flag = 1, a.deal_time = sysdate
       where a.id = CUR_ORDER_NO.Id;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PKG_PROPOSAL_DETAIL',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PKG_PROPOSAL_DETAIL;

  --****************************************************************************
  --过程名  : USP_PKG_PROPOSAL
  --功能描述: 将包装提案信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_PKG_PROPOSAL IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER_NO IN (SELECT T.*
                           FROM IF_MM_PKG_PROPOSAL T
                          WHERE T.DEAL_FLAG = 0
                          ORDER BY T.CREATION_TIME) LOOP

      IF CUR_ORDER_NO.DO_FLAG = 'I' THEN
        insert into ilmsportal.MM_PKG_PROPOSAL@mm_if_in
          (ID,
           CAR_TYPE,
           SUPPLIER_NO,
           PART_NO,
           PROPOSAL_STATUS,
           PACK_TYPE,
           BOX_TYPE,
           REPLY_LIMIT_DATE,
           IS_COM_PACK,
           STATUS,
           SIGN_PRO_FILE,
           EFF_START,
           EFF_END,
           CREATION_USER,
           Creation_Time,
           LAST_MODIFIED_USER,
           Last_Modified_Time,
           FACTORY_CODE,
           PART_RESP_USER,
           PROJECT,
           PURCHASE_TYPE,
           IS_SHOW_CHANGE,
           COM_PACK_REMARK)
        values
          (CUR_ORDER_NO.ID,
           CUR_ORDER_NO.CAR_TYPE,
           CUR_ORDER_NO.SUPPLIER_NO,
           CUR_ORDER_NO.PART_NO,
           CUR_ORDER_NO.PROPOSAL_STATUS,
           CUR_ORDER_NO.PACK_TYPE,
           CUR_ORDER_NO.BOX_TYPE,
           CUR_ORDER_NO.REPLY_LIMIT_DATE,
           CUR_ORDER_NO.IS_COM_PACK,
           CUR_ORDER_NO.STATUS,
           CUR_ORDER_NO.SIGN_PRO_FILE,
           CUR_ORDER_NO.EFF_START,
           CUR_ORDER_NO.EFF_END,
           CUR_ORDER_NO.CREATION_USER,
           SYSDATE,
           CUR_ORDER_NO.LAST_MODIFIED_USER,
           CUR_ORDER_NO.Last_Modified_Time,
           CUR_ORDER_NO.FACTORY_CODE,
           CUR_ORDER_NO.PART_RESP_USER,
           CUR_ORDER_NO.PROJECT,
           CUR_ORDER_NO.PURCHASE_TYPE,
           CUR_ORDER_NO.IS_SHOW_CHANGE,
           CUR_ORDER_NO.COM_PACK_REMARK);

      ELSIF CUR_ORDER_NO.DO_FLAG = 'U' THEN
        update ilmsportal.MM_PKG_PROPOSAL@mm_if_in a
           set a.PACK_TYPE          = CUR_ORDER_NO.PACK_TYPE,
               a.BOX_TYPE           = CUR_ORDER_NO.PACK_TYPE,
               a.REPLY_LIMIT_DATE   = CUR_ORDER_NO.REPLY_LIMIT_DATE,
               a.IS_COM_PACK        = CUR_ORDER_NO.IS_COM_PACK,
               a.STATUS             = CUR_ORDER_NO.STATUS,
               a.SIGN_PRO_FILE      = CUR_ORDER_NO.SIGN_PRO_FILE,
               a.LAST_MODIFIED_USER = CUR_ORDER_NO.LAST_MODIFIED_USER,
               a.Last_Modified_Time = CUR_ORDER_NO.Last_Modified_Time,
               a.PART_RESP_USER     = CUR_ORDER_NO.PART_RESP_USER,
               a.PROJECT            = CUR_ORDER_NO.PROJECT,
               a.PURCHASE_TYPE      = CUR_ORDER_NO.PURCHASE_TYPE,
               a.COM_PACK_REMARK    = CUR_ORDER_NO.COM_PACK_REMARK,
               a.IS_SHOW_CHANGE     = CUR_ORDER_NO.IS_SHOW_CHANGE,
               a.PROPOSAL_STATUS    = CUR_ORDER_NO.PROPOSAL_STATUS
         where a.CAR_TYPE = CUR_ORDER_NO.CAR_TYPE
           and a.SUPPLIER_NO = CUR_ORDER_NO.SUPPLIER_NO
           and a.PART_NO = CUR_ORDER_NO.PART_NO
           and a.factory_code = CUR_ORDER_NO.FACTORY_CODE
           and CUR_ORDER_NO.Do_Flag = 'U'
           and CUR_ORDER_NO.Deal_Flag = '0';

      ELSIF CUR_ORDER_NO.DO_FLAG = 'D' THEN
        delete from ilmsportal.MM_PKG_PROPOSAL@mm_if_in a
         where a.CAR_TYPE = CUR_ORDER_NO.CAR_TYPE
           and a.SUPPLIER_NO = CUR_ORDER_NO.SUPPLIER_NO
           and a.PART_NO = CUR_ORDER_NO.PART_NO
           and a.PROPOSAL_STATUS = CUR_ORDER_NO.PROPOSAL_STATUS
           and a.EFF_START = CUR_ORDER_NO.EFF_START
           and a.EFF_END = CUR_ORDER_NO.EFF_END
           and a.IS_SHOW_CHANGE = CUR_ORDER_NO.IS_SHOW_CHANGE
           and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;

      END IF;
      --更新中间表处理标记位为已处理
      update IF_MM_PKG_PROPOSAL a
         set a.deal_flag = 1, a.deal_time = sysdate
       where a.id = CUR_ORDER_NO.Id
         and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;

      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PKG_PROPOSAL',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PKG_PROPOSAL;

  --****************************************************************************
  --过程名  : USP_PKG_BOX_QTY
  --功能描述: 将包装箱子数量管理同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_PKG_BOX_QTY IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER_NO IN (SELECT T.*
                           FROM IF_MM_PKG_BOX_QTY T
                          WHERE T.DEAL_FLAG = 0
                          ORDER BY T.CREATION_TIME) LOOP

      IF CUR_ORDER_NO.DO_FLAG = 'I' THEN
        insert into ilmsportal.MM_PKG_BOX_QTY@mm_if_in
          (Id,
           PROPOSAL_ID,
           PROVIDE_QTY,
           BOX_REQUIRE_QTY,
           HAIR_NOTE_MODEL,
           PLAN_DATE,
           DELAY_REASON,
           CREATION_USER,
           CREATION_TIME,
           LAST_MODIFIED_USER,
           LAST_MODIFIED_TIME,
           Factory_Code)
        values
          (ilmsportal.SEQ_MM_PKG_BOX_QTY.NEXTVAL@mm_if_in,
           CUR_ORDER_NO.PROPOSAL_ID,
           CUR_ORDER_NO.PROVIDE_QTY,
           CUR_ORDER_NO.BOX_REQUIRE_QTY,
           CUR_ORDER_NO.HAIR_NOTE_MODEL,
           CUR_ORDER_NO.PLAN_DATE,
           CUR_ORDER_NO.DELAY_REASON,
           CUR_ORDER_NO.CREATION_USER,
           SYSDATE,
           CUR_ORDER_NO.LAST_MODIFIED_USER,
           CUR_ORDER_NO.LAST_MODIFIED_TIME,
           CUR_ORDER_NO.Factory_Code);

      ELSIF CUR_ORDER_NO.DO_FLAG = 'U' THEN
        update ilmsportal.MM_PKG_BOX_QTY@mm_if_in a
           set a.PROVIDE_QTY        = CUR_ORDER_NO.PROVIDE_QTY,
               a.BOX_REQUIRE_QTY    = CUR_ORDER_NO.BOX_REQUIRE_QTY,
               a.HAIR_NOTE_MODEL    = CUR_ORDER_NO.HAIR_NOTE_MODEL,
               a.PLAN_DATE          = CUR_ORDER_NO.PLAN_DATE,
               a.DELAY_REASON       = CUR_ORDER_NO.DELAY_REASON,
               a.CREATION_USER      = CUR_ORDER_NO.CREATION_USER,
               a.CREATION_TIME      = SYSDATE,
               a.LAST_MODIFIED_USER = CUR_ORDER_NO.LAST_MODIFIED_USER,
               a.LAST_MODIFIED_TIME = CUR_ORDER_NO.LAST_MODIFIED_TIME
         where a.PROPOSAL_ID = CUR_ORDER_NO.PROPOSAL_ID
           and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;

      ELSIF CUR_ORDER_NO.DO_FLAG = 'D' THEN
        delete from ilmsportal.MM_PKG_BOX_QTY@mm_if_in a
         where a.PROPOSAL_ID = CUR_ORDER_NO.PROPOSAL_ID
           and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;

      END IF;
      --更新中间表处理标记位为已处理
      update IF_MM_PKG_BOX_QTY a
         set a.deal_flag = 1, a.deal_time = sysdate
       where a.id = CUR_ORDER_NO.Id
         and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PKG_BOX_QTY',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PKG_BOX_QTY;

  --****************************************************************************
  --过程名  : USP_PKG_TRAY_QTY
  --功能描述: 将包装托盘数量信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_PKG_TRAY_QTY IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER_NO IN (SELECT T.*
                           FROM IF_MM_PKG_TRAY_QTY T
                          WHERE T.DEAL_FLAG = 0
                          ORDER BY T.CREATION_TIME) LOOP

      IF CUR_ORDER_NO.DO_FLAG = 'I' THEN
        insert into ilmsportal.MM_PKG_TRAY_QTY@mm_if_in
          (Id,
           CAR_TYPE,
           SUPPLIER_NO,
           PROVIDE_QTY,
           TRAY_REQUIRE_QTY,
           PLAN_DATE,
           DELAY_REASON,
           CREATION_USER,
           CREATION_TIME,
           LAST_MODIFIED_USER,
           LAST_MODIFIED_TIME,
           FACTORY_CODE)
        values
          (ilmsportal.SEQ_MM_PKG_TRAY_QTY.NEXTVAL@mm_if_in,
           CUR_ORDER_NO.CAR_TYPE,
           CUR_ORDER_NO.SUPPLIER_NO,
           CUR_ORDER_NO.PROVIDE_QTY,
           CUR_ORDER_NO.TRAY_REQUIRE_QTY,
           CUR_ORDER_NO.PLAN_DATE,
           CUR_ORDER_NO.DELAY_REASON,
           CUR_ORDER_NO.CREATION_USER,
           SYSDATE,
           CUR_ORDER_NO.LAST_MODIFIED_USER,
           CUR_ORDER_NO.LAST_MODIFIED_TIME,
           CUR_ORDER_NO.FACTORY_CODE);

      ELSIF CUR_ORDER_NO.DO_FLAG = 'U' THEN
        update ilmsportal.MM_PKG_TRAY_QTY@mm_if_in a
           set a.PROVIDE_QTY        = CUR_ORDER_NO.PROVIDE_QTY,
               a.TRAY_REQUIRE_QTY   = CUR_ORDER_NO.TRAY_REQUIRE_QTY,
               a.PLAN_DATE          = CUR_ORDER_NO.PLAN_DATE,
               a.DELAY_REASON       = CUR_ORDER_NO.DELAY_REASON,
               a.LAST_MODIFIED_USER = CUR_ORDER_NO.LAST_MODIFIED_USER,
               a.LAST_MODIFIED_TIME = CUR_ORDER_NO.LAST_MODIFIED_TIME
         where a.supplier_no = CUR_ORDER_NO.Supplier_No
           and a.CAR_TYPE = CUR_ORDER_NO.CAR_TYPE
           and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;

      ELSIF CUR_ORDER_NO.DO_FLAG = 'D' THEN
        delete from ilmsportal.MM_PKG_TRAY_QTY@mm_if_in a
         where a.SUPPLIER_NO = CUR_ORDER_NO.SUPPLIER_NO
           and a.CAR_TYPE = CUR_ORDER_NO.CAR_TYPE
           and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;

      END IF;
      --更新中间表处理标记位为已处理
      update IF_MM_PKG_TRAY_QTY a
         set a.deal_flag = 1, a.deal_time = sysdate
       where a.id = CUR_ORDER_NO.Id
         and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PKG_TRAY_QTY',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PKG_TRAY_QTY;

  --****************************************************************************
  --过程名  : USP_PUB_SUPPLIER
  --功能描述: 当厂内供应商数据发生变化时，将信息发布至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_PUB_SUPPLIER IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER IN (SELECT T.*
                        FROM MM_PUB_SUPPLIER T
                       WHERE T.DEAL_FLAG = 0
                       ORDER BY T.CREATION_TIME) LOOP
      /*IF CUR_ORDER.DO_FLAG = 'I' THEN
        --写入门户平台供应商数据
        insert into ilmsportalTEST.MM_PUB_SUPPLIER@MM_IF_IN
          (SUP_FACTORY,
           SUPPLIER_NO,
           SUPPLIER_NAME,
           DETAIL_ADDR,
           SUP_STATUS,
           BLONG_AREA,
           IMPORT_DEP,
           IMPORT_POSITION,
           IMPORT_NAME,
           IMPORT_MOBILE,
           IMPORT_TEL,
           IMPORT_MAIL,
           PT_DEP,
           PT_POSITION,
           PT_NAME,
           PT_MOBIL,
           PT_TEL,
           PT_MAIL,
           MASS_DEP,
           MASS_POSITION,
           MASS_NAME,
           MASS_MOBIL,
           MASS_TEL,
           MASS_MAIL,
           EXCEP_DEP,
           EXCEP_POSITION,
           EXCEP_NAME_A,
           EXCEP_NAME_B,
           EXCEP_MOBIL_A,
           EXCEP_MOBIL_B,
           EXCEP_TEL_A,
           EXCEP_TEL_B,
           DEVICE_DEP,
           DEVICE_POSITION,
           DEVICE_NAME,
           DEVICE_MOBIL,
           DEVICE_TEL,
           DEVICE_MAIL,
           PACK_DEPT_NAME,
           PACK_DEPT_TEL,
           PACK_DEPT_MAIL,
           PACK_DEPT_CONTACT,
           PACK_DEPT_CHIEF,
           PACK_DEPT_MINISTER,
           CREATION_TIME,
           LAST_MODIFIED_TIME)
        VALUES
          (CUR_ORDER.SUP_FACTORY,
           CUR_ORDER.SUPPLIER_NO,
           CUR_ORDER.SUPPLIER_NAME,
           CUR_ORDER.DETAIL_ADDR,
           CUR_ORDER.SUP_STATUS,
           CUR_ORDER.BLONG_AREA,
           CUR_ORDER.IMPORT_DEP,
           CUR_ORDER.IMPORT_POSITION,
           CUR_ORDER.IMPORT_NAME,
           CUR_ORDER.IMPORT_MOBILE,
           CUR_ORDER.IMPORT_TEL,
           CUR_ORDER.IMPORT_MAIL,
           CUR_ORDER.PT_DEP,
           CUR_ORDER.PT_POSITION,
           CUR_ORDER.PT_NAME,
           CUR_ORDER.PT_MOBIL,
           CUR_ORDER.PT_TEL,
           CUR_ORDER.PT_MAIL,
           CUR_ORDER.MASS_DEP,
           CUR_ORDER.MASS_POSITION,
           CUR_ORDER.MASS_NAME,
           CUR_ORDER.MASS_MOBIL,
           CUR_ORDER.MASS_TEL,
           CUR_ORDER.MASS_MAIL,
           CUR_ORDER.EXCEP_DEP,
           CUR_ORDER.EXCEP_POSITION,
           CUR_ORDER.EXCEP_NAME_A,
           CUR_ORDER.EXCEP_NAME_B,
           CUR_ORDER.EXCEP_MOBIL_A,
           CUR_ORDER.EXCEP_MOBIL_B,
           CUR_ORDER.EXCEP_TEL_A,
           CUR_ORDER.EXCEP_TEL_B,
           CUR_ORDER.DEVICE_DEP,
           CUR_ORDER.DEVICE_POSITION,
           CUR_ORDER.DEVICE_NAME,
           CUR_ORDER.DEVICE_MOBIL,
           CUR_ORDER.DEVICE_TEL,
           CUR_ORDER.DEVICE_MAIL,
           CUR_ORDER.PACK_DEPT_NAME,
           CUR_ORDER.PACK_DEPT_TEL,
           CUR_ORDER.PACK_DEPT_MAIL,
           CUR_ORDER.PACK_DEPT_CONTACT,
           CUR_ORDER.PACK_DEPT_CHIEF,
           CUR_ORDER.PACK_DEPT_MINISTER,
           CUR_ORDER.CREATION_TIME,
           CUR_ORDER.LAST_MODIFIED_TIME);

      ELSIF CUR_ORDER.DO_FLAG = 'U' THEN
        --更新门户平台供应商数据
        UPDATE ilmsportalTEST.MM_PUB_SUPPLIER@MM_IF_IN a
           SET a.SUP_FACTORY        = CUR_ORDER.SUP_FACTORY,
               a.SUPPLIER_NO        = CUR_ORDER.SUPPLIER_NO,
               a.SUPPLIER_NAME      = CUR_ORDER.SUPPLIER_NAME,
               a.DETAIL_ADDR        = CUR_ORDER.DETAIL_ADDR,
               a.SUP_STATUS         = CUR_ORDER.SUP_STATUS,
               a.BLONG_AREA         = CUR_ORDER.BLONG_AREA,
               a.IMPORT_DEP         = CUR_ORDER.IMPORT_DEP,
               a.IMPORT_POSITION    = CUR_ORDER.IMPORT_POSITION,
               a.IMPORT_NAME        = CUR_ORDER.IMPORT_NAME,
               a.IMPORT_MOBILE      = CUR_ORDER.IMPORT_MOBILE,
               a.IMPORT_TEL         = CUR_ORDER.IMPORT_TEL,
               a.IMPORT_MAIL        = CUR_ORDER.IMPORT_MAIL,
               a.PT_DEP             = CUR_ORDER.PT_DEP,
               a.PT_POSITION        = CUR_ORDER.PT_POSITION,
               a.PT_NAME            = CUR_ORDER.PT_NAME,
               a.PT_MOBIL           = CUR_ORDER.PT_MOBIL,
               a.PT_TEL             = CUR_ORDER.PT_TEL,
               a.PT_MAIL            = CUR_ORDER.PT_MAIL,
               a.MASS_DEP           = CUR_ORDER.MASS_DEP,
               a.MASS_POSITION      = CUR_ORDER.MASS_POSITION,
               a.MASS_NAME          = CUR_ORDER.MASS_NAME,
               a.MASS_MOBIL         = CUR_ORDER.MASS_MOBIL,
               a.MASS_TEL           = CUR_ORDER.MASS_TEL,
               a.MASS_MAIL          = CUR_ORDER.MASS_MAIL,
               a.EXCEP_DEP          = CUR_ORDER.EXCEP_DEP,
               a.EXCEP_POSITION     = CUR_ORDER.EXCEP_POSITION,
               a.EXCEP_NAME_A       = CUR_ORDER.EXCEP_NAME_A,
               a.EXCEP_NAME_B       = CUR_ORDER.EXCEP_NAME_B,
               a.EXCEP_MOBIL_A      = CUR_ORDER.EXCEP_MOBIL_A,
               a.EXCEP_MOBIL_B      = CUR_ORDER.EXCEP_MOBIL_B,
               a.EXCEP_TEL_A        = CUR_ORDER.EXCEP_TEL_A,
               a.EXCEP_TEL_B        = CUR_ORDER.EXCEP_TEL_B,
               a.DEVICE_DEP         = CUR_ORDER.DEVICE_DEP,
               a.DEVICE_POSITION    = CUR_ORDER.DEVICE_POSITION,
               a.DEVICE_NAME        = CUR_ORDER.DEVICE_NAME,
               a.DEVICE_MOBIL       = CUR_ORDER.DEVICE_MOBIL,
               a.DEVICE_TEL         = CUR_ORDER.DEVICE_TEL,
               a.DEVICE_MAIL        = CUR_ORDER.DEVICE_MAIL,
               a.PACK_DEPT_NAME     = CUR_ORDER.PACK_DEPT_NAME,
               a.PACK_DEPT_TEL      = CUR_ORDER.PACK_DEPT_TEL,
               a.PACK_DEPT_MAIL     = CUR_ORDER.PACK_DEPT_MAIL,
               a.PACK_DEPT_CONTACT  = CUR_ORDER.PACK_DEPT_CONTACT,
               a.PACK_DEPT_CHIEF    = CUR_ORDER.PACK_DEPT_CHIEF,
               a.PACK_DEPT_MINISTER = CUR_ORDER.PACK_DEPT_MINISTER,
               a.CREATION_TIME      = CUR_ORDER.CREATION_TIME,
               a.LAST_MODIFIED_TIME = CUR_ORDER.LAST_MODIFIED_TIME
         where a.SUP_FACTORY = CUR_ORDER.SUP_FACTORY;
      ELSIF CUR_ORDER.DO_FLAG = 'D' THEN
        --删除门户平台供应商数据
        delete from ilmsportalTEST.MM_PUB_SUPPLIER@MM_IF_IN a
         where a.SUP_FACTORY = CUR_ORDER.SUP_FACTORY;
        --更新deal_flag标记位为1
      END IF;*/

      --写入信息共享平台供应商主数据
      MERGE INTO ilmsportal.MM_PUB_SUPPLIER@MM_IF_IN C
      USING (SELECT 1 FROM DUAL) B
      ON (C.SUP_FACTORY = CUR_ORDER.SUP_FACTORY)
      WHEN MATCHED THEN
        UPDATE
           SET C.SUPPLIER_NAME      = CUR_ORDER.SUPPLIER_NAME,
               C.DETAIL_ADDR        = CUR_ORDER.DETAIL_ADDR,
               C.SUP_STATUS         = CUR_ORDER.SUP_STATUS,
               C.EMAIL              = CUR_ORDER.EMAIL,
               C.CONTACT            = CUR_ORDER.CONTACT,
               C.MOBILE_NO          = CUR_ORDER.MOBILE_NO,
               C.TEL_NO             = CUR_ORDER.TEL_NO,
               C.LAST_MODIFIED_TIME = SYSDATE
      WHEN NOT MATCHED THEN
        INSERT
          (C.SUPPLIER_NO,
           C.SUP_FACTORY,
           C.SUPPLIER_NAME,
           C.DETAIL_ADDR,
           C.SUP_STATUS,
           C.EMAIL,
           C.CONTACT,
           C.MOBILE_NO,
           C.TEL_NO,
           C.CREATION_TIME)
        VALUES
          (CUR_ORDER.SUPPLIER_NO,
           CUR_ORDER.SUP_FACTORY,
           CUR_ORDER.SUPPLIER_NAME,
           CUR_ORDER.DETAIL_ADDR,
           CUR_ORDER.SUP_STATUS,
           CUR_ORDER.EMAIL,
           CUR_ORDER.CONTACT,
           CUR_ORDER.MOBILE_NO,
           CUR_ORDER.TEL_NO,
           SYSDATE);

      update MM_PUB_SUPPLIER t
         set t.DEAL_FLAG = 1, t.deal_time = sysdate
       where t.SUP_FACTORY = CUR_ORDER.SUP_FACTORY;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PUB_SUPPLIER_SEND',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PUB_SUPPLIER;

  --****************************************************************************
  --过程名  : USP_PUB_PART
  --功能描述: 当厂内零件主数数据发生变化时，将信息发布至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_PUB_PART IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER IN (SELECT T.*
                        FROM MM_PUB_PART T
                       WHERE T.DEAL_FLAG = 0
                       ORDER BY T.CREATION_TIME) LOOP

      --存在更新，不存在新增
      --写入信息共享平台
      MERGE INTO ilmsportal.MM_PUB_PART@MM_IF_IN C
      USING (SELECT 1 FROM DUAL) B
      ON (C.PART_NO = CUR_ORDER.PART_NO AND C.FACTORY_CODE = CUR_ORDER.FACTORY_CODE)
      WHEN MATCHED THEN
        UPDATE
           SET C.PART_NAME_CN       = CUR_ORDER.PART_NAME_CN,
               C.PART_NAME_EN       = CUR_ORDER.PART_NAME_EN,
               C.PART_SPEC          = CUR_ORDER.PART_SPEC,
               C.PURCHASE_TYPE      = CUR_ORDER.PURCHASE_TYPE,
               C.PART_UNIT          = CUR_ORDER.PART_UNIT,
               C.LAST_MODIFIED_TIME = SYSDATE
      WHEN NOT MATCHED THEN
        INSERT
          (C.PART_NO,
           C.PART_SHORT_NO,
           C.PART_NAME_CN,
           C.PART_NAME_EN,
           C.PART_SPEC,
           C.PURCHASE_TYPE,
           C.PART_UNIT,
           C.CREATION_TIME,
           C.FACTORY_CODE)
        VALUES
          (CUR_ORDER.PART_NO,
           CUR_ORDER.PART_SHORT_NO,
           CUR_ORDER.PART_NAME_CN,
           CUR_ORDER.PART_NAME_EN,
           CUR_ORDER.PART_SPEC,
           CUR_ORDER.PURCHASE_TYPE,
           CUR_ORDER.PART_UNIT,
           SYSDATE,
           CUR_ORDER.FACTORY_CODE);

      update MM_PUB_PART t
         set t.DEAL_FLAG = 1, t.deal_time = sysdate
       where T.PART_NO = CUR_ORDER.PART_NO
         AND T.FACTORY_CODE = CUR_ORDER.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PUB_PART_SEND',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PUB_PART;

  --****************************************************************************
  --过程名  : USP_PUB_SUPPLIER
  --功能描述: 当厂内零件供应商数据发生变化时，将信息发布至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_PUB_PART_SUPPLIER IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER IN (SELECT T.*
                        FROM MM_PUB_PART_SUPPLIER_HIS T
                       WHERE T.DEAL_FLAG = 0
                       ORDER BY T.CREATION_TIME) LOOP

      --如果供应商不为空，并且供应商代码长度大于0,且零件号不为空，并且零件号长度大于0
      IF CUR_ORDER.SUPPLIER_NO IS NOT NULL AND
         LENGTH(TRIM(CUR_ORDER.SUPPLIER_NO)) > 0 AND
         CUR_ORDER.PART_NO IS NOT NULL AND
         LENGTH(TRIM(CUR_ORDER.PART_NO)) > 0 THEN

        --存在更新，不存在新增
        MERGE INTO ilmsportal.MM_PUB_PART_SUPPLIER_HIS@MM_IF_IN C
        USING (SELECT 1 FROM DUAL) B
        ON (C.PART_NO = CUR_ORDER.PART_NO AND C.SUPPLIER_NO = CUR_ORDER.SUPPLIER_NO AND C.FACTORY_CODE = CUR_ORDER.FACTORY_CODE)
        WHEN MATCHED THEN
          UPDATE
             SET C.EFF_START          = CUR_ORDER.EFF_START,
                 C.SUP_FACTORY        = CUR_ORDER.SUP_FACTORY,
                 C.EFF_END            = CUR_ORDER.EFF_END,
                 C.LAST_MODIFIED_TIME = SYSDATE
        WHEN NOT MATCHED THEN
          INSERT
            (C.FACTORY_CODE,
             C.SUPPLIER_NO,
             C.SUP_FACTORY,
             C.PART_NO,
             C.MIN_ORDER_NUM,
             C.STANDARD_PACKAGE,
             C.IN_PLAN_FORWARD_TIME,
             C.EFF_START,
             C.EFF_END,
             C.CREATION_TIME)
          VALUES
            (CUR_ORDER.FACTORY_CODE,
             CUR_ORDER.SUPPLIER_NO,
             CUR_ORDER.SUP_FACTORY,
             CUR_ORDER.PART_NO,
             CUR_ORDER.MIN_ORDER_NUM,
             CUR_ORDER.STANDARD_PACKAGE,
             CUR_ORDER.IN_PLAN_FORWARD_TIME,
             CUR_ORDER.EFF_START,
             CUR_ORDER.EFF_END,
             SYSDATE);
      END IF;

      --更新状态
      UPDATE MM_PUB_PART_SUPPLIER_HIS T
         SET T.DEAL_FLAG = 1, T.DEAL_TIME = SYSDATE
       WHERE T.PART_NO = CUR_ORDER.PART_NO
         AND T.FACTORY_CODE = CUR_ORDER.FACTORY_CODE
         AND T.SUPPLIER_NO = CUR_ORDER.SUPPLIER_NO;

    END LOOP;

    /*  --删除不存在与本地的零件供应商关系
    DELETE FROM ILMSPMC.MM_PUB_PART_SUPPLIER@MM_IF_IN B
     WHERE NOT EXISTS (SELECT 1
              FROM MM_PUB_PART_SUPPLIER C
             WHERE B.PART_NO = C.PART_NO
               AND B.FACTORY_CODE = C.FACTORY_CODE
               AND B.SUPPLIER_NO = C.SUPPLIER_NO);*/

    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PUB_PART_SUPPLIER_SEND',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PUB_PART_SUPPLIER;

  --****************************************************************************
  --过程名  : USP_SW_ORDER
  --功能描述: 当厂内订单数据发生变化时，将信息发布至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_SW_ORDER IS
    err_num    number(10); --错误代码
    err_msg    varchar2(200); --错误信息
    V_ORDER_NO VARCHAR2(50);
    V_NUM      VARCHAR2(5);
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER IN (SELECT T.*
                        FROM MM_SW_ORDER T
                       WHERE T.DEAL_FLAG = 0
                       ORDER BY T.ORDER_NO) LOOP

      --判断在共享平台是否存在该订单
      SELECT COUNT(1)
        INTO V_NUM
        FROM ilmsportal.MM_SW_ORDER@MM_IF_IN T
       WHERE T.PURCHASE_NO = CUR_ORDER.PURCHASE_NO;

      --如果存在
      IF V_NUM > 0 THEN
        --更新订单表
        UPDATE ilmsportal.MM_SW_ORDER@MM_IF_IN T
           SET T.FACTORY_CODE       = CUR_ORDER.FACTORY_CODE,
               T.SUPPLIER_NO        = CUR_ORDER.SUPPLIER_NO,
               T.ORDER_DATE         = CUR_ORDER.ORDER_DATE,
               T.LAST_MODIFIED_TIME = SYSDATE,
               T.DEPOT_NO           = CUR_ORDER.DEPOT_NO,
               T.SP_TYPE            = CUR_ORDER.SP_TYPE,
               T.RECEIVE_DATE       = CUR_ORDER.RECEIVE_DATE,
               T.RECEIVE_STATUS     = CUR_ORDER.RECEIVE_STATUS,
               T.RECEIVE_COUNT      = CUR_ORDER.RECEIVE_COUNT,
               T.PLAN_PREPARE_TIME  = CUR_ORDER.PLAN_PREPARE_TIME,
               T.SUP_FACTORY        = CUR_ORDER.SUP_FACTORY,
               T.REC_USER           = CUR_ORDER.REC_USER,
               T.REC_TEL            = CUR_ORDER.REC_TEL,
               T.PLANNER            = CUR_ORDER.PLANNER,
               T.ZG_FLAG            = CUR_ORDER.ZG_FLAG
         WHERE T.PURCHASE_NO = CUR_ORDER.PURCHASE_NO;
      ELSE
        --写入订单信息头表
        INSERT INTO ilmsportal.MM_SW_ORDER@MM_IF_IN
          (PURCHASE_NO,
           ORDER_NO,
           ORDER_TYPE,
           FACTORY_CODE,
           SUPPLIER_NO,
           ORDER_DATE,
           CREATION_TIME,
           DEPOT_NO,
           SP_TYPE,
           ARRIVE_DATE,
           RECEIVE_STATUS,
           RECEIVE_COUNT,
           PLAN_PREPARE_TIME,
           REC_USER,
           REC_TEL,
           PLANNER,
           ZG_FLAG,
           SUP_FACTORY)
        VALUES
          (CUR_ORDER.PURCHASE_NO,
           CUR_ORDER.ORDER_NO,
           CUR_ORDER.ORDER_TYPE,
           CUR_ORDER.FACTORY_CODE,
           CUR_ORDER.SUPPLIER_NO,
           CUR_ORDER.ORDER_DATE,
           SYSDATE,
           CUR_ORDER.DEPOT_NO,
           CUR_ORDER.SP_TYPE,
           CUR_ORDER.ARRIVE_DATE,
           CUR_ORDER.RECEIVE_STATUS,
           CUR_ORDER.RECEIVE_COUNT,
           CUR_ORDER.PLAN_PREPARE_TIME,
           CUR_ORDER.REC_USER,
           CUR_ORDER.REC_TEL,
           CUR_ORDER.PLANNER,
           CUR_ORDER.ZG_FLAG,
           CUR_ORDER.SUP_FACTORY);
      END IF;

      --循环该订单的订单明细数据
      FOR CUR_ORDER_DETAIL IN (SELECT *
                                 FROM MM_SW_ORDER_DETAIL A
                                WHERE A.PURCHASE_NO = CUR_ORDER.PURCHASE_NO) LOOP
        --判断在订单明细表是否存在
        SELECT COUNT(1)
          INTO V_NUM
          FROM ilmsportal.MM_SW_ORDER_DETAIL@MM_IF_IN M
         WHERE M.PURCHASE_NO = CUR_ORDER_DETAIL.PURCHASE_NO
           AND M.PURCHASE_ROWNO = CUR_ORDER_DETAIL.PURCHASE_ROWNO;

        --如果存在 更新订单明细数据
        IF V_NUM > 0 THEN
          UPDATE ilmsportal.MM_SW_ORDER_DETAIL@MM_IF_IN D
             SET D.DEPOT_NO           = CUR_ORDER_DETAIL.DEPOT_NO,
                 D.DEPOT_ADDRESS      = CUR_ORDER_DETAIL.DEPOT_ADDRESS,
                 D.ORDER_QTY          = CUR_ORDER_DETAIL.ORDER_QTY,
                 D.CANCEL_NUM         = CUR_ORDER_DETAIL.CANCEL_NUM,
                 D.ORDER_UNIT         = CUR_ORDER_DETAIL.ORDER_UNIT,
                 D.PART_NO            = CUR_ORDER_DETAIL.PART_NO,
                 D.STANDARD_PACKAGE   = CUR_ORDER_DETAIL.STANDARD_PACKAGE,
                 D.COST_CENTER        = CUR_ORDER_DETAIL.COST_CENTER,
                 D.ZK_FLAG            = CUR_ORDER_DETAIL.ZK_FLAG,
                 D.INV_TYPE           = CUR_ORDER_DETAIL.INV_TYPE,
                 D.COST_CODE          = CUR_ORDER_DETAIL.COST_CODE,
                 D.ARRIVE_NUM         = CUR_ORDER_DETAIL.ARRIVE_NUM,
                 D.RECEIVE_STATUS     = CUR_ORDER_DETAIL.RECEIVE_STATUS,
                 D.RECEIVE_DATE       = CUR_ORDER_DETAIL.RECEIVE_DATE,
                 D.RECEIVE_COUNT      = CUR_ORDER_DETAIL.RECEIVE_COUNT,
                 D.LAST_MODIFIED_TIME = SYSDATE,
                 D.USE                = CUR_ORDER_DETAIL.USE,
                 D.DEMAND_DEPARTMENT  = CUR_ORDER_DETAIL.DEMAND_DEPARTMENT,
                 D.DEMANDER           = CUR_ORDER_DETAIL.DEMANDER,
                 D.CON_NUMBER         = CUR_ORDER_DETAIL.CON_NUMBER
           WHERE D.PURCHASE_NO = CUR_ORDER_DETAIL.PURCHASE_NO
             AND D.PURCHASE_ROWNO = CUR_ORDER_DETAIL.PURCHASE_ROWNO;
        ELSE
          --不存在写入门户订单明细表
          INSERT INTO ilmsportal.MM_SW_ORDER_DETAIL@MM_IF_IN
            (ID,
             PURCHASE_NO,
             PURCHASE_ROWNO,
             ORDER_NO,
             ORDER_ROWNO,
             DEPOT_NO,
             DEPOT_ADDRESS,
             ORDER_QTY,
             CANCEL_NUM,
             ORDER_UNIT,
             PART_NO,
             STANDARD_PACKAGE,
             COST_CENTER,
             ZK_FLAG,
             INV_TYPE,
             COST_CODE,
             ARRIVE_NUM,
             RECEIVE_STATUS,
             RECEIVE_DATE,
             RECEIVE_COUNT,
             CREATION_TIME,
             USE,
             DEMAND_DEPARTMENT,
             DEMANDER,
             CON_NUMBER)
          VALUES
            (ilmsportal.SEQ_MM_SW_ORDER_DETAIL.NEXTVAL@MM_IF_IN,
             CUR_ORDER_DETAIL.PURCHASE_NO,
             CUR_ORDER_DETAIL.PURCHASE_ROWNO,
             CUR_ORDER_DETAIL.ORDER_NO,
             CUR_ORDER_DETAIL. ORDER_ROWNO,
             CUR_ORDER_DETAIL. DEPOT_NO,
             CUR_ORDER_DETAIL.DEPOT_ADDRESS,
             CUR_ORDER_DETAIL.ORDER_QTY,
             CUR_ORDER_DETAIL. CANCEL_NUM,
             CUR_ORDER_DETAIL. ORDER_UNIT,
             CUR_ORDER_DETAIL. PART_NO,
             CUR_ORDER_DETAIL. STANDARD_PACKAGE,
             CUR_ORDER_DETAIL. COST_CENTER,
             CUR_ORDER_DETAIL. ZK_FLAG,
             CUR_ORDER_DETAIL. INV_TYPE,
             CUR_ORDER_DETAIL. COST_CODE,
             CUR_ORDER_DETAIL.ARRIVE_NUM,
             CUR_ORDER_DETAIL.RECEIVE_STATUS,
             CUR_ORDER_DETAIL.RECEIVE_DATE,
             CUR_ORDER_DETAIL.RECEIVE_COUNT,
             SYSDATE,
             CUR_ORDER_DETAIL.USE,
             CUR_ORDER_DETAIL.DEMAND_DEPARTMENT,
             CUR_ORDER_DETAIL.DEMANDER,
             CUR_ORDER_DETAIL.CON_NUMBER);
        END IF;

        --删除订单数量为0的零件明细
        DELETE FROM ilmsportal.MM_SW_ORDER_DETAIL@mm_if_in A
         WHERE A.ORDER_QTY = 0
           AND A.PURCHASE_NO = CUR_ORDER_DETAIL.PURCHASE_NO
           AND A.PURCHASE_ROWNO = CUR_ORDER_DETAIL.PURCHASE_ROWNO;
      END LOOP;

      --删除门户端没有订单明细的订单数据
      DELETE FROM ilmsportal.MM_SW_ORDER@mm_if_in A
       WHERE NOT EXISTS (SELECT 1
                FROM ilmsportal.MM_SW_ORDER_DETAIL@mm_if_in B
               WHERE A.PURCHASE_NO = B.PURCHASE_NO);

      --更新订单表的处理状态
      UPDATE MM_SW_ORDER A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.PURCHASE_NO = CUR_ORDER.PURCHASE_NO;

    END LOOP;

    COMMIT;

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_SW_ORDER_SEND',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_SW_ORDER;

  --****************************************************************************
  --过程名  : USP_SW_PICK_PLAN
  --功能描述: 将预测数据信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_SW_DEMAND_FORECAST IS
    err_num         number(10); --错误代码
    err_msg         varchar2(200); --错误信息
    V_VERSION_EXIST NUMBER(10); --判断版本是否存在
  BEGIN

    /*   FOR VERSION_FORECASE IN (
      SELECT COUNT(1) NUM, A.VERSION, A.FORE_TYPE
        from MM_SW_DEMAND_FORECAST A
        WHERE A.DEAL_FLAG = 0
        GROUP BY A.VERSION,A.FORE_TYPE
        ORDER BY A.VERSION) LOOP

    IF VERSION_FORECASE.NUM > 0 THEN
      SELECT COUNT(1) INTO V_VERSION_EXIST FROM ilmsportal.MM_SW_DEMAND_FORECAST@mm_if_in A WHERE A.VERSION = VERSION_FORECASE.VERSION; --判断下发下来的版本是否已存在
      IF V_VERSION_EXIST > 0 THEN
          UPDATE MM_SW_DEMAND_FORECAST A SET A.DEAL_FLAG = 1 WHERE A.DEAL_FLAG = 0
          AND A.VERSION = VERSION_FORECASE.VERSION; --如果存在则直接将该版本修改为已处理
        ELSE
          DELETE ilmsportal.MM_SW_DEMAND_FORECAST@mm_if_in A WHERE A.FORE_TYPE = VERSION_FORECASE.FORE_TYPE; --如果不存在则删除上一个版本的数据，区分周预测和月预测
       END IF;
    END IF ;
    END LOOP;*/
    --查询未处理订单
    FOR CUR_ORDER_NO IN (SELECT T.*
                           FROM MM_SW_DEMAND_FORECAST T
                          WHERE T.DEAL_FLAG = 0
                          ORDER BY T.CREATION_TIME) LOOP

      IF CUR_ORDER_NO.DO_FLAG = 'I' THEN
        insert into ilmsportal.MM_SW_DEMAND_FORECAST@mm_if_in
          (ID,
           FACTORY_CODE,
           FORE_TYPE,
           VERSION,
           PLAN_DELIVERY,
           START_DATE,
           END_DATE,
           PHASE,
           UNLOAD_PORT,
           PART_NO,
           PART_UNIT,
           ORDER_QTY,
           SUPPLIER_NO,
           SUPPLIER_NAME,
           SUP_FACTORY_ADDR,
           SUP_FACTORY,
           MODEL_CODE,
           LOGISTICS_MODE,
           DOWNLOAD_STATUS,
           DOWNLOAD_TIME,
           CREATION_USER,
           CREATION_TIME,
           LAST_MODIFIED_USER,
           LAST_MODIFIED_TIME,
           RELEASE_STATUS,
           FEEDBACK_STATUS,
           FEEDBACK_REMARK,
           PUBLISH_MONTH,
           OBJ_MONTH,
           PUBLISH_WEEK,
           OBJ_WEEK,
           ADVANCE_TIME,
           P_SUPPLIER)
        values
          (ilmsportal.SEQ_MM_SW_DEMAND_FORE.nextval@mm_if_in,
           CUR_ORDER_NO.FACTORY_CODE,
           CUR_ORDER_NO.FORE_TYPE,
           CUR_ORDER_NO.VERSION,
           CUR_ORDER_NO.PLAN_DELIVERY,
           CUR_ORDER_NO.START_DATE,
           CUR_ORDER_NO.END_DATE,
           CUR_ORDER_NO.PHASE,
           CUR_ORDER_NO.UNLOAD_PORT,
           CUR_ORDER_NO.PART_NO,
           CUR_ORDER_NO.PART_UNIT,
           CUR_ORDER_NO.ORDER_QTY,
           CUR_ORDER_NO.SUPPLIER_NO,
           CUR_ORDER_NO.SUPPLIER_NAME,
           CUR_ORDER_NO.SUP_FACTORY_ADDR,
           CUR_ORDER_NO.SUP_FACTORY,
           CUR_ORDER_NO.MODEL_CODE,
           CUR_ORDER_NO.LOGISTICS_MODE,
           CUR_ORDER_NO.DOWNLOAD_STATUS,
           CUR_ORDER_NO.DOWNLOAD_TIME,
           CUR_ORDER_NO.CREATION_USER,
           CUR_ORDER_NO.CREATION_TIME,
           CUR_ORDER_NO.LAST_MODIFIED_USER,
           CUR_ORDER_NO.LAST_MODIFIED_TIME,
           CUR_ORDER_NO.RELEASE_STATUS,
           CUR_ORDER_NO.FEEDBACK_STATUS,
           CUR_ORDER_NO.FEEDBACK_REMARK,
           CUR_ORDER_NO.PUBLISH_MONTH,
           CUR_ORDER_NO.OBJ_MONTH,
           CUR_ORDER_NO.PUBLISH_WEEK,
           CUR_ORDER_NO.OBJ_WEEK,
           CUR_ORDER_NO.ADVANCE_TIME,
           CUR_ORDER_NO.P_SUPPLIER);

      ELSIF CUR_ORDER_NO.DO_FLAG = 'U' THEN
        update ilmsportal.MM_SW_DEMAND_FORECAST@mm_if_in a
           set FACTORY_CODE       = CUR_ORDER_NO.FACTORY_CODE,
               FORE_TYPE          = CUR_ORDER_NO.FORE_TYPE,
               VERSION            = CUR_ORDER_NO.VERSION,
               PLAN_DELIVERY      = CUR_ORDER_NO.PLAN_DELIVERY,
               START_DATE         = CUR_ORDER_NO.START_DATE,
               END_DATE           = CUR_ORDER_NO.END_DATE,
               PHASE              = CUR_ORDER_NO.PHASE,
               UNLOAD_PORT        = CUR_ORDER_NO.UNLOAD_PORT,
               PART_NO            = CUR_ORDER_NO.PART_NO,
               PART_UNIT          = CUR_ORDER_NO.PART_UNIT,
               ORDER_QTY          = CUR_ORDER_NO.ORDER_QTY,
               SUPPLIER_NO        = CUR_ORDER_NO.SUPPLIER_NO,
               SUPPLIER_NAME      = CUR_ORDER_NO.SUPPLIER_NAME,
               SUP_FACTORY_ADDR   = CUR_ORDER_NO.SUP_FACTORY_ADDR,
               SUP_FACTORY        = CUR_ORDER_NO.SUP_FACTORY,
               MODEL_CODE         = CUR_ORDER_NO.MODEL_CODE,
               LOGISTICS_MODE     = CUR_ORDER_NO.LOGISTICS_MODE,
               DOWNLOAD_STATUS    = CUR_ORDER_NO.DOWNLOAD_STATUS,
               DOWNLOAD_TIME      = CUR_ORDER_NO.DOWNLOAD_TIME,
               CREATION_USER      = CUR_ORDER_NO.CREATION_USER,
               CREATION_TIME      = sysdate,
               LAST_MODIFIED_USER = CUR_ORDER_NO.LAST_MODIFIED_USER,
               LAST_MODIFIED_TIME = CUR_ORDER_NO.LAST_MODIFIED_TIME,
               RELEASE_STATUS     = CUR_ORDER_NO.RELEASE_STATUS,
               FEEDBACK_STATUS    = CUR_ORDER_NO.FEEDBACK_STATUS,
               FEEDBACK_REMARK    = CUR_ORDER_NO.FEEDBACK_REMARK,
               PUBLISH_MONTH      = CUR_ORDER_NO.PUBLISH_MONTH,
               OBJ_MONTH          = CUR_ORDER_NO.OBJ_MONTH,
               PUBLISH_WEEK       = CUR_ORDER_NO.PUBLISH_WEEK,
               OBJ_WEEK           = CUR_ORDER_NO.OBJ_WEEK,
               ADVANCE_TIME       = CUR_ORDER_NO.ADVANCE_TIME,
               P_SUPPLIER         = CUR_ORDER_NO.P_SUPPLIER
         where a.FORE_TYPE = CUR_ORDER_NO.FORE_TYPE
           and a.VERSION = CUR_ORDER_NO.VERSION
           and a.PHASE = CUR_ORDER_NO.PHASE
           and a.PART_NO = CUR_ORDER_NO.PART_NO
           and a.SUPPLIER_NO = CUR_ORDER_NO.SUPPLIER_NO
           and a.MODEL_CODE = CUR_ORDER_NO.MODEL_CODE
           and a.PLAN_DELIVERY = CUR_ORDER_NO.PLAN_DELIVERY;

      ELSIF CUR_ORDER_NO.DO_FLAG = 'D' THEN
        delete from ilmsportal.MM_SW_DEMAND_FORECAST@mm_if_in a
         where a.FORE_TYPE = CUR_ORDER_NO.FORE_TYPE
           and a.VERSION = CUR_ORDER_NO.VERSION
           and a.PHASE = CUR_ORDER_NO.PHASE
           and a.PART_NO = CUR_ORDER_NO.PART_NO
           and a.SUPPLIER_NO = CUR_ORDER_NO.SUPPLIER_NO
           and a.MODEL_CODE = CUR_ORDER_NO.MODEL_CODE
           and a.PLAN_DELIVERY = CUR_ORDER_NO.PLAN_DELIVERY;

      END IF;
      --更新中间表处理标记位为已处理
      update MM_SW_DEMAND_FORECAST a
         set a.deal_flag = 1, a.deal_time = sysdate
       where a.id = CUR_ORDER_NO.Id
         and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_SW_DEMAND_FORECAST',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_SW_DEMAND_FORECAST;

  --****************************************************************************
  --过程名  : USP_SW_ACCOUNT_BILL
  --功能描述: 将发票对账信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_SW_ACCOUNT_BILL IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER_NO IN (SELECT T.*
                           FROM MM_SW_ACCOUNT_BILL T
                          WHERE T.DEAL_FLAG2 = 0
                          ORDER BY T.CREATION_TIME) LOOP

      IF CUR_ORDER_NO.DO_FLAG = 'I' THEN
        insert into ilmsportal.MM_SW_ACCOUNT_BILL@mm_if_in
          (BILL_NO,
           FACTORY_CODE,
           SUPPLIER_NO,
           TAX_EXCLUDED,
           TAX_INCLUSIVE,
           TOTAL_TAX,
           MAKE_DATE,
           CURRENCY_TYPE,
           REBATE,
           REBATE_DESC,
           DEDUCT_MONEY,
           DEDUCT_MONEY_DESC,
           YEAR_ADJUST,
           YEAR_ADJUST_DESC,
           MOULD_AMOUNT,
           MOULD_AMOUNT_DESC,
           PAY_TERM,
           INVOICE_STATUS,
           INVOICE_ENTRY_TIME,
           DEAL_FLAG,
           DEAL_TIME,
           REMARK,
           ACCOUNT_STATUS,
           CREATION_USER,
           CREATION_TIME,
           SUBMIT_STATUS)

        VALUES
          (CUR_ORDER_NO.BILL_NO,
           CUR_ORDER_NO.FACTORY_CODE,
           CUR_ORDER_NO.SUPPLIER_NO,
           CUR_ORDER_NO.TAX_EXCLUDED,
           CUR_ORDER_NO.TAX_INCLUSIVE,
           CUR_ORDER_NO.TOTAL_TAX,
           CUR_ORDER_NO.MAKE_DATE,
           CUR_ORDER_NO.CURRENCY_TYPE,
           CUR_ORDER_NO.REBATE,
           CUR_ORDER_NO.REBATE_DESC,
           CUR_ORDER_NO.DEDUCT_MONEY,
           CUR_ORDER_NO.DEDUCT_MONEY_DESC,
           CUR_ORDER_NO.YEAR_ADJUST,
           CUR_ORDER_NO.YEAR_ADJUST_DESC,
           CUR_ORDER_NO.MOULD_AMOUNT,
           CUR_ORDER_NO.MOULD_AMOUNT_DESC,
           CUR_ORDER_NO.PAY_TERM,
           CUR_ORDER_NO.INVOICE_STATUS,
           CUR_ORDER_NO.INVOICE_ENTRY_TIME,
           CUR_ORDER_NO.DEAL_FLAG,
           CUR_ORDER_NO.DEAL_TIME,
           CUR_ORDER_NO.REMARK,
           CUR_ORDER_NO.ACCOUNT_STATUS,
           CUR_ORDER_NO.CREATION_USER,
           SYSDATE,
           CUR_ORDER_NO.SUBMIT_STATUS);

      ELSIF CUR_ORDER_NO.DO_FLAG = 'U' THEN
        update ilmsportal.MM_SW_ACCOUNT_BILL@mm_if_in a
           set BILL_NO            = CUR_ORDER_NO.BILL_NO,
               FACTORY_CODE       = CUR_ORDER_NO.FACTORY_CODE,
               SUPPLIER_NO        = CUR_ORDER_NO.SUPPLIER_NO,
               TAX_EXCLUDED       = CUR_ORDER_NO.TAX_EXCLUDED,
               TAX_INCLUSIVE      = CUR_ORDER_NO.TAX_INCLUSIVE,
               TOTAL_TAX          = CUR_ORDER_NO.TOTAL_TAX,
               MAKE_DATE          = CUR_ORDER_NO.MAKE_DATE,
               CURRENCY_TYPE      = CUR_ORDER_NO.CURRENCY_TYPE,
               REBATE             = CUR_ORDER_NO.REBATE,
               REBATE_DESC        = CUR_ORDER_NO.REBATE_DESC,
               DEDUCT_MONEY       = CUR_ORDER_NO.DEDUCT_MONEY,
               DEDUCT_MONEY_DESC  = CUR_ORDER_NO.DEDUCT_MONEY_DESC,
               YEAR_ADJUST        = CUR_ORDER_NO.YEAR_ADJUST,
               YEAR_ADJUST_DESC   = CUR_ORDER_NO.YEAR_ADJUST_DESC,
               MOULD_AMOUNT       = CUR_ORDER_NO.MOULD_AMOUNT,
               MOULD_AMOUNT_DESC  = CUR_ORDER_NO.MOULD_AMOUNT_DESC,
               PAY_TERM           = CUR_ORDER_NO.PAY_TERM,
               INVOICE_STATUS     = CUR_ORDER_NO.INVOICE_STATUS,
               INVOICE_ENTRY_TIME = CUR_ORDER_NO.INVOICE_ENTRY_TIME,
               DEAL_FLAG          = CUR_ORDER_NO.DEAL_FLAG,
               DEAL_TIME          = CUR_ORDER_NO.DEAL_TIME,
               REMARK             = CUR_ORDER_NO.REMARK,
               LAST_MODIFIED_USER = CUR_ORDER_NO.LAST_MODIFIED_USER,
               LAST_MODIFIED_TIME = SYSDATE,
               SUBMIT_STATUS      = CUR_ORDER_NO.SUBMIT_STATUS,
               ACCOUNT_STATUS     = CUR_ORDER_NO.ACCOUNT_STATUS

         where a.BILL_NO = CUR_ORDER_NO.BILL_NO
           and a.FACTORY_CODE = CUR_ORDER_NO.FACTORY_CODE;

      ELSIF CUR_ORDER_NO.DO_FLAG = 'D' THEN
        delete from ilmsportal.MM_SW_ACCOUNT_BILL@mm_if_in a
         where a.BILL_NO = CUR_ORDER_NO.BILL_NO
           and a.FACTORY_CODE = CUR_ORDER_NO.FACTORY_CODE;

      END IF;
      --更新中间表处理标记位为已处理
      update MM_SW_ACCOUNT_BILL a
         set a.deal_flag2 = 1, a.deal_time = sysdate
       where a.bill_no = CUR_ORDER_NO.bill_no
         and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_SW_ACCOUNT_BILL',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_SW_ACCOUNT_BILL;

  --****************************************************************************
  --过程名  : USP_SW_ACCOUNT_BILL_DETAIL
  --功能描述: 将发票对账信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_SW_ACCOUNT_BILL_DETAIL IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER_NO IN (SELECT T.*
                           FROM MM_SW_ACCOUNT_BILL_DETAIL T
                          WHERE T.DEAL_FLAG = 0
                          ORDER BY T.BILL_NO) LOOP

      IF CUR_ORDER_NO.DO_FLAG = 'I' THEN
        insert into ilmsportal.MM_SW_ACCOUNT_BILL_DETAIL@mm_if_in
          (BILL_NO,
           BILL_ROW_NO,
           PURCHASE_NO,
           PURCHASE_ROW_NO,
           REC_VOUCHER_YEAR,
           REC_VOUCHER_BILLNO,
           REC_VOUCHER_ROWNO,
           REF_REC_VOUCHER_BILL,
           REF_REC_VOUCHER_ROWNO,
           REC_DATE,
           LOAN_FLAG,
           PRICE_STATUS,
           EVA_PRICE,
           OFFICIAL_PRICE,
           ADJUST_DIFF_PRICE,
           EVA_PRICE_PERCENT,
           EVA_SETTLE_PRICE,
           ERP_FACTORY_CODE,
           PART_NO,
           SUPPLIER_NO,
           REC_NUM,
           PAY_AMOUNT,
           TAX_RATE,
           TAX_AMOUNT,
           CURRENCY_TYPE,
           PART_UNIT)
        VALUES
          (CUR_ORDER_NO.BILL_NO,
           CUR_ORDER_NO.BILL_ROW_NO,
           CUR_ORDER_NO.PURCHASE_NO,
           CUR_ORDER_NO.PURCHASE_ROW_NO,
           CUR_ORDER_NO.REC_VOUCHER_YEAR,
           CUR_ORDER_NO.REC_VOUCHER_BILLNO,
           CUR_ORDER_NO.REC_VOUCHER_ROWNO,
           CUR_ORDER_NO.REF_REC_VOUCHER_BILL,
           CUR_ORDER_NO.REF_REC_VOUCHER_ROWNO,
           CUR_ORDER_NO.REC_DATE,
           CUR_ORDER_NO.LOAN_FLAG,
           CUR_ORDER_NO.PRICE_STATUS,
           CUR_ORDER_NO.EVA_PRICE,
           CUR_ORDER_NO.OFFICIAL_PRICE,
           CUR_ORDER_NO.ADJUST_DIFF_PRICE,
           CUR_ORDER_NO.EVA_PRICE_PERCENT,
           CUR_ORDER_NO.EVA_SETTLE_PRICE,
           CUR_ORDER_NO.ERP_FACTORY_CODE,
           CUR_ORDER_NO.PART_NO,
           CUR_ORDER_NO.SUPPLIER_NO,
           CUR_ORDER_NO.REC_NUM,
           CUR_ORDER_NO.PAY_AMOUNT,
           CUR_ORDER_NO.TAX_RATE,
           CUR_ORDER_NO.TAX_AMOUNT,
           CUR_ORDER_NO.CURRENCY_TYPE,
           CUR_ORDER_NO.PART_UNIT);

      ELSIF CUR_ORDER_NO.DO_FLAG = 'U' THEN
        update ilmsportal.MM_SW_ACCOUNT_BILL_DETAIL@mm_if_in a
           set BILL_NO               = CUR_ORDER_NO.BILL_NO,
               BILL_ROW_NO           = CUR_ORDER_NO.BILL_ROW_NO,
               PURCHASE_NO           = CUR_ORDER_NO.PURCHASE_NO,
               PURCHASE_ROW_NO       = CUR_ORDER_NO.PURCHASE_ROW_NO,
               REC_VOUCHER_YEAR      = CUR_ORDER_NO.REC_VOUCHER_YEAR,
               REC_VOUCHER_BILLNO    = CUR_ORDER_NO.REC_VOUCHER_BILLNO,
               REC_VOUCHER_ROWNO     = CUR_ORDER_NO.REC_VOUCHER_ROWNO,
               REF_REC_VOUCHER_BILL  = CUR_ORDER_NO.REF_REC_VOUCHER_BILL,
               REF_REC_VOUCHER_ROWNO = CUR_ORDER_NO.REF_REC_VOUCHER_ROWNO,
               REC_DATE              = CUR_ORDER_NO.REC_DATE,
               LOAN_FLAG             = CUR_ORDER_NO.LOAN_FLAG,
               PRICE_STATUS          = CUR_ORDER_NO.PRICE_STATUS,
               EVA_PRICE             = CUR_ORDER_NO.EVA_PRICE,
               OFFICIAL_PRICE        = CUR_ORDER_NO.OFFICIAL_PRICE,
               ADJUST_DIFF_PRICE     = CUR_ORDER_NO.ADJUST_DIFF_PRICE,
               EVA_PRICE_PERCENT     = CUR_ORDER_NO.EVA_PRICE_PERCENT,
               EVA_SETTLE_PRICE      = CUR_ORDER_NO.EVA_SETTLE_PRICE,
               ERP_FACTORY_CODE      = CUR_ORDER_NO.ERP_FACTORY_CODE,
               PART_NO               = CUR_ORDER_NO.PART_NO,
               SUPPLIER_NO           = CUR_ORDER_NO.SUPPLIER_NO,
               REC_NUM               = CUR_ORDER_NO.REC_NUM,
               PAY_AMOUNT            = CUR_ORDER_NO.PAY_AMOUNT,
               TAX_RATE              = CUR_ORDER_NO.TAX_RATE,
               TAX_AMOUNT            = CUR_ORDER_NO.TAX_AMOUNT,
               CURRENCY_TYPE         = CUR_ORDER_NO.CURRENCY_TYPE,
               PART_UNIT             = CUR_ORDER_NO.PART_UNIT

         where a.BILL_NO = CUR_ORDER_NO.BILL_NO
           and NVL(a.ERP_FACTORY_CODE, '#') =
               NVL(CUR_ORDER_NO.ERP_FACTORY_CODE, '#')
           and a.BILL_ROW_NO = CUR_ORDER_NO.BILL_ROW_NO;

      ELSIF CUR_ORDER_NO.DO_FLAG = 'D' THEN
        delete from ilmsportal.MM_SW_ACCOUNT_BILL_DETAIL@mm_if_in a
         where a.BILL_NO = CUR_ORDER_NO.BILL_NO
           and NVL(a.ERP_FACTORY_CODE, '#') =
               NVL(CUR_ORDER_NO.ERP_FACTORY_CODE, '#')
           and a.BILL_ROW_NO = CUR_ORDER_NO.BILL_ROW_NO;

      END IF;
      --更新中间表处理标记位为已处理
      update MM_SW_ACCOUNT_BILL_DETAIL a
         set a.deal_flag = 1, a.deal_time = sysdate
       where a.bill_no = CUR_ORDER_NO.bill_no
         and a.bill_row_no = CUR_ORDER_NO.BILL_ROW_NO;
      --and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_SW_ACCOUNT_BILL_DETAIL',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_SW_ACCOUNT_BILL_DETAIL;

  --****************************************************************************
  --过程名  : USP_SW_LONG_ORDER
  --功能描述: 将长周期信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_SW_LONG_ORDER IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER_NO IN (SELECT T.*
                           FROM MM_SW_LONG_ORDER T

                          WHERE T.DEAL_FLAG = 0
                          ORDER BY T.CREATION_TIME) LOOP

      IF CUR_ORDER_NO.DO_FLAG = 'I' THEN
        insert into ilmsportal.MM_SW_LONG_ORDER@mm_if_in
          (ID,
           VERSION,
           ORDER_NO,
           CURRENT_MONTH,
           OBJ_MONTH,
           ORDER_PERIOD,
           FORECAST_PERIOD,
           FORECAST_FIRST,
           FORECAST_FIRST_NUM,
           FORECAST_SECOND,
           FORECAST_SECOND_NUM,
           FORECAST_THIRD,
           FORECAST_THIRD_NUM,
           CREATION_TIME,
           PRINT_STATUS)
        VALUES
          (ilmsportal.SEQ_MM_SW_LONG_ORDER.NEXTVAL@mm_if_in,
           CUR_ORDER_NO.VERSION,
           CUR_ORDER_NO.ORDER_NO,
           CUR_ORDER_NO.CURRENT_MONTH,
           CUR_ORDER_NO.OBJ_MONTH,
           CUR_ORDER_NO.ORDER_PERIOD,
           CUR_ORDER_NO.FORECAST_PERIOD,
           CUR_ORDER_NO.FORECAST_FIRST,
           CUR_ORDER_NO.FORECAST_FIRST_NUM,
           CUR_ORDER_NO.FORECAST_SECOND,
           CUR_ORDER_NO.FORECAST_SECOND_NUM,
           CUR_ORDER_NO.FORECAST_THIRD,
           CUR_ORDER_NO.FORECAST_THIRD_NUM,
           SYSDATE,
           '0');

      ELSIF CUR_ORDER_NO.DO_FLAG = 'U' THEN
        update ilmsportal.MM_SW_LONG_ORDER@mm_if_in a
           set VERSION             = CUR_ORDER_NO.VERSION,
               ORDER_NO            = CUR_ORDER_NO.ORDER_NO,
               CURRENT_MONTH       = CUR_ORDER_NO.CURRENT_MONTH,
               OBJ_MONTH           = CUR_ORDER_NO.OBJ_MONTH,
               ORDER_PERIOD        = CUR_ORDER_NO.ORDER_PERIOD,
               FORECAST_PERIOD     = CUR_ORDER_NO.FORECAST_PERIOD,
               FORECAST_FIRST      = CUR_ORDER_NO.FORECAST_FIRST,
               FORECAST_FIRST_NUM  = CUR_ORDER_NO.FORECAST_FIRST_NUM,
               FORECAST_SECOND     = CUR_ORDER_NO.FORECAST_SECOND,
               FORECAST_SECOND_NUM = CUR_ORDER_NO.FORECAST_SECOND_NUM,
               FORECAST_THIRD      = CUR_ORDER_NO.FORECAST_THIRD,
               FORECAST_THIRD_NUM  = CUR_ORDER_NO.FORECAST_THIRD_NUM,
               LAST_MODIFIED_TIME  = SYSDATE

         where a.VERSION = CUR_ORDER_NO.VERSION
           and a.ORDER_NO = CUR_ORDER_NO.ORDER_NO;

      ELSIF CUR_ORDER_NO.DO_FLAG = 'D' THEN
        delete from ilmsportal.MM_SW_LONG_ORDER@mm_if_in a
         where a.VERSION = CUR_ORDER_NO.VERSION
           and a.ORDER_NO = CUR_ORDER_NO.ORDER_NO;

      END IF;
      --更新中间表处理标记位为已处理
      update MM_SW_LONG_ORDER a
         set a.deal_flag = 1, a.deal_time = sysdate
       where a.VERSION = CUR_ORDER_NO.VERSION
         and a.ORDER_NO = CUR_ORDER_NO.ORDER_NO;
      --and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_SW_LONG_ORDER',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_SW_LONG_ORDER;

  --****************************************************************************
  --过程名  : USP_SW_ACCOUNT_BILL_DETAIL
  --功能描述: 将长周期明细信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_SW_LONG_ORDER_DETAIL IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER_NO IN (SELECT T.*
                           FROM MM_SW_LONG_ORDER_DETAIL T

                          WHERE T.DEAL_FLAG = 0
                          ORDER BY T.ORDER_NO) LOOP

      IF CUR_ORDER_NO.DO_FLAG = 'I' THEN
        insert into ilmsportal.MM_SW_LONG_ORDER_DETAIL@mm_if_in
          (VERSION,
           ORDER_NO,
           PART_NO,
           CAR_TYPE,
           SUPPLIER_NO,
           SUP_FACTORY,
           REQUIRE_NUM,
           ORDER_REQUIRE_NUM,
           PART_UNIT,
           ORDER_NUM,
           ORDER_BOX,
           TOTAL_DELIV_QTY,
           FORECAST_FIRST_NUM,
           FORECAST_SECOND_NUM,
           FORECAST_THIRD_NUM,
           FEEDBACK_STATUS)
        VALUES
          (CUR_ORDER_NO.VERSION,
           CUR_ORDER_NO.ORDER_NO,
           CUR_ORDER_NO.PART_NO,
           CUR_ORDER_NO.CAR_TYPE,
           CUR_ORDER_NO.SUPPLIER_NO,
           CUR_ORDER_NO.SUP_FACTORY,
           CUR_ORDER_NO.REQUIRE_NUM,
           CUR_ORDER_NO.ORDER_REQUIRE_NUM,
           CUR_ORDER_NO.PART_UNIT,
           CUR_ORDER_NO.ORDER_NUM,
           CUR_ORDER_NO.ORDER_BOX,
           CUR_ORDER_NO.TOTAL_DELIV_QTY,
           CUR_ORDER_NO.FORECAST_FIRST_NUM,
           CUR_ORDER_NO.FORECAST_SECOND_NUM,
           CUR_ORDER_NO.FORECAST_THIRD_NUM,
           '0');

      ELSIF CUR_ORDER_NO.DO_FLAG = 'U' THEN
        update ilmsportal.MM_SW_LONG_ORDER_DETAIL@mm_if_in a
           set VERSION             = CUR_ORDER_NO.VERSION,
               ORDER_NO            = CUR_ORDER_NO.ORDER_NO,
               PART_NO             = CUR_ORDER_NO.PART_NO,
               CAR_TYPE            = CUR_ORDER_NO.CAR_TYPE,
               SUPPLIER_NO         = CUR_ORDER_NO.SUPPLIER_NO,
               SUP_FACTORY         = CUR_ORDER_NO.SUP_FACTORY,
               REQUIRE_NUM         = CUR_ORDER_NO.REQUIRE_NUM,
               ORDER_REQUIRE_NUM   = CUR_ORDER_NO.ORDER_REQUIRE_NUM,
               PART_UNIT           = CUR_ORDER_NO.PART_UNIT,
               ORDER_NUM           = CUR_ORDER_NO.ORDER_NUM,
               ORDER_BOX           = CUR_ORDER_NO.ORDER_BOX,
               TOTAL_DELIV_QTY     = CUR_ORDER_NO.TOTAL_DELIV_QTY,
               FORECAST_FIRST_NUM  = CUR_ORDER_NO.FORECAST_FIRST_NUM,
               FORECAST_SECOND_NUM = CUR_ORDER_NO.FORECAST_SECOND_NUM,
               FORECAST_THIRD_NUM  = CUR_ORDER_NO.FORECAST_THIRD_NUM,
               FEEDBACK_STATUS     = '0'

         where a.VERSION = CUR_ORDER_NO.VERSION
           and a.ORDER_NO = CUR_ORDER_NO.ORDER_NO
           AND A.PART_NO = CUR_ORDER_NO.PART_NO;

      ELSIF CUR_ORDER_NO.DO_FLAG = 'D' THEN
        delete from ilmsportal.MM_SW_LONG_ORDER_DETAIL@mm_if_in a
         where a.VERSION = CUR_ORDER_NO.VERSION
           and a.ORDER_NO = CUR_ORDER_NO.ORDER_NO
           AND A.PART_NO = CUR_ORDER_NO.PART_NO;

      END IF;
      --更新中间表处理标记位为已处理
      update MM_SW_LONG_ORDER_DETAIL a
         set a.deal_flag = 1, a.deal_time = sysdate
       where a.VERSION = CUR_ORDER_NO.VERSION
         and a.ORDER_NO = CUR_ORDER_NO.ORDER_NO
         AND A.PART_NO = CUR_ORDER_NO.PART_NO;
      --and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_SW_LONG_ORDER_DETAIL',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_SW_LONG_ORDER_DETAIL;

  --****************************************************************************
  --过程名  : USP_PUB_PART_UDA
  --功能描述: 将订购零件基础信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_PUB_PART_UDA IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_PART IN (SELECT T.*
                       FROM IF_MM_PUB_PART_UDA T
                      WHERE T.DEAL_FLAG = 0
                        AND ROWNUM <= 500
                      ORDER BY T.ID, T.CREATION_TIME) LOOP
      IF CUR_PART.DO_FLAG = 'D' THEN
        DELETE FROM ilmsportal.MM_PUB_PART_UDA@MM_IF_IN A
         WHERE A.FACTORY_CODE = CUR_PART.FACTORY_CODE
           AND A.PART_NO = CUR_PART.PART_NO;
      ELSE
        MERGE INTO ilmsportal.MM_PUB_PART_UDA@MM_IF_IN B
        USING (SELECT 1 FROM DUAL)
        ON (B.PART_NO = CUR_PART.PART_NO AND B.FACTORY_CODE = CUR_PART.FACTORY_CODE)
        WHEN MATCHED THEN
          UPDATE
             SET B.SUPPLIER_NO        = CUR_PART.SUPPLIER_NO,
                 B.SUP_FACTORY        = CUR_PART.SUP_FACTORY,
                 B.PART_SHORT_NO      = CUR_PART.PART_SHORT_NO,
                 B.PART_NAME_CN       = CUR_PART.PART_NAME_CN,
                 B.SUPPLIER_NAME      = CUR_PART.SUPPLIER_NAME,
                 B.STANDARD_PACKAGE   = CUR_PART.STANDARD_PACKAGE,
                 B.CREATION_USER      = CUR_PART.CREATION_USER,
                 B.CREATION_TIME      = CUR_PART.CREATION_TIME,
                 B.LAST_MODIFIED_USER = CUR_PART.LAST_MODIFIED_USER,
                 B.LAST_MODIFIED_TIME = CUR_PART.LAST_MODIFIED_TIME
        WHEN NOT MATCHED THEN
          INSERT
            (B.ID,
             B.FACTORY_CODE,
             B.PART_NO,
             B.SUPPLIER_NO,
             B.SUP_FACTORY,
             B.PART_SHORT_NO,
             B.PART_NAME_CN,
             B.SUPPLIER_NAME,
             B.STANDARD_PACKAGE,
             B.CREATION_USER,
             B.CREATION_TIME,
             B.LAST_MODIFIED_USER,
             B.LAST_MODIFIED_TIME)
          VALUES
            (ilmsportal.SEQ_MM_PUB_PART_UDA.NEXTVAL@MM_IF_IN,
             CUR_PART.FACTORY_CODE,
             CUR_PART.PART_NO,
             CUR_PART.SUPPLIER_NO,
             CUR_PART.SUP_FACTORY,
             CUR_PART.PART_SHORT_NO,
             CUR_PART.PART_NAME_CN,
             CUR_PART.SUPPLIER_NAME,
             CUR_PART.STANDARD_PACKAGE,
             CUR_PART.CREATION_USER,
             CUR_PART.CREATION_TIME,
             CUR_PART.LAST_MODIFIED_USER,
             CUR_PART.LAST_MODIFIED_TIME);
      END IF;

      --更新接口处理标识
      UPDATE IF_MM_PUB_PART_UDA A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = CUR_PART.ID
         AND A.FACTORY_CODE = CUR_PART.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PUB_PART_UDA',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_PUB_PART_UDA;

  --****************************************************************************
  --过程名  : USP_INV_PART_LOCATION
  --功能描述: 将属地基础信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_INV_PART_LOCATION IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_LOC IN (SELECT T.*
                      FROM IF_MM_INV_PART_LOCATION T
                     WHERE T.DEAL_FLAG = 0
                     ORDER BY T.CREATION_TIME) LOOP

      IF CUR_LOC.DO_FLAG = 'I' THEN
        INSERT INTO ilmsportal.MM_INV_PART_LOCATION@mm_if_in
          (ID,
           FACTORY_CODE,
           PART_NO,
           MODEL_CODE,
           SUPPLIER_NO,
           WARE_CODE,
           STATION_CODE,
           WORKCENTER,
           UNLOAD_PORT,
           DEP_NO,
           PREPARE_PERSON,
           CARPOOL,
           DISTRI_PERSON,
           LOCATION,
           SHELF_NO,
           LOCATION_NUM,
           STORAGE,
           EFF_START,
           EFF_END,
           CREATION_USER,
           CREATION_TIME,
           LAST_MODIFIED_USER,
           LAST_MODIFIED_TIME)
        VALUES
          (CUR_LOC.ID,
           --(ilmspmc.SEQ_MM_INV_PART_LOCATION.NEXTVAL@MM_IF_IN,
           CUR_LOC.FACTORY_CODE,
           CUR_LOC.PART_NO,
           CUR_LOC.MODEL_CODE,
           CUR_LOC.SUPPLIER_NO,
           CUR_LOC.WARE_CODE,
           CUR_LOC.STATION_CODE,
           CUR_LOC.WORKCENTER,
           CUR_LOC.UNLOAD_PORT,
           CUR_LOC.DEP_NO,
           CUR_LOC.PREPARE_PERSON,
           CUR_LOC.CARPOOL,
           CUR_LOC.DISTRI_PERSON,
           CUR_LOC.LOCATION,
           CUR_LOC.SHELF_NO,
           CUR_LOC.LOCATION_NUM,
           CUR_LOC.STORAGE,
           CUR_LOC.EFF_START,
           CUR_LOC.EFF_END,
           CUR_LOC.CREATION_USER,
           CUR_LOC.CREATION_TIME,
           CUR_LOC.LAST_MODIFIED_USER,
           CUR_LOC.LAST_MODIFIED_TIME);
      ELSIF CUR_LOC.DO_FLAG = 'U' THEN
        UPDATE ilmsportal.MM_INV_PART_LOCATION@MM_IF_IN
           SET FACTORY_CODE       = CUR_LOC.Factory_Code,
               PART_NO            = CUR_LOC.Part_No,
               SUPPLIER_NO        = CUR_LOC.Supplier_No,
               WARE_CODE          = CUR_LOC.Ware_Code,
               STATION_CODE       = CUR_LOC.Station_Code,
               WORKCENTER         = CUR_LOC.WORKCENTER,
               UNLOAD_PORT        = CUR_LOC.UNLOAD_PORT,
               DEP_NO             = CUR_LOC.DEP_NO,
               PREPARE_PERSON     = CUR_LOC.PREPARE_PERSON,
               CARPOOL            = CUR_LOC.CARPOOL,
               DISTRI_PERSON      = CUR_LOC.DISTRI_PERSON,
               LOCATION           = CUR_LOC.LOCATION,
               SHELF_NO           = CUR_LOC.SHELF_NO,
               LOCATION_NUM       = CUR_LOC.LOCATION_NUM,
               MODEL_CODE         = CUR_LOC.MODEL_CODE,
               STORAGE            = CUR_LOC.STORAGE,
               EFF_START          = CUR_LOC.EFF_START,
               EFF_END            = CUR_LOC.EFF_END,
               CREATION_USER      = CUR_LOC.CREATION_USER,
               CREATION_TIME      = CUR_LOC.CREATION_TIME,
               LAST_MODIFIED_USER = CUR_LOC.LAST_MODIFIED_USER,
               LAST_MODIFIED_TIME = CUR_LOC.LAST_MODIFIED_TIME
         WHERE ID = CUR_LOC.ID;
      ELSIF CUR_LOC.DO_FLAG = 'D' THEN
        DELETE FROM ilmsportal.MM_INV_PART_LOCATION@MM_IF_IN A
         WHERE ID = CUR_LOC.ID;
      END IF;
      --更新中间表处理标记位为已处理
      UPDATE IF_MM_INV_PART_LOCATION A
         SET A.DEAL_FLAG = 1, A.DEAL_TIME = SYSDATE
       WHERE A.ID = CUR_LOC.ID
         AND A.FACTORY_CODE = CUR_LOC.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_PART_LOCATION',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_INV_PART_LOCATION;
  --*******************************************************************************

  --****************************************************************************
  --过程名  : USP_SW_PICK_PLAN
  --功能描述: 将取货订单信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lxq
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_SW_PICK_PLAN IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER_NO IN (SELECT T.*
                           FROM IF_MM_SW_PICKUP_PLAN T
                          WHERE T.DEAL_FLAG = 0
                          ORDER BY T.ID) LOOP

      IF CUR_ORDER_NO.DO_FLAG = 'I' THEN
        insert into ilmsportal.MM_SW_PICKUP_PLAN@mm_if_in
          (ORDER_NO,
           PURCHASE_NO,
           CONFIRM_DAYS,
           INTER_LOGIS_MANAGER,
           ORDER_USE,
           PLAN_ASSEMBLE_TIME,
           PLAN_ARR_TIME,
           PLAN_PICKUP_TIME,
           TODAY_CAR_BATCH,
           FEEDBACK_STATUS,
           LOGISTICS_MODE,
           AREA,
           CAR_TYPE,
           ROUTE_CODE,
           TOTAL_BATCHS,
           MERGE_BATCHS,
           SUP_FACTORY,
           SUPPLIER_NO,
           WORK_DATE,
           FACTORY_CODE,
           ORDER_DESC,
           PICKUP_TYPE,
           ORDER_ARR_DATE,
           UNLOAD_PORT,
           DOWNLOAD_STATUS,
           DOWNLOAD_TIME,
           CREATION_USER,
           CREATION_TIME,
           LAST_MODIFIED_USER,
           LAST_MODIFIED_TIME,
           ADJ_STATUS,
           DIFF_FLAG)
        values
          (CUR_ORDER_NO.ORDER_NO,
           CUR_ORDER_NO.PURCHASE_NO,
           CUR_ORDER_NO.CONFIRM_DAYS,
           CUR_ORDER_NO.INTER_LOGIS_MANAGER,
           CUR_ORDER_NO.ORDER_USE,
           CUR_ORDER_NO.PLAN_ASSEMBLE_TIME,
           CUR_ORDER_NO.PLAN_ARR_TIME,
           CUR_ORDER_NO.PLAN_PICKUP_TIME,
           CUR_ORDER_NO.TODAY_CAR_BATCH,
           CUR_ORDER_NO. FEEDBACK_STATUS,
           CUR_ORDER_NO.LOGISTICS_MODE,
           CUR_ORDER_NO.AREA,
           CUR_ORDER_NO.CAR_TYPE,
           CUR_ORDER_NO.ROUTE_CODE,
           CUR_ORDER_NO.TOTAL_BATCHS,
           CUR_ORDER_NO.MERGE_BATCHS,
           CUR_ORDER_NO.SUP_FACTORY,
           CUR_ORDER_NO.SUPPLIER_NO,
           CUR_ORDER_NO.WORK_DATE,
           CUR_ORDER_NO.FACTORY_CODE,
           CUR_ORDER_NO.ORDER_DESC,
           CUR_ORDER_NO.PICKUP_TYPE,
           CUR_ORDER_NO. ORDER_ARR_DATE,
           CUR_ORDER_NO.UNLOAD_PORT,
           CUR_ORDER_NO.DOWNLOAD_STATUS,
           CUR_ORDER_NO.DOWNLOAD_TIME,
           CUR_ORDER_NO.CREATION_USER,
           CUR_ORDER_NO.CREATION_TIME,
           CUR_ORDER_NO.LAST_MODIFIED_USER,
           CUR_ORDER_NO.LAST_MODIFIED_TIME,
           CUR_ORDER_NO.ADJ_STATUS,
           CUR_ORDER_NO.DIFF_FLAG);

      ELSIF CUR_ORDER_NO.DO_FLAG = 'U' THEN
        update ilmsportal.MM_SW_PICKUP_PLAN@mm_if_in a
           set ORDER_NO            = CUR_ORDER_NO.ORDER_NO,
               PURCHASE_NO         = CUR_ORDER_NO.PURCHASE_NO,
               CONFIRM_DAYS        = CUR_ORDER_NO.CONFIRM_DAYS,
               INTER_LOGIS_MANAGER = CUR_ORDER_NO.INTER_LOGIS_MANAGER,
               ORDER_USE           = CUR_ORDER_NO.ORDER_USE,
               PLAN_ASSEMBLE_TIME  = CUR_ORDER_NO.PLAN_ASSEMBLE_TIME,
               PLAN_ARR_TIME       = CUR_ORDER_NO.PLAN_ARR_TIME,
               PLAN_PICKUP_TIME    = CUR_ORDER_NO.PLAN_PICKUP_TIME,
               TODAY_CAR_BATCH     = CUR_ORDER_NO.TODAY_CAR_BATCH,
               FEEDBACK_STATUS     = CUR_ORDER_NO.FEEDBACK_STATUS,
               LOGISTICS_MODE      = CUR_ORDER_NO.LOGISTICS_MODE,
               AREA                = CUR_ORDER_NO.AREA,
               CAR_TYPE            = CUR_ORDER_NO.CAR_TYPE,
               ROUTE_CODE          = CUR_ORDER_NO.ROUTE_CODE,
               TOTAL_BATCHS        = CUR_ORDER_NO.TOTAL_BATCHS,
               MERGE_BATCHS        = CUR_ORDER_NO.MERGE_BATCHS,
               SUP_FACTORY         = CUR_ORDER_NO.SUP_FACTORY,
               SUPPLIER_NO         = CUR_ORDER_NO.SUPPLIER_NO,
               WORK_DATE           = CUR_ORDER_NO.WORK_DATE,
               FACTORY_CODE        = CUR_ORDER_NO.FACTORY_CODE,
               ORDER_DESC          = CUR_ORDER_NO.ORDER_DESC,
               PICKUP_TYPE         = CUR_ORDER_NO.PICKUP_TYPE,
               ORDER_ARR_DATE      = CUR_ORDER_NO.ORDER_ARR_DATE,
               UNLOAD_PORT         = CUR_ORDER_NO.UNLOAD_PORT,
               DOWNLOAD_STATUS     = CUR_ORDER_NO.DOWNLOAD_STATUS,
               DOWNLOAD_TIME       = CUR_ORDER_NO.DOWNLOAD_TIME,
               CREATION_USER       = CUR_ORDER_NO.CREATION_USER,
               CREATION_TIME       = CUR_ORDER_NO.CREATION_TIME,
               LAST_MODIFIED_USER  = CUR_ORDER_NO.LAST_MODIFIED_USER,
               LAST_MODIFIED_TIME  = CUR_ORDER_NO.LAST_MODIFIED_TIME,
               ADJ_STATUS          = CUR_ORDER_NO.ADJ_STATUS,
               DIFF_FLAG           = CUR_ORDER_NO.DIFF_FLAG

         where a.ORDER_NO = CUR_ORDER_NO.ORDER_NO
           AND a.PURCHASE_NO = CUR_ORDER_NO.PURCHASE_NO;

      ELSIF CUR_ORDER_NO.DO_FLAG = 'D' THEN
        delete from ilmsportal.MM_SW_PICKUP_PLAN@mm_if_in a
         where a.ORDER_NO = CUR_ORDER_NO.ORDER_NO
           AND a.PURCHASE_NO = CUR_ORDER_NO.PURCHASE_NO;

      END IF;
      --更新中间表处理标记位为已处理
      update IF_MM_SW_PICKUP_PLAN a
         set a.deal_flag = 1, a.deal_time = sysdate
       where a.id = CUR_ORDER_NO.Id
         and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_SW_PICK_PLAN',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_SW_PICK_PLAN;
  --***********************************************************

  --****************************************************************************
  --过程名  : USP_INV_IN
  --功能描述: 将收货数据写入信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2018-12-27
  --****************************************************************************
  PROCEDURE USP_INV_IN IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER IN (SELECT *
                        FROM MM_INV_IN T
                       WHERE T.P_DEAL_FLAG = 0
                       ORDER BY T.CREATION_TIME) LOOP
      --写入信息共享平台拉动订单主信息
      INSERT INTO ilmsportal.MM_INV_IN@MM_IF_IN
        SELECT *
          FROM MM_INV_IN A
         WHERE A.REC_NO = CUR_ORDER.REC_NO
           AND A.P_DEAL_FLAG = 0;

      --写入信息共享平台拉动订单明细
      INSERT INTO ilmsportal.MM_INV_IN_DETAIL@MM_IF_IN
        SELECT *
          FROM MM_INV_IN_DETAIL DETAIL
         WHERE DETAIL.REC_NO = CUR_ORDER.REC_NO;

      --更新接口处理标识
      UPDATE MM_INV_IN T
         SET T.P_DEAL_FLAG = 1, T.P_DEAL_TIME = SYSDATE
       WHERE T.REC_NO = CUR_ORDER.REC_NO;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_INV_IN',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_INV_IN;
  --***********************************************************

  --****************************************************************************
  --过程名  : USP_JISO_PART_PLAN
  --功能描述: 将厂内同步零件下线计划写入信息共享平台
  --参数说明: 无
  --创建人员: lxq
  --创建时间: 2019-04-06
  --****************************************************************************
  PROCEDURE USP_JISO_PART_PLAN IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    --查询未处理订单
    FOR CUR_ORDER IN (SELECT T.*
                        FROM MM_JISO_PART_PLAN T
                       WHERE T.DEAL_FLAG_IN = 0
                       ORDER BY T.CREATION_TIME) LOOP
      --写入信息共享平台同步零件下线计划信息
      INSERT INTO ilmsportal.MM_JISO_PART_PLAN@MM_IF_IN
        (ID,
         SUPPLIER_NO,
         ARR_DEPOT,
         PARTGROUP_NO,
         PART_NO,
         REQUIRE_NUM,
         OFFLINE_TIME,
         CREATION_TIME,
         CREATION_USER,
         LAST_MODIFIED_TIME,
         LAST_MODIFIED_USER,
         FACTORY_CODE,
         MODEL_CODE)
      VALUES
        (ilmsportal.SEQ_MM_JISO_PART_PLAN.NEXTVAL@MM_IF_IN,
         CUR_ORDER.SUPPLIER_NO,
         CUR_ORDER.ARR_DEPOT,
         CUR_ORDER.PARTGROUP_NO,
         CUR_ORDER.PART_NO,
         CUR_ORDER.REQUIRE_NUM,
         CUR_ORDER.OFFLINE_TIME,
         CUR_ORDER.CREATION_TIME,
         CUR_ORDER.CREATION_USER,
         CUR_ORDER.LAST_MODIFIED_TIME,
         CUR_ORDER.LAST_MODIFIED_USER,
         CUR_ORDER.FACTORY_CODE,
         CUR_ORDER.MODEL_CODE);

      --更新接口处理标识
      UPDATE MM_JISO_PART_PLAN T
         SET T.DEAL_FLAG_IN = 1, T.DEAL_TIME_IN = SYSDATE
       WHERE T.ID = CUR_ORDER.ID;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_JISO_PART_PLAN',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_JISO_PART_PLAN;
  --****************************************************************************
  --过程名  : USP_JISO_INS_ORDERNO_SY
  --功能描述: 同步厂外同步指示票订单号
  --参数说明: 无
  --创建人员: dtp
  --创建时间: 2019-04-06
  --****************************************************************************
  PROCEDURE USP_JISO_INS_ORDERNO_SY IS
    err_num number(10); --错误代码
    err_msg varchar2(200); --错误信息
  BEGIN
    FOR CUR_INS IN (SELECT *
                      FROM ilmsportal.MM_JISO_INS@MM_IF_IN T
                     WHERE T.ORDER_NO IS NULL
                     ORDER BY T.CREATION_TIME) LOOP
      --根据INS_NO更新ORDER_NO
      UPDATE ilmsportal.MM_JISO_INS@MM_IF_IN I
         SET I.ORDER_NO =
             (SELECT S.ORDER_NO
                FROM MM_JISO_INS S
               WHERE S.INS_NO = CUR_INS.INS_NO)
       WHERE I.INS_NO = CUR_INS.INS_NO;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_JISO_INS_ORDERNO_SY',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_JISO_INS_ORDERNO_SY;
  --****************************************************************************

end PKG_IF_SEND_IN;
/

prompt
prompt Creating package body PKG_INV_CHECK
prompt ===================================
prompt
CREATE OR REPLACE PACKAGE BODY PKG_INV_CHECK IS
  --总装虚拟仓
  AF_PC_VIRTUAL_WAREHOUSE VARCHAR2(20) := 'AM11';
  --焊装虚拟仓
  WE_PC_VIRTUAL_WAREHOUSE VARCHAR2(20) := 'WM11';
  --总装零部件线边仓
  AF_LINE_WAREHOUSE VARCHAR2(20) := 'AW11';
  --焊装零部件线边仓
  WE_LINE_WAREHOUSE VARCHAR2(20) := 'WW11';
  --总装PC
  AF_PC_WAREHOUSE VARCHAR2(20) := 'AA11';
  --焊装PC
  WE_PC_WAREHOUSE VARCHAR2(20) := 'WA11';

  --***************************************************************************
  --存储过程名：INV_STOCK_IMPORT_CHECK
  --功能描述： 库存管理Excel导入检查校验
  --参数说明：
  --输入：
  --IN_VAR_UUID 导入UUID
  --IN_VAR_USERNAME 操作人名称
  --IN_VAR_OPEIP ip地址
  --输出：
  --OUT_ERROR_FLAG 错误标识
  --OUT_OUT_ERROR_MSG 错误信息
  --创建人员: zmj
  --创建时间： 2018/10/12
  PROCEDURE INV_STOCK_IMPORT_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                   IN_VAR_USERNAME   IN VARCHAR2,
                                   IN_VAR_OPEIP      IN VARCHAR2,
                                   OUT_ERROR_FLAG    OUT VARCHAR2,
                                   OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

  BEGIN
    out_error_flag    := '0';
    out_out_error_msg := '';

    /*--判断Excel数据是否重复
    update mm_inv_stock_imp spi
       set spi.check_result = '0',
           spi.check_info   = nvl(spi.check_info, '') || 'Excel数据重复;'
     where spi.id in (select id
                        from mm_inv_stock_imp
                       where (ware_code, part_no) in
                             (select spi.ware_code, spi.part_no
                                from mm_inv_stock_imp spi
                               where spi.imp_uuid = in_var_uuid
                                 and spi.import_status = '0'
                               group by spi.ware_code, spi.part_no
                              having count(*) > 1));

    --判断仓库是否存在
    update mm_inv_stock_imp mis
       set mis.check_result = 0,
           mis.check_info  =
           (nvl(mis.check_info, '') || '仓库不存在;')
     where not exists (select 1
              from mm_inv_warehouse mpp
             where mpp.ware_code = mis.ware_code)
       and mis.imp_uuid = in_var_uuid;

    --判断零件号是否存在
    update mm_inv_stock_imp mis
       set mis.check_result = 0,
           mis.check_info  =
           (nvl(mis.check_info, '') || '零件不存在;')
     where not exists (select 1
              from mm_pub_part mpp
             where mpp.part_no = mis.part_no
               and mpp.factory_code = mis.factory_code)
       and mis.imp_uuid = in_var_uuid;

    --判断零件是否在仓库下存在库存
    update mm_inv_stock_imp mist
       set mist.ope_type = 'U'
     where exists (select 1
              from mm_inv_stock mip
             where mip.factory_code = mist.factory_code
               and mip.ware_code = mist.ware_code
               and mip.part_no = mist.part_no
               and mist.imp_uuid = in_var_uuid
               and mist.import_status = 0)
       and mist.imp_uuid = in_var_uuid;

    --若导入数据小于0且无库存数据,不允许导入
    update mm_inv_stock_imp mist
       set mist.check_result = 0,
           mist.check_info  =
           (nvl(mist.check_info, '') || '无法扣减库存,不支持导入')
     where not exists (select 1
              from mm_inv_stock mip
             where mip.factory_code = mist.factory_code
               and mip.ware_code = mist.ware_code
               and mip.part_no = mist.part_no
               and mist.imp_uuid = in_var_uuid
               and mist.import_status = 0)
       and mist.imp_uuid = in_var_uuid
       and mist.stock < 0;

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MM_INV.INV_STOCK_IMPORT_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;*/
  --判断Excel数据是否重复
  update mm_inv_stock_imp spi
       set spi.check_result = '0',
           spi.check_info   = nvl(spi.check_info, '') || 'Excel数据重复;'
     where spi.id in
           (select id
              from mm_inv_stock_imp
             where (spi.from_depot_no, spi.to_depot_no, part_no) in
                   (select spi.from_depot_no, spi.to_depot_no, spi.part_no
                      from mm_inv_stock_imp spi
                     where spi.imp_uuid = in_var_uuid
                       and spi.import_status = '0'
                     group by spi.from_depot_no, spi.to_depot_no, spi.part_no
                    having count(*) > 1));

    --判断出库仓库是否存在
    update mm_inv_stock_imp mis
       set mis.check_result = 0,
           mis.check_info  =
           (nvl(mis.check_info, '') || '出库仓库不存在;')
     where not exists (select 1
              from mm_inv_warehouse mpp
             where mpp.ware_code = mis.from_depot_no)
       and mis.imp_uuid = in_var_uuid;

    --判断入库仓库是否存在
    update mm_inv_stock_imp mis
       set mis.check_result = 0,
           mis.check_info  =
           (nvl(mis.check_info, '') || '入库仓库不存在;')
     where not exists (select 1
              from mm_inv_warehouse mpp
             where mpp.ware_code = mis.to_depot_no)
       and mis.imp_uuid = in_var_uuid;

    --判断零件号是否存在
    update mm_inv_stock_imp mis
       set mis.check_result = 0,
           mis.check_info  =
           (nvl(mis.check_info, '') || '零件不存在;')
     where not exists
     (select 1 from mm_pub_part mpp where mpp.part_no = mis.part_no)
       and mis.imp_uuid = in_var_uuid;

    --判断零件是否在仓库下存在库存
    update mm_inv_stock_imp mist
       set mist.ope_type = 'U'
     where exists (select 1
              from mm_inv_stock mip
             where mip.factory_code = mist.factory_code
               and mip.ware_code = mist.to_depot_no
               and mip.part_no = mist.part_no
               and mist.imp_uuid = in_var_uuid
               and mist.import_status = 0)
       and mist.imp_uuid = in_var_uuid;

    --若导入数据小于0且无库存数据,不允许导入
    update mm_inv_stock_imp mist
       set mist.check_result = 0,
           mist.check_info  =
           --(nvl(mist.check_info, '') || 'not support 0')
           (nvl(mist.check_info, '') || '无法扣减库存，不支持导入')
     where not exists (select 1
              from mm_inv_stock mip
             where mip.factory_code = mist.factory_code
               and mip.ware_code = mist.from_depot_no
               and mip.part_no = mist.part_no
               and mist.imp_uuid = in_var_uuid
               and mist.import_status = 0)
       and mist.imp_uuid = in_var_uuid
       and mist.stock < 0;

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MM_INV.INV_STOCK_IMPORT_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END INV_STOCK_IMPORT_CHECK;

  --***************************************************************************
  --存储过程名：INV_STOCKTAK_IMPORT_CHECK
  --功能描述： 取货计划查询Excel导入检查校验
  --参数说明：
  --输入：
  --IN_VAR_UUID 导入UUID
  --IN_VAR_USERNAME 操作人名称
  --IN_VAR_OPEIP ip地址
  --输出：
  --OUT_ERROR_FLAG 错误标识
  --OUT_OUT_ERROR_MSG 错误信息
  --创建人员: zmj
  --创建时间： 2018/10/12
  PROCEDURE INV_STOCKTAK_IMPORT_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                      IN_VAR_USERNAME   IN VARCHAR2,
                                      IN_VAR_OPEIP      IN VARCHAR2,
                                      OUT_ERROR_FLAG    OUT VARCHAR2,
                                      OUT_OUT_ERROR_MSG OUT VARCHAR2) IS

    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

  BEGIN
    out_error_flag    := '0';
    out_out_error_msg := '';

    --EXCEL是否重复
    update mm_inv_stock_take_imp siglt
       set siglt.check_result = 0,
           siglt.ope_type     = 'U',
           siglt.check_info  =
           (nvl(siglt.check_info, '') || 'Excel数据重复;')
     where siglt.part_no in
           (select distinct T.part_no
              from mm_inv_stock_take_imp t,
                   (select PART_NO, WARE_CODE
                      from (select count(*) count,
                                   siglt.PART_NO,
                                   siglt.WARE_CODE
                              from mm_inv_stock_take_imp siglt
                             where siglt.imp_uuid = in_var_uuid
                               and siglt.import_status = '0'
                             group by siglt.PART_NO, siglt.WARE_CODE)
                     where count > 1) b
             where t.PART_NO = b.PART_NO
               and t.WARE_CODE = B.WARE_CODE);

    --判断零件号是否存在
    update mm_inv_stock_take_imp mis
       set mis.check_result = 0,
           mis.check_info  =
           (nvl(mis.check_info, '') || '零件号不存在;')
     where not exists (select 1
              from mm_pub_part mpp
             where mpp.part_no = mis.part_no
               and mpp.factory_code = mis.factory_code)
       and mis.imp_uuid = in_var_uuid;

    --判断仓库是否存在
    update mm_inv_stock_take_imp mis
       set mis.check_result = 0,
           mis.check_info  =
           (nvl(mis.check_info, '') || '仓库代码不存在;')
     where not exists (select 1
              from mm_inv_warehouse mpp
             where mpp.ware_code = mis.ware_code)
       and mis.imp_uuid = in_var_uuid;

    --判断仓库与零件是否对应
    update mm_inv_stock_take_imp mis
       set mis.check_result = 0,
           mis.check_info  =
           (nvl(mis.check_info, '') || '该仓库下暂无该零件库存;')
     where not exists (select 1
              from mm_inv_stock_take_imp mist
              left join mm_inv_part_location mip
                on mip.factory_code = mist.factory_code
               and mip.ware_code = mist.ware_code
               and mip.part_no = mist.part_no
             where mist.imp_uuid = in_var_uuid
               and mist.import_status = 0);

    --将零件包装数写入临时表
    UPDATE MM_INV_STOCK_TAKE_IMP MIS
       SET MIS.STANDARD_PACKAGE =
           (SELECT TEMP.STANDARD_PACKAGE
              FROM (SELECT MIST.PART_NO          PART_NO,
                           MPPD.STANDARD_PACKAGE STANDARD_PACKAGE
                      FROM MM_INV_STOCK_TAKE_IMP MIST
                      LEFT JOIN MM_PUB_PART_SUPPLIER MPPS
                        ON MIST.PART_NO = MPPS.PART_NO
                       AND MIST.FACTORY_CODE = MPPS.FACTORY_CODE
                      LEFT JOIN MM_PKG_PROPOSAL MPP
                        ON MIST.PART_NO = MPP.PART_NO
                       AND MPP.SUPPLIER_NO = MPPS.SUPPLIER_NO
                       AND MIST.FACTORY_CODE = MPP.FACTORY_CODE
                       AND MPP.PROPOSAL_STATUS = '5'
                       AND TRUNC(SYSDATE) BETWEEN TRUNC(MPP.EFF_START) AND
                           TRUNC(MPP.EFF_END)
                      LEFT JOIN MM_PKG_PROPOSAL_DETAIL MPPD
                        ON MPPD.PROPOSAL_ID = MPP.ID
                     WHERE MIST.IMP_UUID = IN_VAR_UUID
                       AND MIST.CHECK_RESULT = '1'
                       AND MIST.IMPORT_STATUS = '0') TEMP
             WHERE MIS.PART_NO = TEMP.PART_NO)
     where MIS.IMP_UUID = IN_VAR_UUID
       AND MIS.CHECK_RESULT = '1'
       AND MIS.IMPORT_STATUS = '0';

    --获取不到包装数的记为异常数据
    update mm_inv_stock_take_imp mis
       set mis.check_result = 0,
           mis.check_info  =
           (nvl(mis.check_info, '') || '该零件包装数不存在;')
     where mis.imp_uuid = in_var_uuid
       and mis.standard_package is null
       and mis.check_result = 1
       and mis.import_status = 0;

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MM_INV.INV_STOCKTAK_IMPORT_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END INV_STOCKTAK_IMPORT_CHECK;

  --***************************************************************************
  --存储过程名：INV_GET_STOCK_TOTAL
  --功能描述： 获取PC库和线边库的库存总和，写入到库存推移基础表（MM_INV_DEV_BASE）
  --参数说明：
  --输入：
  --IN_VAR_FACTORY 工厂代码
  --IN_VAR_USERNAME 操作人名称
  --输出：
  --OUT_ERROR_FLAG 错误标识
  --OUT_OUT_ERROR_MSG 错误信息
  --创建人员: zmj
  --创建时间： 2018/10/16
  PROCEDURE INV_GET_STOCK_TOTAL(IN_VAR_FACTORY    IN VARCHAR2,
                                IN_VAR_USERNAME   IN VARCHAR2,
                                OUT_ERROR_FLAG    OUT VARCHAR2,
                                OUT_OUT_ERROR_MSG OUT VARCHAR2) AS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
  BEGIN
    out_error_flag    := '0';
    out_out_error_msg := '';

    DELETE FROM MM_INV_DEV_BASE MID
     WHERE MID.FACTORY_CODE = IN_VAR_FACTORY;

    INSERT INTO MM_INV_DEV_BASE
      (ID,
       FACTORY_CODE,
       PART_NO,
       STOCK,
       CREATION_TIME,
       CREATION_USER,
       WORK_CENTER)
      SELECT PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_INV_STOCK'),
             IN_VAR_FACTORY,
             MIS.PART_NO,
             SUM(MIS.STOCK),
             SYSDATE,
             IN_VAR_USERNAME,
             'A1' WORKCENTER
        FROM MM_INV_STOCK MIS
       WHERE MIS.FACTORY_CODE = IN_VAR_FACTORY
         AND MIS.WARE_CODE IN
             (AF_PC_WAREHOUSE, AF_LINE_WAREHOUSE, AF_PC_VIRTUAL_WAREHOUSE)
         AND EXISTS
       (SELECT 1
                FROM MM_MP_PART MMP
               WHERE MIS.PART_NO = MMP.PART_NO
                 AND MMP.WORKCENTER = 'A1'
                 AND MIS.FACTORY_CODE = MMP.FACTORY_CODE)
       GROUP BY MIS.PART_NO
      UNION ALL
      SELECT PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_INV_STOCK'),
             IN_VAR_FACTORY,
             MIS.PART_NO,
             SUM(MIS.STOCK),
             SYSDATE,
             IN_VAR_USERNAME,
             'W1' WORKCENTER
        FROM MM_INV_STOCK MIS
       WHERE MIS.FACTORY_CODE = IN_VAR_FACTORY
         AND MIS.WARE_CODE IN
             (WE_PC_WAREHOUSE, WE_LINE_WAREHOUSE, WE_PC_VIRTUAL_WAREHOUSE)
         AND EXISTS
       (SELECT 1
                FROM MM_MP_PART MMP
               WHERE MIS.PART_NO = MMP.PART_NO
                 AND MMP.WORKCENTER = 'W1'
                 AND MIS.FACTORY_CODE = MMP.FACTORY_CODE)
       GROUP BY MIS.PART_NO;

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MM_INV.INV_GET_STOCK_TOTAL',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END INV_GET_STOCK_TOTAL;

  --***************************************************************************
  --存储过程名：USP_INV_EMPTY_CHECK
  --功能描述：空容器库存导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: linzhuo
  --创建时间： 2018/09/10

  PROCEDURE USP_INV_EMPTY_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                IN_VAR_USERNAME   IN VARCHAR2,
                                IN_VAR_OPEIP      IN VARCHAR2,
                                OUT_ERROR_FLAG    OUT VARCHAR2,
                                OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

    V_TEMP_NUM   number;
    V_CHECK_INFO varchar2(300);
  BEGIN

    --车间是否存在
    UPDATE MM_INV_EC_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '车间不存在;'
     WHERE NOT EXISTS (SELECT 1
              FROM MM_PUB_DATA_DICT B
             WHERE B.CODE_TYPE = 'PUB_WORKCENTER'
               AND B.CODE_VALUE = A.WORK_CENTER
               AND B.FACTORY_CODE = A.FACTORY_CODE)
       AND A.IMP_UUID = IN_VAR_UUID;

    --供应商代码是否存在
    UPDATE MM_INV_EC_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '供应商代码不存在;'
     WHERE NOT EXISTS (SELECT 1
              FROM MM_PUB_SUPPLIER B
             WHERE A.SUPPLIER_NO = B.SUPPLIER_NO)
       AND A.IMP_UUID = IN_VAR_UUID;

    --校验箱种是否存在
    UPDATE MM_INV_EC_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '箱种不存在;'
     WHERE NOT EXISTS (SELECT 1
              FROM MM_PUB_DATA_DICT B
             WHERE B.CODE_TYPE = 'PKG_BOX_TYPE'
               AND B.CODE_VALUE = A.BOX_TYPE
               AND B.FACTORY_CODE = A.FACTORY_CODE)
       AND A.IMP_UUID = IN_VAR_UUID;

    --EXCEL是否重复
    update MM_INV_EC_IMP siglt
       set siglt.check_result = '0',
           siglt.check_info  =
           (nvl(siglt.check_info, '') || 'Excel数据重复;')
     where siglt.Pk_Id in
           (select distinct T.PK_ID
              from MM_INV_EC_IMP t,
                   (select FACTORY_CODE, SUPPLIER_NO, BOX_TYPE, WORK_CENTER
                      from (select count(*) count,
                                   siglt.factory_Code,
                                   siglt.supplier_No,
                                   siglt.box_Type,
                                   siglt.work_Center
                              from MM_INV_EC_IMP siglt
                             where siglt.imp_uuid = in_var_uuid
                               and siglt.import_status = '0'
                             group by siglt.factory_Code,
                                      siglt.supplier_No,
                                      siglt.box_Type,
                                      siglt.work_Center)
                     where count > 1) b
             where t.factory_Code = b.factory_Code
               and t.supplier_No = b.supplier_No
               and t.box_Type = b.box_Type
               and t.work_Center = b.work_Center);

    --主表中是否已存在该条记录
    MERGE INTO MM_INV_EC_IMP A
    USING (SELECT B.PK_ID, C.ID
             FROM MM_INV_EC C, MM_INV_EC_IMP B
            WHERE B.CHECK_RESULT = 1
              AND B.IMP_UUID = in_var_uuid
              AND B.WORK_CENTER = C.WORK_CENTER
              AND B.BOX_TYPE = C.BOX_TYPE
              AND B.SUPPLIER_NO = C.SUPPLIER_NO
              AND B.FACTORY_CODE = C.FACTORY_CODE
              AND B.CHECK_RESULT = 1) D
    ON (A.PK_ID = D.PK_ID AND A.IMP_UUID = in_var_uuid)
    WHEN MATCHED THEN
      UPDATE
         SET A.BUSI_ID    = D.ID,
             A.OPE_TYPE   = 'U',
             A.CHECK_INFO = A.CHECK_INFO || ';' || '数据已存在';

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_INV_CHECK.USP_INV_EMPTY_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_INV_EMPTY_CHECK;
  --***************************************************************************

  /*  ---------------------------------------
  --货架标签导入
  -------------------------------------
  PROCEDURE USP_MM_INV_SHELVES_IMPORT(ERROR_TAG OUT VARCHAR2) AS
    V_IF_CTRL       VARCHAR2(20);
    V_SHELVES_ADDR  VARCHAR2(150);
    V_FACTORY_CODE  VARCHAR2(20);
    V_PART_NO       VARCHAR2(20);
    V_SUPPLIER_NO   VARCHAR2(20);
    V_STANDARD_PACK NUMBER(10);
    V_SAFE_STOCK    NUMBER(10);
    V_CAR_TYPE      VARCHAR2(20);
    V_STACK_LAYERS  NUMBER(10);
    V_ID            NUMBER;
    V_IP_ADDRESS    VARCHAR2(64);
    V_OP_USER       VARCHAR2(64);
  BEGIN
    V_IP_ADDRESS := SYS_CONTEXT('USERENV', 'IP_ADDRESS');
    V_OP_USER    := SYS_CONTEXT('USERENV', 'OS_USER');
    \*    --存储过程执行标识
    FOR CTRL IN (SELECT P.PARAM_VAL
                   FROM MM_PUB_SYS_PARAM P
                  WHERE P.PARAM_GROUP = 'MM_INV_SHELVES'
                    AND P.PARAM_CODE = 'MM_INV_SHELVES_IMPORT') LOOP
      V_IF_CTRL := CTRL.PARAM_VAL;
      EXIT;
    END LOOP;
    IF V_IF_CTRL IS NOT NULL AND V_IF_CTRL = '0' THEN
      UPDATE MM_PUB_SYS_PARAM P
         SET P.PARAM_VAL = '1', P.CREATION_TIME = SYSDATE
       WHERE P.PARAM_GROUP = 'MM_INV_SHELVES'
         AND P.PARAM_CODE = 'MM_INV_SHELVES_IMPORT';
      COMMIT;
    ELSE
      RETURN;
    END IF;*\
    --执行业务
    V_IP_ADDRESS := SYS_CONTEXT('USERENV', 'IP_ADDRESS');
    V_OP_USER    := SYS_CONTEXT('USERENV', 'OS_USER');
    ERROR_TAG    := '0';
    FOR CUR IN (SELECT SHELVES_ADDR,
                       FACTORY_CODE,
                       PART_NO,
                       SUPPLIER_NO,
                       STANDARD_PACK,
                       SAFE_STOCK,
                       CAR_TYPE,
                       STACK_LAYERS,
                       ID

                  FROM MM_INV_SHELVES_LABEL_TEMP T
                 WHERE T.DEAL_FLAG != '1'
                   AND T.CHECK_FLAG = '1'
                 ORDER BY T.ID ASC) LOOP
      V_SHELVES_ADDR  := CUR.SHELVES_ADDR;
      V_FACTORY_CODE  := CUR.FACTORY_CODE;
      V_PART_NO       := CUR.PART_NO;
      V_SUPPLIER_NO   := CUR.SUPPLIER_NO;
      V_STANDARD_PACK := CUR.STANDARD_PACK;
      V_SAFE_STOCK    := CUR.SAFE_STOCK;
      V_CAR_TYPE      := CUR.CAR_TYPE;
      V_STACK_LAYERS  := CUR.STACK_LAYERS;
      V_ID            := CUR.ID;
      INSERT INTO MM_INV_SHELVES_LABEL
        (ID,
         SHELVES_ADDR,
         FACTORY_CODE,
         PART_NO,
         SUPPLIER_NO,
         STANDARD_PACK,
         SAFE_STOCK,
         CAR_TYPE,
         STACK_LAYERS,
         CREATION_USER,
         CREATION_TIME)
      VALUES
        (SEQ_MM_INV_SHELVES_TEMP.NEXTVAL,
         V_SHELVES_ADDR,
         V_FACTORY_CODE,
         V_PART_NO,
         V_SUPPLIER_NO,
         V_STANDARD_PACK,
         V_SAFE_STOCK,
         V_CAR_TYPE,
         V_STACK_LAYERS,
         V_OP_USER,
         SYSDATE);
      UPDATE MM_INV_SHELVES_LABEL_TEMP SET DEAL_FLAG = '1' WHERE ID = V_ID;
    END LOOP;
    \* --存储过程执行标识
    UPDATE MM_PUB_SYS_PARAM P
       SET P.PARAM_VAL = '0', P.LAST_MODIFIED_TIME = SYSDATE
     WHERE P.PARAM_GROUP = 'MM_INV_SHELVES'
       AND P.PARAM_CODE = 'MM_INV_SHELVES_IMPORT';*\
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ERROR_TAG := '1';
      ROLLBACK;
  END USP_MM_INV_SHELVES_IMPORT;*/
  /*--***************************************************************************
  --存储过程名：USP_MATERIAL_IMPORT_CHECK
  --功能描述：资材订单反馈导入校验
  --参数说明：
  --IN_VAR_UUID
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  PROCEDURE USP_MATERIAL_IMPORT_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                      OUT_ERROR_FLAG    OUT VARCHAR2,
                                      OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
    V_SUB_NUM NUMBER;
  BEGIN

    UPDATE MM_SW_FEEDBACK_ZC_IMP A
       SET A.CHECK_INFO = '资材订单已反馈', A.CHECK_RESULT = '0'
     WHERE EXISTS (SELECT 1
              FROM MM_SW_FEEDBACK_ZC B
             WHERE A.PURCHASE_NO = B.PURCHASE_NO
               AND A.PURCHASE_ROWNO = B.PURCHASE_ROW_NO)
       AND A.IMP_UUID = IN_VAR_UUID
       AND A.CHECK_RESULT = '1';

    FOR CUR IN (SELECT IMP.PURCHASE_NO PURCHASE_NO,
                       IMP.PURCHASE_ROWNO PURCHASE_ROWNO,
                       COUNT(1) COUNT_ROW,
                       SUM(IMP.PLAN_NUM) SUM_NUM
                  FROM MM_SW_FEEDBACK_ZC_IMP IMP
                 WHERE IMP.IMP_UUID = IN_VAR_UUID
                   AND IMP.CHECK_RESULT = '1'
                 GROUP BY IMP.PURCHASE_NO, IMP.PURCHASE_ROWNO) LOOP

      SELECT (CUR.SUM_NUM - SUM(OD.ORDER_QTY))
        INTO V_SUB_NUM
        FROM MM_SW_ORDER_DETAIL OD
       WHERE OD.PURCHASE_NO = CUR.PURCHASE_NO
         AND OD.PURCHASE_ROWNO = CUR.PURCHASE_ROWNO
         AND NOT EXISTS
       (SELECT 1
                FROM MM_SW_FEEDBACK_ZC ZC
               WHERE ZC.PURCHASE_NO = OD.PURCHASE_NO
                 AND ZC.PURCHASE_ROW_NO = OD.PURCHASE_ROWNO);
      IF V_SUB_NUM = 0 AND CUR.COUNT_ROW >= 2 THEN
        UPDATE MM_SW_FEEDBACK_ZC_IMP IMP
           SET IMP.RETURN_STATUS = '2', IMP.CHECK_RESULT = '1'
         WHERE IMP.IMP_UUID = IN_VAR_UUID
           AND IMP.PURCHASE_NO = CUR.PURCHASE_NO
           AND IMP.PURCHASE_ROWNO = CUR.PURCHASE_ROWNO;
      ELSIF V_SUB_NUM = 0 AND CUR.COUNT_ROW = 1 THEN
        UPDATE MM_SW_FEEDBACK_ZC_IMP IMP
           SET IMP.RETURN_STATUS = '1', IMP.CHECK_RESULT = '1'
         WHERE IMP.IMP_UUID = IN_VAR_UUID
           AND IMP.PURCHASE_NO = CUR.PURCHASE_NO
           AND IMP.PURCHASE_ROWNO = CUR.PURCHASE_ROWNO;
      ELSE
        UPDATE MM_SW_FEEDBACK_ZC_IMP IMP
           SET IMP.CHECK_INFO   = '资材订单计划数汇总不等于订单采购数',
               IMP.CHECK_RESULT = '0'
         WHERE IMP.IMP_UUID = IN_VAR_UUID
           AND IMP.PURCHASE_NO = CUR.PURCHASE_NO
           AND IMP.PURCHASE_ROWNO = CUR.PURCHASE_ROWNO;
      END IF;
    END LOOP;

    UPDATE MM_SW_FEEDBACK_ZC_IMP A
       SET A.CHECK_INFO   = '订单号和订单行号对应的资材订单不存在',
           A.CHECK_RESULT = '0'
     WHERE NOT EXISTS (SELECT 1
              FROM MM_SW_ORDER_DETAIL B
              LEFT JOIN MM_SW_ORDER C
                ON B.PURCHASE_NO = C.PURCHASE_NO
               AND C.ORDER_TYPE = '14'
             WHERE A.PURCHASE_NO = B.PURCHASE_NO
               AND A.PURCHASE_ROWNO = B.PURCHASE_ROWNO)
       AND A.IMP_UUID = IN_VAR_UUID
       AND A.CHECK_RESULT = '1';
    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_PUB_CHECK.USP_SPSCONFIG_IMPORT_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END USP_MATERIAL_IMPORT_CHECK;
  --****************************************************************************/
  --***************************************************************************
  --存储过程名：USP_INV_WEEK_CAL_CHECK
  --功能描述：支给件推算周导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: luoxianqin
  --创建时间： 2019-05-28
  PROCEDURE USP_INV_WEEK_CAL_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                   IN_VAR_USERNAME   IN VARCHAR2,
                                   IN_VAR_OPEIP      IN VARCHAR2,
                                   OUT_ERROR_FLAG    OUT VARCHAR2,
                                   OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

    V_TEMP_NUM   number;
    V_CHECK_INFO varchar2(300);
  BEGIN
    --仓库代码不能为空
    UPDATE MM_INV_WEEK_CAL_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '仓库代码不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.WARE_CODE IS NULL;

    --仓库代码在系统中不存在
    UPDATE MM_INV_WEEK_CAL_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '仓库代码在系统中不存在;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND NOT EXISTS (SELECT 1
              FROM MM_INV_WAREHOUSE B
             WHERE A.WARE_CODE = B.WARE_CODE
               AND A.FACTORY_CODE = B.FACTORY_CODE);

/*    UPDATE MM_INV_WEEK_CAL_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '零件号不属于支给件;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND NOT EXISTS (SELECT 1
              FROM MM_PUB_SUPPORTING_PART B
             WHERE A.PART_NO = B.PART_NO
               AND A.FACTORY_CODE = B.FACTORY_CODE);*/

    --零件号不能为空
    UPDATE MM_INV_WEEK_CAL_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '零件号不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.PART_NO IS NULL;

    --EXCEL数据重复
    UPDATE MM_INV_WEEK_CAL_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || 'EXCEL数据重复'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND EXISTS (SELECT 1
              FROM (SELECT B.WARE_CODE, B.PART_NO
                      FROM MM_INV_WEEK_CAL_IMP B
                     WHERE B.IMP_UUID = IN_VAR_UUID
                       AND B.IMPORT_STATUS = 0
                     GROUP BY B.WARE_CODE, B.PART_NO
                    HAVING COUNT(1) > 1) C
             WHERE A.WARE_CODE = C.WARE_CODE
               AND A.PART_NO = C.PART_NO);

    --支给件需求数量不能为null或者<=0
    UPDATE MM_INV_WEEK_CAL_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '需求数量需要为正整数;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND (A.CAL_WEEK IS NULL OR A.CAL_WEEK <= 0)
        OR MOD(A.CAL_WEEK, 1) != 0;

    --已存在，导入更新
    UPDATE MM_INV_WEEK_CAL_IMP A
       SET A.CHECK_INFO = NVL(A.CHECK_INFO, '') || '已存在，导入更新',
           A.OPE_TYPE   = 'U'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.CHECK_RESULT = 1
       AND EXISTS (SELECT 1
              FROM MM_INV_WEEK_CAL B
             WHERE A.WARE_CODE = B.WARE_CODE
               AND A.PART_NO = B.PART_NO);

    --不存在存在，导入新增
    UPDATE MM_INV_WEEK_CAL_IMP A
       SET A.CHECK_INFO = NVL(A.CHECK_INFO, '') || '不存在，导入新增',
           A.OPE_TYPE   = 'I'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.CHECK_RESULT = 1
       AND NOT EXISTS (SELECT 1
              FROM MM_INV_WEEK_CAL B
             WHERE A.WARE_CODE = B.WARE_CODE
               AND A.PART_NO = B.PART_NO);

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_INV_WEEK_CAL_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_INV_WEEK_CAL_CHECK;
  --***************************************************************************

/*  ---------------------------------------
  --货架标签导入
  -------------------------------------
  PROCEDURE USP_MM_INV_SHELVES_IMPORT(ERROR_TAG OUT VARCHAR2) AS
    V_IF_CTRL       VARCHAR2(20);
    V_SHELVES_ADDR  VARCHAR2(150);
    V_FACTORY_CODE  VARCHAR2(20);
    V_PART_NO       VARCHAR2(20);
    V_SUPPLIER_NO   VARCHAR2(20);
    V_STANDARD_PACK NUMBER(10);
    V_SAFE_STOCK    NUMBER(10);
    V_CAR_TYPE      VARCHAR2(20);
    V_STACK_LAYERS  NUMBER(10);
    V_ID            NUMBER;
    V_IP_ADDRESS    VARCHAR2(64);
    V_OP_USER       VARCHAR2(64);
  BEGIN
    V_IP_ADDRESS := SYS_CONTEXT('USERENV', 'IP_ADDRESS');
    V_OP_USER    := SYS_CONTEXT('USERENV', 'OS_USER');
    \*    --存储过程执行标识
    FOR CTRL IN (SELECT P.PARAM_VAL
                   FROM MM_PUB_SYS_PARAM P
                  WHERE P.PARAM_GROUP = 'MM_INV_SHELVES'
                    AND P.PARAM_CODE = 'MM_INV_SHELVES_IMPORT') LOOP
      V_IF_CTRL := CTRL.PARAM_VAL;
      EXIT;
    END LOOP;
    IF V_IF_CTRL IS NOT NULL AND V_IF_CTRL = '0' THEN
      UPDATE MM_PUB_SYS_PARAM P
         SET P.PARAM_VAL = '1', P.CREATION_TIME = SYSDATE
       WHERE P.PARAM_GROUP = 'MM_INV_SHELVES'
         AND P.PARAM_CODE = 'MM_INV_SHELVES_IMPORT';
      COMMIT;
    ELSE
      RETURN;
    END IF;*\
    --执行业务
    V_IP_ADDRESS := SYS_CONTEXT('USERENV', 'IP_ADDRESS');
    V_OP_USER    := SYS_CONTEXT('USERENV', 'OS_USER');
    ERROR_TAG    := '0';
    FOR CUR IN (SELECT SHELVES_ADDR,
                       FACTORY_CODE,
                       PART_NO,
                       SUPPLIER_NO,
                       STANDARD_PACK,
                       SAFE_STOCK,
                       CAR_TYPE,
                       STACK_LAYERS,
                       ID

                  FROM MM_INV_SHELVES_LABEL_TEMP T
                 WHERE T.DEAL_FLAG != '1'
                   AND T.CHECK_FLAG = '1'
                 ORDER BY T.ID ASC) LOOP
      V_SHELVES_ADDR  := CUR.SHELVES_ADDR;
      V_FACTORY_CODE  := CUR.FACTORY_CODE;
      V_PART_NO       := CUR.PART_NO;
      V_SUPPLIER_NO   := CUR.SUPPLIER_NO;
      V_STANDARD_PACK := CUR.STANDARD_PACK;
      V_SAFE_STOCK    := CUR.SAFE_STOCK;
      V_CAR_TYPE      := CUR.CAR_TYPE;
      V_STACK_LAYERS  := CUR.STACK_LAYERS;
      V_ID            := CUR.ID;
      INSERT INTO MM_INV_SHELVES_LABEL
        (ID,
         SHELVES_ADDR,
         FACTORY_CODE,
         PART_NO,
         SUPPLIER_NO,
         STANDARD_PACK,
         SAFE_STOCK,
         CAR_TYPE,
         STACK_LAYERS,
         CREATION_USER,
         CREATION_TIME)
      VALUES
        (SEQ_MM_INV_SHELVES_TEMP.NEXTVAL,
         V_SHELVES_ADDR,
         V_FACTORY_CODE,
         V_PART_NO,
         V_SUPPLIER_NO,
         V_STANDARD_PACK,
         V_SAFE_STOCK,
         V_CAR_TYPE,
         V_STACK_LAYERS,
         V_OP_USER,
         SYSDATE);
      UPDATE MM_INV_SHELVES_LABEL_TEMP SET DEAL_FLAG = '1' WHERE ID = V_ID;
    END LOOP;
    \* --存储过程执行标识
    UPDATE MM_PUB_SYS_PARAM P
       SET P.PARAM_VAL = '0', P.LAST_MODIFIED_TIME = SYSDATE
     WHERE P.PARAM_GROUP = 'MM_INV_SHELVES'
       AND P.PARAM_CODE = 'MM_INV_SHELVES_IMPORT';*\
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ERROR_TAG := '1';
      ROLLBACK;
  END USP_MM_INV_SHELVES_IMPORT;*/
/*--***************************************************************************
  --存储过程名：USP_MATERIAL_IMPORT_CHECK
  --功能描述：资材订单反馈导入校验
  --参数说明：
  --IN_VAR_UUID
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  PROCEDURE USP_MATERIAL_IMPORT_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                      OUT_ERROR_FLAG    OUT VARCHAR2,
                                      OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
    V_SUB_NUM NUMBER;
  BEGIN

    UPDATE MM_SW_FEEDBACK_ZC_IMP A
       SET A.CHECK_INFO = '资材订单已反馈', A.CHECK_RESULT = '0'
     WHERE EXISTS (SELECT 1
              FROM MM_SW_FEEDBACK_ZC B
             WHERE A.PURCHASE_NO = B.PURCHASE_NO
               AND A.PURCHASE_ROWNO = B.PURCHASE_ROW_NO)
       AND A.IMP_UUID = IN_VAR_UUID
       AND A.CHECK_RESULT = '1';

    FOR CUR IN (SELECT IMP.PURCHASE_NO PURCHASE_NO,
                       IMP.PURCHASE_ROWNO PURCHASE_ROWNO,
                       COUNT(1) COUNT_ROW,
                       SUM(IMP.PLAN_NUM) SUM_NUM
                  FROM MM_SW_FEEDBACK_ZC_IMP IMP
                 WHERE IMP.IMP_UUID = IN_VAR_UUID
                   AND IMP.CHECK_RESULT = '1'
                 GROUP BY IMP.PURCHASE_NO, IMP.PURCHASE_ROWNO) LOOP

      SELECT (CUR.SUM_NUM - SUM(OD.ORDER_QTY))
        INTO V_SUB_NUM
        FROM MM_SW_ORDER_DETAIL OD
       WHERE OD.PURCHASE_NO = CUR.PURCHASE_NO
         AND OD.PURCHASE_ROWNO = CUR.PURCHASE_ROWNO
         AND NOT EXISTS
       (SELECT 1
                FROM MM_SW_FEEDBACK_ZC ZC
               WHERE ZC.PURCHASE_NO = OD.PURCHASE_NO
                 AND ZC.PURCHASE_ROW_NO = OD.PURCHASE_ROWNO);
      IF V_SUB_NUM = 0 AND CUR.COUNT_ROW >= 2 THEN
        UPDATE MM_SW_FEEDBACK_ZC_IMP IMP
           SET IMP.RETURN_STATUS = '2', IMP.CHECK_RESULT = '1'
         WHERE IMP.IMP_UUID = IN_VAR_UUID
           AND IMP.PURCHASE_NO = CUR.PURCHASE_NO
           AND IMP.PURCHASE_ROWNO = CUR.PURCHASE_ROWNO;
      ELSIF V_SUB_NUM = 0 AND CUR.COUNT_ROW = 1 THEN
        UPDATE MM_SW_FEEDBACK_ZC_IMP IMP
           SET IMP.RETURN_STATUS = '1', IMP.CHECK_RESULT = '1'
         WHERE IMP.IMP_UUID = IN_VAR_UUID
           AND IMP.PURCHASE_NO = CUR.PURCHASE_NO
           AND IMP.PURCHASE_ROWNO = CUR.PURCHASE_ROWNO;
      ELSE
        UPDATE MM_SW_FEEDBACK_ZC_IMP IMP
           SET IMP.CHECK_INFO   = '资材订单计划数汇总不等于订单采购数',
               IMP.CHECK_RESULT = '0'
         WHERE IMP.IMP_UUID = IN_VAR_UUID
           AND IMP.PURCHASE_NO = CUR.PURCHASE_NO
           AND IMP.PURCHASE_ROWNO = CUR.PURCHASE_ROWNO;
      END IF;
    END LOOP;

    UPDATE MM_SW_FEEDBACK_ZC_IMP A
       SET A.CHECK_INFO   = '订单号和订单行号对应的资材订单不存在',
           A.CHECK_RESULT = '0'
     WHERE NOT EXISTS (SELECT 1
              FROM MM_SW_ORDER_DETAIL B
              LEFT JOIN MM_SW_ORDER C
                ON B.PURCHASE_NO = C.PURCHASE_NO
               AND C.ORDER_TYPE = '14'
             WHERE A.PURCHASE_NO = B.PURCHASE_NO
               AND A.PURCHASE_ROWNO = B.PURCHASE_ROWNO)
       AND A.IMP_UUID = IN_VAR_UUID
       AND A.CHECK_RESULT = '1';
    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_PUB_CHECK.USP_SPSCONFIG_IMPORT_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END USP_MATERIAL_IMPORT_CHECK;
  --****************************************************************************/
END PKG_INV_CHECK;
/

prompt
prompt Creating package body PKG_INV_MAIN
prompt ==================================
prompt
create or replace package body PKG_INV_MAIN is

  --总装虚拟仓
  AF_PC_VIRTUAL_WAREHOUSE VARCHAR2(20) := 'AM11';
  --焊装虚拟仓
  WE_PC_VIRTUAL_WAREHOUSE VARCHAR2(20) := 'WM11';
  --总装零部件线边仓
  AF_LINE_WAREHOUSE VARCHAR2(20) := 'AW11';
  --焊装零部件线边仓
  WE_LINE_WAREHOUSE VARCHAR2(20) := 'WW11';
  --总装PC
  AF_PC_WAREHOUSE VARCHAR2(20) := 'AA11';
  --焊装PC
  WE_PC_WAREHOUSE VARCHAR2(20) := 'WA11';
  --总装下线点
  AF_OFF_POINT VARCHAR2(20) := 'AF-OFF';
  --焊装下线点
  WE_OFF_POINT VARCHAR2(20) := 'WE-OFF';
  --总装
  AF_WORKCENTER VARCHAR2(20) := 'A1';
  --焊装
  WE_WORKCENTER VARCHAR2(20) := 'W1';
  --协同订单类型
  SW_ORDERTYPE VARCHAR2(20) := 'SW';
  --拉动订单类型
  JIT_ORDERTYPE VARCHAR2(20) := 'JIT';
  --同步订单类型
  JISO_ORDERTYPE VARCHAR2(20) := 'JISO';
  --***************************************************************************
  --存储过程名：USP_INVENTORY_DEAL_MAIN
  --功能描述：库存处理
  --参数说明：
  --in_warehouse_type 仓库类型  0 表示零件仓库   1 表示虚拟仓库   2 表示线边仓库
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_INVENTORY_DEAL_MAIN(in_warehouse_type IN VARCHAR2) AS
    err_num number;
    err_msg varchar2(300);
    --工作中心
    v_workcenter varchar2(20);
    v_packnum    number;
  BEGIN
    --判断传入的仓库类型
    IF in_warehouse_type IS NOT NULL THEN
      IF in_warehouse_type = '0' THEN
        --如果为零件仓库
      
        --循环备件记录中为未处理的数据
        FOR cur_out IN (SELECT *
                          FROM MM_INV_OUT A
                        --找到库存处理标识为未处理的数据
                         WHERE A.INV_FLAG = 0
                           AND A.FROM_DEPOT_NO IS NOT NULL
                           AND A.PC_INV_FLAG = 0) LOOP
          FOR cur_out_detail IN (SELECT *
                                   FROM MM_INV_OUT_DETAIL B
                                  WHERE B.INV_OUT_NO = cur_out.INV_OUT_NO) LOOP
          
            --更新库存
            USP_MODIFY_INV_STOCK(cur_out.FROM_DEPOT_NO,
                                 cur_out_detail.PART_NO,
                                 - (cur_out_detail.REC_QTY),
                                 cur_out.FACTORY_CODE);
          END LOOP;
        
          --更新PC仓库存处理标识
          UPDATE MM_INV_OUT D
             SET D.PC_INV_FLAG = 1, D.PC_INV_TIME = SYSDATE
           WHERE D.INV_OUT_NO = cur_out.INV_OUT_NO;
        END LOOP;
      
        COMMIT;
      
      ELSIF in_warehouse_type = '1' THEN
        --如果为虚拟仓
        --循环备件记录中为未处理的数据
        FOR cur_out IN (SELECT *
                          FROM MM_INV_OUT A
                        --找到库存处理标识为未处理的数据, 但是PC仓库存处理标识为已处理的数据
                         WHERE A.INV_FLAG = 0
                           AND A.TO_DEPOT_NO IS NOT NULL
                           AND A.PC_INV_FLAG = 1) LOOP
          FOR cur_out_detail IN (SELECT *
                                   FROM MM_INV_OUT_DETAIL B
                                  WHERE B.INV_OUT_NO = cur_out.INV_OUT_NO) LOOP
            --更新或者新增库存数据
          
            --需要PDA那里将到货仓库写入记录里面，备件出库扫描厂内拉动配送票，配送票里面有信息点， 用信息点关联信息点表，得到工作中心
            --如果是总装则入总装虚拟缓存区8889，如果为焊装则入焊装虚拟缓存区9998
            --更新库存
            USP_MODIFY_INV_STOCK(cur_out.TO_DEPOT_NO,
                                 cur_out_detail.PART_NO,
                                 cur_out_detail.REC_QTY,
                                 cur_out.FACTORY_CODE);
          END LOOP;
        
          --更新PC仓库存处理标识
          UPDATE MM_INV_OUT D
             SET D.INV_FLAG = 1, D.INV_TIME = SYSDATE
           WHERE D.INV_OUT_NO = cur_out.INV_OUT_NO;
        END LOOP;
      
        COMMIT;
      
        /**上架扣减虚拟仓库存**/
        FOR cur_confirm_order IN (SELECT *
                                    FROM MM_INV_CONFIRM A
                                   WHERE A.VIRTUAL_INV_FLAG = 0
                                   ORDER BY A.CREATION_TIME) LOOP
          --判断这个条记录是是总装还是焊装
          IF cur_confirm_order.work_center = AF_WORKCENTER THEN
            --为总装
            FOR cur_confirm_detail IN (SELECT *
                                         FROM MM_INV_CONFIRM_DETAIL C
                                        WHERE C.CONFIRM_NO =
                                              cur_confirm_order.CONFIRM_NO) LOOP
            
              --更新库存
              USP_MODIFY_INV_STOCK(AF_PC_VIRTUAL_WAREHOUSE,
                                   cur_confirm_detail.PART_NO,
                                   - (cur_confirm_detail.REC_QTY),
                                   cur_confirm_order.FACTORY_CODE);
            END LOOP;
          ELSIF cur_confirm_order.work_center = WE_WORKCENTER THEN
            --为焊装
            FOR cur_confirm_detail IN (SELECT *
                                         FROM MM_INV_CONFIRM_DETAIL C
                                        WHERE C.CONFIRM_NO =
                                              cur_confirm_order.CONFIRM_NO) LOOP
            
              --更新库存
              USP_MODIFY_INV_STOCK(WE_PC_VIRTUAL_WAREHOUSE,
                                   cur_confirm_detail.PART_NO,
                                   - (cur_confirm_detail.REC_QTY),
                                   cur_confirm_order.FACTORY_CODE);
            END LOOP;
          END IF;
        
          --更新库存处理状态
          UPDATE MM_INV_CONFIRM D
             SET D.VIRTUAL_INV_FLAG = 1, D.VIRTUAL_INV_TIME = SYSDATE
           WHERE D.CONFIRM_NO = cur_confirm_order.CONFIRM_NO;
        END LOOP;
      
      ELSIF in_warehouse_type = '2' THEN
        --如果为线边仓
        /**上架新增线边仓库存**/
        FOR cur_confirm_order IN (SELECT *
                                    FROM MM_INV_CONFIRM A
                                   WHERE A.VIRTUAL_INV_FLAG = 1
                                     AND A.INV_FLAG = 0
                                   ORDER BY A.CREATION_TIME) LOOP
          --判断这个条记录是是总装还是焊装
          IF cur_confirm_order.work_center = AF_WORKCENTER THEN
            --为总装
            FOR cur_confirm_detail IN (SELECT *
                                         FROM MM_INV_CONFIRM_DETAIL C
                                        WHERE C.CONFIRM_NO =
                                              cur_confirm_order.CONFIRM_NO) LOOP
            
              --更新库存
              USP_MODIFY_INV_STOCK(AF_LINE_WAREHOUSE,
                                   cur_confirm_detail.PART_NO,
                                   cur_confirm_detail.REC_QTY,
                                   cur_confirm_order.FACTORY_CODE);
            END LOOP;
          ELSIF cur_confirm_order.work_center = WE_WORKCENTER THEN
            --为焊装
            FOR cur_confirm_detail IN (SELECT *
                                         FROM MM_INV_CONFIRM_DETAIL C
                                        WHERE C.CONFIRM_NO =
                                              cur_confirm_order.CONFIRM_NO) LOOP
            
              --更新库存
              USP_MODIFY_INV_STOCK(WE_LINE_WAREHOUSE,
                                   cur_confirm_detail.PART_NO,
                                   cur_confirm_detail.REC_QTY,
                                   cur_confirm_order.FACTORY_CODE);
            END LOOP;
          END IF;
        
          --更新库存处理状态
          UPDATE MM_INV_CONFIRM D
             SET D.INV_FLAG = 1, D.INV_TIME = SYSDATE
           WHERE D.CONFIRM_NO = cur_confirm_order.CONFIRM_NO;
        END LOOP;
      
        --ERP仓库转移数据处理,包含例外出库数据，线边仓例外领用通过这里，如果这里扣除了是否还需要在不良品扣减库存
        FOR cur_exc_out IN (SELECT *
                              FROM IF_INV_TRAN_ERP A
                             WHERE A.DEAL_FLAG = 0
                             ORDER BY A.CREATE_DATE, A.ID) LOOP
          FOR cur_exc_out_detail IN (SELECT *
                                       FROM IF_INV_TRAN_ERP_DETAIL B
                                      WHERE cur_exc_out.BUSINESS_NO =
                                            B.BUSINESS_NO) LOOP
            --直接从出货仓库扣减库存，当做是线边仓扣减
            USP_MODIFY_INV_STOCK(cur_exc_out_detail.FROM_DEPOT_NO,
                                 cur_exc_out_detail.PART_ID,
                                 - (cur_exc_out_detail.PART_NUM),
                                 cur_exc_out.COMP);
          END LOOP;
        
          --更新库存处理状态
          UPDATE IF_INV_TRAN_ERP D
             SET D.DEAL_FLAG = 1, D.DEAL_TIME = SYSDATE
           WHERE D.BUSINESS_NO = cur_exc_out.BUSINESS_NO;
        
        END LOOP;
      
        --**************************************************总装线边仓库存处理*******************************************************
        --?????不良品扣减库存
      
        /*--SPS指示票扣减库存
        FOR cur_sps_ins IN (SELECT A.*, B.WORKCENTER, B.FACTORY_CODE
                              FROM MM_SPS_INS A
                              LEFT JOIN MM_PUB_PLAN_CODE B
                                ON A.PLAN_CODE = B.PLAN_CODE
                             WHERE A.INV_FLAG = 0
                             ORDER BY A.CREATION_TIME) LOOP
        
          --判断工作中心
          IF cur_sps_ins.WORKCENTER = AF_WORKCENTER THEN
          
            FOR cur_sps_ins_detail IN (SELECT *
                                         FROM MM_SPS_INS_DETAIL C
                                        WHERE C.INS_NO = cur_sps_ins.INS_NO) LOOP
              --更新库存
              USP_MODIFY_INV_STOCK(AF_LINE_WAREHOUSE,
                                   cur_sps_ins_detail.PART_NO,
                                   - (cur_sps_ins_detail.QUANTITY),
                                   cur_sps_ins.FACTORY_CODE);
            
            END LOOP;
          ELSIF cur_sps_ins.WORKCENTER = WE_WORKCENTER THEN
            FOR cur_sps_ins_detail IN (SELECT *
                                         FROM MM_SPS_INS_DETAIL C
                                        WHERE C.INS_NO = cur_sps_ins.INS_NO) LOOP
              --更新库存
              USP_MODIFY_INV_STOCK(WE_LINE_WAREHOUSE,
                                   cur_sps_ins_detail.PART_NO,
                                   - (cur_sps_ins_detail.QUANTITY),
                                   cur_sps_ins.FACTORY_CODE);
            
            END LOOP;
          END IF;
        
          --更新库存处理状态
          UPDATE MM_SPS_INS D
             SET D.INV_FLAG = 1, D.INV_TIME = SYSDATE
           WHERE D.INS_NO = cur_sps_ins.INS_NO;
        
        END LOOP;
        
        --批次件关键件扣减库存
        FOR cur_key_part IN (SELECT *
                               FROM IF_KEYPART_BIND A
                              WHERE A.DEAL_FLAG = 0
                              ORDER BY A.CREATION_TIME, A.FACTORY_CODE, A.ID) LOOP
          --判断是关键件还是批次件
          IF cur_key_part.KEY_PART_TYPE = 1 THEN
            --如果是1是按键绑定,按关键件处理，直接扣除总装线边仓库存
            USP_MODIFY_INV_STOCK(AF_LINE_WAREHOUSE,
                                 cur_key_part.PART_NO,
                                 - (cur_key_part.BIND_NUM),
                                 cur_key_part.FACTORY_CODE);
          
          ELSIF cur_key_part.KEY_PART_TYPE = 2 THEN
            --如果是2是批次绑定,按批次件处理,按照二维码中的包装数扣除
            --解析二维码
            SELECT SUBSTR(cur_key_part.PART_BAR_CODE,
                          INSTR(cur_key_part.PART_BAR_CODE, '#', -1, 2) + 1,
                          INSTR(cur_key_part.PART_BAR_CODE, '#', -1, 1) -
                          INSTR(cur_key_part.PART_BAR_CODE, '#', -1, 2) - 1)
              INTO v_packnum
              FROM DUAL;
          
            USP_MODIFY_INV_STOCK(AF_LINE_WAREHOUSE,
                                 cur_key_part.PART_NO,
                                 - (v_packnum),
                                 cur_key_part.FACTORY_CODE);
          END IF;
        
          ----更新库存处理状态
          UPDATE IF_KEYPART_BIND D
             SET D.DEAL_FLAG = 1, D.DEAL_TIME = SYSDATE
           WHERE D.ID = cur_key_part.ID;
        
        END LOOP;
        
        --?????总装下线扣减库存
        FOR cur_af_pass IN (SELECT *
                              FROM IF_VEH_PASS A
                             WHERE A.DEAL_FLAG = 0
                               AND A.STATION_CODE = AF_OFF_POINT
                             ORDER BY A.PASS_TIME, A.ID) LOOP
        
          --找出所有需要扣减的零件
          FOR cur_af_part IN (SELECT A.PART_NO, A.NUM
                                FROM MM_PUB_ORDER_BOM A
                               WHERE A.ORDER_NO = cur_af_pass.ORDER_NO
                                 AND A.WORKCENTER = AF_WORKCENTER
                                 AND NOT EXISTS
                               (SELECT 1
                                      --排除SPS扣除过的零件
                                        FROM (SELECT C.PART_NO
                                                FROM MM_SPS_INS B
                                                LEFT JOIN MM_SPS_INS_DETAIL C
                                                  ON B.INS_NO = C.INS_NO
                                                LEFT JOIN MM_PUB_PLAN_CODE D
                                                  ON B.PLAN_CODE = D.PLAN_CODE
                                               WHERE B.VIN = cur_af_pass.VIN
                                                 AND D.FACTORY_CODE =
                                                     cur_af_pass.FACTORY_CODE
                                              UNION
                                              --排除关键件扣除过的零件
                                              SELECT E.PART_NO
                                                FROM IF_KEYPART_BIND E
                                               WHERE E.VIN = cur_af_pass.VIN
                                                 AND E.KEY_PART_TYPE = 1
                                                 AND E.FACTORY_CODE =
                                                     cur_af_pass.FACTORY_CODE
                                              --???????????排除批次件扣除过的零件
                                              ) F
                                       WHERE F.PART_NO = A.PART_NO)) LOOP
          
            --扣减总装零件仓库存
            USP_MODIFY_INV_STOCK(WE_LINE_WAREHOUSE,
                                 cur_af_part.PART_NO,
                                 - (cur_af_part.NUM),
                                 cur_af_pass.FACTORY_CODE);
          END LOOP;
        
          ----更新库存处理状态
          UPDATE IF_VEH_PASS D
             SET D.DEAL_FLAG = 1, D.DEAL_TIME = SYSDATE
           WHERE D.ID = cur_af_pass.ID;
        
        END LOOP;*/
      
        --总装下线扣减库存
        FOR cur_af_pass IN (SELECT *
                              FROM IF_VEH_PASS A
                             WHERE A.INV_FLAG = 0
                               AND A.STATION_CODE = AF_OFF_POINT
                             ORDER BY A.PASS_TIME, A.ID) LOOP
        
          --找出所有需要扣减的零件
          FOR cur_af_part IN (SELECT A.PART_NO, A.NUM
                                FROM MM_PUB_ORDER_BOM A
                               WHERE A.ORDER_NO = cur_af_pass.ERP_ORDER_NO
                                 AND A.WORKCENTER = AF_WORKCENTER
                                 AND A.PURCHASE_TYPE IN ('W', 'AW')) LOOP
          
            --扣减焊装零件仓库存
            USP_MODIFY_INV_STOCK(AF_LINE_WAREHOUSE,
                                 cur_af_part.PART_NO,
                                 - (cur_af_part.NUM),
                                 cur_af_pass.FACTORY_CODE);
          END LOOP;
        
          ----更新库存处理状态
          UPDATE IF_VEH_PASS D
             SET D.INV_FLAG = 1, D.INV_TIME = SYSDATE
           WHERE D.ID = cur_af_pass.ID;
        
        END LOOP;
      
        COMMIT;
      
        --*************************************************************************************************************************
      
        --**************************************************焊装线边仓库存处理*******************************************************
      
        --焊装下线扣减库存
        FOR cur_we_pass IN (SELECT *
                              FROM IF_VEH_PASS A
                             WHERE A.INV_FLAG = 0
                               AND A.STATION_CODE = WE_OFF_POINT
                             ORDER BY A.PASS_TIME, A.ID) LOOP
        
          --找出所有需要扣减的零件
          FOR cur_we_part IN (SELECT A.PART_NO, A.NUM
                                FROM MM_PUB_ORDER_BOM A
                               WHERE A.ORDER_NO = cur_we_pass.ERP_ORDER_NO
                                 AND A.WORKCENTER = WE_WORKCENTER
                                 AND A.PURCHASE_TYPE IN ('W', 'AW')) LOOP
          
            --扣减焊装零件仓库存
            USP_MODIFY_INV_STOCK(WE_LINE_WAREHOUSE,
                                 cur_we_part.PART_NO,
                                 - (cur_we_part.NUM),
                                 cur_we_pass.FACTORY_CODE);
          END LOOP;
        
          ----更新库存处理状态
          UPDATE IF_VEH_PASS D
             SET D.INV_FLAG = 1, D.INV_TIME = SYSDATE
           WHERE D.ID = cur_we_pass.ID;
        
        END LOOP;
      
        COMMIT;
      
        --*************************************************************************************************************************
      END IF;
    END IF;
  
    COMMIT;
  
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_INVENTORY_DEAL_MAIN',
           err_num,
           err_msg,
           sysdate,
           '库存处理');
        COMMIT;
      END;
  END USP_INVENTORY_DEAL_MAIN;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_INVENTORY_DEAL_MAIN
  --功能描述：库存处理
  --参数说明：
  --in_warehouse_type 仓库类型  0 表示零件仓库   1 表示虚拟仓库   2 表示线边仓库
  --创建人员: wangyu
  --创建时间： 2018/10/23
  PROCEDURE USP_INVENTORY_DEAL_SH_MAIN AS
    err_num number;
    err_msg varchar2(300);
    --工作中心
    v_workcenter varchar2(20);
    v_packnum    number;
  BEGIN
  
    --先从收货记录里面查询拉动订单未处理的收货数据
    FOR cur_rec_order IN (SELECT *
                            FROM MM_INV_IN A
                          --找到库存处理标识为未处理的数据
                           WHERE A.INV_FLAG = 0
                                --mod by zmj 20190805 先发送ERP再处理库存
                             AND A.DEAL_FLAG = 1
                             AND A.ORDER_TYPE = JIT_ORDERTYPE
                                --mod by zmj 20190805
                             AND EXISTS
                          --并且根据卸货口获取仓库代码都不为空的数据
                           (SELECT 1
                                    FROM MM_INV_IN G
                                    LEFT JOIN MM_INV_IN_DETAIL B
                                      ON G.REC_NO = B.REC_NO
                                    LEFT JOIN (SELECT D.PART_NO,
                                                     D.ORDER_NO,
                                                     E.WARE_CODE,
                                                     D.UNLOAD_PORT
                                                FROM (SELECT C.PART_NO,
                                                             C.ORDER_NO,
                                                             G.FACTORY_CODE,
                                                             MIN(C.UNLOAD_PORT) UNLOAD_PORT
                                                        FROM MM_JIT_LABEL C
                                                        LEFT JOIN MM_PUB_PLAN_CODE G
                                                          ON C.PLAN_CODE =
                                                             G.PLAN_CODE
                                                       GROUP BY C.PART_NO,
                                                                C.ORDER_NO,
                                                                G.FACTORY_CODE) D
                                                LEFT JOIN MM_INV_UNLOAD E
                                                  ON D.UNLOAD_PORT =
                                                     E.UNLOAD_PORT
                                                 AND E.FACTORY_CODE =
                                                     D.FACTORY_CODE
                                               WHERE D.UNLOAD_PORT IS NOT NULL
                                                 AND E.WARE_CODE IS NOT NULL) F
                                      ON B.PART_NO = F.PART_NO
                                     AND F.ORDER_NO = G.ORDER_NO
                                   WHERE B.REC_NO = A.REC_NO
                                        --mod by zmj 20190805 AND G.DEAL_FLAG = 0
                                     AND G.INV_FLAG = 0)) LOOP
      --循环拉动收货明细数据
      FOR cur_rec_detail IN (SELECT C.PART_NO, C.REC_QTY, G.WARE_CODE
                               FROM MM_INV_IN_DETAIL C
                               LEFT JOIN (SELECT E.PART_NO,
                                                E.ORDER_NO,
                                                F.WARE_CODE
                                           FROM (SELECT D.ORDER_NO,
                                                        D.PART_NO,
                                                        H.FACTORY_CODE,
                                                        MIN(D.UNLOAD_PORT) UNLOAD_PORT
                                                   FROM MM_JIT_LABEL D
                                                   LEFT JOIN MM_PUB_PLAN_CODE H
                                                     ON D.PLAN_CODE =
                                                        H.PLAN_CODE
                                                  WHERE D.ORDER_NO =
                                                        cur_rec_order.ORDER_NO
                                                    AND H.FACTORY_CODE =
                                                        cur_rec_order.FACTORY_CODE
                                                  GROUP BY D.ORDER_NO,
                                                           D.PART_NO,
                                                           H.FACTORY_CODE) E
                                           LEFT JOIN MM_INV_UNLOAD F
                                             ON E.UNLOAD_PORT =
                                                F.UNLOAD_PORT
                                            AND F.FACTORY_CODE =
                                                E.FACTORY_CODE) G
                                 ON C.PART_NO = G.PART_NO
                                AND G.ORDER_NO = cur_rec_order.ORDER_NO
                              WHERE C.REC_NO = cur_rec_order.REC_NO) LOOP
      
        --更新库存
        USP_MODIFY_INV_STOCK(cur_rec_detail.WARE_CODE,
                             cur_rec_detail.PART_NO,
                             cur_rec_detail.REC_QTY,
                             cur_rec_order.FACTORY_CODE);
      END LOOP;
    
      --更新库存处理状态
      UPDATE MM_INV_IN D
         SET D.INV_FLAG = 1, D.INV_TIME = SYSDATE
       WHERE D.REC_NO = cur_rec_order.REC_NO;
    END LOOP;
  
    COMMIT;
  
    --先从收货记录里面查询协同订单未处理的收货数据
    FOR cur_rec_order IN (SELECT A.*
                            FROM MM_INV_IN A
                            LEFT JOIN MM_SW_ORDER B
                              ON A.ORDER_NO = B.ORDER_NO
                          --找到库存处理标识为未处理的数据
                           WHERE A.INV_FLAG = 0
                             AND A.ORDER_TYPE = SW_ORDERTYPE
                             AND A.DEPOT_NO IS NOT NULL
                                --处理零件订单，长周期订单，例外订单，新车型订单
                             AND B.ORDER_TYPE IN ('01', '11', '02', '05')) LOOP
    
      FOR cur_rec_detail IN (SELECT *
                               FROM MM_INV_IN_DETAIL C
                              WHERE C.REC_NO = cur_rec_order.REC_NO) LOOP
        --更新库存
        USP_MODIFY_INV_STOCK(cur_rec_order.DEPOT_NO,
                             cur_rec_detail.PART_NO,
                             cur_rec_detail.REC_QTY,
                             cur_rec_order.FACTORY_CODE);
      
      END LOOP;
    
      --更新库存处理状态
      UPDATE MM_INV_IN D
         SET D.INV_FLAG = 1, D.INV_TIME = SYSDATE
       WHERE D.REC_NO = cur_rec_order.REC_NO;
    END LOOP;
  
    COMMIT;
  
    --同步收货入线边仓
    --先从收货记录里面查询同步订单未处理的收货数据
    FOR cur_rec_order IN (SELECT *
                            FROM MM_INV_IN A
                          --找到库存处理标识为未处理的数据
                           WHERE A.INV_FLAG = 0
                             AND A.ORDER_TYPE = JISO_ORDERTYPE) LOOP
    
      --判断这个订单是总装还是焊装
      BEGIN
        --若不相同则从差异量表中获取该路线该零件的差异量
        SELECT E.WORKCENTER
          INTO v_workcenter
          FROM MM_JISO_ORDER D
          LEFT JOIN MM_PUB_PLAN_CODE E
            ON D.PLAN_CODE = E.PLAN_CODE
         WHERE D.ORDER_NO = cur_rec_order.ORDER_NO;
      EXCEPTION
        WHEN OTHERS THEN
          v_workcenter := NULL;
      END;
    
      IF v_workcenter = AF_WORKCENTER THEN
        --为总装
        FOR cur_rec_detail IN (SELECT *
                                 FROM MM_INV_IN_DETAIL C
                                WHERE C.REC_NO = cur_rec_order.REC_NO) LOOP
          --支给件库存处理
          USP_SUPPORT_PART_DEAL(cur_rec_detail.Part_No,
                                cur_rec_order.FACTORY_CODE,
                                cur_rec_detail.REC_QTY);
        
          --更新库存
          USP_MODIFY_INV_STOCK(AF_LINE_WAREHOUSE,
                               cur_rec_detail.PART_NO,
                               cur_rec_detail.REC_QTY,
                               cur_rec_order.FACTORY_CODE);
        
        END LOOP;
      ELSIF v_workcenter = WE_WORKCENTER THEN
        --为焊装
        FOR cur_rec_detail IN (SELECT *
                                 FROM MM_INV_IN_DETAIL C
                                WHERE C.REC_NO = cur_rec_order.REC_NO) LOOP
          --支给件库存处理
          USP_SUPPORT_PART_DEAL(cur_rec_detail.Part_No,
                                cur_rec_order.FACTORY_CODE,
                                cur_rec_detail.REC_QTY);
        
          --更新库存
          USP_MODIFY_INV_STOCK(WE_LINE_WAREHOUSE,
                               cur_rec_detail.PART_NO,
                               cur_rec_detail.REC_QTY,
                               cur_rec_order.FACTORY_CODE);
        END LOOP;
      END IF;
    
      --更新库存处理状态
      UPDATE MM_INV_IN D
         SET D.INV_FLAG = 1, D.INV_TIME = SYSDATE
       WHERE D.REC_NO = cur_rec_order.REC_NO;
    END LOOP;
    COMMIT;
  
    --RGV收货
    /*    FOR cur_rec_order IN (SELECT *
                            FROM MM_JISO_INS_DETAIL_RECEIVE A
                          --找到库存处理标识为未处理的数据
                           WHERE A.DEAL_FLAG = 0
                           ORDER BY A.CREATION_TIME) LOOP
    
      --判断这个订单是总装还是焊装
      BEGIN
        --若不相同则从差异量表中获取该路线该零件的差异量
        SELECT E.WORKCENTER
          INTO v_workcenter
          FROM MM_JISO_INS D
          LEFT JOIN MM_PUB_PLAN_CODE E
            ON D.PLAN_CODE = E.PLAN_CODE
         WHERE D.INS_NO = cur_rec_order.INS_NO;
      EXCEPTION
        WHEN OTHERS THEN
          v_workcenter := NULL;
      END;
    
      IF v_workcenter = AF_WORKCENTER THEN
        --支给件库存处理
        USP_SUPPORT_PART_DEAL(cur_rec_order.Part_No,
                              cur_rec_order.FACTORY_CODE,
                              cur_rec_order.NUM);
      
        --更新库存
        USP_MODIFY_INV_STOCK(AF_LINE_WAREHOUSE,
                             cur_rec_order.PART_NO,
                             cur_rec_order.NUM,
                             cur_rec_order.FACTORY_CODE);
      
      ELSIF v_workcenter = WE_WORKCENTER THEN
        --支给件库存处理
        USP_SUPPORT_PART_DEAL(cur_rec_order.Part_No,
                              cur_rec_order.FACTORY_CODE,
                              cur_rec_order.NUM);
      
        --更新库存
        USP_MODIFY_INV_STOCK(WE_LINE_WAREHOUSE,
                             cur_rec_order.PART_NO,
                             cur_rec_order.NUM,
                             cur_rec_order.FACTORY_CODE);
      END IF;
    
      --更新库存处理状态
      UPDATE MM_JISO_INS_DETAIL_RECEIVE D
         SET D.DEAL_FLAG = 1, D.DEAL_TIME = SYSDATE
       WHERE D.INS_NO = cur_rec_order.INS_NO
         AND D.FACTORY_CODE = cur_rec_order.FACTORY_CODE
         AND D.VIN = cur_rec_order.VIN
         AND D.PART_NO = cur_rec_order.PART_NO;
    END LOOP;
    COMMIT;*/
  
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_INVENTORY_DEAL_SH_MAIN',
           err_num,
           err_msg,
           sysdate,
           '库存收货处理');
        COMMIT;
      END;
  END USP_INVENTORY_DEAL_SH_MAIN;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_INVENTORY_CAL_MAIN
  --功能描述：库存推移
  --参数说明：
  --in_factorycode 工厂
  --创建人员: wangyu
  --创建时间： 2018/11/22
  PROCEDURE USP_INVENTORY_CAL_MAIN(in_factorycode IN VARCHAR2) AS
    err_num number;
    err_msg varchar2(300);
    v_num   number;
    --推算了多少个小时
    v_inv_count number;
    --当前时间
    v_cur_date date;
  BEGIN
    v_inv_count := 1;
    v_cur_date  := SYSDATE;
    --先删除之前用于计算的车辆计划
    EXECUTE IMMEDIATE 'truncate table MM_INV_PRO_PLAN';
  
    --判断是否锁定
    SELECT A.TYPE_VALUE
      INTO v_num
      FROM MM_INV_LOCK A
     WHERE A.FACTORY = in_factorycode
       AND A.TYPE_NAME = 'IS_LOCK';
    IF v_num = 1 THEN
      RETURN;
    END IF;
  
    --获取推算状态
    SELECT A.TYPE_VALUE
      INTO v_num
      FROM MM_INV_LOCK A
     WHERE A.FACTORY = in_factorycode
       AND A.TYPE_NAME = 'IS_AUTO';
    IF v_num <> 1 THEN
      RETURN;
    END IF;
  
    --更新状态为锁定
    UPDATE MM_INV_LOCK A
       SET A.TYPE_VALUE = 1, A.END_DATE = NULL, A.BEGIN_DATE = SYSDATE
     WHERE A.FACTORY = in_factorycode
       AND A.TYPE_NAME = 'IS_LOCK';
  
    COMMIT;
  
    --初始化后续一天的车辆下线计划
    INSERT INTO MM_INV_PRO_PLAN
      (FACTORY_CODE,
       ORDER_NO,
       ORDER_TYPE,
       WEON_TIME,
       AFOFF_TIME,
       SORT_ID,
       MTOC,
       MODEL_CODE,
       PHASE,
       CREATION_TIME)
      SELECT A.FACTORY_CODE,
             A.ORDER_NO,
             A.ORDER_TYPE,
             A.WEON_TIME,
             A.AFOFF_TIME,
             A.SORT_ID,
             A.MTOC,
             A.MODEL_CODE,
             A.PHASE,
             SYSDATE
        FROM MM_PUB_PRO_PLAN A
       WHERE A.AFOFF_TIME >= SYSDATE
         AND A.AFOFF_TIME <= SYSDATE + 1
         AND A.FACTORY_CODE = in_factorycode;
    COMMIT;
  
    --初始化对应生产计划的BOM数据
    EXECUTE IMMEDIATE 'truncate table MM_INV_ORDER_BOM';
  
    --初始化BOM数据
    PKG_INV_MAIN.USP_INIT_BOM(in_factorycode);
  
    --先判断现在是不是启动过后第一次推算
    SELECT A.TYPE_VALUE
      INTO v_num
      FROM MM_INV_LOCK A
     WHERE A.FACTORY = in_factorycode
       AND A.TYPE_NAME = 'IS_FIRST';
    IF v_num <> 0 THEN
      --初始化库存
      USP_INIT_INV_BASE(in_factorycode, 'SYSTEM', '0');
    ELSE
      --初始化库存
      USP_INIT_INV_BASE(in_factorycode, 'SYSTEM', '1');
    END IF;
  
    --删除上次推移数据
    EXECUTE IMMEDIATE 'truncate table MM_INV_DEVELOP';
  
    LOOP
      --写入消耗的数据
      INSERT INTO MM_INV_DEVELOP
        (ID,
         FACTORY_CODE,
         WORK_CENTER,
         PART_NO,
         STOCK,
         PRO_QTY,
         PLAN_QTY,
         CAR_TYPE,
         CAL_POINT)
        SELECT PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_INV_DEVELOP'),
               in_factorycode,
               F.WORK_CENTER,
               F.PART_NO,
               NVL(F.ADJ_STOCK, NVL(F.STOCK, 0)) - NVL(N.PRE_TOTAL_NUM, 0) +
               NVL(N.PRE_ARRIVE_NUM, 0),
               NVL(N.PRO_NUM, 0) - NVL(N.PRE_TOTAL_NUM, 0),
               NVL(N.ARRIVE_NUM, 0) - NVL(N.PRE_ARRIVE_NUM, 0),
               N.MODEL_CODE,
               TO_DATE(TO_CHAR(v_cur_date + v_inv_count / 24,
                               'YYYY-MM-DD HH24:MI'),
                       'YYYY-MM-DD HH24:MI')
          FROM MM_INV_DEV_BASE_TEMP F
          LEFT JOIN (
                     --计划消耗处理
                     SELECT NVL(D.PART_NO, E.PART_NO) PART_NO,
                             NVL(D.WORKCENTER, E.WORK_CENTER) WORK_CENTER,
                             NVl(D.FACTORY_CODE, E.FACTORY_CODE) FACTORY_CODE,
                             NVL(D.MODEL_CODE, E.CAR_TYPE) MODEL_CODE,
                             NVL(D.TOTAL_NUM, 0) PRO_NUM,
                             NVL(E.TOTAL_NUM, 0) ARRIVE_NUM,
                             NVL(O.PRE_TOTAL_NUM, 0) PRE_TOTAL_NUM,
                             NVL(P.PRE_TOTAL_NUM, 0) PRE_ARRIVE_NUM
                       FROM (SELECT B.PART_NO,
                                     B.WORKCENTER,
                                     B.FACTORY_CODE,
                                     A.MODEL_CODE,
                                     SUM(B.NUM) TOTAL_NUM
                                FROM MM_INV_PRO_PLAN A
                                LEFT JOIN MM_INV_ORDER_BOM B
                                  ON A.FACTORY_CODE = B.FACTORY_CODE
                                 AND A.ORDER_NO = B.ORDER_NO
                               WHERE A.AFOFF_TIME >= v_cur_date
                                 AND A.AFOFF_TIME <
                                     v_cur_date + v_inv_count / 24
                                 AND A.FACTORY_CODE = in_factorycode
                                 AND EXISTS
                               (SELECT 1
                                        FROM MM_INV_DEV_BASE C
                                       WHERE B.WORKCENTER = C.WORK_CENTER
                                         AND A.FACTORY_CODE = C.FACTORY_CODE
                                         AND B.PART_NO = C.PART_NO
                                         AND C.FACTORY_CODE = in_factorycode)
                               GROUP BY B.PART_NO,
                                        B.WORKCENTER,
                                        B.FACTORY_CODE,
                                        A.MODEL_CODE) D
                     --到货处理
                       FULL JOIN (SELECT L.PART_NO,
                                         L.WORK_CENTER,
                                         L.CAR_TYPE,
                                         SUM(L.ORDER_QTY) TOTAL_NUM,
                                         L.FACTORY_CODE
                                    FROM (SELECT G.FACTORY_CODE,
                                                 I.PART_NO,
                                                 K.WORK_CENTER,
                                                 G.CAR_TYPE,
                                                 I.ORDER_QTY
                                            FROM MM_SW_PICKUP_PLAN G
                                            LEFT JOIN MM_SW_ORDER H
                                              ON G.ORDER_NO = H.ORDER_NO
                                            LEFT JOIN MM_SW_ORDER_DETAIL I
                                              ON H.ORDER_NO = I.ORDER_NO
                                            LEFT JOIN (SELECT MIN(J.WORK_CENTER) WORK_CENTER,
                                                             J.WARE_CODE
                                                        FROM MM_INV_UNLOAD J
                                                       GROUP BY J.WARE_CODE) K
                                              ON H.DEPOT_NO = K.WARE_CODE
                                           WHERE G.PLAN_ARR_TIME >= v_cur_date
                                             AND G.PLAN_ARR_TIME <
                                                 v_cur_date + v_inv_count / 24
                                             AND EXISTS
                                           (SELECT 1
                                                    FROM MM_INV_DEV_BASE_TEMP M
                                                   WHERE K.WORK_CENTER =
                                                         M.WORK_CENTER
                                                     AND G.FACTORY_CODE =
                                                         M.FACTORY_CODE
                                                     AND I.PART_NO = M.PART_NO
                                                     AND M.FACTORY_CODE =
                                                         in_factorycode)) L
                                   GROUP BY L.PART_NO,
                                            L.WORK_CENTER,
                                            L.CAR_TYPE,
                                            L.FACTORY_CODE) E
                         ON D.PART_NO = E.PART_NO
                        AND D.WORKCENTER = E.WORK_CENTER
                        AND D.FACTORY_CODE = E.FACTORY_CODE
                        AND D.MODEL_CODE = E.CAR_TYPE
                       FULL JOIN (SELECT B.PART_NO,
                                         B.WORKCENTER,
                                         B.FACTORY_CODE,
                                         A.MODEL_CODE,
                                         SUM(B.NUM) PRE_TOTAL_NUM
                                    FROM MM_INV_PRO_PLAN A
                                    LEFT JOIN MM_INV_ORDER_BOM B
                                      ON A.FACTORY_CODE = B.FACTORY_CODE
                                     AND A.ORDER_NO = B.ORDER_NO
                                   WHERE A.AFOFF_TIME >= v_cur_date
                                     AND A.AFOFF_TIME <
                                         v_cur_date + (v_inv_count - 1) / 24
                                     AND A.FACTORY_CODE = in_factorycode
                                     AND EXISTS
                                   (SELECT 1
                                            FROM MM_INV_DEV_BASE C
                                           WHERE B.WORKCENTER = C.WORK_CENTER
                                             AND A.FACTORY_CODE =
                                                 C.FACTORY_CODE
                                             AND B.PART_NO = C.PART_NO
                                             AND C.FACTORY_CODE =
                                                 in_factorycode)
                                   GROUP BY B.PART_NO,
                                            B.WORKCENTER,
                                            B.FACTORY_CODE,
                                            A.MODEL_CODE) O
                         ON D.PART_NO = O.PART_NO
                        AND D.WORKCENTER = O.WORKCENTER
                        AND D.FACTORY_CODE = O.FACTORY_CODE
                        AND D.MODEL_CODE = O.MODEL_CODE
                     --到货前一个小时到货数量处理
                       FULL JOIN (SELECT L.PART_NO,
                                         L.WORK_CENTER,
                                         L.CAR_TYPE,
                                         SUM(L.ORDER_QTY) PRE_TOTAL_NUM,
                                         L.FACTORY_CODE
                                    FROM (SELECT G.FACTORY_CODE,
                                                 I.PART_NO,
                                                 K.WORK_CENTER,
                                                 G.CAR_TYPE,
                                                 I.ORDER_QTY
                                            FROM MM_SW_PICKUP_PLAN G
                                            LEFT JOIN MM_SW_ORDER H
                                              ON G.ORDER_NO = H.ORDER_NO
                                            LEFT JOIN MM_SW_ORDER_DETAIL I
                                              ON H.ORDER_NO = I.ORDER_NO
                                            LEFT JOIN (SELECT MIN(J.WORK_CENTER) WORK_CENTER,
                                                             J.WARE_CODE
                                                        FROM MM_INV_UNLOAD J
                                                       GROUP BY J.WARE_CODE) K
                                              ON H.DEPOT_NO = K.WARE_CODE
                                           WHERE G.PLAN_ARR_TIME >= v_cur_date
                                             AND G.PLAN_ARR_TIME <
                                                 v_cur_date +
                                                 (v_inv_count - 1) / 24
                                             AND EXISTS
                                           (SELECT 1
                                                    FROM MM_INV_DEV_BASE_TEMP M
                                                   WHERE K.WORK_CENTER =
                                                         M.WORK_CENTER
                                                     AND G.FACTORY_CODE =
                                                         M.FACTORY_CODE
                                                     AND I.PART_NO = M.PART_NO
                                                     AND M.FACTORY_CODE =
                                                         in_factorycode)) L
                                   GROUP BY L.PART_NO,
                                            L.WORK_CENTER,
                                            L.CAR_TYPE,
                                            L.FACTORY_CODE) P
                         ON D.PART_NO = P.PART_NO
                        AND D.WORKCENTER = P.WORK_CENTER
                        AND D.FACTORY_CODE = P.FACTORY_CODE
                        AND D.MODEL_CODE = P.CAR_TYPE) N
            ON F.PART_NO = N.PART_NO
           AND F.WORK_CENTER = N.WORK_CENTER
           AND F.FACTORY_CODE = N.FACTORY_CODE;
    
      -- mod by wangyu 2019-06-03
      --因数据库频繁出现死锁，所以这里增加提交处理
      COMMIT;
    
      v_inv_count := v_inv_count + 1;
    
      EXIT WHEN v_inv_count > 504;
    
    END LOOP;
  
    --更新状态为未锁定
    UPDATE MM_INV_LOCK A
       SET A.TYPE_VALUE = 0, A.END_DATE = SYSDATE
     WHERE A.FACTORY = in_factorycode
       AND A.TYPE_NAME = 'IS_LOCK';
  
    --更新是否第一次为不是第一次
    UPDATE MM_INV_LOCK A
       SET A.TYPE_VALUE = 1
     WHERE A.FACTORY = in_factorycode
       AND A.TYPE_NAME = 'IS_FIRST';
  
    COMMIT;
  
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_INVENTORY_CAL_MAIN',
           err_num,
           err_msg,
           sysdate,
           '库存推移');
        COMMIT;
      END;
  END USP_INVENTORY_CAL_MAIN;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_INIT_BOM
  --功能描述：初始化库存推移BOM
  --参数说明：
  --in_factorycode 工厂
  --in_workcenter 工作中心
  --创建人员: wangyu
  --创建时间： 2018/11/23
  PROCEDURE USP_INIT_BOM(in_factorycode IN VARCHAR2) AS
    err_num number;
    err_msg varchar2(300);
  BEGIN
    --根据要推算的计划加载BOM数据
    INSERT INTO MM_INV_ORDER_BOM
      (FACTORY_CODE,
       ORDER_NO,
       PART_ROWNO,
       VEHICLE_PART_NO,
       PART_NO,
       WORKCENTER,
       STATION_CODE,
       NUM,
       USAGE_AMOUNT_UNIT,
       PURCHASE_TYPE,
       CREATION_TIME)
      SELECT A.FACTORY_CODE,
             A.ORDER_NO,
             B.PART_ROWNO,
             B.VEHICLE_PART_NO,
             B.PART_NO,
             B.WORKCENTER,
             B.STATION_CODE,
             B.NUM,
             B.USAGE_AMOUNT_UNIT,
             B.PURCHASE_TYPE,
             SYSDATE
        FROM MM_INV_PRO_PLAN A
        LEFT JOIN MM_PUB_ORDER_BOM B
          ON A.ORDER_NO = B.ORDER_NO
         AND A.FACTORY_CODE = B.FACTORY_CODE
       WHERE A.FACTORY_CODE = in_factorycode
         AND EXISTS (SELECT 1
                FROM MM_INV_DEV_BASE C
               WHERE B.WORKCENTER = C.WORK_CENTER
                 AND B.PART_NO = C.PART_NO);
    COMMIT;
  END USP_INIT_BOM;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_INIT_INV_BASE
  --功能描述：初始化库存
  --参数说明：
  --in_factorycode 工厂
  --创建人员: wangyu
  --创建时间： 2018/12/11
  PROCEDURE USP_INIT_INV_BASE(IN_VAR_FACTORY  IN VARCHAR2,
                              IN_VAR_USERNAME IN VARCHAR2,
                              IN_TYPE         IN VARCHAR2) AS
    err_num number;
    err_msg varchar2(300);
  BEGIN
    --表明不是第一次推算，需要获取实时库存
    DELETE FROM MM_INV_DEV_BASE_TEMP MID
     WHERE MID.FACTORY_CODE = IN_VAR_FACTORY;
  
    IF IN_TYPE = '0' THEN
      --写入基础库存临时表
      INSERT INTO MM_INV_DEV_BASE_TEMP
        (ID,
         FACTORY_CODE,
         PART_NO,
         STOCK,
         CREATION_TIME,
         CREATION_USER,
         WORK_CENTER)
        SELECT PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_INV_STOCK'),
               IN_VAR_FACTORY,
               MIS.PART_NO,
               SUM(MIS.STOCK),
               SYSDATE,
               IN_VAR_USERNAME,
               'A1' WORKCENTER
          FROM MM_INV_STOCK MIS
         WHERE MIS.FACTORY_CODE = IN_VAR_FACTORY
           AND MIS.WARE_CODE IN (AF_PC_WAREHOUSE,
                                 AF_LINE_WAREHOUSE,
                                 AF_PC_VIRTUAL_WAREHOUSE,
                                 AF_PC_VIRTUAL_WAREHOUSE)
           AND EXISTS
         (SELECT 1
                  FROM MM_MP_PART MMP
                 WHERE MIS.PART_NO = MMP.PART_NO
                   AND MMP.WORKCENTER = 'A1'
                   AND MIS.FACTORY_CODE = MMP.FACTORY_CODE)
         GROUP BY MIS.PART_NO
        UNION ALL
        SELECT PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_INV_STOCK'),
               IN_VAR_FACTORY,
               MIS.PART_NO,
               SUM(MIS.STOCK),
               SYSDATE,
               IN_VAR_USERNAME,
               'W1' WORKCENTER
          FROM MM_INV_STOCK MIS
         WHERE MIS.FACTORY_CODE = IN_VAR_FACTORY
           AND MIS.WARE_CODE IN (WE_PC_WAREHOUSE,
                                 WE_LINE_WAREHOUSE,
                                 WE_PC_VIRTUAL_WAREHOUSE,
                                 WE_PC_VIRTUAL_WAREHOUSE)
              --并且存在于取货零件中
           AND EXISTS
         (SELECT 1
                  FROM MM_MP_PART MMP
                 WHERE MIS.PART_NO = MMP.PART_NO
                   AND MMP.WORKCENTER = 'W1'
                   AND MIS.FACTORY_CODE = MMP.FACTORY_CODE)
         GROUP BY MIS.PART_NO;
    ELSIF IN_TYPE = '1' THEN
      --第一次计算直接将MM_INV_DEV_BASE的数据写入临时表
      INSERT INTO MM_INV_DEV_BASE_TEMP
        (ID,
         FACTORY_CODE,
         PART_NO,
         STOCK,
         ADJ_STOCK,
         CREATION_TIME,
         CREATION_USER,
         WORK_CENTER)
        SELECT PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_INV_STOCK'),
               A.FACTORY_CODE,
               A.PART_NO,
               A.STOCK,
               A.ADJ_STOCK,
               SYSDATE,
               A.CREATION_USER,
               A.WORK_CENTER
          FROM MM_INV_DEV_BASE A
         WHERE A.FACTORY_CODE = IN_VAR_FACTORY;
    END IF;
    COMMIT;
  END USP_INIT_INV_BASE;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_EC_OUT_INS
  --功能描述：空容器出库指示
  --参数说明：
  --in_factorycode 工厂
  --创建人员: wangyu
  --创建时间： 2018/12/06
  PROCEDURE USP_EC_OUT_INS(in_factorycode IN VARCHAR2, out_code OUT NUMBER) AS
    err_num number;
    err_msg varchar2(300);
  BEGIN
    out_code := 0;
  
    --写入空容器出库指示之前，先删除之前计算的空容器出库指示
    DELETE FROM MM_INV_EC_OUT_INS A WHERE A.FACTORY_CODE = in_factorycode;
  
    --生成空容器出库指示
    INSERT INTO MM_INV_EC_OUT_INS
      (ID,
       FACTORY_CODE,
       SUPPLIER_NO,
       CAR_TYPE,
       ROUTE_CODE,
       TOTAL_CAR_NO,
       BOX_TYPE,
       OUT_QTY,
       PICKUP_TIME,
       CREATION_USER,
       CREATION_TIME)
      SELECT PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_INV_EC_OUT_INS'),
             G.FACTORY_CODE,
             G.SUPPLIER_NO,
             G.CAR_TYPE,
             G.ROUTE_CODE,
             G.TOTAL_BATCHS,
             --如果为EU箱使用EU箱的算法
             --如果为台车使用台车的算法
             --如果为铁架使用铁架的算法
             DECODE(G.BOX_TYPE, 2, '0', '1', '1', '4', '4') BOX_TYPE,
             CASE
               WHEN G.BOX_TYPE = '2' THEN
               --使用体积计算需要多少托
                CEIL(SUM(G.BOX_NUM) / 0.8 / 1.2 / 1.1)
               WHEN G.BOX_TYPE = '1' THEN
                CEIL(SUM(G.BOX_NUM))
               WHEN G.BOX_TYPE = '4' THEN
                CEIL(SUM(G.BOX_NUM))
             END AS OUT_QTY,
             MIN(G.PLAN_PICKUP_TIME) PLAN_PICKUP_TIME,
             'SYSTEM',
             SYSDATE
        FROM (SELECT A.FACTORY_CODE,
                     B.SUPPLIER_NO,
                     A.CAR_TYPE,
                     A.ROUTE_CODE,
                     A.TOTAL_BATCHS,
                     A.PLAN_PICKUP_TIME,
                     F.BOX_TYPE,
                     C.PART_NO,
                     CASE
                       WHEN F.BOX_TYPE = 2 THEN
                        ROUND(C.ORDER_QTY / E.STANDARD_PACKAGE *
                              (F.PACK_LENGTH / 1000 * F.PACK_HEIGHT / 1000 *
                              F.PACK_WIDTH / 1000),
                              3)
                       WHEN F.BOX_TYPE = 1 THEN
                        ROUND(C.ORDER_QTY / E.STANDARD_PACKAGE)
                     END AS BOX_NUM
                FROM MM_SW_PICKUP_PLAN A
                LEFT JOIN MM_SW_ORDER B
                  ON A.PURCHASE_NO = B.PURCHASE_NO
                LEFT JOIN MM_SW_ORDER_DETAIL C
                  ON B.ORDER_NO = C.ORDER_NO
                LEFT JOIN MM_PKG_PROPOSAL D
                  ON B.SUPPLIER_NO = D.SUPPLIER_NO
                 AND C.PART_NO = D.PART_NO
                 AND D.PROPOSAL_STATUS = 5
                 AND D.EFF_START < SYSDATE
                 AND D.EFF_END > SYSDATE
                LEFT JOIN MM_PKG_PROPOSAL_DETAIL E
                  ON D.ID = E.PROPOSAL_ID
                LEFT JOIN MM_PKG_BOX F
                  ON E.BOX_CODE = F.BOX_CODE
                 AND F.STATUS = 1
               WHERE A.FACTORY_CODE = in_factorycode
                 AND F.BOX_TYPE IS NOT NULL) G
       GROUP BY G.FACTORY_CODE,
                G.SUPPLIER_NO,
                G.CAR_TYPE,
                G.ROUTE_CODE,
                G.TOTAL_BATCHS,
                G.BOX_TYPE;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_EC_OUT_INS',
           err_num,
           err_msg,
           sysdate,
           '空容器出库指示');
        COMMIT;
      END;
  END USP_EC_OUT_INS;

  --***************************************************************************
  --存储过程名：USP_MODIFY_INV_STOCK
  --功能描述：更新库存
  --参数说明：
  --in_warehouse 仓库类型
  --in_partno 零件号
  --in_quantity 数量
  --in_factorycode 工厂
  --创建人员: wangyu
  --创建时间： 2018/11/1
  PROCEDURE USP_MODIFY_INV_STOCK(in_warehouse   IN VARCHAR2,
                                 in_partno      IN VARCHAR2,
                                 in_quantity    IN NUMBER,
                                 in_factorycode IN VARCHAR2) AS
    err_num number;
    err_msg varchar2(300);
  BEGIN
    --更新或者新增库存数据
    MERGE INTO MM_INV_STOCK D
    USING (SELECT 1 FROM DUAL) E
    ON (D.WARE_CODE = in_warehouse AND D.PART_NO = in_partno AND D.FACTORY_CODE = in_factorycode)
    WHEN MATCHED THEN
      UPDATE
         SET D.STOCK              = NVL(D.STOCK, 0) + in_quantity,
             D.LAST_MODIFIED_TIME = SYSDATE
    WHEN NOT MATCHED THEN
      INSERT
        (ID,
         FACTORY_CODE,
         WARE_CODE,
         PART_NO,
         SAFE_STOCK,
         STOCK,
         CREATION_USER,
         CREATION_TIME)
      VALUES
        (SEQ_MM_INV_STOCK.NEXTVAL,
         in_factorycode,
         in_warehouse,
         in_partno,
         NULL,
         in_quantity,
         'SYSTEM',
         SYSDATE);
    --mod by zmj 20190804 库存转移修改
    /* COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        BEGIN
          ROLLBACK;
          err_num := sqlcode;
          err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                             1,
                             200);
          --异常的时候记录异常日志
          INSERT INTO MM_PUB_PRO_ERROR
            (id, alert_type, error_name, error_desc, creation_date, key_name)
          VALUES
            (seq_pub_pro_error.nextval,
             'USP_MODIFY_INV_STOCK',
             err_num,
             err_msg,
             sysdate,
             '更新库存');
          COMMIT;
        END;*/
  END USP_MODIFY_INV_STOCK;

  --***************************************************************************
  --存储过程名：USP_SUPPORT_PART_DEAL
  --功能描述：支给件库存处理
  --参数说明：
  --in_partno 零件号
  --in_factorycode 工厂
  --创建人员: wangyu
  --创建时间： 2019/04/13
  PROCEDURE USP_SUPPORT_PART_DEAL(in_partno      IN VARCHAR2,
                                  in_factorycode IN VARCHAR2,
                                  in_num         IN NUMBER) AS
    err_num number;
    err_msg varchar2(300);
    v_count number;
  
  BEGIN
  
    --判断该零件是否是总成件
    SELECT COUNT(1)
      INTO v_count
      FROM MM_PUB_SUPPORTING_PART A
     WHERE A.PARTF_ID = in_partno
       AND A.FACTORY_CODE = in_factorycode;
    IF v_count > 0 THEN
      --如果数量大于0则表明是总成件，需要扣除支给件的库存
      FOR cur_support_part IN (SELECT B.PART_NO,
                                      B.FACTORY_CODE,
                                      B.NEXT_PLACEMENT,
                                      in_num *
                                      MY_EVAL_NUMBER(1 ||
                                                     SYS_CONNECT_BY_PATH(B.NUM,
                                                                         '*')) NUM
                                 FROM MM_PUB_SUPPORTING_PART B
                                START WITH B.PARTF_ID = in_partno
                                       AND B.FACTORY_CODE = in_factorycode
                               CONNECT BY NOCYCLE
                                PRIOR B.PART_NO = B.PARTF_ID) LOOP
        USP_MODIFY_INV_STOCK(cur_support_part.NEXT_PLACEMENT,
                             cur_support_part.Part_No,
                             - (cur_support_part.Num),
                             cur_support_part.FACTORY_CODE);
      END LOOP;
    END IF;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_SUPPORT_PART_DEAL',
           err_num,
           err_msg,
           sysdate,
           '支给件库存处理');
        COMMIT;
      END;
  END USP_SUPPORT_PART_DEAL;

  --***************************************************************************
  --存储过程名：USP_INV_STOCK_GEN
  --功能描述：W-1周库存处理
  --参数说明：
  --in_factorycode 工厂
  --in_caluser 操作人
  --out_code 返回值
  --创建人员: wangyu
  --创建时间： 2019/05/14
  PROCEDURE USP_INV_STOCK_GEN(in_factorycode IN VARCHAR2,
                              in_caluser     IN VARCHAR2,
                              out_code       OUT NUMBER) AS
    err_num number;
    err_msg varchar2(300);
    v_count number;
  
  BEGIN
  
    DELETE FROM TEST_PART;
  
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_INV_STOCK_GEN',
           err_num,
           err_msg,
           sysdate,
           'W-1周库存处理');
        COMMIT;
      END;
  END USP_INV_STOCK_GEN;

  --***************************************************************************
  --存储过程名：USP_INV_GET_DIFFERENCE
  --功能描述：支给获取库存差异
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: luoxq
  --创建时间： 2019/05/30
  PROCEDURE USP_INV_GET_DIFFERENCE(in_arr_factory in VARCHAR2,
                                   in_account     in VARCHAR2,
                                   out_code       out VARCHAR2) AS
  
    err_num   number;
    err_msg   varchar2(200);
    V_NUM     NUMBER;
    v_count   number;
    v_count_a number;
    v_count_b number;
  BEGIN
    --每次生成之前删除上次的数据
    --EXECUTE IMMEDIATE 'truncate table mm_inv_difference';
    DELETE FROM MM_INV_DIFFERENCE;
    --删除支给件订单BOM
    --EXECUTE IMMEDIATE 'truncate table MM_SUPP_ORDER_BOM'; --新增之前删除临时支给bom
    DELETE FROM MM_INV_SUPP_ORDER_BOM;
    v_count := 1;
    select nvl(max(a.cal_week), 0)
      into v_count_a
      from mm_inv_week_cal a
     where a.factory_code = in_arr_factory;
  
    --初始化支给BOM数据
    INSERT INTO MM_INV_SUPP_ORDER_BOM
      (FACTORY_CODE,
       WARE_CODE,
       PART_NO,
       NUM,
       USAGE_AMOUNT_UNIT,
       PURCHASE_TYPE,
       CREATION_TIME,
       CREATION_USER,
       AFOFF_TIME)
      SELECT H.FACTORY_CODE,
             H.WARE_CODE,
             H.PART_NO,
             sum(H.NUM) NUM,
             H.USAGE_AMOUNT_UNIT,
             H.PURCHASE_TYPE,
             sysdate,
             in_account,
             to_date(TO_CHAR(H.AFOFF_TIME, 'YYYY-MM-DD'), 'yyyy-mm-dd')
        FROM (SELECT D.FACTORY_CODE,
                     CONNECT_BY_ROOT(D.ORDER_NO) ORDER_NO,
                     D. PART_ROWNO,
                     D.PART_NO,
                     D.WARE_CODE,
                     MY_EVAL_NUMBER(1 || SYS_CONNECT_BY_PATH(D.NUM, '*')) NUM,
                     D.USAGE_AMOUNT_UNIT,
                     D.PURCHASE_TYPE,
                     D. PARTF_ID,
                     SYSDATE,
                     in_account,
                     CONNECT_BY_ROOT(D.AFOFF_TIME) AFOFF_TIME
                FROM (SELECT A.FACTORY_CODE,
                             A.ORDER_NO,
                             A.MODEL_CODE,
                             A.PART_ROWNO,
                             A.VEHICLE_PART_NO,
                             A.PART_NO,
                             null                WARE_CODE,
                             A.STATION_CODE,
                             A.NUM,
                             A.USAGE_AMOUNT_UNIT,
                             NULL                PARTF_ID,
                             P.AFOFF_TIME        AFOFF_TIME,
                             A.PURCHASE_TYPE
                        FROM MM_PUB_ORDER_BOM A
                        LEFT JOIN MM_PUB_PRO_PLAN P
                          ON A.ORDER_NO = P.ORDER_NO
                       WHERE EXISTS (SELECT 1
                                FROM MM_PUB_PRO_PLAN B
                               WHERE A.ORDER_NO = B.ORDER_NO
                                 AND A.FACTORY_CODE = B.FACTORY_CODE)
                         AND trunc(P.AFOFF_TIME) >=
                             TRUNC(SYSDATE + 7, 'D') + 1
                         AND trunc(P.AFOFF_TIME) <
                             TRUNC(SYSDATE + 7, 'D') + 1 + v_count_a
                         AND A.FACTORY_CODE = in_arr_factory
                      UNION ALL
                      SELECT C.FACTORY_CODE,
                             NULL                  ORDER_NO,
                             NULL                  MODEL_CODE,
                             NULL                  PART_ROWNO,
                             NULL                  VEHICLE_PART_NO,
                             C.PART_NO,
                             C.NEXT_PLACEMENT      WARE_CODE,
                             C.LINE_STATION,
                             C.NUM,
                             C.USE_AGE_AMOUNT_UNIT,
                             C.PARTF_ID,
                             NULL                  AFOFF_TIME,
                             C.PURCHASE_TYPE
                        FROM MM_PUB_SUPPORTING_PART C
                       WHERE C.FACTORY_CODE = in_arr_factory) D
               START WITH D.ORDER_NO IS NOT NULL
              CONNECT BY NOCYCLE PRIOR D.PART_NO = D.PARTF_ID) H
       WHERE H.PURCHASE_TYPE = 'FW'
       group by H.FACTORY_CODE,
                H.WARE_CODE,
                H.PART_NO,
                H.USAGE_AMOUNT_UNIT,
                H.PURCHASE_TYPE,
                in_account,
                to_date(TO_CHAR(H.AFOFF_TIME, 'YYYY-MM-DD'), 'yyyy-mm-dd');
  
    COMMIT;
  
    --外层循环，循环次数，循环MM_INV_WEEK_CAL的最大天数
    --loop
    INSERT INTO MM_INV_DIFFERENCE
      (ID,
       FACTORY_CODE,
       PART_NO,
       WARE_CODE,
       BASE_NUM,
       USE_NUM,
       AF_DATE,
       CREATION_USER,
       CREATION_TIME)
      SELECT PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_INV_DIFFERENCE'),
             in_arr_factory,
             B.PART_NO,
             B.WARE_CODE,
             C.STOCK,
             B.NUM,
             --TRUNC(SYSDATE + 7, 'D') + 1 + v_count,
             B.AFOFF_TIME,
             in_account,
             SYSDATE
        FROM MM_INV_SUPP_ORDER_BOM B
        LEFT JOIN MM_INV_BENCHMARK C
          ON B.FACTORY_CODE = C.FACTORY_CODE
         AND B.WARE_CODE = C.WARE_CODE
         AND B.PART_NO = C.PART_NO
         AND C.FACTORY_CODE = in_arr_factory
       WHERE B.FACTORY_CODE = in_arr_factory
         AND B.AFOFF_TIME <= TRUNC(SYSDATE + 7, 'D') + 1 + v_count;
    --GROUP BY B.FACTORY_CODE, B.WARE_CODE, B.PART_NO;
  
    --v_count := v_count + 1;
    --当天数大于最大天数时推出外层循环
    --exit when v_count > v_count;
    --end loop;
    COMMIT;
    out_code := 0;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_INV_GET_DIFFERENCE',
           err_num,
           err_msg,
           sysdate,
           '支给库存获取差异查询');
        COMMIT;
        ROLLBACK;
      
      END;
  END USP_INV_GET_DIFFERENCE;

  --***************************************************************************
  --存储过程名：USP_INV_GET_DIFFERENCE
  --功能描述：支给获取库存差异
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: luoxq
  --创建时间： 2019/05/30
  PROCEDURE USP_INV_GET_DIFFERENCE_A(in_arr_factory in VARCHAR2,
                                     in_account     in VARCHAR2,
                                     out_code       out VARCHAR2) AS
  
    err_num   number;
    err_msg   varchar2(200);
    V_NUM     NUMBER;
    v_count   number;
    v_count_a number;
    v_count_b number;
  BEGIN
    --每次生成之前删除上次的数据
    EXECUTE IMMEDIATE 'truncate table mm_inv_difference';
    --DELETE FROM MM_INV_DIFFERENCE;
    --删除支给件订单BOM
    EXECUTE IMMEDIATE 'truncate table MM_INV_SUPP_ORDER_BOM'; --新增之前删除临时支给bom
    --DELETE FROM MM_INV_SUPP_ORDER_BOM;
    v_count := 1;
    select nvl(max(a.cal_week), 0)
      into v_count_a
      from mm_inv_week_cal a
     where a.factory_code = in_arr_factory;
    V_NUM := 0;
  
    LOOP
      --初始化支给BOM数据
      INSERT INTO MM_INV_SUPP_ORDER_BOM
        (FACTORY_CODE,
         WARE_CODE,
         PART_NO,
         NUM,
         USAGE_AMOUNT_UNIT,
         PURCHASE_TYPE,
         CREATION_TIME,
         CREATION_USER,
         AFOFF_TIME)
      
        SELECT H.FACTORY_CODE,
               H.WARE_CODE,
               H.PART_NO,
               --sum(H.NUM) NUM,
               H.NUM NUM,
               H.USAGE_AMOUNT_UNIT,
               H.PURCHASE_TYPE,
               sysdate,
               in_account,
               --to_date(TO_CHAR(H.AFOFF_TIME, 'YYYY-MM-DD'), 'yyyy-mm-dd')
               H.AFOFF_TIME
          FROM (SELECT D.FACTORY_CODE,
                       CONNECT_BY_ROOT(D.ORDER_NO) ORDER_NO,
                       D. PART_ROWNO,
                       D.PART_NO,
                       D.WARE_CODE,
                       MY_EVAL_NUMBER(1 || SYS_CONNECT_BY_PATH(D.NUM, '*')) NUM,
                       D.USAGE_AMOUNT_UNIT,
                       D.PURCHASE_TYPE,
                       D. PARTF_ID,
                       SYSDATE,
                       in_account,
                       CONNECT_BY_ROOT(D.AFOFF_TIME) AFOFF_TIME
                  FROM (SELECT A.FACTORY_CODE,
                               A.ORDER_NO,
                               A.MODEL_CODE,
                               A.PART_ROWNO,
                               A.VEHICLE_PART_NO,
                               A.PART_NO,
                               null                WARE_CODE,
                               A.STATION_CODE,
                               A.NUM,
                               A.USAGE_AMOUNT_UNIT,
                               NULL                PARTF_ID,
                               P.AFOFF_TIME        AFOFF_TIME,
                               A.PURCHASE_TYPE
                          FROM MM_PUB_ORDER_BOM A
                          LEFT JOIN MM_PUB_PRO_PLAN P
                            ON A.ORDER_NO = P.ORDER_NO
                         WHERE EXISTS (SELECT 1
                                  FROM MM_PUB_PRO_PLAN B
                                 WHERE A.ORDER_NO = B.ORDER_NO
                                   AND A.FACTORY_CODE = B.FACTORY_CODE)
                           AND trunc(P.AFOFF_TIME) =
                               TRUNC(SYSDATE + 7, 'D') + 1 + V_NUM
                              
                           AND A.FACTORY_CODE = in_arr_factory
                        UNION ALL
                        
                        SELECT C.FACTORY_CODE,
                               NULL                  ORDER_NO,
                               NULL                  MODEL_CODE,
                               NULL                  PART_ROWNO,
                               NULL                  VEHICLE_PART_NO,
                               C.PART_NO,
                               C.NEXT_PLACEMENT      WARE_CODE,
                               C.LINE_STATION,
                               C.NUM,
                               C.USE_AGE_AMOUNT_UNIT,
                               C.PARTF_ID,
                               NULL                  AFOFF_TIME,
                               C.PURCHASE_TYPE
                          FROM MM_PUB_SUPPORTING_PART C
                         WHERE C.FACTORY_CODE = in_arr_factory) D
                
                 START WITH D.ORDER_NO IS NOT NULL
                CONNECT BY NOCYCLE PRIOR D.PART_NO = D.PARTF_ID) H
         WHERE H.PURCHASE_TYPE = 'FW';
    
      V_NUM := V_NUM + 1;
    
      exit when V_NUM = v_count_a;
    END LOOP;
  
    COMMIT;
  
    --外层循环，循环次数，循环MM_INV_WEEK_CAL的最大天数
    --loop
    INSERT INTO MM_INV_DIFFERENCE
      (ID,
       FACTORY_CODE,
       PART_NO,
       WARE_CODE,
       BASE_NUM,
       USE_NUM,
       AF_DATE,
       CREATION_USER,
       CREATION_TIME)
      SELECT PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_INV_DIFFERENCE'),
             in_arr_factory,
             B.PART_NO,
             B.WARE_CODE,
             C.STOCK,
             SUM(B.NUM) USER_NUM,
             --TRUNC(SYSDATE + 7, 'D') + 1 + v_count,
             TRUNC(B.AFOFF_TIME),
             in_account,
             SYSDATE
        FROM MM_INV_SUPP_ORDER_BOM B
        LEFT JOIN MM_INV_BENCHMARK C
          ON B.FACTORY_CODE = C.FACTORY_CODE
         AND B.WARE_CODE = C.WARE_CODE
         AND B.PART_NO = C.PART_NO
         AND C.FACTORY_CODE = in_arr_factory
       WHERE B.FACTORY_CODE = in_arr_factory
         AND B.AFOFF_TIME <= TRUNC(SYSDATE + 7, 'D') + 1 + v_count_a
       GROUP BY B.FACTORY_CODE,
                B.WARE_CODE,
                B.PART_NO,
                TRUNC(B.AFOFF_TIME),
                C.STOCK;
  
    --v_count := v_count + 1;
    --当天数大于最大天数时推出外层循环
    --exit when v_count > v_count_a;
    --end loop;
    COMMIT;
    out_code := 0;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_INV_GET_DIFFERENCE',
           err_num,
           err_msg,
           sysdate,
           '支给库存获取差异查询');
        COMMIT;
        ROLLBACK;
      
      END;
  END USP_INV_GET_DIFFERENCE_A;

  --***************************************************************************
  --存储过程名：USP_INVENTORY_DEAL_MOVE_MAIN
  --功能描述：库存移动处理
  --创建人员: zmj
  --创建时间： 2019/08/03
  PROCEDURE USP_INVENTORY_DEAL_MOVE_MAIN AS
    err_num number;
    err_msg varchar2(300);
    --工作中心
    v_workcenter varchar2(20);
    v_packnum    number;
    v_flag       number(10);
    v_warecode   varchar2(20);
  BEGIN
    --备件库存移动
    FOR CUR_OUT IN (SELECT A.*, C.WORKCENTER
                      FROM MM_INV_OUT A, MM_JIT_INS B, MM_PUB_PLAN_CODE C
                     WHERE A.INS_NO = B.INS_NO
                       AND B.PLAN_CODE = C.PLAN_CODE
                       AND A.INV_FLAG = 0
                       AND A.INV_OUT_NO NOT LIKE 'RES%'
                     ORDER BY A.CREATION_TIME) LOOP
      FOR CUR_OUT_DETAIL IN (SELECT A.*, C.WARE_CODE
                               FROM MM_INV_OUT_DETAIL    A,
                                    MM_INV_PART_LOCATION B,
                                    MM_INV_UNLOAD        C
                              WHERE A.INV_OUT_NO = CUR_OUT.INV_OUT_NO
                                AND A.PART_NO = B.PART_NO
                                AND B.FACTORY_CODE = CUR_OUT.FACTORY_CODE
                                AND B.UNLOAD_PORT = C.UNLOAD_PORT
                                AND B.FACTORY_CODE = C.FACTORY_CODE
                                AND B.WORKCENTER = CUR_OUT.WORKCENTER
                                AND SYSDATE BETWEEN B.EFF_START AND
                                    B.EFF_END) LOOP
        --扣减物流库库存
        USP_MODIFY_INV_STOCK(CUR_OUT_DETAIL.WARE_CODE,
                             CUR_OUT_DETAIL.PART_NO,
                             - (CUR_OUT_DETAIL.REC_QTY),
                             CUR_OUT.FACTORY_CODE);
      
        --从物流库转移到对应车间的虚拟库
        IF CUR_OUT.WORKCENTER = 'A1' THEN
          --总装
          USP_MODIFY_INV_STOCK('AX11',
                               CUR_OUT_DETAIL.PART_NO,
                               (CUR_OUT_DETAIL.REC_QTY),
                               CUR_OUT.FACTORY_CODE);
        ELSIF CUR_OUT.WORKCENTER = 'W1' THEN
          --焊装
          USP_MODIFY_INV_STOCK('WX11',
                               CUR_OUT_DETAIL.PART_NO,
                               (CUR_OUT_DETAIL.REC_QTY),
                               CUR_OUT.FACTORY_CODE);
        END IF;
      END LOOP;
      --更新处理标识
      UPDATE MM_INV_OUT A
         SET A.INV_FLAG = 1, A.INV_TIME = SYSDATE
       WHERE A.INV_OUT_NO = CUR_OUT.INV_OUT_NO;
    END LOOP;
    COMMIT;
  
    --配送上架库存移动
    FOR CUR_CONFIRM IN (SELECT *
                          FROM MM_INV_CONFIRM A
                         WHERE A.INV_FLAG = 0
                         ORDER BY A.CREATION_TIME) LOOP
      FOR CUR_CONFIRM_DETAIL IN (SELECT *
                                   FROM MM_INV_CONFIRM_DETAIL A
                                  WHERE A.CONFIRM_NO =
                                        CUR_CONFIRM.CONFIRM_NO) LOOP
        --从虚拟仓转移到对应车间的线边仓
        IF CUR_CONFIRM.WORK_CENTER = 'A1' THEN
          --扣减总装虚拟仓库存
          USP_MODIFY_INV_STOCK('AX11',
                               CUR_CONFIRM_DETAIL.PART_NO,
                               - (CUR_CONFIRM_DETAIL.REC_QTY),
                               CUR_CONFIRM.FACTORY_CODE);
          --总装线边仓库存增加
          USP_MODIFY_INV_STOCK('AW11',
                               CUR_CONFIRM_DETAIL.PART_NO,
                               (CUR_CONFIRM_DETAIL.REC_QTY),
                               CUR_CONFIRM.FACTORY_CODE);
        
        ELSIF CUR_CONFIRM.WORK_CENTER = 'W1' THEN
          --如果是取货件，扣减虚拟仓库存，如果是拉动件，直接扣减P链库存
          --判断是否是拉动零件
          SELECT COUNT(1)
            INTO v_flag
            FROM MM_JIT_PART C, MM_PUB_PLAN_CODE D
           WHERE C.PART_NO = CUR_CONFIRM_DETAIL.PART_NO
             AND D.WORKCENTER = CUR_CONFIRM.WORK_CENTER
             AND C.PLAN_CODE = D.PLAN_CODE
             AND D.FACTORY_CODE = CUR_CONFIRM.FACTORY_CODE
             AND SYSDATE BETWEEN C.EFF_START AND C.EFF_END;
          --默认是取货零件，如果是拉动件，直接从P链出
          v_warecode := 'WX11';
          IF 0 < v_flag THEN
            v_warecode := 'WM11';
          END IF;
          USP_MODIFY_INV_STOCK(v_warecode,
                               CUR_CONFIRM_DETAIL.PART_NO,
                               - (CUR_CONFIRM_DETAIL.REC_QTY),
                               CUR_CONFIRM.FACTORY_CODE);
          --焊装线边库存增加
          USP_MODIFY_INV_STOCK('WW11',
                               CUR_CONFIRM_DETAIL.PART_NO,
                               (CUR_CONFIRM_DETAIL.REC_QTY),
                               CUR_CONFIRM.FACTORY_CODE);
        END IF;
      END LOOP;
      --更新处理标识
      UPDATE MM_INV_CONFIRM A
         SET A.INV_FLAG = 1, A.INV_TIME = SYSDATE
       WHERE A.CONFIRM_NO = CUR_CONFIRM.CONFIRM_NO;
    END LOOP;
    COMMIT;
  
    --ERP仓库转移数据处理,包含例外出库数据，线边仓例外领用通过这里，如果这里扣除了是否还需要在不良品扣减库存
    FOR cur_exc_out IN (SELECT *
                          FROM IF_INV_TRAN_ERP A
                         WHERE A.DEAL_FLAG = 0
                         ORDER BY A.CREATE_DATE, A.ID) LOOP
      FOR cur_exc_out_detail IN (SELECT *
                                   FROM IF_INV_TRAN_ERP_DETAIL B
                                  WHERE cur_exc_out.BUSINESS_NO =
                                        B.BUSINESS_NO) LOOP
        --直接从出货仓库扣减库存，当做是线边仓扣减
        USP_MODIFY_INV_STOCK(cur_exc_out_detail.FROM_DEPOT_NO,
                             cur_exc_out_detail.PART_ID,
                             - (cur_exc_out_detail.PART_NUM),
                             cur_exc_out.COMP);
      END LOOP;
    
      --更新库存处理状态
      UPDATE IF_INV_TRAN_ERP D
         SET D.DEAL_FLAG = 1, D.DEAL_TIME = SYSDATE
       WHERE D.BUSINESS_NO = cur_exc_out.BUSINESS_NO;
    
    END LOOP;
    COMMIT;
  
    --总装下线扣减库存
    FOR cur_af_pass IN (SELECT *
                          FROM IF_VEH_PASS A
                         WHERE A.INV_FLAG = 0
                           AND A.STATION_CODE = AF_OFF_POINT
                         ORDER BY A.PASS_TIME, A.ID) LOOP
    
      --找出所有需要扣减的零件
      FOR cur_af_part IN (SELECT A.PART_NO, A.NUM
                            FROM MM_PUB_ORDER_BOM A
                           WHERE A.ORDER_NO = cur_af_pass.ERP_ORDER_NO
                             AND A.WORKCENTER = AF_WORKCENTER
                             AND A.PURCHASE_TYPE IN ('W', 'AW')) LOOP
      
        --扣减焊装零件仓库存
        USP_MODIFY_INV_STOCK(AF_LINE_WAREHOUSE,
                             cur_af_part.PART_NO,
                             - (cur_af_part.NUM),
                             cur_af_pass.FACTORY_CODE);
      END LOOP;
    
      ----更新库存处理状态
      UPDATE IF_VEH_PASS D
         SET D.INV_FLAG = 1, D.INV_TIME = SYSDATE
       WHERE D.ID = cur_af_pass.ID;
    
    END LOOP;
  
    COMMIT;
  
    --*************************************************************************************************************************
  
    --**************************************************焊装线边仓库存处理*******************************************************
  
    --焊装下线扣减库存
    FOR cur_we_pass IN (SELECT *
                          FROM IF_VEH_PASS A
                         WHERE A.INV_FLAG = 0
                           AND A.STATION_CODE = WE_OFF_POINT
                         ORDER BY A.PASS_TIME, A.ID) LOOP
    
      --找出所有需要扣减的零件
      FOR cur_we_part IN (SELECT A.PART_NO, A.NUM
                            FROM MM_PUB_ORDER_BOM A
                           WHERE A.ORDER_NO = cur_we_pass.ERP_ORDER_NO
                             AND A.WORKCENTER = WE_WORKCENTER
                             AND A.PURCHASE_TYPE IN ('W', 'AW')) LOOP
      
        --扣减焊装零件仓库存
        USP_MODIFY_INV_STOCK(WE_LINE_WAREHOUSE,
                             cur_we_part.PART_NO,
                             - (cur_we_part.NUM),
                             cur_we_pass.FACTORY_CODE);
      END LOOP;
    
      ----更新库存处理状态
      UPDATE IF_VEH_PASS D
         SET D.INV_FLAG = 1, D.INV_TIME = SYSDATE
       WHERE D.ID = cur_we_pass.ID;
    
    END LOOP;
  
    COMMIT;
  
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_INVENTORY_DEAL_MOVE_MAIN',
           err_num,
           err_msg,
           sysdate,
           '移库处理');
        COMMIT;
      END;
  END USP_INVENTORY_DEAL_MOVE_MAIN;

  --***************************************************************************
  --存储过程名：USP_DEAL_MOVE_MAIN
  --功能描述：库存移动处理总成
  --创建人员: zmj
  --创建时间： 2019/08/04
  PROCEDURE USP_DEAL_MOVE_MAIN AS
    v_exec_start_time date; --存储过程执行开始时间点
    err_num           number;
    err_msg           varchar2(300);
  BEGIN
    v_exec_start_time := sysdate;
    --执行收货库存修改
    USP_INVENTORY_DEAL_SH_MAIN();
    --执行备件及上架库存修改
    USP_INVENTORY_DEAL_MOVE_MAIN();
    --执行库存转移发送ERP
    PKG_IF_SEND.USP_TRAN_MOVE_LMS();
    --统计存储过程执行消耗时间
    insert into mm_pub_exec_time_log
      (exec_code, exec_desc, start_time, end_time)
    values
      ('USP_DEAL_MOVE_MAIN',
       '库存移动处理总成',
       v_exec_start_time,
       sysdate);
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_DEAL_MOVE_MAIN',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_DEAL_MOVE_MAIN;

end PKG_INV_MAIN;
/

prompt
prompt Creating package body PKG_JISI
prompt ==============================
prompt
create or replace package body PKG_JISI is


  --****************************************************************************
  --过程名  : USP_JISI_GET_PASS_QUEUE
  --功能描述: 厂内同步获取车序队列
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-29
  --****************************************************************************
  PROCEDURE USP_JISI_GET_PASS_QUEUE(in_plan_code in varchar2) IS
    v_max_pass_time    mm_jiso_queue_config.max_pass_time%type; --已获取队列最大过点时间
    v_kb_product_seqno mm_jiso_queue_config.kb_product_seqno%type; --看板批次产品流水号
    v_kb_time          mm_jiso_queue_config.kb_time%type; --看板时间
    v_produce_time     number(10,3); --生产节拍
    v_exec_flag        number(1); --是否获取队列标志，0：未获取 1：获取
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    --获取过点车序队列配置表信息
    for cur_queue_config in (select a.factory_code, a.workcenter, a.station_code, b.*
                               from mm_pub_plan_code a,
                                    mm_jisi_queue_config b
                              where a.plan_code = b.plan_code
                                and a.plan_code = in_plan_code)
    loop
      v_max_pass_time    := cur_queue_config.max_pass_time;
      v_kb_product_seqno := cur_queue_config.kb_product_seqno;
      v_kb_time          := cur_queue_config.kb_time;

      --获取生产节拍???
      v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_queue_config.factory_code, cur_queue_config.workcenter, null);

      v_exec_flag := 0;
      --根据配置信息获取获取过点队列数据
      for cur_queue in (select a.*
                          from mm_pub_veh_pass a
                         where a.factory_code = cur_queue_config.factory_code
                           and a.station_code = cur_queue_config.station_code
                           and a.pass_time > cur_queue_config.max_pass_time
                         order by a.pass_time)
      loop
        v_exec_flag     :=1;
        v_kb_time       := PKG_PUB.USF_GET_NEXT_WORKTIME(cur_queue_config.factory_code, cur_queue_config.workcenter, v_kb_time, 1*v_produce_time);
        v_max_pass_time := cur_queue.pass_time;

        --车辆是否跳动看板，跳动赋予新的产品流水号（跟拉动共看板）
        for cur_param in (select a.param_val
                            from mm_pub_sys_param a, mm_pub_data_dict b
                           where a.factory_code = b.factory_code
                             and b.code_type = 'PUB_PHASE'
                             and a.factory_code = cur_queue.factory_code
                             and a.param_group = 'JIT_CAL'
                             and a.param_code like 'JIT_CAL_PHASE%'
                             and a.param_val = b.code_value_name
                             and b.code_value = cur_queue.phase)
        loop
          v_kb_product_seqno := v_kb_product_seqno + 1;
        end loop;

        --写入厂外同步推算队列
        insert into mm_jisi_veh_queue
          (plan_code,
           order_no,
           vin,
           model_code,
           phase,
           pass_time,
           wc_seqno,
           pl_seqno,
           kb_product_seqno,
           kb_time)
        values
          (in_plan_code,
           cur_queue.order_no,
           cur_queue.vin,
           cur_queue.model_code,
           cur_queue.phase,
           v_max_pass_time,
           cur_queue.wc_seqno,
           cur_queue.pl_seqno,
           v_kb_product_seqno,
           v_kb_time);
      end loop;

      --更新厂外同步过点车序队列配置信息
      if v_exec_flag = 1 then
        update mm_jisi_queue_config t
           set t.max_pass_time    = v_max_pass_time,
               t.kb_product_seqno = v_kb_product_seqno,
               t.kb_time          = v_kb_time
         where t.plan_code = in_plan_code;
      end if;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JISI_GET_PASS_QUEUE'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JISI_GET_PASS_QUEUE;

  --****************************************************************************
  --过程名  : USP_JISI_CREATE_INS
  --功能描述: 计算生成指示票
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-29
  --****************************************************************************
  PROCEDURE USP_JISI_CREATE_INS(in_plan_code in varchar2) IS
    v_factory_prefix   varchar(1); --指示票号:工厂前缀
    v_work_date        date; --当前时间的工作日期(不包含时分秒)
    v_printer_name     mm_pr_printer.printer_name%type; --打印机名称
    v_date_char        varchar(4); --指示票号:日期
    v_seq_no           number(4); --指示票号:流水
    v_ins_no           mm_sps_ins.ins_no%type; --指示票号
    v_factory_code     mm_pub_plan_code.factory_code%type; -- 工厂代码 mod by dtp 20190602
    v_flag             number(1); --临时标识
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    --i-LMS2019053001 mod by dtp
    for cur_fc in (select * from mm_pub_plan_code c where c.plan_code = in_plan_code)
      loop
        v_factory_code := cur_fc.factory_code;
      end loop;

    --遍历未组票的车辆信息
    for cur_queue in (select a.factory_code, a.workcenter, b.*
                        from mm_pub_plan_code  a,
                             mm_jisi_veh_queue b
                       where a.plan_code = b.plan_code
                         and b.exec_status = 0
                         and a.plan_code = in_plan_code
                       order by b.pass_time)
    loop
      --按打印机进行组票
      for cur_pr in (select distinct a.printer_id
                       from mm_jisi_partgroup a
                      where a.plan_code = cur_queue.plan_code
                        and a.eff_start <= cur_queue.pass_time
                        and a.eff_end > cur_queue.pass_time)
      loop
        --生成指示票号、分零件组指示票代码
        --获取前缀
        v_factory_prefix := null;
        for cur_prefix in (select a.factory_code_str
                             from mm_pub_bill_prefix a
                            where a.bill_group = 'JISI_INS'
                              and a.plan_code = in_plan_code)
        loop
          v_factory_prefix := cur_prefix.factory_code_str;
        end loop;
        v_work_date      := PKG_PUB.USF_GET_WORK_DATE(cur_queue.factory_code, cur_queue.workcenter, cur_queue.pass_time);
        v_date_char      := to_char(v_work_date, 'yyyy-mm-dd') ;
        select count(1)
          into v_flag
          from mm_jisi_ins_sn a
         where a.plan_code = cur_queue.plan_code
           and a.printer_id = cur_pr.printer_id
           and a.use_date = v_work_date;
        if v_flag = 0 then
          v_seq_no := 1;
          insert into mm_jisi_ins_sn
            (plan_code, printer_id, use_date, seq_no)
          values
            (cur_queue.plan_code, cur_pr.printer_id, v_work_date, 1);
        else
          select seq_no + 1
            into v_seq_no
            from mm_jisi_ins_sn a
           where a.plan_code = cur_queue.plan_code
             and a.printer_id = cur_pr.printer_id
             and a.use_date = v_work_date;
          update mm_jisi_ins_sn a
             set a.seq_no = v_seq_no
           where a.plan_code = cur_queue.plan_code
             and a.printer_id = cur_pr.printer_id
             and a.use_date = v_work_date;
        end if;
        select a.printer_name
          into v_printer_name
          from mm_pr_printer a
         where a.id = cur_pr.printer_id;
        v_ins_no := v_factory_prefix|| v_date_char || v_printer_name || lpad(v_seq_no, 4, '0');

        --写入指示票主信息
        insert into mm_jisi_ins
          (ins_no,
           plan_code,
           printer_id,
           order_no,
           vin,
           model_code,
           wc_seqno,
           pl_seqno,
           pass_time,
           kb_product_seqno,
           kb_time)
        values
          (v_ins_no,
           cur_queue.plan_code,
           cur_pr.printer_id,
           cur_queue.order_no,
           cur_queue.vin,
           cur_queue.model_code,
           cur_queue.wc_seqno,
           cur_queue.pl_seqno,
           cur_queue.pass_time,
           cur_queue.kb_product_seqno,
           cur_queue.kb_time);
        --写入指示票明细信息
        insert into mm_jisi_ins_detail
          (ins_no,
           print_location,
           part_no,
           require_num,
           partgroup_no,
           partgroup_name,
           part_short_no,
           part_name,
           part_mark,
           location)
          select v_ins_no,
                 a.print_location,
                 c.part_no,
                 sum(c.num) require_num,
                 a.partgroup_no,
                 p.part_short_no,
                 a.partgroup_name,
                 p.part_name_cn,
                 b.part_mark,
                 min(d.location)
            from mm_jisi_partgroup    a,
                 mm_jisi_part         b,
                 mm_pub_order_bom     c
            left join mm_inv_part_location d
              on d.factory_code = c.factory_code
             and d.workcenter = c.workcenter
             and d.part_no = c.part_no
             and d.station_code = c.station_code
             and d.eff_start <= cur_queue.pass_time
             and d.eff_end > cur_queue.pass_time
             --i-LMS2019053001 mod by dtp
            left join mm_pub_part p
              on p.part_no = c.part_no and p.factory_code = v_factory_code
           where a.plan_code = cur_queue.plan_code
             and a.printer_id = cur_pr.printer_id
             and a.eff_start <= cur_queue.pass_time
             and a.eff_end > cur_queue.pass_time
             and b.partgroup_id = a.id
             and b.eff_start <= cur_queue.pass_time
             and b.eff_end > cur_queue.pass_time
             and c.factory_code = cur_queue.factory_code
             and c.order_no = cur_queue.order_no
             and c.workcenter = cur_queue.workcenter
             and c.part_no = b.part_no
           group by a.print_location,
                    c.part_no,
                    a.partgroup_no,
                    p.part_short_no,
                    a.partgroup_name,
                    p.part_name_cn,
                    b.part_mark,
                    d.location;
      end loop;

      --更新车序组票状态
      update mm_jisi_veh_queue a
         set a.exec_status = 1, a.exec_time = sysdate
       where a.plan_code = cur_queue.plan_code
         and a.order_no = cur_queue.order_no
         and a.exec_status = 0;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JISI_CREATE_INS'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JISI_CREATE_INS;

  --****************************************************************************
  --过程名  : USP_JISI_CAL_EXEC
  --功能描述: 执行厂内同步推算
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-29
  --****************************************************************************
  PROCEDURE USP_JISI_CAL_EXEC(in_plan_code in varchar2) IS
    v_flag             number(1); --临时标识
    v_exec_start_time  date; --存储过程执行开始时间点
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    --判断自动计算服务是否开启
    select a.is_auto_exec into v_flag from mm_pub_plan_code a where a.plan_code = in_plan_code;
    if v_flag = 0 then
      return;
    end if;
    --判断执行标识位是否为执行中
    select a.exec_state into v_flag from mm_pub_plan_code a where a.plan_code = in_plan_code;
    if v_flag = 1 then
      return;
    end if;
    --更新执行标识位为执行中
    update mm_pub_plan_code a
       set a.exec_state = 1
     where a.plan_code = in_plan_code;
    commit;

    v_exec_start_time := sysdate;
    --获取推算队列
    USP_JISI_GET_PASS_QUEUE(in_plan_code);
    --组票
    USP_JISI_CREATE_INS(in_plan_code);

    --更新执行标识位为未执行
    update mm_pub_plan_code a
       set a.exec_state = 0, a.last_exec_time = v_exec_start_time
     where a.plan_code = in_plan_code;

    --统计存储过程执行消耗时间
    insert into mm_pub_exec_time_log
      (exec_code, exec_desc, start_time, end_time)
    values
      ('USP_JISI_CAL_EXEC'||in_plan_code, '执行厂内同步推算', v_exec_start_time, sysdate);

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JISI_CAL_EXEC'||in_plan_code, err_num, err_msg, sysdate,'');

        --更新执行标识位为未执行
        update mm_pub_plan_code a
           set a.exec_state = 0
         where a.plan_code = in_plan_code;
        COMMIT;
  END USP_JISI_CAL_EXEC;

end PKG_JISI;
/

prompt
prompt Creating package body PKG_JISO
prompt ==============================
prompt
create or replace package body PKG_JISO is

  --****************************************************************************
  --过程名  : USP_JISO_GET_PASS_QUEUE
  --功能描述: 厂外同步获取车序队列
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-11
  --修改记录：
  --          定制化订单-新增销售单写入 mod by wxl 20190315
  --          调整车辆下线时间计算 mod by wxl 20190413
  --****************************************************************************
  PROCEDURE USP_JISO_GET_PASS_QUEUE(in_plan_code in varchar2) IS
    v_max_pass_time    mm_jiso_queue_config.max_pass_time%type; --已获取队列最大过点时间
    v_kb_product_seqno mm_jiso_queue_config.kb_product_seqno%type; --看板批次产品流水号
    v_kb_time          mm_jiso_queue_config.kb_time%type; --看板时间
    v_produce_time     number(10,3); --生产节拍
    --v_kb_num           number(10); --信息点至看板工程深度
    v_exec_flag        number(1); --是否获取队列标志，0：未获取 1：获取
    v_loc_num          number(19); --车间工深
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    --获取厂外同步过点车序队列配置表信息
    for cur_queue_config in (select a.factory_code, a.workcenter, a.station_code, b.*
                               from mm_pub_plan_code a,
                                    mm_jiso_queue_config b
                              where a.plan_code = b.plan_code
                                and a.plan_code = in_plan_code)
    loop
      v_max_pass_time    := cur_queue_config.max_pass_time;
      v_kb_product_seqno := cur_queue_config.kb_product_seqno;
      v_kb_time          := cur_queue_config.kb_time;

      --获取生产节拍???
      v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_queue_config.factory_code, cur_queue_config.workcenter, null);

      v_exec_flag := 0;
      --根据配置信息获取获取过点队列数据
      for cur_queue in (select a.*
                          from mm_pub_veh_pass a
                         where a.factory_code = cur_queue_config.factory_code
                           and a.station_code = cur_queue_config.station_code
                           and a.pass_time > cur_queue_config.max_pass_time
                         order by a.pass_time)
      loop
        v_exec_flag     :=1;
        --获取过看板时间???
        --mod by wxl 20190413
        --v_kb_time       := PKG_PUB.USF_GET_NEXT_WORKTIME(cur_queue_config.factory_code, cur_queue_config.workcenter, v_kb_time, 1*v_produce_time);
        v_loc_num := NVL(to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_queue_config.factory_code, 'MAX_LOC', 'PBS_TOTAL_PRO_NUM')),0) + NVL(to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_queue_config.factory_code, 'MAX_LOC', 'AF_TOTAL_PRO_NUM')),0);
        v_kb_time := PKG_PUB.USF_GET_NEXT_WORKTIME(cur_queue_config.factory_code, cur_queue_config.workcenter, cur_queue.pass_time, v_loc_num*v_produce_time);
        v_max_pass_time := cur_queue.pass_time;

        --车辆是否跳动看板，跳动赋予新的产品流水号（跟拉动共看板）
        for cur_param in (select a.param_val
                            from mm_pub_sys_param a, mm_pub_data_dict b
                           where a.factory_code = b.factory_code
                             and b.code_type = 'PUB_PHASE'
                             and a.factory_code = cur_queue.factory_code
                             and a.param_group = 'JIT_CAL'
                             and a.param_code like 'JIT_CAL_PHASE%'
                             and a.param_val = b.code_value_name
                             and b.code_value = cur_queue.phase)
        loop
          v_kb_product_seqno := v_kb_product_seqno + 1;
        end loop;

        --写入厂外同步推算队列
        insert into mm_jiso_veh_queue
          (plan_code,
           order_no,
           erp_order_no,
           sale_no,
           sale_rowno,
           vin,
           model_code,
           phase,
           pass_time,
           wc_seqno,
           pl_seqno,
           kb_product_seqno,
           kb_time)
        values
          (in_plan_code,
           cur_queue.order_no,
           cur_queue.erp_order_no,
           cur_queue.sale_no,
           cur_queue.sale_rowno,
           cur_queue.vin,
           cur_queue.model_code,
           cur_queue.phase,
           v_max_pass_time,
           cur_queue.wc_seqno,
           cur_queue.pl_seqno,
           v_kb_product_seqno,
           v_kb_time);
      end loop;

      --更新厂外同步过点车序队列配置信息
      if v_exec_flag = 1 then
        update mm_jiso_queue_config t
           set t.max_pass_time    = v_max_pass_time,
               t.kb_product_seqno = v_kb_product_seqno,
               t.kb_time          = v_kb_time
         where t.plan_code = in_plan_code;
      end if;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JISO_GET_PASS_QUEUE_'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JISO_GET_PASS_QUEUE;

  --****************************************************************************
  --过程名  : USP_JISO_CAL_NET_REQ
  --功能描述: 计算零件净需求
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-11
  --修改记录：
  --          定制化订单-新增销售单写入 mod by wxl 20190315
  --****************************************************************************
  PROCEDURE USP_JISO_CAL_NET_REQ(in_plan_code in varchar2) IS
    v_work_date           DATE; --当前时间的工作日期(不包含时分秒)
    v_partgroup_num       mm_jiso_veh_queue.partgroup_num%type; --同步零件组总数
    v_cal_flag            number; --是否计算需求，0：不计算需求 1：计算需求
    v_flag                number; --临时标识
    v_supplier_name       mm_pub_part_uda.part_name_cn%type; --供应商名称
    v_factory_code        mm_pub_plan_code.factory_code%type; --mod by dtp 20190602 新增工厂代码
    err_num               number(10); --错误代码
    err_msg               varchar2(200); --错误信息
  BEGIN
    --mod by dtp 20190602 新增工厂代码
    for cur_fc in (select * from mm_pub_plan_code c where c.plan_code = in_plan_code)
      loop
        v_factory_code := cur_fc.factory_code;
      end loop;
    --遍历未产生净需求的车
    for cur_queue in (select a.factory_code, a.workcenter, b.*
                        from mm_pub_plan_code  a,
                             mm_jiso_veh_queue b
                       where a.plan_code = b.plan_code
                         and b.exec_status = 0
                         and a.plan_code = in_plan_code
                       order by b.pass_time)
    loop
      --根据生产阶段获取计算标识
      v_cal_flag := 0;
      for cur_param in (select a.param_val
                          from mm_pub_sys_param a, mm_pub_data_dict b
                         where a.factory_code = b.factory_code
                           and b.code_type = 'PUB_PHASE'
                           and a.factory_code = cur_queue.factory_code
                           and a.param_group = 'JISO_CAL'
                           and a.param_code like 'JISO_CAL_PHASE%'
                           and a.param_val = b.code_value_name
                           and b.code_value = cur_queue.phase)
      loop
        v_cal_flag := 1;
      end loop;

      --获取工作日期(不包含时分秒)
      v_work_date := PKG_PUB.USF_GET_WORK_DATE(cur_queue.factory_code, cur_queue.workcenter, cur_queue.pass_time);

      --遍历所有生效的厂外同步零件组
      v_partgroup_num := 0;
      for cur_partgroup in(select distinct a.id, a.partgroup_no
                             from mm_jiso_partgroup       a,
                                  mm_jiso_partgroup_route b
                            where a.id = b.partgroup_id
                              and a.plan_code = in_plan_code
                              and a.eff_start <= v_work_date and a.eff_end > v_work_date
                              and b.eff_start <= v_work_date and b.eff_end > v_work_date)
      loop
        v_partgroup_num := v_partgroup_num + 1;
        --判断零件组与零件对应关系是否存在
        /*
        select count(1)
          into v_flag
          from mm_jiso_partgroup a,
               mm_jiso_partgroup_route b,
               mm_jiso_part c,
               mm_pub_part_uda d
         where a.id = b.partgroup_id
           and a.id = c.partgroup_id
           and d.factory_code = cur_queue.factory_code
           and c.part_no = d.part_no
           and b.supplier_no = d.supplier_no
           and b.sup_factory = d.sup_factory
           and a.eff_start <= v_work_date and a.eff_end > v_work_date
           and b.eff_start <= v_work_date and b.eff_end > v_work_date
           and c.eff_start <= v_work_date and c.eff_end > v_work_date
           and a.id = cur_partgroup.id;
        */
        select count(1)
          into v_flag
          from mm_jiso_partgroup       a,
               mm_jiso_partgroup_route b,
               mm_jiso_part            c,
               mm_pub_part_uda         d,
               mm_pub_order_bom        e
         where a.id = b.partgroup_id
           and a.id = c.partgroup_id
           and d.factory_code = cur_queue.factory_code
           and c.model_code = cur_queue.model_code
           and c.part_no = d.part_no
           and b.supplier_no = d.supplier_no
           and b.sup_factory = d.sup_factory
           and a.eff_start <= v_work_date
           and a.eff_end > v_work_date
           and b.eff_start <= v_work_date
           and b.eff_end > v_work_date
           and c.eff_start <= v_work_date
           and c.eff_end > v_work_date
           and a.id = cur_partgroup.id
           and e.factory_code = cur_queue.factory_code
           and e.order_no = cur_queue.erp_order_no
           and e.workcenter = cur_queue.workcenter
           and e.part_no = c.part_no
           and rownum = 1;
        if v_flag = 0 or v_cal_flag = 0 then
          --如果零件组与零件对应关系数据没有维护 或 不计算需求，随机取一路线数据，写入空需求
          --是否考虑上一张单据的路线???
          for cur_route in (select *
                              from (select 1 seq,a.partgroup_no,a.sup_factory,a.route_code, a.route_desc, a.supplier_no
                                      from mm_jiso_net_req a
                                     where a.plan_code = in_plan_code
                                       and a.partgroup_no = cur_partgroup.partgroup_no
                                       and a.pass_time =
                                           (select max(b.pass_time)
                                              from mm_jiso_net_req b
                                             where b.plan_code = a.plan_code
                                               and b.partgroup_no = a.partgroup_no)
                                    union
                                    select 2 seq, a.partgroup_no, b.sup_factory, b.route_code, b.route_desc, b.supplier_no
                                      from mm_jiso_partgroup a,
                                           mm_jiso_partgroup_route b
                                     where a.id = b.partgroup_id
                                       and a.plan_code = in_plan_code
                                       and a.id = cur_partgroup.id
                                       and a.eff_start <= v_work_date and a.eff_end > v_work_date
                                       and b.eff_start <= v_work_date and b.eff_end > v_work_date
                                   )
                             order by seq)

          loop
            v_supplier_name := null;
            --i-LMS2019053001 mod by dtp
            for cur_sup in (select a.supplier_name
                              from mm_pub_part_uda a
                             where a.supplier_no = cur_route.supplier_no and a.factory_code = v_factory_code)
            loop
              v_supplier_name := cur_sup.supplier_name;
              exit;
            end loop;
            insert into mm_jiso_net_req
              (plan_code,
               partgroup_no,
               order_no,
               sale_no,
               sale_rowno,
               supplier_no,
               sup_factory,
               supplier_name,
               part_no,
               part_short_no,
               part_name,
               require_num,
               part_mark,
               route_code,
               route_desc,
               vin,
               model_code,
               phase,
               pass_time,
               wc_seqno,
               pl_seqno,
               kb_product_seqno,
               kb_time)
            values
              (in_plan_code,
               cur_route.partgroup_no,
               cur_queue.order_no,
               cur_queue.sale_no,
               cur_queue.sale_rowno,
               cur_route.supplier_no,
               cur_route.sup_factory,
               v_supplier_name,
               null,
               null,
               null,
               null,
               null,
               cur_route.route_code,
               cur_route.route_desc,
               cur_queue.vin,
               cur_queue.model_code,
               cur_queue.phase,
               cur_queue.pass_time,
               cur_queue.wc_seqno,
               cur_queue.pl_seqno,
               cur_queue.kb_product_seqno,
               cur_queue.kb_time);
            exit;
          end loop;
        else
          --存在且计算时，计算并写入零件需求信息
          insert into mm_jiso_net_req
            (plan_code,
             partgroup_no,
             order_no,
             sale_no,
             sale_rowno,
             supplier_no,
             sup_factory,
             supplier_name,
             part_no,
             part_short_no,
             part_name,
             require_num,
             part_mark,
             route_code,
             route_desc,
             vin,
             model_code,
             phase,
             pass_time,
             wc_seqno,
             pl_seqno,
             kb_product_seqno,
             kb_time)
            select a.plan_code,
                   a.partgroup_no,
                   cur_queue.order_no,
                   cur_queue.sale_no,
                   cur_queue.sale_rowno,
                   b.supplier_no,
                   b.sup_factory,
                   d.supplier_name,
                   c.part_no,
                   d.part_short_no,
                   d.part_name_cn,
                   sum(e.num) require_num,
                   c.part_mark,
                   b.route_code,
                   b.route_desc,
                   cur_queue.vin,
                   cur_queue.model_code,
                   cur_queue.phase,
                   cur_queue.pass_time,
                   cur_queue.wc_seqno,
                   cur_queue.pl_seqno,
                   cur_queue.kb_product_seqno,
                   cur_queue.kb_time
              from mm_jiso_partgroup       a,
                   mm_jiso_partgroup_route b,
                   mm_jiso_part            c,
                   mm_pub_part_uda         d,
                   mm_pub_order_bom        e
             where a.id = b.partgroup_id
               and a.id = c.partgroup_id
               and d.factory_code = cur_queue.factory_code
               and c.model_code = cur_queue.model_code
               and c.part_no = d.part_no
               and b.supplier_no = d.supplier_no
               and b.sup_factory = d.sup_factory
               and a.eff_start <= v_work_date
               and a.eff_end > v_work_date
               and b.eff_start <= v_work_date
               and b.eff_end > v_work_date
               and c.eff_start <= v_work_date
               and c.eff_end > v_work_date
               and a.id = cur_partgroup.id
               and e.factory_code = cur_queue.factory_code
               and e.order_no = cur_queue.erp_order_no
               and e.workcenter = cur_queue.workcenter
               and e.part_no = c.part_no
             group by a.plan_code,
                      a.partgroup_no,
                      e.order_no,
                      b.supplier_no,
                      b.sup_factory,
                      d.supplier_name,
                      c.part_no,
                      d.part_short_no,
                      d.part_name_cn,
                      c.part_mark,
                      b.route_code,
                      b.route_desc;
        end if;
      end loop;

      --更新车辆推算状态
      update mm_jiso_veh_queue a
         set a.exec_status   = 1,
             a.exec_time     = sysdate,
             a.partgroup_num = v_partgroup_num
       where a.plan_code = cur_queue.plan_code
         and a.order_no = cur_queue.order_no;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JISO_CAL_NET_REQ_'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JISO_CAL_NET_REQ;

  --****************************************************************************
  --函数名  : USF_JISO_GET_CAR_BATCH
  --功能描述: 获取车次
  --参数说明:
  -- in_car_batch_seqno  :车次流水号
  --返回值  : 车次流水号
  --创建人员: wxl
  --创建时间: 2018-09-14
  --****************************************************************************
  FUNCTION USF_JISO_GET_CAR_BATCH(in_car_batch_seqno in number) RETURN NUMBER AS
    out_car_batch number;
  BEGIN
    /*
    --车次1-999循环
    if in_car_batch_seqno is not null then
      out_car_batch := mod(in_car_batch_seqno, 999);
      if out_car_batch = 0 then
        out_car_batch := 999;
      end if;
    end if;
    */
    out_car_batch := in_car_batch_seqno;
    return out_car_batch;
  END USF_JISO_GET_CAR_BATCH;

  --****************************************************************************
  --函数名  : USF_JISO_GET_CAR_BATCHSEQNO
  --功能描述: 获取车次信息
  --参数说明:
  -- in_plan_code  :信息点
  -- in_partgroup_no  :零件组代码
  -- in_sup_factory  :供应商出货地
  --返回值  : 车次流水号
  --创建人员: wxl
  --创建时间: 2018-09-14
  --****************************************************************************
  FUNCTION USF_JISO_GET_CAR_BATCHSEQNO(in_plan_code    in varchar2,
                                       in_partgroup_no in varchar2,
                                       in_sup_factory  in varchar2) RETURN NUMBER AS
    v_ins_num           mm_jiso_car_batch.ins_num%type; --待组单指示票数
    v_end_flag          number(1); --结束标识
    v_exist_flag        number; --存在使用中路线车次信息
    out_car_batch_seqno number;
  BEGIN
    for cur_pg in (select a.plan_code,
                          a.partgroup_no,
                          a.order_ins_num,
                          b.route_code
                     from mm_jiso_partgroup a,
                          mm_jiso_partgroup_route b
                    where a.id = b.partgroup_id
                      and a.plan_code = in_plan_code
                      and a.partgroup_no = in_partgroup_no
                      and b.sup_factory = in_sup_factory)
    loop
      v_exist_flag := 0;
      --获取该零件组路线车次信息
      for cur_batch in (select a.ins_num, a.route_code, a.car_batch_seqno, a.end_flag, a.use_flag
                          from mm_jiso_car_batch a
                         where a.plan_code = cur_pg.plan_code
                           and a.partgroup_no = cur_pg.partgroup_no
                           and a.route_code = cur_pg.route_code)
      loop
        v_exist_flag := 1;

        --如果本车次已完结，获取下一车次,否则获取本车次
        if cur_batch.end_flag = 1 then
          out_car_batch_seqno := cur_batch.car_batch_seqno + 1;
          v_ins_num           := 1;
        else
          out_car_batch_seqno := cur_batch.car_batch_seqno ;
          v_ins_num           := cur_batch.ins_num + 1;

          --如果发生路线发生切换，更新车次信息,待组票指示票数1
          if cur_batch.use_flag = 0 then
             out_car_batch_seqno := out_car_batch_seqno + 1;
             v_ins_num           := 1;
          end if;
        end if;
        v_end_flag := 0;
        --如果达到组单指示票数,结束本车次
        if v_ins_num >= cur_pg.order_ins_num then
          v_end_flag := 1;
        end if;

        --更新当前零件组其它路线为未使用
        update mm_jiso_car_batch a
           set a.use_flag = 0
         where a.plan_code = cur_pg.plan_code
           and a.partgroup_no = cur_pg.partgroup_no
           and a.route_code <> cur_pg.route_code;
        --更新当前路线车次信息
        update mm_jiso_car_batch a
           set a.car_batch_seqno    = out_car_batch_seqno,
               a.ins_num            = v_ins_num,
               a.end_flag           = v_end_flag,
               a.use_flag           = 1
         where a.plan_code = cur_pg.plan_code
           and a.partgroup_no = cur_pg.partgroup_no
           and a.route_code = cur_pg.route_code;
      end loop;

      if v_exist_flag = 0 then
        --获取该路线最小车次流水号
        for cur_min_batch in (select * from (
                                select min(a.car_batch_seqno) car_batch_seqno
                                  from mm_jiso_car_batch a
                                 where a.plan_code  = cur_pg.plan_code
                                   and a.route_code = cur_pg.route_code
                                union
                                select min(b.car_batch_seqno) car_batch_seqno
                                  from mm_jiso_ins b
                                 where b.plan_code = cur_pg.plan_code
                                   and b.route_code = cur_pg.route_code
                                   and b.order_deal_flag = 0)
                               order by car_batch_seqno)
        loop
          out_car_batch_seqno := cur_min_batch.car_batch_seqno;
          exit;
        end loop;
        if out_car_batch_seqno is null then
          out_car_batch_seqno := 1;
        end if;
        v_ins_num  := 1;

        v_end_flag := 0;
        --如果达到组单指示票数,结束本车次
        if v_ins_num >= cur_pg.order_ins_num then
          v_end_flag := 1;
        end if;

        insert into mm_jiso_car_batch
          (plan_code, partgroup_no, route_code, car_batch_seqno, ins_num, end_flag, use_flag)
        values
          (cur_pg.plan_code, cur_pg.partgroup_no, cur_pg.route_code, out_car_batch_seqno, v_ins_num, v_end_flag, 1);
      end if;
      exit;
    end loop;

    return out_car_batch_seqno;
  END USF_JISO_GET_CAR_BATCHSEQNO;

  --****************************************************************************
  --过程名  : USP_JISO_CREATE_INS
  --功能描述: 生成厂外同步指示票
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-12
  --修改记录：
  --          调整单据前缀获取逻辑 mod by wxl 20190129
  --          LMS2019011503出货地代码调整为1位 mod by wxl 20190215
  --          LMS2019021303派生切换时加颜色标识 mod by wxl 20190228
  --          定制化订单-新增销售单写入 mod by wxl 20190315
  --          手工组票BUG修复 mod by wxl 20190415
  --          手工组票优化 mod by wxl 20190416
  --          修复死锁bug mod by wxl 20190416
  --****************************************************************************
  PROCEDURE USP_JISO_CREATE_INS(in_plan_code in varchar2) IS
    v_ins_prod_num     mm_jiso_partgroup.ins_product_num%type; --组票台套数
    v_gen_ins_way      mm_jiso_partgroup.gen_ins_way%type; --组票方式：0 不考虑出货地切换 1 考虑出货地切换
    v_prod_count       number; --待组票台套数
    v_supfactory_count number; --待组票出货地数
    v_manu_flag        number; --手工组票标识，0：不手工组票 1：手工组票
    v_manu_user        mm_jiso_ins_manu_deal.manu_req_user%type; --手工组票人
    v_manu_time        mm_jiso_ins_manu_deal.manu_req_time%type; --手工组票时间
    v_manu_ip          mm_jiso_ins_manu_deal.manu_req_ip%type; --手工组票IP
    --v_supplier_no      varchar2(20); --供应商代码 mod by wxl 20190215
    v_supplier_name    varchar2(150); --供应商名称
    v_route_code       mm_jiso_partgroup_route.route_code%type; --路线代码
    v_route_desc       mm_jiso_partgroup_route.route_desc%type; --路线描述
    v_car_batch_seqno  mm_jiso_car_batch.car_batch_seqno%type; --车次流水号
    v_prod_count_temp  number; --临时待组票台套数
    v_start_pass_time  mm_jiso_net_req.pass_time%type; --组票开始过点时间
    v_end_pass_time    mm_jiso_net_req.pass_time%type; --组票结束过点时间
    v_pre_orderno      mm_jiso_net_req.order_no%type; --前生产订单号
    v_pre_supplier_no  mm_jiso_net_req.supplier_no%type; --前生产订单的供应商代码 mod by wxl 20190215
    v_pre_supfactory   mm_jiso_net_req.sup_factory%type; --前生产订单的供应商出货地
    v_produce_time     number(10,3); --生产节拍
    v_location         mm_jiso_ins.location%type; --落点
    v_distri_person    mm_jiso_ins.distri_person%type; --配送工程
    v_prepare_num      number(10);--备件流动数
    v_dispatch_num     number(10);--发车流动数
    v_delivery_num     number(10);--发货流动数
    v_arrive_num       number(10);--到货流动数
    v_distri_num       number(10);--配送流动数
    v_use_location_num mm_jiso_ins.use_location_num%type;
    v_loc_num          number(10);--落点车体流动数
    v_s_kb_time        date; --看板时间
    v_prepare_time     date; --备货时间
    v_dispatch_time    date; --发车时间
    v_delivery_time    date; --发货时间
    v_arrive_time      date; --到货时间
    v_distri_time      date; --配送时间
    v_s_kb_product_seqno     number(19); --组票开始看板批次产品流水号
    v_prepare_product_seqno  number(19); --备件批次产品流水号
    v_dispatch_product_seqno number(19); --发车批次产品流水号
    v_delivery_product_seqno number(19); --发货批次产品流水号
    v_arrive_product_seqno   number(19); --到货批次产品流水号
    v_distri_product_seqno   number(19); --配送批次产品流水号
    v_flag             number; --临时
    v_factory_prefix   varchar(1); --指示票号:工厂前缀
    v_work_date        date; --当前时间的工作日期(不包含时分秒)
    v_date_char        varchar(8); --指示票号:日期
    v_seq_no           number(4); --指示票号:流水
    v_ins_no           mm_jiso_ins.ins_no%type; --指示票号
    v_ins_pg_seqno     mm_jiso_ins.ins_partgroup_seqno%type; --分零件组指示票代码
    v_ins_sf_seqno     mm_jiso_ins.ins_supfactory_seqno%type; --分供应商指示票代码
    type part_table_type is table of mm_jiso_net_req.kb_product_seqno%type index by mm_jiso_net_req.part_no%type; --mod by wxl 20190228
    v_pre_part_table   part_table_type; --mod by wxl 20190228
    v_remark_flag      mm_jiso_ins_detail.remark_flag%type; --零件打切标识 mod by wxl 2019-02-28
    v_pre_ins_no       mm_jiso_ins.ins_no%type; --前一张指示票号 mod by wxl 2019-02-28
    v_notexists        varchar2(10); --不存在标识字符 mod by wxl 2019-02-28
    v_index_str        mm_jiso_net_req.part_no%type; --mod by wxl 2019-02-28
    v_work_date_t      date; --临时记录
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    v_notexists := 'NOTEXISTS';
    --按零件组循环进行组票
    for cur_pg in (select distinct a.factory_code,
                          a.workcenter,
                          b.id,
                          b.plan_code,
                          b.partgroup_no,
                          b.partgroup_name,
                          b.arr_depot,
                          b.gen_ins_way,
                          b.ins_product_num,
                          b.order_flg,
                          b.prepare_num,
                          b.dispatch_num,
                          b.delivery_num,
                          b.arrive_num,
                          b.distribution_num
                     from mm_pub_plan_code a,
                          mm_jiso_partgroup b,
                          mm_jiso_net_req c
                    where a.plan_code = b.plan_code
                      and b.plan_code = c.plan_code
                      and b.partgroup_no = c.partgroup_no
                      and a.plan_code = in_plan_code
                    order by a.factory_code, b.partgroup_no)
    loop
      --清除前一个零件组计算的零件需求
      v_pre_part_table.delete;
      --获取生产节拍???
      v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_pg.factory_code, cur_pg.workcenter, null);
      --初始化上产品号
      v_pre_orderno := null;
      loop
        v_ins_prod_num  := cur_pg.ins_product_num;
        v_gen_ins_way   := cur_pg.gen_ins_way;

        --获取待组票台套数、出货地数
        select count(distinct a.order_no)
          into v_prod_count
          from mm_jiso_net_req a
         where a.plan_code = cur_pg.plan_code
           and a.partgroup_no = cur_pg.partgroup_no;
        select count(*)
          into v_supfactory_count
          from (select distinct a.supplier_no, a.sup_factory
                  from mm_jiso_net_req a
                 where a.plan_code = cur_pg.plan_code
                   and a.partgroup_no = cur_pg.partgroup_no);

        --当存在需求且不满足指示票台套数时，判断是否手工组票
        v_manu_flag := 0;
        v_manu_time := null;
        v_manu_user := null;
        v_manu_ip   := null;
        --mod by wxl 20190415
        --if v_prod_count < v_ins_prod_num and v_prod_count > 0 then
        if v_prod_count > 0 and v_prod_count < v_ins_prod_num and (v_gen_ins_way=0 or (v_gen_ins_way=1 and v_supfactory_count<2)) then
          for cur_manu in(select a.manu_req_time, a.manu_req_user, a.manu_req_ip
                            from mm_jiso_ins_manu_deal a
                           where a.plan_code = cur_pg.plan_code
                             and a.partgroup_no = cur_pg.partgroup_no
                             and a.deal_flag = 0
                           order by manu_req_time desc)
          loop
              v_manu_flag := 1;
              v_manu_time := cur_manu.manu_req_time;
              v_manu_user := cur_manu.manu_req_user;
              v_manu_ip   := cur_manu.manu_req_ip;
              v_ins_prod_num := v_prod_count;
              exit;
          end loop;
        end if;

        --当不满足指示票台套数 且 供应商出货地未发生变化 时退出组票
        exit when v_prod_count < v_ins_prod_num  and (v_gen_ins_way=0 or (v_gen_ins_way=1 and v_supfactory_count<2));

        --初始化临时待组票台套数
        v_prod_count_temp := 0;
        --对零件组下的未组票净需求循环遍历处理
        for cur_req in (select a.*
                          from mm_jiso_net_req a
                         where a.plan_code = cur_pg.plan_code
                           and a.partgroup_no = cur_pg.partgroup_no
                         order by a.pass_time, a.part_no)
        loop
          --记录组票开始信息
          if v_prod_count_temp = 0 then
            v_pre_supplier_no := cur_req.supplier_no;
            v_pre_supfactory  := cur_req.sup_factory;
            v_start_pass_time := cur_req.pass_time;
            v_s_kb_time       := cur_req.kb_time;
            v_s_kb_product_seqno := cur_req.kb_product_seqno;
          end if;
          --当生产单号发生变化时，更新临时待组票台套数
          if v_pre_orderno is null or v_pre_orderno <> cur_req.order_no then
            v_pre_orderno := cur_req.order_no;
            v_prod_count_temp := v_prod_count_temp + 1;
          end if;

          --满指示票台套数 或 供应商出货地发生变化 时组票
          if v_prod_count_temp = v_ins_prod_num or (v_gen_ins_way = 1 and (v_pre_supplier_no <> cur_req.supplier_no or v_pre_supfactory <> cur_req.sup_factory)) then
            --如果不考虑供应商出货地切换 或 供应商出货地未切换，更改组单结束过点时间
            if v_gen_ins_way = 0 or (v_pre_supplier_no = cur_req.supplier_no and v_pre_supfactory = cur_req.sup_factory) then
               v_end_pass_time := cur_req.pass_time;
            end if;

            for cur_supfactory in (select * from (
                                     select distinct a.supplier_no, a.sup_factory, min(a.pass_time) min_pass_time
                                       from mm_jiso_net_req a
                                      where a.plan_code = cur_pg.plan_code
                                        and a.partgroup_no = cur_pg.partgroup_no
                                        and a.pass_time >= v_start_pass_time
                                        and a.pass_time <= v_end_pass_time
                                      group by a.supplier_no, a.sup_factory)
                                    order by min_pass_time)
            loop
              --获取路线、供应商信息???
              v_route_code    := null;
              v_route_desc    := null;
              --v_supplier_no   := null;
              v_supplier_name := null;
              for cur_route in (select a.route_code,
                                       a.route_desc,
                                       --a.supplier_no,
                                       a.supplier_name
                                  from mm_jiso_net_req a
                                 where a.plan_code = cur_pg.plan_code
                                   and a.partgroup_no = cur_pg.partgroup_no
                                   and a.pass_time = cur_supfactory.min_pass_time
                                   and a.supplier_no = cur_supfactory.supplier_no
                                   and a.sup_factory = cur_supfactory.sup_factory)
              loop
                v_route_code    := cur_route.route_code;
                v_route_desc    := cur_route.route_desc;
                --v_supplier_no   := cur_route.supplier_no;
                v_supplier_name := cur_route.supplier_name;
                exit;
              end loop;

              --获取车次信息
              v_car_batch_seqno := USF_JISO_GET_CAR_BATCHSEQNO(cur_pg.plan_code, cur_pg.partgroup_no, v_pre_supfactory);

              --获取属地信息
              v_location := null;
              v_loc_num  := 0;
              v_distri_person := null;
              --1、根据零件获取属地信息中任一落点信息
              for cur_loc in (select a.location, a.location_num, a.distri_person
                                from mm_inv_part_location a, mm_jiso_part b
                               where a.factory_code = cur_pg.factory_code
                                 and a.workcenter = cur_pg.workcenter
                                 and a.part_no = b.part_no
                                 and a.eff_start <= sysdate
                                 and a.eff_end > sysdate
                                 and b.partgroup_id = cur_pg.id
                               order by a.location_num desc)
              loop
                v_location := cur_loc.location;
                v_loc_num  := cur_loc.location_num;
                v_distri_person := cur_loc.distri_person;
                v_use_location_num := 'LOC';
                exit;
              end loop;
              --2、获取属地信息中车间最大工深
              if v_location is null then
                select decode(max(a.location_num), null, 0, max(a.location_num))
                  into v_loc_num
                  from mm_inv_part_location a
                 where a.factory_code = cur_pg.factory_code
                   and a.workcenter = cur_pg.workcenter
                   and a.eff_start <= sysdate
                   and a.eff_end > sysdate;
                v_use_location_num := 'WC';
              end if;
              --3、获取系统参数中车间最大工深
              if v_location is null then
                v_loc_num := to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_pg.factory_code, 'MAX_LOC', 'AF_TOTAL_PRO_NUM'));
                v_use_location_num := 'SYS';
              end if;
              if v_loc_num is null then
                v_loc_num := 0;
                v_use_location_num := null;
              end if;

              --计算物流周期
              --计算备件流动数
              v_prepare_num  := cur_pg.prepare_num+cur_pg.delivery_num+cur_pg.arrive_num+cur_pg.distribution_num+v_loc_num;
              --计算发车流动数
              v_dispatch_num := cur_pg.dispatch_num+cur_pg.delivery_num+cur_pg.arrive_num+cur_pg.distribution_num+v_loc_num;
              --计算发货流动数
              v_delivery_num := cur_pg.delivery_num+cur_pg.arrive_num+cur_pg.distribution_num+v_loc_num;
              --计算到货流动数
              v_arrive_num   := cur_pg.arrive_num+cur_pg.distribution_num+v_loc_num;
              --计算配送流动数
              v_distri_num   := cur_pg.distribution_num+v_loc_num;
              --计算备件时间
              v_prepare_time := PKG_PUB.USF_GET_PRE_WORKTIME(cur_pg.factory_code, cur_pg.workcenter, v_s_kb_time, -v_prepare_num*v_produce_time);
              --计算发车时间
              v_dispatch_time := PKG_PUB.USF_GET_PRE_WORKTIME(cur_pg.factory_code, cur_pg.workcenter, v_s_kb_time, -v_dispatch_num*v_produce_time);
              --计算发货时间
              v_delivery_time := PKG_PUB.USF_GET_PRE_WORKTIME(cur_pg.factory_code, cur_pg.workcenter, v_s_kb_time, -v_delivery_num*v_produce_time);
              --计算到货时间
              v_arrive_time := PKG_PUB.USF_GET_PRE_WORKTIME(cur_pg.factory_code, cur_pg.workcenter, v_s_kb_time, -v_arrive_num*v_produce_time);
              --计算配送时间
              v_distri_time := PKG_PUB.USF_GET_PRE_WORKTIME(cur_pg.factory_code, cur_pg.workcenter, v_s_kb_time, -v_distri_num*v_produce_time);
              --计算备件产品流水号
              v_prepare_product_seqno := v_s_kb_product_seqno-v_prepare_num;
              --计算发车产品流水号
              v_dispatch_product_seqno := v_s_kb_product_seqno-v_dispatch_num;
              --计算发货产品流水号
              v_delivery_product_seqno := v_s_kb_product_seqno-v_delivery_num;
              --计算到货产品流水号
              v_arrive_product_seqno := v_s_kb_product_seqno-v_arrive_num;
              --计算配送产品流水号
              v_distri_product_seqno := v_s_kb_product_seqno-v_distri_num;

              --生成指示票号、分零件组指示票代码
              --获取前缀
              v_factory_prefix := null;
              --mod by wxl 20190129
              for cur_prefix in (select a.factory_code_str
                                   from mm_pub_bill_prefix a
                                  where a.bill_group = 'JISO_INS'
                                    and a.plan_code = cur_pg.plan_code)
              loop
                v_factory_prefix := cur_prefix.factory_code_str;
              end loop;

              --获取前一个生产订单号零件需求
              if v_pre_part_table.count = 0 then
                v_pre_ins_no    := null;
                for cur_ins_sn in (select *
                                     from mm_jiso_ins_sn a
                                    where a.plan_code = cur_pg.plan_code
                                      and a.partgroup_no = cur_pg.partgroup_no
                                      and a.use_flag = 1
                                    order by use_date desc)
                loop
                  v_pre_ins_no := v_factory_prefix||to_char(cur_ins_sn.use_date, 'yyyymmdd')|| cur_ins_sn.partgroup_no ||lpad(cur_ins_sn.seq_no, 4, '0');
                  exit;--mod by wxl 20190416
                end loop;
                for cur_veh in (select order_no, kb_product_seqno
                                  from mm_jiso_ins_detail
                                 where ins_no = v_pre_ins_no
                                 order by pass_time desc, kb_product_seqno desc)
                loop
                  for cur_part in (select distinct part_no
                                     from mm_jiso_ins_detail
                                    where ins_no = v_pre_ins_no
                                      and order_no = cur_veh.order_no)
                  loop
                    if cur_part.part_no is null then
                      v_index_str := v_notexists;
                    else
                      v_index_str := cur_part.part_no;
                    end if;
                    v_pre_part_table(v_index_str) := cur_veh.kb_product_seqno;
                  end loop;
                  exit;
                end loop;
              end if;

              --生成指示票号
              v_work_date      := PKG_PUB.USF_GET_WORK_DATE(cur_pg.factory_code, cur_pg.workcenter, v_start_pass_time);
              v_date_char      := to_char(v_work_date, 'yyyymmdd') ;
              select count(1)
                into v_flag
                from mm_jiso_ins_sn a
               where a.plan_code = cur_pg.plan_code
                 and a.partgroup_no = cur_pg.partgroup_no
                 and a.use_date = v_work_date;
              if v_flag = 0 then
                --更新原流水为未使用
                --mod by wxl 20190416
                /*
                update mm_jiso_ins_sn a
                   set a.use_flag = 0
                 where a.plan_code = cur_pg.plan_code
                   and a.partgroup_no = cur_pg.partgroup_no
                   and a.use_flag = 1;
                */
                v_seq_no := 1;
                insert into mm_jiso_ins_sn
                  (plan_code, partgroup_no, use_date, seq_no, use_flag)
                values
                  (cur_pg.plan_code, cur_pg.partgroup_no, v_work_date, 1, 1);
              else
                select seq_no + 1
                  into v_seq_no
                  from mm_jiso_ins_sn a
                 where a.plan_code = cur_pg.plan_code
                   and a.partgroup_no = cur_pg.partgroup_no
                   and a.use_date = v_work_date;
                update mm_jiso_ins_sn a
                   set a.seq_no = v_seq_no
                 where a.plan_code = cur_pg.plan_code
                   and a.partgroup_no = cur_pg.partgroup_no
                   and a.use_date = v_work_date;
              end if;
              v_ins_no := v_factory_prefix||v_date_char || cur_pg.partgroup_no ||lpad(v_seq_no, 4, '0');
              v_ins_pg_seqno := cur_pg.partgroup_no || '-' || v_seq_no;

              --生成分出货地指示票代码
              select count(1)
                into v_flag
                from mm_jiso_ins_sn_sup a
               where a.plan_code = cur_pg.plan_code
                 and a.partgroup_no = cur_pg.partgroup_no
                 and a.supplier_no = v_pre_supplier_no
                 and a.sup_factory = v_pre_supfactory
                 and a.use_date = v_work_date;
              if v_flag = 0 then
                v_seq_no := 1;
                insert into mm_jiso_ins_sn_sup
                  (plan_code, partgroup_no, supplier_no, sup_factory, use_date, seq_no)
                values
                  (cur_pg.plan_code, cur_pg.partgroup_no, v_pre_supplier_no, v_pre_supfactory, v_work_date, 1);
              else
                select seq_no + 1
                  into v_seq_no
                  from mm_jiso_ins_sn_sup a
                 where a.plan_code = cur_pg.plan_code
                   and a.partgroup_no = cur_pg.partgroup_no
                   and a.supplier_no = v_pre_supplier_no
                   and a.sup_factory = v_pre_supfactory
                   and a.use_date = v_work_date;
                update mm_jiso_ins_sn_sup a
                   set a.seq_no = v_seq_no
                 where a.plan_code = cur_pg.plan_code
                   and a.partgroup_no = cur_pg.partgroup_no
                   and a.supplier_no = v_pre_supplier_no
                   and a.sup_factory = v_pre_supfactory
                   and a.use_date = v_work_date;
              end if;
              v_ins_sf_seqno := cur_pg.partgroup_no || v_pre_supplier_no || v_pre_supfactory || '-' || v_seq_no;

              --写入指示票主信息
              insert into mm_jiso_ins
                (ins_no,
                 plan_code,
                 partgroup_no,
                 arr_depot,
                 supplier_no,
                 sup_factory,
                 supplier_name,
                 ins_partgroup_seqno,
                 ins_supfactory_seqno,
                 partgroup_name,
                 order_flg,
                 gen_ins_way,
                 route_code,
                 route_desc,
                 car_batch,
                 car_batch_seqno,
                 location,
                 distri_person,
                 prepare_product_seqno,
                 dispatch_product_seqno,
                 delivery_product_seqno,
                 arrive_product_seqno,
                 distri_product_seqno,
                 prepare_time,
                 dispatch_time,
                 delivery_time,
                 arrive_time,
                 distri_time,
                 arrive_batch_no,
                 is_manu_deal,
                 manu_req_time,
                 manu_req_user,
                 manu_req_ip,
                 order_deal_flag)
                values(v_ins_no,
                       cur_pg.plan_code,
                       cur_pg.partgroup_no,
                       cur_pg.arr_depot,
                       --v_supplier_no,
                       v_pre_supplier_no,
                       v_pre_supfactory,
                       v_supplier_name,
                       v_ins_pg_seqno,
                       v_ins_sf_seqno,
                       cur_pg.partgroup_name,
                       cur_pg.order_flg,
                       cur_pg.gen_ins_way,
                       v_route_code,
                       v_route_desc,
                       USF_JISO_GET_CAR_BATCH(v_car_batch_seqno),
                       v_car_batch_seqno,
                       v_location,
                       v_distri_person,
                       v_prepare_product_seqno,
                       v_dispatch_product_seqno,
                       v_delivery_product_seqno,
                       v_arrive_product_seqno,
                       v_distri_product_seqno,
                       v_prepare_time,
                       v_dispatch_time,
                       v_delivery_time,
                       v_arrive_time,
                       v_distri_time,
                       PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(cur_pg.plan_code, v_arrive_product_seqno),
                       v_manu_flag,
                       v_manu_time,
                       v_manu_user,
                       v_manu_ip,
                       decode(cur_pg.order_flg, 1, 0, 1));
              --写入指示票明细信息 mod by wxl 20190228
              /*
              insert into mm_jiso_ins_detail
                (ins_no,
                 order_no,
                 part_no,
                 require_num,
                 part_short_no,
                 part_name,
                 part_mark,
                 vin,
                 model_code,
                 phase,
                 pass_time,
                 wc_seqno,
                 pl_seqno,
                 kb_product_seqno)
                select v_ins_no,
                       a.order_no,
                       a.part_no,
                       a.require_num,
                       a.part_short_no,
                       a.part_name,
                       a.part_mark,
                       a.vin,
                       a.model_code,
                       a.phase,
                       a.pass_time,
                       a.wc_seqno,
                       a.pl_seqno,
                       a.kb_product_seqno
                  from mm_jiso_net_req a
                 where a.plan_code = cur_pg.plan_code
                   and a.partgroup_no = cur_pg.partgroup_no
                   and a.pass_time >= v_start_pass_time
                   and a.pass_time <= v_end_pass_time;
              */
              for cur_detail in (select a.order_no,
                                        a.sale_no,
                                        a.sale_rowno,
                                        a.part_no,
                                        a.require_num,
                                        a.part_short_no,
                                        a.part_name,
                                        a.part_mark,
                                        a.vin,
                                        a.model_code,
                                        a.phase,
                                        a.pass_time,
                                        a.wc_seqno,
                                        a.pl_seqno,
                                        a.kb_product_seqno
                                   from mm_jiso_net_req a
                                  where a.plan_code = cur_pg.plan_code
                                    and a.partgroup_no = cur_pg.partgroup_no
                                    and a.pass_time >= v_start_pass_time
                                    and a.pass_time <= v_end_pass_time
                                  order by a.pass_time,
                                           a.order_no,
                                           a.part_no)
              loop
                if cur_detail.part_no is null then
                  v_index_str := v_notexists;
                else
                  v_index_str := cur_detail.part_no;
                end if;
                --未切换：1、前面没有订单；2、零件需求的最近订单为前一个生产订单号
                v_remark_flag := '1';
                if v_pre_part_table.count = 0 or (v_pre_part_table.EXISTS(v_index_str) and v_pre_part_table(v_index_str) = cur_detail.kb_product_seqno-1) then
                  v_remark_flag := '0';
                end if;
                --增加定制化标识 mod by wxl 20190315
                if cur_detail.part_no is not null and substr(cur_detail.part_no,length(cur_detail.part_no)-6,1) = 'D' then
                  v_remark_flag := '2';
                end if;
                v_pre_part_table(v_index_str) := cur_detail.kb_product_seqno;

                --插入明细
                insert into mm_jiso_ins_detail
                  (ins_no,
                   order_no,
                   sale_no,
                   sale_rowno,
                   part_no,
                   require_num,
                   part_short_no,
                   part_name,
                   part_mark,
                   remark_flag,
                   vin,
                   model_code,
                   phase,
                   pass_time,
                   wc_seqno,
                   pl_seqno,
                   kb_product_seqno)
                values
                  (v_ins_no,
                   cur_detail.order_no,
                   cur_detail.sale_no,
                   cur_detail.sale_rowno,
                   cur_detail.part_no,
                   cur_detail.require_num,
                   cur_detail.part_short_no,
                   cur_detail.part_name,
                   cur_detail.part_mark,
                   v_remark_flag,
                   cur_detail.vin,
                   cur_detail.model_code,
                   cur_detail.phase,
                   cur_detail.pass_time,
                   cur_detail.wc_seqno,
                   cur_detail.pl_seqno,
                   cur_detail.kb_product_seqno);
              end loop;

              --更新车辆组票的零件组数
              update mm_jiso_veh_queue a
                 set a.partgroup_ins_num = a.partgroup_ins_num + 1
               where a.plan_code = cur_pg.plan_code
                 and a.order_no in
                     (select distinct t.order_no
                        from mm_jiso_net_req t
                       where t.plan_code = cur_pg.plan_code
                         and t.partgroup_no = cur_pg.partgroup_no
                         and t.pass_time >= v_start_pass_time
                         and t.pass_time <= v_end_pass_time);
              --删除已生成指示票的零件需求
              delete from mm_jiso_net_req a
               where a.plan_code = cur_pg.plan_code
                 and a.partgroup_no = cur_pg.partgroup_no
                 and a.pass_time >= v_start_pass_time
                 and a.pass_time <= v_end_pass_time;
            end loop;
            --本次组票完成退出循环，进入下一次组票
            exit;
          end if;

          --更新组票结束时间
          v_end_pass_time := cur_req.pass_time;
        end loop;
        --当手工组票时，则需要更新手工组票标识为已处理，同时重新对指示票标准台套数赋值
        if v_manu_flag = 1 then
          update mm_jiso_ins_manu_deal a
             set a.deal_flag = 1, a.deal_time = sysdate
           where a.plan_code = cur_pg.plan_code
             and a.partgroup_no = cur_pg.partgroup_no
             and a.deal_flag = 0;
        end if;
      end loop;
    end loop;
    --处理无需求的手工组票需求 mod by wxl 20190416
    update mm_jiso_ins_manu_deal a
       set a.deal_flag = 1, a.deal_time = sysdate
     where a.plan_code = in_plan_code
       and a.deal_flag = 0;
    --更新原流水为未使用 mod by wxl 20190416
    for cur_sn in (select a.plan_code, a.partgroup_no, max(a.use_date) max_use_date
                     from mm_jiso_ins_sn a
                    where a.plan_code = in_plan_code
                      and a.use_flag = 1
                    group by a.plan_code, a.partgroup_no)
    loop
      update mm_jiso_ins_sn a
         set a.use_flag = 0
       where a.plan_code = in_plan_code
         and a.partgroup_no = cur_sn.partgroup_no
         and a.use_flag = 1
         and a.use_date < cur_sn.max_use_date;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JISO_CREATE_INS_'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JISO_CREATE_INS;

  --****************************************************************************
  --过程名  : USP_JISO_CREATE_ORDER
  --功能描述: 生成厂外同步订单
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-13
  --****************************************************************************
  PROCEDURE USP_JISO_CREATE_ORDER(in_plan_code in varchar2) IS
    v_max_car_batch_seqno  mm_jiso_car_batch.car_batch_seqno%type; --最大可组单车次流水号
    v_kb_order_num         number(2); --厂外同步看板展示订单数
    v_route_pre_supplier_no mm_jiso_order_sup_kb.supplier_no%type; --路线上一个订单供应商 mod by wxl 20190215
    v_route_pre_supfactory mm_jiso_order_sup_kb.sup_factory%type; --路线上一个订单出货地
    v_manu_flag            number; --手工组票标识，0：不手工组单 1：手工组单
    v_manu_user            mm_jiso_ins_manu_deal.manu_req_user%type; --手工组单人
    v_manu_time            mm_jiso_ins_manu_deal.manu_req_time%type; --手工组单时间
    v_manu_ip              mm_jiso_ins_manu_deal.manu_req_ip%type; --手工组单IP
    v_route_desc           mm_jiso_ins.route_desc%type; --路线描述
    --v_supplier_no          mm_jiso_ins.supplier_no%type; --供应商代码
    v_supplier_name        mm_jiso_ins.supplier_name%type; --供应商名称
    v_order_no             mm_jiso_order.order_no%type; --物流单号
    v_order_rowno          mm_jiso_order_detail.order_rowno%type; --物流单行号
    v_part_short_no        mm_jiso_order_detail.part_short_no%type; --零件简号
    v_part_name            mm_jiso_order_detail.part_name%type; --零件名称
    v_standard_package     mm_jiso_order_detail.standard_package%type; --规格包装数
    v_kb_pre_supplier_no   mm_jiso_order_sup_kb.supplier_no%type; --看板上一个订单供应商 mod by wxl 20190215
    v_kb_pre_supfactory    mm_jiso_order_sup_kb.sup_factory%type; --看板上一个订单出货地
    v_kb_pre_order_seqno   mm_jiso_order_sup_kb.order_seqno%type; --看板上一个订单流水号
    v_flag                 number(1);
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    --按路线遍历未组单的零件组订单
    for cur_route in (select a.factory_code, a.plan_code, b.route_code,
                             min(b.car_batch_seqno) min_carbatch_seqno
                        from mm_pub_plan_code a, mm_jiso_car_batch b
                       where a.plan_code = b.plan_code
                         and a.plan_code = in_plan_code
                         and b.use_flag = 1
                       group by a.factory_code, a.plan_code, b.route_code)
    loop
      --获取最大可组单车次流水号
      v_max_car_batch_seqno := cur_route.min_carbatch_seqno;
      select min(t.end_flag)
        into v_flag
        from mm_jiso_car_batch t
       where t.plan_code = cur_route.plan_code
         and t.route_code = cur_route.route_code
         and t.car_batch_seqno = v_max_car_batch_seqno;
      if v_flag = 0 then
         v_max_car_batch_seqno := v_max_car_batch_seqno - 1;
      end if;

      --获取厂外同步出货地切换看板保留订单数
      v_kb_order_num := TO_NUMBER(PKG_PUB.USF_GET_SYS_PARAM(cur_route.factory_code, 'JISO_KB', 'JISO_ORDER_SUP_KB_NUM'));
      /*获取当前路线上次组单的最后一个订单的所属出货地，
        在本次组单时候，与上次组单最后一个订单出货地一样的出货地在本次订单优先生成，
        这样保证当巡回取货模式时候，不会在订单出货地切换看板上显示多次切换出货地异常。
        体现在如下的游标cur_sup_kb脚本排序字段上*/
      v_route_pre_supplier_no := null;
      v_route_pre_supfactory  := null;
      for cur_sup_kb in(select a.supplier_no, a.sup_factory, a.order_seqno
                          from mm_jiso_order_sup_kb a
                         where a.plan_code = cur_route.plan_code
                           and a.route_code = cur_route.route_code
                         order by a.order_seqno desc)
      loop
        v_route_pre_supplier_no := cur_sup_kb.supplier_no;
        v_route_pre_supfactory := cur_sup_kb.sup_factory;
        exit;
      end loop;

      --按信息点、供应商出货地、到货仓库、车次流水号生成订单
      for cur_pg_order in(select *
                            from (select a.route_code,
                                         a.supplier_no,
                                         a.sup_factory,
                                         a.arr_depot,
                                         a.car_batch,
                                         a.car_batch_seqno,
                                         min(a.prepare_product_seqno) prepare_product_seqno,
                                         min(a.dispatch_product_seqno) dispatch_product_seqno,
                                         min(a.delivery_product_seqno) delivery_product_seqno,
                                         min(a.arrive_product_seqno) arrive_product_seqno,
                                         min(a.distri_product_seqno) distri_product_seqno,
                                         min(a.prepare_time) prepare_time,
                                         min(a.dispatch_time) dispatch_time,
                                         min(a.delivery_time) delivery_time,
                                         min(a.arrive_time) arrive_time,
                                         min(a.distri_time) distri_time
                                    from mm_jiso_ins a
                                   where a.plan_code = cur_route.plan_code
                                     and a.route_code = cur_route.route_code
                                     and (a.car_batch_seqno <= v_max_car_batch_seqno
                                     or exists (select 1 from mm_jiso_order_manu_deal t
                                                  where t.plan_code = a.plan_code
                                                    and t.route_code = a.route_code
                                                    and t.supplier_no = a.supplier_no
                                                    and t.sup_factory = a.sup_factory
                                                    and t.car_batch_seqno = a.car_batch_seqno
                                                    and t.deal_flag = 0))
                                     and a.order_deal_flag = 0
                                   group by a.plan_code,
                                            a.route_code,
                                            a.supplier_no,
                                            a.sup_factory,
                                            a.arr_depot,
                                            a.car_batch,
                                            a.car_batch_seqno)
                           order by car_batch_seqno,
                                    prepare_product_seqno,
                                    decode(supplier_no, v_route_pre_supplier_no, decode(sup_factory, v_route_pre_supfactory, 1, 2), 2),
                                    supplier_no,
                                    sup_factory)
      loop
        --判断是否手工组单
        v_manu_flag := 0;
        v_manu_time := null;
        v_manu_user := null;
        v_manu_ip   := null;

        if cur_pg_order.car_batch_seqno > v_max_car_batch_seqno then
          for cur_manu in(select a.manu_req_time, a.manu_req_user, a.manu_req_ip
                            from mm_jiso_order_manu_deal a
                           where a.plan_code = cur_route.plan_code
                             and a.supplier_no = cur_pg_order.supplier_no
                             and a.sup_factory = cur_pg_order.sup_factory
                             and a.route_code = cur_pg_order.route_code
                             and a.car_batch_seqno = cur_pg_order.car_batch_seqno
                             and a.deal_flag = 0
                           order by a.manu_req_time desc)
          loop
              v_manu_flag := 1;
              v_manu_time := cur_manu.manu_req_time;
              v_manu_user := cur_manu.manu_req_user;
              v_manu_ip   := cur_manu.manu_req_ip;
              exit;
          end loop;
        end if;

        --是否存在需组单需求
        v_flag := 0;
        select count(1)
          into v_flag
          from mm_jiso_ins a, mm_jiso_ins_detail b
         where a.ins_no = b.ins_no
           and a.plan_code = cur_route.plan_code
           and a.route_code = cur_route.route_code
           and a.supplier_no = cur_pg_order.supplier_no
           and a.sup_factory = cur_pg_order.sup_factory
           and a.arr_depot = cur_pg_order.arr_depot
           and a.car_batch_seqno = cur_pg_order.car_batch_seqno
           and a.order_deal_flag = 0
           and b.require_num is not null
           and rownum = 1;
        if v_flag = 1 then
          --获取路线、供应商信息???
          v_route_desc    := null;
          --v_supplier_no   := null;
          v_supplier_name := null;
          for cur_routeInfo in (select a.route_code,
                                       a.route_desc,
                                       --a.supplier_no,
                                       a.supplier_name
                                  from mm_jiso_ins a
                                 where a.plan_code = cur_route.plan_code
                                   and a.route_code = cur_pg_order.route_code
                                   and a.supplier_no = cur_pg_order.supplier_no
                                   and a.sup_factory = cur_pg_order.sup_factory
                                   and a.arr_depot = cur_pg_order.arr_depot
                                   and a.car_batch_seqno = cur_pg_order.car_batch_seqno
                                   and a.order_deal_flag = 0
                                 order by a.creation_time)
          loop
            v_route_desc    := cur_routeInfo.route_desc;
            --v_supplier_no   := cur_routeInfo.supplier_no;
            v_supplier_name := cur_routeInfo.supplier_name;
            exit;
          end loop;

          --生成物流单号
          v_order_no := PKG_PUB.USF_GET_ORDER_NO(cur_route.plan_code);

          --写入厂外同步订单主信息
          insert into mm_jiso_order
            (order_no,
             plan_code,
             arr_depot,
             sup_factory,
             route_code,
             car_batch_seqno,
             supplier_no,
             supplier_name,
             route_desc,
             car_batch,
             prepare_product_seqno,
             dispatch_product_seqno,
             delivery_product_seqno,
             arrive_product_seqno,
             distri_product_seqno,
             prepare_time,
             dispatch_time,
             delivery_time,
             arrive_time,
             distri_time,
             arrive_batch_no,
             is_manu_deal,
             manu_req_time,
             manu_req_user,
             manu_req_ip,
             purchase_orderno)
            values( v_order_no,
                   cur_route.plan_code,
                   cur_pg_order.arr_depot,
                   cur_pg_order.sup_factory,
                   cur_pg_order.route_code,
                   cur_pg_order.car_batch_seqno,
                   --v_supplier_no,
                   cur_pg_order.supplier_no,
                   v_supplier_name,
                   v_route_desc,
                   cur_pg_order.car_batch,
                   cur_pg_order.prepare_product_seqno,
                   cur_pg_order.dispatch_product_seqno,
                   cur_pg_order.delivery_product_seqno,
                   cur_pg_order.arrive_product_seqno,
                   cur_pg_order.distri_product_seqno,
                   cur_pg_order.prepare_time,
                   cur_pg_order.dispatch_time,
                   cur_pg_order.delivery_time,
                   cur_pg_order.arrive_time,
                   cur_pg_order.distri_time,
                   PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(cur_route.plan_code, cur_pg_order.arrive_product_seqno),
                   v_manu_flag,
                   v_manu_time,
                   v_manu_user,
                   v_manu_ip,
                   v_order_no);
          --写入厂外同步订单明细信息
          v_order_rowno := 0;
          for cur_part in (select b.part_no, sum(b.require_num) require_num
                             from mm_jiso_ins a, mm_jiso_ins_detail b
                            where a.ins_no = b.ins_no
                              and a.plan_code = cur_route.plan_code
                              and a.route_code = cur_route.route_code
                              and a.supplier_no = cur_pg_order.supplier_no
                              and a.sup_factory = cur_pg_order.sup_factory
                              and a.arr_depot = cur_pg_order.arr_depot
                              and a.car_batch_seqno = cur_pg_order.car_batch_seqno
                              and b.require_num is not null
                              and a.order_deal_flag = 0
                            group by b.part_no)
          loop
            v_order_rowno := v_order_rowno + 10;

            --获取零件简号、零件名称、规格包装数???
            v_part_short_no := null;
            v_part_name     := null;
            v_standard_package := null;
            for cur_partInfo in (select a.part_short_no, a.part_name_cn, a.standard_package
                                   from mm_pub_part_uda a
                                  where a.factory_code = cur_route.factory_code
                                    and a.part_no = cur_part.part_no)
            loop
              v_part_short_no := cur_partInfo.part_short_no;
              v_part_name     := cur_partInfo.part_name_cn;
              v_standard_package := cur_partInfo.standard_package;
              exit;
            end loop;

            insert into mm_jiso_order_detail
              (order_no,
               order_rowno,
               part_no,
               require_num,
               part_short_no,
               part_name,
               standard_package)
            values
              (v_order_no,
               v_order_rowno,
               cur_part.part_no,
               cur_part.require_num,
               v_part_short_no,
               v_part_name,
               v_standard_package);
          end loop;

          --当手工组单时，则需要更新手工组单标识为已处理
          if v_manu_flag = 1 then
            update mm_jiso_order_manu_deal a
               set a.deal_flag = 1, a.deal_time = sysdate
             where a.plan_code = cur_route.plan_code
               and a.supplier_no = cur_pg_order.supplier_no
               and a.sup_factory = cur_pg_order.sup_factory
               and a.route_code = cur_pg_order.route_code
               and a.car_batch_seqno = cur_pg_order.car_batch_seqno;
          end if;

          --更新厂外同步出货地切换看板信息
          for cur_kb in (select distinct a.partgroup_no
                           from mm_jiso_ins a
                          where a.plan_code = cur_route.plan_code
                            and a.route_code = cur_route.route_code
                            and a.supplier_no = cur_pg_order.supplier_no
                            and a.sup_factory = cur_pg_order.sup_factory
                            and a.arr_depot = cur_pg_order.arr_depot
                            and a.car_batch_seqno = cur_pg_order.car_batch_seqno
                            and a.order_deal_flag = 0)
          loop
            --获取上一个订单信息
            v_kb_pre_supplier_no := null;
            v_kb_pre_supfactory  := null;
            v_kb_pre_order_seqno := 0;
            for cur_kb_pre_order in (select a.supplier_no, a.sup_factory, a.order_seqno
                                       from mm_jiso_order_sup_kb a
                                      where a.plan_code = cur_route.plan_code
                                        and a.partgroup_no = cur_kb.partgroup_no
                                      order by a.order_seqno desc)
            loop
              v_kb_pre_supplier_no := cur_kb_pre_order.supplier_no;
              v_kb_pre_supfactory  := cur_kb_pre_order.sup_factory;
              v_kb_pre_order_seqno := cur_kb_pre_order.order_seqno;
              exit;
            end loop;
            --写入厂外同步订单供应商切换看板数据
            insert into mm_jiso_order_sup_kb
              (plan_code,
               partgroup_no,
               order_no,
               supplier_no,
               sup_factory,
               route_code,
               order_seqno)
            values
              (cur_route.plan_code,
               cur_kb.partgroup_no,
               v_order_no,
               cur_pg_order.supplier_no,
               cur_pg_order.sup_factory,
               cur_route.route_code,
               v_kb_pre_order_seqno + 1);
            --当出货地发生切换时，写入厂外同步订单供应商切换看板处理数据
            if v_kb_pre_supfactory is not null and cur_pg_order.sup_factory <> v_kb_pre_supfactory then
              insert into mm_jiso_order_sup_kb_deal
                (plan_code, partgroup_no, order_no)
              values
                (cur_route.plan_code, cur_kb.partgroup_no, v_order_no);
            end if;
            --删除不需显示于看板的订单信息
            delete from mm_jiso_order_sup_kb a
             where a.plan_code = cur_route.plan_code
               and a.partgroup_no = cur_kb.partgroup_no
               and a.order_seqno <= v_kb_pre_order_seqno - v_kb_order_num + 1;
          end loop;

          --更新车辆已组单的零件组总数
          for cur_queue in (select count(distinct a.partgroup_no) partgroup_num, b.order_no
                              from mm_jiso_ins a, mm_jiso_ins_detail b
                             where a.ins_no = b.ins_no
                               and a.plan_code = cur_route.plan_code
                               and a.route_code = cur_route.route_code
                               and a.supplier_no = cur_pg_order.supplier_no
                               and a.sup_factory = cur_pg_order.sup_factory
                               and a.arr_depot = cur_pg_order.arr_depot
                               and a.car_batch_seqno = cur_pg_order.car_batch_seqno
                               and a.order_deal_flag = 0
                             group by b.order_no)
          loop
            update mm_jiso_veh_queue a
               set a.partgroup_order_num = a.partgroup_order_num +
                                           cur_queue.partgroup_num
             where a.plan_code = cur_route.plan_code
               and a.order_no = cur_queue.order_no;
          end loop;

          --更新指示票订单信息
          update mm_jiso_ins a
             set a.order_deal_flag = 1,
                 a.order_no        = v_order_no,
                 a.order_deal_time = sysdate
           where a.plan_code = cur_route.plan_code
             and a.route_code = cur_route.route_code
             and a.supplier_no = cur_pg_order.supplier_no
             and a.sup_factory = cur_pg_order.sup_factory
             and a.arr_depot = cur_pg_order.arr_depot
             and a.car_batch_seqno = cur_pg_order.car_batch_seqno
             and a.order_deal_flag = 0;
        else
          --当手工组单时，则需要更新手工组单标识为已处理
          if v_manu_flag = 1 then
            update mm_jiso_order_manu_deal a
               set a.deal_flag = 1, a.deal_time = sysdate
             where a.plan_code = cur_route.plan_code
               and a.supplier_no = cur_pg_order.supplier_no
               and a.sup_factory = cur_pg_order.sup_factory
               and a.route_code = cur_pg_order.route_code
               and a.car_batch_seqno = cur_pg_order.car_batch_seqno;
          end if;

          --更新指示票订单信息
          update mm_jiso_ins a
             set a.order_deal_flag = 1,
                 a.order_deal_time = sysdate
           where a.plan_code = cur_route.plan_code
             and a.route_code = cur_route.route_code
             and a.supplier_no = cur_pg_order.supplier_no
             and a.sup_factory = cur_pg_order.sup_factory
             and a.arr_depot = cur_pg_order.arr_depot
             and a.car_batch_seqno = cur_pg_order.car_batch_seqno
             and a.order_deal_flag = 0;
        end if;
      end loop;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JISO_CREATE_ORDER_'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JISO_CREATE_ORDER;

  --****************************************************************************
  --过程名  : USP_JISO_CAL_EXEC
  --功能描述: 执行厂外同步推算
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --****************************************************************************
  PROCEDURE USP_JISO_CAL_EXEC(in_plan_code in varchar2) IS
    v_exec_start_time  date; --存储过程执行开始时间点
    v_produce_time     number(10,3); --生产节拍
    excep1             exception; --自定义异常
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    for cur_plancode in (select a.is_auto_exec, a.exec_state, a.factory_code, a.workcenter
                           from mm_pub_plan_code a
                          where a.plan_code = in_plan_code
                            and a.plan_code_type = 'JISO'
                            and a.is_enable = 1
                            and a.is_auto_exec = 1
                            and a.exec_state = 0)
    loop
      --获取生产节拍???
      v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_plancode.factory_code, cur_plancode.workcenter, null);
      if v_produce_time is null then
        raise excep1;
      end if;
      --更新执行标识位为执行中
      update mm_pub_plan_code a
         set a.exec_state = 1
       where a.plan_code = in_plan_code;
      commit;

      v_exec_start_time := sysdate;
      --获取推算队列
      USP_JISO_GET_PASS_QUEUE(in_plan_code);
      --展开零件净需求
      USP_JISO_CAL_NET_REQ(in_plan_code);
      --组票
      USP_JISO_CREATE_INS(in_plan_code);
      --组单
      USP_JISO_CREATE_ORDER(in_plan_code);

      --更新执行标识位为未执行
      update mm_pub_plan_code a
         set a.exec_state = 0, a.last_exec_time = v_exec_start_time
       where a.plan_code = in_plan_code;

      --统计存储过程执行消耗时间
      insert into mm_pub_exec_time_log
        (exec_code, exec_desc, start_time, end_time)
      values
        ('USP_JISO_CAL_EXEC'||in_plan_code, '执行厂外同步推算', v_exec_start_time, sysdate);
    end loop;

    COMMIT;
    EXCEPTION
      WHEN excep1 THEN
        ROLLBACK;
        err_num := 1;
        err_msg := '未维护生产节拍';
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JISO_CAL_EXEC_'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JISO_CAL_EXEC_'||in_plan_code, err_num, err_msg, sysdate,'');

        --更新厂外同步执行标识位为未执行
        update mm_pub_plan_code a
           set a.exec_state = 0
         where a.plan_code = in_plan_code;
        COMMIT;
  END USP_JISO_CAL_EXEC;

  --****************************************************************************
  --过程名  : USP_JISO_PART_PLAN
  --功能描述: 计算零件下线计划
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: lxq
  --创建时间: 2019-04-06
  --****************************************************************************
  PROCEDURE USP_JISO_PART_PLAN(in_plan_code in varchar2) IS
    v_exec_start_time  date; --存储过程执行开始时间点
    v_max_pass_time    mm_jiso_queue_config.max_pass_time%type; --已获取队列最大过点时间
    v_exec_flag        number(1); --是否获取队列标志，0：未获取 1：获取
    v_work_date        DATE; --当前时间的工作日期(不包含时分秒)
    v_cal_flag         number; --是否计算需求，0：不计算需求 1：计算需求
    v_flag             number; --临时标识
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    --遍历未产生净需求的车
    for cur_queue_config in (select a.factory_code, a.workcenter, b.*
                               from mm_pub_plan_code a,
                                    mm_jiso_queue_config b
                              where a.plan_code = b.plan_code
                                and a.plan_code = in_plan_code
                                and not exists (select 1 from mm_pub_plan_code t
                                                 where t.factory_code = a.factory_code
                                                   and t.workcenter = a.workcenter
                                                   and t.plan_code_type = 'JISO'
                                                   and t.is_enable = 1
                                                   and t.is_auto_exec = 0)
                                and a.plan_code_type = 'JISOP'
                                and a.is_enable = 1
                                and a.is_auto_exec = 1
                                and a.exec_state = 0)
    loop
      --更新执行标识位为执行中
      update mm_pub_plan_code a
         set a.exec_state = 1
       where a.plan_code = in_plan_code;
      commit;

      v_exec_start_time := sysdate;
      v_max_pass_time   := cur_queue_config.max_pass_time;
      v_exec_flag := 0;
      --根据配置信息获取获取过点队列数据
      for cur_queue in (select a.factory_code,
                               a.erp_order_no,
                               a.model_code,
                               a.phase,
                               to_date(a.weon_time,'yyyy-mm-dd hh24:mi:ss') pass_time,
                               to_date(a.afoff_time,'yyyy-mm-dd hh24:mi:ss') offline_time
                          from if_veh_lock_plan a
                         where a.factory_code = cur_queue_config.factory_code
                           and to_date(a.weon_time,'yyyy-mm-dd hh24:mi:ss') > cur_queue_config.max_pass_time
                         order by to_date(a.weon_time,'yyyy-mm-dd hh24:mi:ss'))
      loop
        v_exec_flag := 1;
        v_max_pass_time := cur_queue.pass_time;

        --获取工作日期(不包含时分秒)
        v_work_date := PKG_PUB.USF_GET_WORK_DATE(cur_queue_config.factory_code, cur_queue_config.workcenter, cur_queue.offline_time);

        --根据生产阶段获取计算标识
        v_cal_flag := 0;
        for cur_param in (select a.param_val
                            from mm_pub_sys_param a, mm_pub_data_dict b
                           where a.factory_code = b.factory_code
                             and b.code_type = 'PUB_PHASE'
                             and a.factory_code = cur_queue.factory_code
                             and a.param_group = 'JISO_CAL'
                             and a.param_code like 'JISO_CAL_PHASE%'
                             and a.param_val = b.code_value_name
                             and b.code_value = cur_queue.phase)
        loop
          v_cal_flag := 1;
        end loop;

        --遍历所有生效的厂外同步零件组
        for cur_partgroup in(select distinct a.id, a.partgroup_no, a.plan_code
                               from mm_jiso_partgroup       a,
                                    mm_jiso_partgroup_route b,
                                    mm_pub_plan_code        c
                              where a.id = b.partgroup_id
                                and a.plan_code = c.plan_code
                                and c.factory_code = cur_queue.factory_code
                                and a.eff_start <= v_work_date and a.eff_end > v_work_date
                                and b.eff_start <= v_work_date and b.eff_end > v_work_date)
        loop
          --判断零件组与零件对应关系是否存在
          select count(1)
            into v_flag
            from mm_jiso_partgroup       a,
                 mm_jiso_partgroup_route b,
                 mm_jiso_part            c,
                 mm_pub_part_uda         d,
                 mm_pub_order_bom        e
           where a.id = b.partgroup_id
             and a.id = c.partgroup_id
             and d.factory_code = cur_queue.factory_code
             and c.model_code = cur_queue.model_code
             and c.part_no = d.part_no
             and b.supplier_no = d.supplier_no
             and b.sup_factory = d.sup_factory
             and a.eff_start <= v_work_date
             and a.eff_end > v_work_date
             and b.eff_start <= v_work_date
             and b.eff_end > v_work_date
             and c.eff_start <= v_work_date
             and c.eff_end > v_work_date
             and a.id = cur_partgroup.id
             and e.factory_code = cur_queue.factory_code
             and e.order_no = cur_queue.erp_order_no
             and e.workcenter = cur_queue_config.workcenter
             and e.part_no = c.part_no
             and rownum = 1;
          if v_flag = 0 or v_cal_flag = 0 then
            --如果零件组与零件对应关系数据没有维护 或 不计算需求，随机取一路线数据，写入空需求
            --是否考虑上一张单据的路线???
            for cur_route in (select *
                                from (select 2 seq, a.partgroup_no, b.supplier_no, a.arr_depot
                                        from mm_jiso_partgroup a,
                                             mm_jiso_partgroup_route b,
                                             mm_pub_plan_code        c
                                       where a.id = b.partgroup_id
                                         and a.plan_code = c.plan_code
                                         and c.factory_code = cur_queue.factory_code
                                         and a.id = cur_partgroup.id
                                         and a.eff_start <= v_work_date and a.eff_end > v_work_date
                                         and b.eff_start <= v_work_date and b.eff_end > v_work_date
                                     )
                               order by seq)

            loop
              insert into mm_jiso_part_plan
                (id,
                 factory_code,
                 partgroup_no,
                 supplier_no,
                 arr_depot,
                 part_no,
                 require_num,
                 offline_time,
                 model_code
                 )
              values
                (seq_mm_jiso_part_plan.nextval,
                 cur_queue.factory_code,
                 cur_route.partgroup_no,
                 cur_route.supplier_no,
                 cur_route.arr_depot,
                 null,
                 null,
                 cur_queue.offline_time,
                 cur_queue.model_code
                 );
              exit;
            end loop;
          else
            for cur_net_req in (select a.partgroup_no,
                                       b.supplier_no,
                                       a.arr_depot,
                                       c.part_no,
                                       sum(e.num) require_num
                                  from mm_jiso_partgroup       a,
                                       mm_jiso_partgroup_route b,
                                       mm_jiso_part            c,
                                       mm_pub_part_uda         d,
                                       mm_pub_order_bom        e
                                 where a.id = b.partgroup_id
                                   and a.id = c.partgroup_id
                                   and d.factory_code = cur_queue.factory_code
                                   and c.model_code = cur_queue.model_code
                                   and c.part_no = d.part_no
                                   and b.supplier_no = d.supplier_no
                                   and b.sup_factory = d.sup_factory
                                   and a.eff_start <= v_work_date
                                   and a.eff_end > v_work_date
                                   and b.eff_start <= v_work_date
                                   and b.eff_end > v_work_date
                                   and c.eff_start <= v_work_date
                                   and c.eff_end > v_work_date
                                   and a.id = cur_partgroup.id
                                   and e.factory_code = cur_queue.factory_code
                                   and e.order_no = cur_queue.erp_order_no
                                   and e.workcenter = cur_queue_config.workcenter
                                   and e.part_no = c.part_no
                                 group by a.partgroup_no,
                                          b.supplier_no,
                                          a.arr_depot,
                                          c.part_no)
            loop
              --存在且计算时，计算并写入零件需求信息
              insert into mm_jiso_part_plan
                (id,
                 factory_code,
                 partgroup_no,
                 supplier_no,
                 arr_depot,
                 part_no,
                 require_num,
                 offline_time,
                 model_code
                 )
              values
                (seq_mm_jiso_part_plan.nextval,
                 cur_queue.factory_code,
                 cur_net_req.partgroup_no,
                 cur_net_req.supplier_no,
                 cur_net_req.arr_depot,
                 cur_net_req.part_no,
                 cur_net_req.require_num,
                 cur_queue.offline_time,
                 cur_queue.model_code);
            end loop;
          end if;
        end loop;
      end loop;

      --更新厂外同步过点车序队列配置信息
      if v_exec_flag = 1 then
        update mm_jiso_queue_config t
           set t.max_pass_time    = v_max_pass_time
         where t.plan_code = in_plan_code;
      end if;
      --更新执行标识位为未执行
      update mm_pub_plan_code a
         set a.exec_state = 0, a.last_exec_time = v_exec_start_time
       where a.plan_code = in_plan_code;

      --统计存储过程执行消耗时间
      insert into mm_pub_exec_time_log
        (exec_code, exec_desc, start_time, end_time)
      values
        ('USP_JISO_PART_PLAN:'||in_plan_code, '执行同步零件下线计划推算', v_exec_start_time, sysdate);
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JISO_PART_PLAN', err_num, err_msg, sysdate,'');

        --更新厂外同步执行标识位为未执行
        update mm_pub_plan_code a
           set a.exec_state = 0
         where a.plan_code = in_plan_code;
        COMMIT;
  END USP_JISO_PART_PLAN;

end PKG_JISO;
/

prompt
prompt Creating package body PKG_JIT
prompt =============================
prompt
create or replace package body PKG_JIT is

  --****************************************************************************
  --函数  : USF_GET_KBPRODSEQNO
  --功能描述: 根据产品流水号判断是否达到批次条件
  --参数说明:
  -- in_plan_code  :信息点
  -- in_check_prod_seqno  :检查的产品流水号
  -- in_ahead_prod_num    :提前台套数
  --返回值: 检查结果
  --创建人员: wxl
  --创建时间: 2018-11-29
  --****************************************************************************
  FUNCTION USF_GET_KBPRODSEQNO(in_plan_code        in varchar2)
    RETURN NUMBER AS
    out_kb_product_seqno    number(19); --看板产品流水号
  BEGIN
    out_kb_product_seqno  := null;
    select b.product_seqno
      into out_kb_product_seqno
      from mm_pub_plan_code a, mm_mon_kb b
     where a.kb_id = b.id
       and a.plan_code = in_plan_code;
    return out_kb_product_seqno;
  end USF_GET_KBPRODSEQNO;

  --****************************************************************************
  --过程名  : USP_JIT_GET_PASS_QUEUE
  --功能描述: 拉动获取车序队列
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --修改记录：
  --         修改获取下一时间方法 mod by wxl 20190120
  --         调整计算过看板时间方法 mod by wxl 20190423
  --         i-LMS2019052901增加信息点车辆过滤 mod by wxl 20190529
  --****************************************************************************
  PROCEDURE USP_JIT_GET_PASS_QUEUE(in_plan_code in varchar2) IS
    v_max_pass_time    mm_jit_queue_config.max_pass_time%type; --已获取队列最大过点时间
    --v_max_sortid       mm_jit_queue_config.max_sortid%type; --已获取队列最大排序码
    v_kb_product_seqno mm_jit_queue_config.kb_product_seqno%type; --看板批次产品流水号
    v_kb_time          mm_jit_queue_config.kb_time%type; --看板时间
    v_produce_time     number(10,3); --生产节拍
    v_exec_flag        number(1); --是否获取队列标志，0：未获取 1：获取
    v_cal_flag         number(1); --是否计算标识,0: 不计算 1：计算
    v_loc_num          number(19); --车间工深
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    --获取拉动过点车序队列配置表信息
    for cur_queue_config in (select a.factory_code, a.workcenter, a.station_code, b.*
                               from mm_pub_plan_code a,
                                    mm_jit_queue_config b
                              where a.plan_code = b.plan_code
                                and a.plan_code = in_plan_code)
    loop
      v_exec_flag        := 0;
      v_kb_product_seqno := cur_queue_config.kb_product_seqno;
      v_max_pass_time    := cur_queue_config.max_pass_time;
      v_kb_time          := cur_queue_config.kb_time;

      --1 计划信息点，0 实绩信息点
      if cur_queue_config.is_plan = 1 then
        --根据配置信息获取获取过点队列数据
        for cur_queue in (select a.*
                            from if_veh_lock_plan a
                           where a.factory_code = cur_queue_config.factory_code
                             and to_date(a.weon_time,'yyyy-mm-dd hh24:mi:ss') > cur_queue_config.max_pass_time
                             --mod by wxl 20190529
                             and not exists (select 1
                                    from mm_pub_plan_code b, mm_jit_veh_filter c
                                   where b.plan_code = c.plan_code
                                     and b.factory_code = a.factory_code
                                     and c.order_no = a.order_no
                                     and c.plan_code = cur_queue_config.plan_code)
                           order by to_date(a.weon_time,'yyyy-mm-dd hh24:mi:ss'))
        loop
          v_exec_flag:=1;
          --v_max_sortid := cur_queue.sort_id;
          v_max_pass_time := to_date(cur_queue.weon_time, 'yyyy-mm-dd hh24:mi:ss');
          --获取生产节拍???
          --mod by wxl 20190423
          --v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_queue_config.factory_code, cur_queue_config.workcenter, null);
          --v_kb_time    := PKG_PUB.USF_GET_CAL_WORKTIME(cur_queue_config.factory_code, cur_queue_config.workcenter, v_kb_time, 1*v_produce_time);
          v_kb_time := to_date(cur_queue.weon_time, 'yyyy-mm-dd hh24:mi:ss');
          if PKG_PUB.USF_GET_WORKCENTER_PRE(cur_queue_config.workcenter) = 'A' then
            --焊装
            v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_queue_config.factory_code, 'W1', 'WE_MAIN');
            v_loc_num      := NVL(to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_queue_config.factory_code, 'MAX_LOC', 'WE_TOTAL_PRO_NUM')),0);
            v_kb_time      := PKG_PUB.USF_GET_CAL_WORKTIME(cur_queue_config.factory_code, 'W1', v_kb_time, v_loc_num*v_produce_time);
            --焊装缓冲
            v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_queue_config.factory_code, 'T1', 'WBS_MAIN');
            v_loc_num      := NVL(to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_queue_config.factory_code, 'MAX_LOC', 'WBS_TOTAL_PRO_NUM')),0);
            v_kb_time      := PKG_PUB.USF_GET_CAL_WORKTIME(cur_queue_config.factory_code, 'T1', v_kb_time, v_loc_num*v_produce_time);
            --涂装
            v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_queue_config.factory_code, 'T1', 'PA_MAIN');
            v_loc_num      := NVL(to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_queue_config.factory_code, 'MAX_LOC', 'PA_TOTAL_PRO_NUM')),0);
            v_kb_time      := PKG_PUB.USF_GET_CAL_WORKTIME(cur_queue_config.factory_code, 'T1', v_kb_time, v_loc_num*v_produce_time);
            --涂装缓冲
            v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_queue_config.factory_code, 'A1', 'ABS_MAIN');
            v_loc_num      := NVL(to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_queue_config.factory_code, 'MAX_LOC', 'PBS_TOTAL_PRO_NUM')),0);
            v_kb_time      := PKG_PUB.USF_GET_CAL_WORKTIME(cur_queue_config.factory_code, 'A1', v_kb_time, v_loc_num*v_produce_time);
            --总装
            v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_queue_config.factory_code, 'A1', 'AF_MAIN');
            v_loc_num      := NVL(to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_queue_config.factory_code, 'MAX_LOC', 'AF_TOTAL_PRO_NUM')),0);
            v_kb_time      := PKG_PUB.USF_GET_CAL_WORKTIME(cur_queue_config.factory_code, 'A1', v_kb_time, (v_loc_num-1)*v_produce_time);
          else
            --焊装
            v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_queue_config.factory_code, 'W1', 'WE_MAIN');
            v_loc_num      := NVL(to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_queue_config.factory_code, 'MAX_LOC', 'WE_TOTAL_PRO_NUM')),0);
            v_kb_time      := PKG_PUB.USF_GET_CAL_WORKTIME(cur_queue_config.factory_code, 'W1', v_kb_time, (v_loc_num-1)*v_produce_time);
          end if;

          v_cal_flag := 0;
          --根据生产阶段获取计算标识
          for cur_param in (select a.param_val
                              from mm_pub_sys_param a, mm_pub_data_dict b
                             where a.factory_code = b.factory_code
                               and b.code_type = 'PUB_PHASE'
                               and a.factory_code = cur_queue.factory_code
                               and a.param_group = 'JIT_CAL'
                               and a.param_code like 'JIT_CAL_PHASE%'
                               and a.param_val = b.code_value_name
                               and b.code_value = cur_queue.phase)
          loop
            v_cal_flag := 1;
          end loop;
          --根据报废车信息获取计算标识,在信息点对应屏蔽报废车间不存在则计算需求
          select decode(count(*), 0, v_cal_flag, 0)
            into v_cal_flag
            from mm_jit_veh_scrap a, mm_pub_plan_code_scrap b
           where a.factory_code = cur_queue.factory_code
             and a.order_no = cur_queue.order_no
             and b.plan_code = cur_queue.factory_code
             and a.scrap_workcenter = b.scrap_workcenter;

          --写入拉动推算队列
          if v_cal_flag = 1 then
            v_kb_product_seqno := v_kb_product_seqno + 1;
            insert into mm_jit_veh_queue
              (plan_code,
               order_no,
               erp_order_no,
               vin,
               model_code,
               phase,
               pass_time,
               sortid,
               kb_product_seqno,
               kb_time)
            values
              (in_plan_code,
               cur_queue.order_no,
               cur_queue.erp_order_no,
               cur_queue.vin,
               cur_queue.model_code,
               cur_queue.phase,
               v_max_pass_time,
               null,
               v_kb_product_seqno,
               v_kb_time);
          end if;
        end loop;
      else
        --根据配置信息获取获取过点队列数据
        for cur_queue in (select a.*
                            from mm_pub_veh_pass a
                           where a.factory_code = cur_queue_config.factory_code
                             and a.station_code = cur_queue_config.station_code
                             and a.pass_time > cur_queue_config.max_pass_time
                             --mod by wxl 20190529
                             and not exists (select 1
                                    from mm_pub_plan_code b, mm_jit_veh_filter c
                                   where b.plan_code = c.plan_code
                                     and b.factory_code = a.factory_code
                                     and b.station_code = a.station_code
                                     and c.order_no = a.order_no
                                     and c.plan_code = cur_queue_config.plan_code)
                           order by a.pass_time)
        loop
          v_exec_flag     := 1;
          v_max_pass_time := cur_queue.pass_time;
          --获取生产节拍???
          --mod by wxl 20190423
          --v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_queue_config.factory_code, cur_queue_config.workcenter, null);
          --v_kb_time      := PKG_PUB.USF_GET_NEXT_WORKTIME(cur_queue_config.factory_code, cur_queue_config.workcenter, v_kb_time, 1*v_produce_time);
          v_kb_time := cur_queue.pass_time;
          if PKG_PUB.USF_GET_WORKCENTER_PRE(cur_queue_config.workcenter) = 'A' then
             --涂装缓冲
            v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_queue_config.factory_code, 'A1', 'ABS_MAIN');
            v_loc_num      := NVL(to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_queue_config.factory_code, 'MAX_LOC', 'PBS_TOTAL_PRO_NUM')),0);
            v_kb_time      := PKG_PUB.USF_GET_CAL_WORKTIME(cur_queue_config.factory_code, 'A1', v_kb_time, v_loc_num*v_produce_time);
            --总装
            v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_queue_config.factory_code, 'A1', 'AF_MAIN');
            v_loc_num      := NVL(to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_queue_config.factory_code, 'MAX_LOC', 'AF_TOTAL_PRO_NUM')),0);
            v_kb_time      := PKG_PUB.USF_GET_CAL_WORKTIME(cur_queue_config.factory_code, 'A1', v_kb_time, (v_loc_num-1)*v_produce_time);
          end if;

          v_cal_flag := 0;
          --根据生产阶段获取计算标识
          for cur_param in (select a.param_val
                              from mm_pub_sys_param a, mm_pub_data_dict b
                             where a.factory_code = b.factory_code
                               and b.code_type = 'PUB_PHASE'
                               and a.factory_code = cur_queue.factory_code
                               and a.param_group = 'JIT_CAL'
                               and a.param_code like 'JIT_CAL_PHASE%'
                               and a.param_val = b.code_value_name
                               and b.code_value = cur_queue.phase)
          loop
            v_cal_flag := 1;
          end loop;
          --根据报废车信息获取计算标识,在信息点对应屏蔽报废车间不存在则计算需求
          select decode(count(*), 0, v_cal_flag, 0)
            into v_cal_flag
            from mm_jit_veh_scrap a, mm_pub_plan_code_scrap b
           where a.factory_code = cur_queue.factory_code
             and a.order_no = cur_queue.order_no
             and b.plan_code = cur_queue.factory_code
             and a.scrap_workcenter = b.scrap_workcenter;

          --写入拉动推算队列
          if v_cal_flag = 1 then
            v_kb_product_seqno := v_kb_product_seqno + 1;
            insert into mm_jit_veh_queue
              (plan_code,
               order_no,
               erp_order_no,
               vin,
               model_code,
               phase,
               pass_time,
               sortid,
               kb_product_seqno,
               kb_time)
            values
              (in_plan_code,
               cur_queue.order_no,
               cur_queue.erp_order_no,
               cur_queue.vin,
               cur_queue.model_code,
               cur_queue.phase,
               v_max_pass_time,
               null,
               v_kb_product_seqno,
               v_kb_time);
          end if;
        end loop;
      end if;
      --更新厂外同步过点车序队列配置信息
      if v_exec_flag = 1 then
        update mm_jit_queue_config t
           set t.max_pass_time = v_max_pass_time,
               --t.max_sortid = v_max_sortid,
               t.kb_product_seqno = v_kb_product_seqno
         where t.plan_code = in_plan_code;
      end if;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JIT_GET_PASS_QUEUE：'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JIT_GET_PASS_QUEUE;

  --****************************************************************************
  --过程名  : USP_JITI_CAL_NET_REQ
  --功能描述: 计算零件净需求（厂内）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --修改记录：
  --         LMS2019011503修改厂内拉动零件清单逻辑 mod by wxl 20190221
  --         disitnct属地信息 mod by wxl 20190325
  --         因内物流同一工厂、车间、零件、工位存在多个落点调整为取任意一点 mod by wxl 20190328
  --         调整包装信息由关联改为存在，加入零件供应商关系判断 mod by wxl 20190402
  --         iLMS2019061401 优化厂内拉动-取消供应商限制 mod by wxl 20190614
  --****************************************************************************
  PROCEDURE USP_JITI_CAL_NET_REQ(in_plan_code in varchar2) IS
    err_num         number(10); --错误代码
    err_msg         varchar2(200); --错误信息
  BEGIN
    --产生净需求
    /*
    零件净需求满足条件：
      1）属地管理中存在此工厂、车间、车型且卸货口厂内物流模式为“厂内拉动”的零件生效记录；
      2）订单BOM中存在此工厂、车间、工位、零件关系；
      3）包装管理中存在此工厂、车型、零件且状态为“实物通过”的生效记录。
    */
    /*
    insert into mm_jit_net_req
      (plan_code,
       order_no,
       part_no,
       location,
       require_num,
       model_code,
       pass_time,
       kb_product_seqno,
       kb_time)
      select b.plan_code,
             b.order_no,
             e.part_no,
             e.location,
             sum(c.num) require_num,
             b.model_code,
             b.pass_time,
             b.kb_product_seqno,
             b.kb_time
        from mm_pub_plan_code     a,
             mm_jit_veh_queue     b,
             mm_pub_order_bom     c,
             mm_inv_unload        d,
             mm_inv_part_location e,
             mm_pkg_proposal      f
       where b.plan_code = in_plan_code
         and b.exec_status = 0
         and a.plan_code = b.plan_code
         and d.factory_code = a.factory_code
         and d.work_center = a.workcenter
         --and d.logistics_mode = 'SW' mod by wxl 20190221
         and d.inner_logistics_model = 'JITI'
         and e.factory_code = d.factory_code
         and e.workcenter = d.work_center
         and e.unload_port = d.unload_port
         and e.eff_start <= b.pass_time
         and e.eff_end > b.pass_time
         and f.factory_code = e.factory_code
         and f.car_type = b.model_code --是否加车型???
         and f.supplier_no = e.supplier_no
         and f.part_no = e.part_no
         and f.proposal_status = 5 --实物通过
         and f.eff_start <= b.pass_time
         and f.eff_end > b.pass_time
         and c.order_no = b.erp_order_no
         and c.factory_code = e.factory_code
         and c.workcenter = e.workcenter
         and c.part_no = e.part_no
         and c.station_code = e.station_code
       group by b.plan_code,
                b.order_no,
                e.part_no,
                e.location,
                b.model_code,
                b.pass_time,
                b.kb_product_seqno,
                b.kb_time;
    */
    insert into mm_jit_net_req
      (plan_code,
       order_no,
       part_no,
       location,
       require_num,
       model_code,
       pass_time,
       kb_product_seqno,
       kb_time)
      select plan_code,
             order_no,
             part_no,
             location,
             sum(num) require_num,
             model_code,
             pass_time,
             kb_product_seqno,
             kb_time
        from (select distinct b.plan_code,
                              b.order_no,
                              e.part_no,
                              e.location,
                              c.part_rowno,
                              c.num,
                              b.model_code,
                              b.pass_time,
                              b.kb_product_seqno,
                              b.kb_time,
                              rank() over(partition by b.plan_code, b.order_no, e.part_no, c.part_rowno, c.num, b.model_code, b.pass_time, b.kb_product_seqno, b.kb_time order by e.location_num desc, e.location) sn
                from mm_pub_plan_code     a,
                     mm_jit_veh_queue     b,
                     mm_pub_order_bom     c,
                     mm_inv_unload        d,
                     mm_inv_part_location e
               where b.plan_code = in_plan_code
                 and b.exec_status = 0
                 and a.plan_code = b.plan_code
                 and d.factory_code = a.factory_code
                 and d.work_center = a.workcenter
                    --and d.logistics_mode = 'SW' mod by wxl 20190221
                 and d.inner_logistics_model = 'JITI'
                 and e.factory_code = d.factory_code
                 and e.workcenter = d.work_center
                 and e.unload_port = d.unload_port
                 and e.model_code = b.model_code --是否加车型???
                 and e.eff_start <= b.pass_time
                 and e.eff_end > b.pass_time
                 and exists
               (select 1
                        from mm_pkg_proposal f, mm_pub_part_supplier s
                       where f.factory_code = e.factory_code
                         and f.car_type = b.model_code --是否加车型???
                         --and f.supplier_no = e.supplier_no mod by wxl 20190614
                         and f.part_no = e.part_no
                         and f.proposal_status = 5 --实物通过
                         and f.eff_start <= b.pass_time
                         and f.eff_end > b.pass_time
                         and f.factory_code = s.factory_code
                         and f.part_no = s.part_no
                         and f.supplier_no = s.supplier_no)
                 and c.order_no = b.erp_order_no
                 and c.factory_code = e.factory_code
                 and c.workcenter = e.workcenter
                 and c.part_no = e.part_no
                 and c.station_code = e.station_code)
       where sn = 1
       group by plan_code,
                order_no,
                part_no,
                location,
                model_code,
                pass_time,
                kb_product_seqno,
                kb_time;
    --更新车辆推算状态
    update mm_jit_veh_queue a
       set a.exec_status = 1, a.exec_time = sysdate
     where a.plan_code = in_plan_code
       and a.exec_status = 0;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JITI_CAL_NET_REQ：'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JITI_CAL_NET_REQ;

  --****************************************************************************
  --过程名  : USP_JITO_CAL_NET_REQ
  --功能描述: 计算零件净需求（厂外）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --         disitnct属地信息 mod by wxl 20190325
  --         因内物流同一工厂、车间、零件、工位存在多个落点调整为取任意一点 mod by wxl 20190326
  --****************************************************************************
  PROCEDURE USP_JITO_CAL_NET_REQ(in_plan_code in varchar2) IS
    err_num         number(10); --错误代码
    err_msg         varchar2(200); --错误信息
  BEGIN
    --产生净需求
    /*
    insert into mm_jit_net_req
      (plan_code,
       order_no,
       part_no,
       location,
       require_num,
       model_code,
       pass_time,
       kb_product_seqno,
       kb_time)
      select req.plan_code,
             req.order_no,
             req.part_no,
             loc.location,
             sum(req.num) require_num,
             req.model_code,
             req.pass_time,
             req.kb_product_seqno,
             req.kb_time
        from (select a.factory_code,
                     a.workcenter,
                     b.plan_code,
                     c.order_no,
                     d.part_no,
                     c.station_code,
                     c.num,
                     b.model_code,
                     b.pass_time,
                     b.kb_product_seqno,
                     b.kb_time
                from mm_pub_plan_code a,
                     mm_jit_veh_queue b,
                     mm_pub_order_bom c,
                     mm_jit_part      d
               where b.plan_code = in_plan_code
                 and b.exec_status = 0
                 and d.plan_code = b.plan_code
                 and d.model_code = b.model_code
                 and d.eff_start <= b.pass_time
                 and d.eff_end > b.pass_time
                 and a.plan_code = b.plan_code
                 and c.order_no = b.erp_order_no
                 and c.factory_code = a.factory_code
                 and c.workcenter = a.workcenter
                 and c.part_no = d.part_no) req
        left join mm_inv_part_location loc
          on loc.factory_code = req.factory_code
         and loc.workcenter = req.workcenter
         and loc.part_no = req.part_no
         and loc.station_code = req.station_code
         and loc.eff_start <= req.pass_time
         and loc.eff_end > req.pass_time
       group by req.plan_code,
                req.order_no,
                req.part_no,
                loc.location,
                req.model_code,
                req.pass_time,
                req.kb_product_seqno,
                req.kb_time;
    */
    insert into mm_jit_net_req
      (plan_code,
       order_no,
       part_no,
       location,
       require_num,
       model_code,
       pass_time,
       kb_product_seqno,
       kb_time)
      select plan_code,
             order_no,
             part_no,
             location,
             sum(num) require_num,
             model_code,
             pass_time,
             kb_product_seqno,
             kb_time
        from (select distinct req.plan_code,
                              req.order_no,
                              req.part_no,
                              loc.location,
                              req.part_rowno,
                              req.num,
                              req.model_code,
                              req.pass_time,
                              req.kb_product_seqno,
                              req.kb_time,
                              rank() over(partition by req.plan_code, req.order_no, req.part_no, req.part_rowno, req.num, req.model_code, req.pass_time, req.kb_product_seqno, req.kb_time order by loc.location_num desc, loc.location) sn
                from (select a.factory_code,
                             a.workcenter,
                             b.plan_code,
                             c.order_no,
                             d.part_no,
                             c.station_code,
                             c.part_rowno,
                             c.num,
                             b.model_code,
                             b.pass_time,
                             b.kb_product_seqno,
                             b.kb_time
                        from mm_pub_plan_code a,
                             mm_jit_veh_queue b,
                             mm_pub_order_bom c,
                             mm_jit_part      d
                       where b.plan_code = in_plan_code
                         and b.exec_status = 0
                         and d.plan_code = b.plan_code
                         and d.model_code = b.model_code
                         and d.eff_start <= b.pass_time
                         and d.eff_end > b.pass_time
                         and a.plan_code = b.plan_code
                         and c.order_no = b.erp_order_no
                         and c.factory_code = a.factory_code
                         and c.workcenter = a.workcenter
                         and c.part_no = d.part_no) req
                left join mm_inv_part_location loc
                  on loc.factory_code = req.factory_code
                 and loc.workcenter = req.workcenter
                 and loc.part_no = req.part_no
                 and loc.station_code = req.station_code
                 and loc.eff_start <= req.pass_time
                 and loc.eff_end > req.pass_time)
       where sn = 1
       group by plan_code,
                order_no,
                part_no,
                location,
                model_code,
                pass_time,
                kb_product_seqno,
                kb_time;
    --更新车辆推算状态
    update mm_jit_veh_queue a
       set a.exec_status = 1, a.exec_time = sysdate
     where a.plan_code = in_plan_code
       and a.exec_status = 0;
    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JITO_CAL_NET_REQ：'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JITO_CAL_NET_REQ;

  --****************************************************************************
  --过程名  : USP_JITD_CAL_NET_REQ
  --功能描述: 计算零件净需求（厂外->厂内）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2019-06-11
  --****************************************************************************
  PROCEDURE USP_JITD_CAL_NET_REQ(in_plan_code in varchar2) IS
    err_num         number(10); --错误代码
    err_msg         varchar2(200); --错误信息
  BEGIN
    --产生净需求
    /*
    零件净需求满足条件：
      1）属地管理中存在此工厂、车间、车型且卸货口厂外物流模式为“厂外拉动”、厂内物流模式不为“厂内拉动”的零件生效记录；
      2）订单BOM中存在此工厂、车间、工位、零件关系；
    */
    insert into mm_jit_net_req
      (plan_code,
       order_no,
       part_no,
       location,
       require_num,
       model_code,
       pass_time,
       kb_product_seqno,
       kb_time)
      select plan_code,
             order_no,
             part_no,
             location,
             sum(num) require_num,
             model_code,
             pass_time,
             kb_product_seqno,
             kb_time
        from (select distinct b.plan_code,
                              b.order_no,
                              e.part_no,
                              e.location,
                              c.part_rowno,
                              c.num,
                              b.model_code,
                              b.pass_time,
                              b.kb_product_seqno,
                              b.kb_time,
                              rank() over(partition by b.plan_code, b.order_no, e.part_no, c.part_rowno, c.num, b.model_code, b.pass_time, b.kb_product_seqno, b.kb_time order by e.location_num desc, e.location) sn
                from mm_pub_plan_code     a,
                     mm_jit_veh_queue     b,
                     mm_pub_order_bom     c,
                     mm_inv_unload        d,
                     mm_inv_part_location e
               where b.plan_code = in_plan_code
                 and b.exec_status = 0
                 and a.plan_code = b.plan_code
                 and d.factory_code = a.factory_code
                 and d.work_center = a.workcenter
                 and d.logistics_mode = 'JIT'
                 and (d.inner_logistics_model != 'JITI' or d.inner_logistics_model is null)
                 and e.factory_code = d.factory_code
                 and e.workcenter = d.work_center
                 and e.unload_port = d.unload_port
                 and e.model_code = b.model_code --是否加车型???
                 and e.eff_start <= b.pass_time
                 and e.eff_end > b.pass_time
                 and c.order_no = b.erp_order_no
                 and c.factory_code = e.factory_code
                 and c.workcenter = e.workcenter
                 and c.part_no = e.part_no)
       where sn = 1
       group by plan_code,
                order_no,
                part_no,
                location,
                model_code,
                pass_time,
                kb_product_seqno,
                kb_time;
    --更新车辆推算状态
    update mm_jit_veh_queue a
       set a.exec_status = 1, a.exec_time = sysdate
     where a.plan_code = in_plan_code
       and a.exec_status = 0;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JITD_CAL_NET_REQ：'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JITD_CAL_NET_REQ;

  --****************************************************************************
  --过程名  : USP_JITI_DPM_DEAL
  --功能描述: 不良品处理（厂内）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-26
  --修改记录：
  --         修改获取下一时间方法 mod by wxl 20190120
  --         修改获取零件简号方法 mod by wxl 20190128
  --         修复使用落点类型记录BUG mod by wxl 20190328
  --         优化使用落点同一工深，取落点编码最小的 mod by wxl 20190328
  --         调整供应商名称获取关联为右关联 mod by wxl 20190402
  --         修复不良品计算后零件余量为空的情况 mod by wxl 20190606
  --         iLMS2019053001 调整多工厂 mod by wxl 20190610
  --         修复截止产品零件余量业务主键冲突BUG mod by wxl 20190611
  --         iLMS2019011503 修改厂内拉动零件清单逻辑(漏调） mod by wxl 20190611
  --         iLMS2019061401 优化厂内拉动-取消供应商限制 mod by wxl 20190614
  --****************************************************************************
  PROCEDURE USP_JITI_DPM_DEAL(in_plan_code in varchar2) IS
    v_remain_exists_flag number(1); --零件余量是否存在
    v_start_remain       mm_jit_part_remain.part_remain%type; --期初余量
    v_end_remain         mm_jit_part_remain.part_remain%type; --期末余量
    v_safety_inventory   mm_jit_part_remain.safety_inventory%type; --安全库存
    v_location           mm_jit_part_remain.location%type; --落点
    v_dpm_num            number(10); --不良品数量
    v_require_num        number(10); --需求量
    v_distri_qty         number(10); --配送量
    v_part_short_no      varchar2(10); --零件简号 ???
    v_part_name          varchar2(150); --零件名称 ???
    v_sup_factory        varchar2(20); --供应商出货地 ???
    v_supplier_no        varchar2(20); --供应商代码 ???
    v_supplier_name      varchar2(150); --供应商名称 ???
    v_ship_depot         mm_jit_part.ship_depot%type; --出货仓库
    v_arr_depot          mm_jit_part.arr_depot%type; --到货仓库
    v_distri_package     mm_jit_part.distri_package%type; --配送包装
    v_standard_package   mm_jit_part.standard_package%type; --规格包装
    v_unload_port        mm_inv_part_location.unload_port%type; --卸货口
    v_storage            mm_inv_part_location.storage%type; --库位
    v_prepare_person     mm_inv_part_location.prepare_person%type; --拣货工程
    v_carpool            mm_inv_part_location.carpool%type; --台车
    v_distri_person      mm_inv_part_location.distri_person%type; --配送工程
    v_use_location_num   mm_jit_pkg_req.use_location_num%type; --使用落点类型
    v_loc_num            mm_inv_part_location.location_num%type; --落点工程深度
    v_work_date          date; --当前时间的工作日期(不包含时分秒)
    v_produce_time       number(10,3); --生产节拍
    v_prepare_num        number(10);--备件流动数
    v_dispatch_num       number(10);--发车流动数
    v_delivery_num       number(10);--发货流动数
    v_arrive_num         number(10);--到货流动数
    v_distri_num         number(10);--配送流动数
    v_prepare_time       date; --备货时间
    v_dispatch_time      date; --发车时间
    v_delivery_time      date; --发货时间
    v_arrive_time        date; --到货时间
    v_distri_time        date; --配送时间
    v_assemble_time      date; --装配时间
    v_prepare_product_seqno  number(19); --备件批次产品流水号
    v_dispatch_product_seqno number(19); --发车批次产品流水号
    v_delivery_product_seqno number(19); --发货批次产品流水号
    v_arrive_product_seqno   number(19); --到货批次产品流水号
    v_distri_product_seqno   number(19); --配送批次产品流水号
    v_assemble_product_seqno number(19); --装配批次产品流水号
    v_pkg_req_id         number(19); --包装需求ID
  BEGIN
    --取当前推算车辆最早时间为不良品物流周期计算依据
    /*
    for cur_queue in (select a.kb_product_seqno,
                             a.kb_time,
                             a.pass_time,
                             a.model_code
                        from mm_jit_veh_queue a
                       where a.plan_code = in_plan_code
                         and a.exec_status = 0
                         and a.kb_product_seqno =
                             (select min(b.kb_product_seqno)
                                from mm_jit_veh_queue b
                               where b.plan_code = in_plan_code
                                 and b.exec_status = 0))
    loop
    */
    for cur_queue in (select distinct a.kb_product_seqno,
                             a.kb_time,
                             a.pass_time,
                             a.model_code
                        from mm_jit_net_req a
                       where a.plan_code = in_plan_code
                         and a.kb_product_seqno =
                             (select min(b.kb_product_seqno)
                                from mm_jit_net_req b
                               where b.plan_code = in_plan_code))
    loop
      --获取需处理的不良品信息???(是否考虑不良车型）
      /*
      不良品满足条件：
        1）不良品状态为“审核通过”
        2）属地管理中存在此工厂、班组且卸货口物流模式为“循环取货”的零件生效记录；
        3）包装管理中存在此工厂、零件、供应商、车型（属地）且状态为“实物通过”的生效记录。
      */
      for cur_req in (select distinct a.plan_code,
                             a.factory_code,
                             a.workcenter,
                             b.part_no,
                             b.resp_dep,
                             c.unload_port
                        from mm_pub_plan_code a, mm_dpm_ins b, mm_inv_unload c
                       where b.factory_code = a.factory_code
                         and c.factory_code = a.factory_code
                         and c.work_center = a.workcenter
                         --and c.logistics_mode = 'SW' mod by wxl 20190611
                         and c.inner_logistics_model = 'JITI'
                         and a.plan_code = in_plan_code
                         --添加已算需求不良品过滤 mod by wxl 20190606
                         and b.apply_no not in (select d.dpm_apply_no from mm_jit_pkg_req_dpm d where d.plan_code = a.plan_code)
                         and b.ins_status = 2 --审核通过
                         and b.delivery_status = 0
                         and exists (select 1
                                from mm_inv_part_location t1, mm_pkg_proposal t2
                               where t1.factory_code = c.factory_code
                                 and t1.workcenter = c.work_center
                                 and t1.unload_port = c.unload_port
                                 and t1.part_no = b.part_no
                                 and t1.dep_no = b.resp_dep
                                 and t1.eff_start <= cur_queue.pass_time
                                 and t1.eff_end > cur_queue.pass_time
                                 and t2.factory_code = t1.factory_code
                                 and t2.car_type = t1.model_code --是否加车型???
                                 --and t2.supplier_no = t1.supplier_no mod by wxl 20190614
                                 and t2.part_no = t1.part_no
                                 and t2.proposal_status = 5 --实物通过
                                 and t2.eff_start <= cur_queue.pass_time
                                 and t2.eff_end > cur_queue.pass_time))
      loop
        v_location := null;

        --获取零件信息
        v_part_short_no := null;
        v_part_name     := null;
        --mod by wxl 20190128
        --mod by wxl 20190610
        /*
        for cur_part in (select b.part_short_no, a.part_name_cn
                           from mm_pub_part a
                           left join mm_pub_part_uda b
                           on a.part_no = b.part_no
                          where a.part_no = cur_req.part_no)
        loop
          v_part_short_no := cur_part.part_short_no;
          v_part_name     := cur_part.part_name_cn;
          exit;
        end loop;
        */
        for cur_part1 in (select a.part_name_cn
                           from mm_pub_part a
                          where a.factory_code = cur_req.factory_code
                            and a.part_no = cur_req.part_no)
        loop
          v_part_name     := cur_part1.part_name_cn;
          exit;
        end loop;
        for cur_part2 in (select a.part_short_no
                           from mm_pub_part_uda a
                          where a.factory_code = cur_req.factory_code
                            and a.part_no = cur_req.part_no)
        loop
          v_part_short_no := cur_part2.part_short_no;
          exit;
        end loop;

        --获取供应商信息???(需一个零件号只对应一个供应商）
        --mod by wxl 20190402
        v_sup_factory   := null;
        v_supplier_no   := null;
        v_supplier_name := null;
        for cur_sup in (select a.sup_factory, a.supplier_no, b.supplier_name
                          from mm_pub_part_supplier a
                          left join mm_pub_supplier b
                            on a.supplier_no  = b.supplier_no
                         where a.factory_code = cur_req.factory_code
                           and a.part_no = cur_req.part_no)
        loop
          v_sup_factory   := cur_sup.sup_factory;
          v_supplier_no   := cur_sup.supplier_no;
          v_supplier_name := cur_sup.supplier_name;
          exit;
        end loop;

        --获取拉动零件基本信息
        v_ship_depot       := null;
        v_arr_depot        := null;
        v_distri_package 	 := 0;
        v_standard_package := 0;
        v_prepare_num      := NVL(TO_NUMBER(PKG_PUB.USF_GET_SYS_PARAM(cur_req.factory_code, 'JITI_CAL', cur_req.workcenter|| '_PRE_AHEAD_PRO_NUM')),0);
        v_dispatch_num     := 0;
        v_delivery_num     := 0;
        v_arrive_num       := 0;
        v_distri_num       := NVL(TO_NUMBER(PKG_PUB.USF_GET_SYS_PARAM(cur_req.factory_code, 'JITI_CAL', cur_req.workcenter|| '_DELI_AHEAD_PRO_NUM')),0);

        --获取零件余量最多的落点为不良补单配送地址
        v_remain_exists_flag := 0;
        v_start_remain       := 0;
        v_safety_inventory   := 0;
        for cur_part_remain in (select a.part_remain, a.safety_inventory, a.location
                                  from mm_jit_part_remain a
                                 where a.plan_code = cur_req.plan_code
                                   and a.part_no = cur_req.part_no
                                   and exists (select 1
                                                 from mm_inv_part_location t
                                                where t.factory_code = cur_req.factory_code
                                                  and t.workcenter   = cur_req.workcenter
                                                  and t.unload_port  = cur_req.unload_port
                                                  and t.part_no = cur_req.part_no
                                                  and t.dep_no = cur_req.resp_dep
                                                  and t.location = a.location
                                                  and t.eff_start <= cur_queue.pass_time
                                                  and t.eff_end > cur_queue.pass_time
                                                  --and t.supplier_no = v_supplier_no mod by wxl 20190614
                                              )
                                 order by (a.part_remain-a.safety_inventory) desc, a.location)
        loop
           v_remain_exists_flag := 1;
           v_start_remain       := cur_part_remain.part_remain;
           v_safety_inventory   := cur_part_remain.safety_inventory;
           v_location           := cur_part_remain.location;
           exit;
        end loop;

        --获取库位、拣货工程、台车、配送工程、落点工程深度信息???
        v_unload_port    := null;
        v_storage        := null;
        v_prepare_person := null;
        v_carpool        := null;
        v_distri_person  := null;
        v_loc_num        := 0;
        v_use_location_num := null;
        for cur_loc in (select b.unload_port,
                               b.storage,
                               b.prepare_person,
                               b.carpool,
                               b.distri_person,
                               b.location_num,
                               b.location,
                               b.ware_code
                          from mm_inv_part_location b
                         where b.factory_code = cur_req.factory_code
                           and b.workcenter   = cur_req.workcenter
                           and b.unload_port  = cur_req.unload_port
                           and b.part_no      = cur_req.part_no
                           and b.dep_no       = cur_req.resp_dep
                           and b.eff_start    <= cur_queue.pass_time
                           and b.eff_end      > cur_queue.pass_time
                           --and b.supplier_no  = v_supplier_no mod by wxl 20190614
                           and (v_location is null or b.location = v_location)
                         order by b.location_num desc, b.location)
        loop
          v_unload_port    := cur_loc.unload_port;
          v_storage        := cur_loc.storage;
          v_prepare_person := cur_loc.prepare_person;
          v_carpool        := cur_loc.carpool;
          v_distri_person  := cur_loc.distri_person;
          v_loc_num        := cur_loc.location_num;
          v_location       := cur_loc.location;
          v_ship_depot     := cur_loc.ware_code;
          v_arr_depot      := cur_loc.ware_code;
          v_use_location_num := 'LOC';
          exit;
        end loop;
        --计算备件流动数
        v_prepare_num  := v_prepare_num+v_delivery_num+v_arrive_num+v_distri_num+v_loc_num;
        --计算发车流动数
        v_dispatch_num := v_dispatch_num+v_delivery_num+v_arrive_num+v_distri_num+v_loc_num;
        --计算发货流动数
        v_delivery_num := v_delivery_num+v_arrive_num+v_distri_num+v_loc_num;
        --计算到货流动数
        v_arrive_num   := v_arrive_num+v_distri_num+v_loc_num;
        --计算配送流动数
        v_distri_num   := v_distri_num+v_loc_num;

        --获取此次待补不良信息
        insert into mm_jit_pkg_req_dpm
          (plan_code, part_no, location, dpm_apply_no, dpm_num)
          select distinct cur_req.plan_code,
                          a.part_no,
                          v_location,
                          a.apply_no,
                          a.dpm_num
            from mm_dpm_ins a
           where a.factory_code = cur_req.factory_code
             and a.part_no = cur_req.part_no
             and a.resp_dep = cur_req.resp_dep
             and a.ins_status = 2 --审核通过
             and a.delivery_status = 0;
        select NVL(sum(dpm_num), 0)
          into v_dpm_num
          from mm_jit_pkg_req_dpm a
         where a.plan_code = cur_req.plan_code
           and a.part_no = cur_req.part_no
           and a.location = v_location
           and a.pkg_deal_flag = 0;

        --获取净需求
        v_require_num := v_dpm_num;

        --零件余量 = 零件余量 - 零件需求量
        v_end_remain := v_start_remain;--mod by wxl 20190606
        v_end_remain := v_end_remain - v_require_num;
        v_distri_qty := 0;
        --当零件余量扣减需求不能满足安全库存时产生新的配送需求
        if v_end_remain < v_safety_inventory then
          --获取包装信息
          select b.standard_package
            into v_standard_package
            from mm_pkg_proposal a, mm_pkg_proposal_detail b
           where a.id = b.proposal_id
             and a.factory_code = cur_req.factory_code
             and a.car_type = cur_queue.model_code --是否加车型???
             and a.part_no = cur_req.part_no
             and a.supplier_no = v_supplier_no
             and a.proposal_status = 5 --实物通过
             and a.eff_start <= cur_queue.pass_time
             and a.eff_end > cur_queue.pass_time;
          v_distri_package := v_standard_package;

          v_distri_qty  := CEIL((v_safety_inventory-v_end_remain)/v_distri_package) * v_distri_package;
          v_end_remain := v_end_remain + v_distri_qty;

          --计算物流周期
          --获取工作日期(不包含时分秒)
          v_work_date := PKG_PUB.USF_GET_WORK_DATE(cur_req.factory_code, cur_req.workcenter, null);
          --获取生产节拍???
          v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_req.factory_code, cur_req.workcenter, null)/(24*3600);
          --计算备件时间
          v_prepare_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_prepare_num*v_produce_time);
          --计算发车时间
          v_dispatch_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_dispatch_num*v_produce_time);
          --计算发货时间
          v_delivery_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_delivery_num*v_produce_time);
          --计算到货时间
          v_arrive_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_arrive_num*v_produce_time);
          --计算配送时间
          v_distri_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_distri_num*v_produce_time);
          --计算装配时间
          v_assemble_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_loc_num*v_produce_time);
          --计算备件产品流水号
          v_prepare_product_seqno := cur_queue.kb_product_seqno-v_prepare_num;
          --计算发车产品流水号
          v_dispatch_product_seqno := cur_queue.kb_product_seqno-v_dispatch_num;
          --计算发货产品流水号
          v_delivery_product_seqno := cur_queue.kb_product_seqno-v_delivery_num;
          --计算到货产品流水号
          v_arrive_product_seqno := cur_queue.kb_product_seqno-v_arrive_num;
          --计算配送产品流水号
          v_distri_product_seqno := cur_queue.kb_product_seqno-v_distri_num;
          --计算装配产品流水号
          v_assemble_product_seqno := cur_queue.kb_product_seqno-v_loc_num;

          --写入包装需求
          v_pkg_req_id := SEQ_MM_JIT_PKG_REQ.NEXTVAL;
          insert into mm_jit_pkg_req
            (id,
             plan_code,
             part_no,
             location,
             --s_product_seqno,
             --e_product_seqno,
             require_num,
             part_short_no,
             part_name,
             sup_factory,
             supplier_no,
             supplier_name,
             ship_depot,
             arr_depot,
             distri_package,
             standard_package,
             unload_port,
             storage,
             prepare_person,
             carpool,
             distri_person,
             kb_product_seqno,
             prepare_product_seqno,
             dispatch_product_seqno,
             delivery_product_seqno,
             arrive_product_seqno,
             distri_product_seqno,
             assemble_product_seqno,
             kb_time,
             prepare_time,
             dispatch_time,
             delivery_time,
             arrive_time,
             distri_time,
             assemble_time,
             use_location_num,
             prepare_batch_seqno)
          values
            (v_pkg_req_id,
             cur_req.plan_code,
             cur_req.part_no,
             v_location,
             v_distri_qty,
             v_part_short_no,
             v_part_name,
             v_sup_factory,
             v_supplier_no,
             v_supplier_name,
             v_ship_depot,
             v_arr_depot,
             v_distri_package,
             v_standard_package,
             v_unload_port,
             v_storage,
             v_prepare_person,
             v_carpool,
             v_distri_person,
             cur_queue.kb_product_seqno,
             v_prepare_product_seqno,
             v_dispatch_product_seqno,
             v_delivery_product_seqno,
             v_arrive_product_seqno,
             v_distri_product_seqno,
             v_assemble_product_seqno,
             cur_queue.kb_time,
             v_prepare_time,
             v_dispatch_time,
             v_delivery_time,
             v_arrive_time,
             v_distri_time,
             v_assemble_time,
             v_use_location_num,
             PKG_PUB.USF_GET_BATCHSEQ_BY_PRODSEQNO(cur_req.plan_code,
                                                   v_prepare_product_seqno));
          --更新不良品处理状态
          update mm_jit_pkg_req_dpm a
             set a.pkg_deal_flag = 1,
                 a.pkg_req_id    = v_pkg_req_id
           where a.plan_code = cur_req.plan_code
             and a.part_no = cur_req.part_no
             and a.location = v_location
             and a.pkg_deal_flag = 0;
        else
          --更新不良品信息
          update mm_dpm_ins a
             set a.delivery_status = 1
           where a.apply_no in (select t.dpm_apply_no
                                  from mm_jit_pkg_req_dpm t
                                 where t.plan_code = cur_req.plan_code
                                   and t.part_no = cur_req.part_no
                                   and t.location = v_location
                                   and t.pkg_deal_flag = 0);
          --删除不良品处理状态
          delete mm_jit_pkg_req_dpm a
           where a.plan_code = cur_req.plan_code
             and a.part_no = cur_req.part_no
             and a.location = v_location
             and a.pkg_deal_flag = 0;
        end if;

        --将截止产品零件余量状态改为已完成???(不良品扣减余量如何查询）
        update mm_jit_part_remain_prod a
           set a.end_remain = v_end_remain,
               a.dpm_num    = v_dpm_num,
               a.is_finish  = 1
         where a.plan_code = cur_req.plan_code
           and a.part_no = cur_req.part_no
           and a.location = v_location
           and a.is_finish = 0;

        if v_remain_exists_flag = 0 then
          --若当前零件余量不存在 则新增
          insert into mm_jit_part_remain
            (id, plan_code, location, part_no, part_remain)
          values
            (SEQ_MM_JIT_PART_REMAIN.NEXTVAL, cur_req.plan_code, v_location, cur_req.part_no, v_end_remain);
        else
          --若当前零件余量存在 则更新
          update mm_jit_part_remain a
             set a.part_remain = v_end_remain
           where a.plan_code = cur_req.plan_code
             and a.location = v_location
             and a.part_no = cur_req.part_no;
        end if;
      end loop;
      exit;
    end loop;
  END USP_JITI_DPM_DEAL;

  --****************************************************************************
  --过程名  : USP_JITO_DPM_DEAL
  --功能描述: 不良品处理（厂外）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-26
  --修改记录：
  --         修改获取下一时间方法 mod by wxl 20190120
  --         外拉动计算卸货口以订购零件基本信息的为准 mod by wxl 20190325
  --         修复使用落点类型记录BUG mod by wxl 20190328
  --         优化使用落点同一工深，取落点编码最小的 mod by wxl 20190328
  --         修复不良品计算后零件余量为空的情况 mod by wxl 20190606
  --         iLMS2019053001 调整多工厂 mod by wxl 20190610
  --****************************************************************************
  PROCEDURE USP_JITO_DPM_DEAL(in_plan_code in varchar2) IS
    v_remain_exists_flag number(1); --零件余量是否存在
    v_start_remain       mm_jit_part_remain.part_remain%type; --期初余量
    v_end_remain         mm_jit_part_remain.part_remain%type; --期末余量
    v_safety_inventory   mm_jit_part_remain.safety_inventory%type; --安全库存
    v_location           mm_jit_part_remain.location%type; --落点
    v_dpm_num            number(10); --不良品数量
    v_require_num        number(10); --需求量
    v_distri_qty         number(10); --配送量
    v_part_short_no      varchar2(10); --零件简号 ???
    v_part_name          varchar2(150); --零件名称 ???
    v_sup_factory        varchar2(20); --供应商出货地 ???
    v_supplier_no        varchar2(20); --供应商代码 ???
    v_supplier_name      varchar2(150); --供应商名称 ???
    v_ship_depot         mm_jit_part.ship_depot%type; --出货仓库
    v_arr_depot          mm_jit_part.arr_depot%type; --到货仓库
    v_distri_package     mm_jit_part.distri_package%type; --配送包装
    v_standard_package   mm_jit_part.standard_package%type; --规格包装
    v_unload_port        mm_inv_part_location.unload_port%type; --卸货口
    v_storage            mm_inv_part_location.storage%type; --库位
    v_prepare_person     mm_inv_part_location.prepare_person%type; --拣货工程
    v_carpool            mm_inv_part_location.carpool%type; --台车
    v_distri_person      mm_inv_part_location.distri_person%type; --配送工程
    v_use_location_num   mm_jit_pkg_req.use_location_num%type; --使用落点类型
    v_loc_num            mm_inv_part_location.location_num%type; --落点工程深度
    v_work_date          date; --当前时间的工作日期(不包含时分秒)
    v_produce_time       number(10,3); --生产节拍
    v_prepare_num        number(10);--备件流动数
    v_dispatch_num       number(10);--发车流动数
    v_delivery_num       number(10);--发货流动数
    v_arrive_num         number(10);--到货流动数
    v_distri_num         number(10);--配送流动数
    v_prepare_time       date; --备货时间
    v_dispatch_time      date; --发车时间
    v_delivery_time      date; --发货时间
    v_arrive_time        date; --到货时间
    v_distri_time        date; --配送时间
    v_assemble_time      date; --装配时间
    v_prepare_product_seqno  number(19); --备件批次产品流水号
    v_dispatch_product_seqno number(19); --发车批次产品流水号
    v_delivery_product_seqno number(19); --发货批次产品流水号
    v_arrive_product_seqno   number(19); --到货批次产品流水号
    v_distri_product_seqno   number(19); --配送批次产品流水号
    v_assemble_product_seqno number(19); --装配批次产品流水号
    v_pkg_req_id         number(19); --包装需求ID
  BEGIN
    /*
    for cur_queue in (select a.kb_product_seqno,
                             a.kb_time,
                             a.pass_time,
                             a.model_code
                        from mm_jit_veh_queue a
                       where a.plan_code = in_plan_code
                         and a.exec_status = 0
                         and a.kb_product_seqno =
                             (select min(b.kb_product_seqno)
                                from mm_jit_veh_queue b
                               where b.plan_code = in_plan_code
                                 and b.exec_status = 0))
    loop
    */
    for cur_queue in (select distinct a.kb_product_seqno,
                             a.kb_time,
                             a.pass_time,
                             a.model_code
                        from mm_jit_net_req a
                       where a.plan_code = in_plan_code
                         and a.kb_product_seqno =
                             (select min(b.kb_product_seqno)
                                from mm_jit_net_req b
                               where b.plan_code = in_plan_code))
    loop
      --获取需处理的不良品信息???(是否考虑不良车型）
      /*
      不良品满足条件：
        1）不良品状态为“审核通过”
        2）属地管理中存在此工厂、班组的零件生效记录；
        3）订购零件基本信息存在此工厂、车间、零件信息。
      */
      for cur_req in (select distinct a.plan_code,
                             a.factory_code,
                             a.workcenter,
                             b.part_no,
                             b.resp_dep,
                             c.ship_depot,
                             c.arr_depot,
                             c.distri_package,
                             c.standard_package,
                             c.prepare_num,
                             c.dispatch_num,
                             c.delivery_num,
                             c.arrive_num,
                             c.distribution_num
                        from mm_pub_plan_code a, mm_dpm_ins b, mm_jit_part c
                       where b.factory_code = a.factory_code
                         and c.plan_code = a.plan_code
                         and c.part_no = b.part_no
                         and c.eff_start <= cur_queue.pass_time
                         and c.eff_end > cur_queue.pass_time
                         and a.plan_code = in_plan_code
                         --添加已算需求不良品过滤 mod by wxl 20190606
                         and b.apply_no not in (select d.dpm_apply_no from mm_jit_pkg_req_dpm d where d.plan_code = a.plan_code)
                         and b.ins_status = 2 --审核通过
                         and b.order_status = 0
                         and exists (select 1
                                from mm_inv_part_location t
                               where t.factory_code = a.factory_code
                                 --and t.ware_code = c.arr_depot--???用仓库还是车间
                                 and t.workcenter = a.workcenter
                                 and t.part_no = c.part_no
                                 and t.dep_no = b.resp_dep
                                 and t.eff_start <= cur_queue.pass_time
                                 and t.eff_end > cur_queue.pass_time))
      loop
        v_location := null;

        --获取零件、供应商信息???
        v_part_short_no := null;
        v_part_name     := null;
        v_sup_factory   := null;
        v_supplier_no   := null;
        v_supplier_name := null;
        --mod by wxl 20190610
        for cur_part in (select a.part_short_no, a.part_name_cn, a.sup_factory, a.supplier_no, a.supplier_name
                           from mm_pub_part_uda a
                          where a.factory_code = cur_req.factory_code
                            and a.part_no = cur_req.part_no)
        loop
          --v_part_short_no := cur_part.part_short_no;
          --v_part_name     := cur_part.part_name_cn;
          v_sup_factory   := cur_part.sup_factory;
          v_supplier_no   := cur_part.supplier_no;
          --v_supplier_name := cur_part.supplier_name;
          exit;
        end loop;
        for cur_part1 in (select a.part_name_cn
                           from mm_pub_part a
                          where a.factory_code = cur_req.factory_code
                            and a.part_no = cur_req.part_no)
        loop
          v_part_name     := cur_part1.part_name_cn;
          exit;
        end loop;
        for cur_part2 in (select a.part_short_no
                           from mm_pub_part_uda a
                          where a.factory_code = cur_req.factory_code
                            and a.part_no = cur_req.part_no)
        loop
          v_part_short_no := cur_part2.part_short_no;
          exit;
        end loop;
        for cur_sup in (select a.supplier_name
                          from mm_pub_supplier a
                         where a.supplier_no = v_supplier_no)
        loop
          v_supplier_name := cur_sup.supplier_name;
          exit;
        end loop;


        --获取拉动零件基本信息
        v_ship_depot       := cur_req.ship_depot;
        v_arr_depot        := cur_req.arr_depot;
        v_distri_package   := cur_req.distri_package;
        v_standard_package := cur_req.standard_package;
        v_prepare_num      := cur_req.prepare_num;
        v_dispatch_num     := cur_req.dispatch_num;
        v_delivery_num     := cur_req.delivery_num;
        v_arrive_num       := cur_req.arrive_num;
        v_distri_num       := cur_req.distribution_num;

        --获取零件余量最多的落点为不良补单配送地址
        v_remain_exists_flag := 0;
        v_start_remain       := 0;
        v_safety_inventory   := 0;
        for cur_part_remain in (select a.part_remain, a.safety_inventory, a.location
                                  from mm_jit_part_remain a
                                 where a.plan_code = cur_req.plan_code
                                   and a.part_no = cur_req.part_no
                                   and exists (select 1
                                                 from mm_inv_part_location t
                                                where t.factory_code = cur_req.factory_code
                                                  --and t.ware_code = v_arr_depot--???用仓库还是车间
                                                  and t.workcenter = cur_req.workcenter
                                                  and t.part_no = cur_req.part_no
                                                  and t.dep_no = cur_req.resp_dep
                                                  and t.location = a.location
                                                  and t.eff_start <= cur_queue.pass_time
                                                  and t.eff_end > cur_queue.pass_time)
                                 order by (a.part_remain-a.safety_inventory) desc, a.location)
        loop
           v_remain_exists_flag := 1;
           v_start_remain       := cur_part_remain.part_remain;
           v_safety_inventory   := cur_part_remain.safety_inventory;
           v_location           := cur_part_remain.location;
           exit;
        end loop;

        --获取库位、拣货工程、台车、配送工程、落点工程深度信息???
        v_unload_port    := null;
        v_storage        := null;
        v_prepare_person := null;
        v_carpool        := null;
        v_distri_person  := null;
        v_loc_num        := 0;
        v_use_location_num := null;
        for cur_loc in (select b.unload_port,
                               b.storage,
                               b.prepare_person,
                               b.carpool,
                               b.distri_person,
                               b.location_num,
                               b.location
                          from mm_inv_part_location b
                         where b.factory_code = cur_req.factory_code
                           --and b.ware_code    = v_arr_depot--???用仓库还是车间
                           and b.workcenter = cur_req.workcenter
                           and b.part_no      = cur_req.part_no
                           and b.dep_no       = cur_req.resp_dep
                           and b.eff_start    <= cur_queue.pass_time
                           and b.eff_end      > cur_queue.pass_time
                           and (v_location is null or b.location = v_location)
                         order by b.location_num desc, b.location)
        loop
          v_unload_port    := cur_loc.unload_port;
          v_storage        := cur_loc.storage;
          v_prepare_person := cur_loc.prepare_person;
          v_carpool        := cur_loc.carpool;
          v_distri_person  := cur_loc.distri_person;
          v_loc_num        := cur_loc.location_num;
          v_location       := cur_loc.location;
          v_use_location_num := 'LOC';
          exit;
        end loop;

        --获取卸货口 mod by wxl 20190325
        for cur_port in (select a.unload_port
                           from mm_pub_part_unload a
                          where a.factory_code = cur_req.factory_code
                            and a.workcenter = cur_req.workcenter
                            and a.part_no = cur_req.part_no
                            and a.logistics_model = 'JIT')
        loop
          v_unload_port := cur_port.unload_port;
        end loop;

        --计算备件流动数
        v_prepare_num  := v_prepare_num+v_delivery_num+v_arrive_num+v_distri_num+v_loc_num;
        --计算发车流动数
        v_dispatch_num := v_dispatch_num+v_delivery_num+v_arrive_num+v_distri_num+v_loc_num;
        --计算发货流动数
        v_delivery_num := v_delivery_num+v_arrive_num+v_distri_num+v_loc_num;
        --计算到货流动数
        v_arrive_num   := v_arrive_num+v_distri_num+v_loc_num;
        --计算配送流动数
        v_distri_num   := v_distri_num+v_loc_num;

        --获取此次待补不良信息
        insert into mm_jit_pkg_req_dpm
          (plan_code, part_no, location, dpm_apply_no, dpm_num)
          select distinct cur_req.plan_code,
                          a.part_no,
                          v_location,
                          a.apply_no,
                          a.dpm_num
            from mm_dpm_ins a
           where a.factory_code = cur_req.factory_code
             and a.part_no = cur_req.part_no
             and a.resp_dep = cur_req.resp_dep
             and a.ins_status = 2 --审核通过
             and a.order_status = 0;
        select NVL(sum(dpm_num), 0)
          into v_dpm_num
          from mm_jit_pkg_req_dpm a
         where a.plan_code = cur_req.plan_code
           and a.part_no = cur_req.part_no
           and a.location = v_location
           and a.pkg_deal_flag = 0;

        --获取净需求
        v_require_num := v_dpm_num;

        --零件余量 = 零件余量 - 零件需求量
        v_end_remain := v_start_remain;--mod by wxl 20190606
        v_end_remain := v_end_remain - v_require_num;
        v_distri_qty := 0;
        --当零件余量扣减需求不能满足安全库存时产生新的配送需求
        if v_end_remain < v_safety_inventory then
          v_distri_qty  := CEIL((v_safety_inventory-v_end_remain)/v_distri_package) * v_distri_package;
          v_end_remain := v_end_remain + v_distri_qty;

          --计算物流周期
          --获取工作日期(不包含时分秒)
          v_work_date := PKG_PUB.USF_GET_WORK_DATE(cur_req.factory_code, cur_req.workcenter, null);
          --获取生产节拍???
          v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_req.factory_code, cur_req.workcenter, null);
          --计算备件时间
          v_prepare_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_prepare_num*v_produce_time);
          --计算发车时间
          v_dispatch_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_dispatch_num*v_produce_time);
          --计算发货时间
          v_delivery_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_delivery_num*v_produce_time);
          --计算到货时间
          v_arrive_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_arrive_num*v_produce_time);
          --计算配送时间
          v_distri_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_distri_num*v_produce_time);
          --计算装配时间
          v_assemble_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_loc_num*v_produce_time);
          --计算备件产品流水号
          v_prepare_product_seqno := cur_queue.kb_product_seqno-v_prepare_num;
          --计算发车产品流水号
          v_dispatch_product_seqno := cur_queue.kb_product_seqno-v_dispatch_num;
          --计算发货产品流水号
          v_delivery_product_seqno := cur_queue.kb_product_seqno-v_delivery_num;
          --计算到货产品流水号
          v_arrive_product_seqno := cur_queue.kb_product_seqno-v_arrive_num;
          --计算配送产品流水号
          v_distri_product_seqno := cur_queue.kb_product_seqno-v_distri_num;
          --计算装配产品流水号
          v_assemble_product_seqno := cur_queue.kb_product_seqno-v_loc_num;

          --写入包装需求
          v_pkg_req_id := SEQ_MM_JIT_PKG_REQ.NEXTVAL;
          insert into mm_jit_pkg_req
            (id,
             plan_code,
             part_no,
             location,
             --s_product_seqno,
             --e_product_seqno,
             require_num,
             part_short_no,
             part_name,
             sup_factory,
             supplier_no,
             supplier_name,
             ship_depot,
             arr_depot,
             distri_package,
             standard_package,
             unload_port,
             storage,
             prepare_person,
             carpool,
             distri_person,
             kb_product_seqno,
             prepare_product_seqno,
             dispatch_product_seqno,
             delivery_product_seqno,
             arrive_product_seqno,
             distri_product_seqno,
             assemble_product_seqno,
             kb_time,
             prepare_time,
             dispatch_time,
             delivery_time,
             arrive_time,
             distri_time,
             assemble_time,
             use_location_num,
             prepare_batch_seqno)
          values
            (v_pkg_req_id,
             cur_req.plan_code,
             cur_req.part_no,
             v_location,
             v_distri_qty,
             v_part_short_no,
             v_part_name,
             v_sup_factory,
             v_supplier_no,
             v_supplier_name,
             v_ship_depot,
             v_arr_depot,
             v_distri_package,
             v_standard_package,
             v_unload_port,
             v_storage,
             v_prepare_person,
             v_carpool,
             v_distri_person,
             cur_queue.kb_product_seqno,
             v_prepare_product_seqno,
             v_dispatch_product_seqno,
             v_delivery_product_seqno,
             v_arrive_product_seqno,
             v_distri_product_seqno,
             v_assemble_product_seqno,
             cur_queue.kb_time,
             v_prepare_time,
             v_dispatch_time,
             v_delivery_time,
             v_arrive_time,
             v_distri_time,
             v_assemble_time,
             v_use_location_num,
             PKG_PUB.USF_GET_BATCHSEQ_BY_PRODSEQNO(cur_req.plan_code,
                                                   v_prepare_product_seqno));
          --更新不良品处理状态
          update mm_jit_pkg_req_dpm a
             set a.pkg_deal_flag = 1,
                 a.pkg_req_id    = v_pkg_req_id
           where a.plan_code = cur_req.plan_code
             and a.part_no = cur_req.part_no
             and a.location = v_location
             and a.pkg_deal_flag = 0;
        else
          --更新不良品信息
          update mm_dpm_ins a
             set a.order_status = 1
           where a.apply_no in (select t.dpm_apply_no
                                  from mm_jit_pkg_req_dpm t
                                 where t.plan_code = cur_req.plan_code
                                   and t.part_no = cur_req.part_no
                                   and t.location = v_location
                                   and t.pkg_deal_flag = 0);
          --删除不良品处理状态
          delete mm_jit_pkg_req_dpm a
           where a.plan_code = cur_req.plan_code
             and a.part_no = cur_req.part_no
             and a.location = v_location
             and a.pkg_deal_flag = 0;
        end if;

        --将截止产品零件余量状态改为已完成
        update mm_jit_part_remain_prod a
           set a.end_remain = v_end_remain,
               a.dpm_num = v_dpm_num,
               a.is_finish = 1
         where a.plan_code = cur_req.plan_code
           and a.part_no = cur_req.part_no
           and a.location = v_location
           and a.is_finish = 0;

        if v_remain_exists_flag = 0 then
          --若当前零件余量不存在 则新增
          insert into mm_jit_part_remain
            (id, plan_code, location, part_no, part_remain)
          values
            (SEQ_MM_JIT_PART_REMAIN.NEXTVAL, cur_req.plan_code, v_location, cur_req.part_no, v_end_remain);
        else
          --若当前零件余量存在 则更新
          update mm_jit_part_remain a
             set a.part_remain = v_end_remain
           where a.plan_code = cur_req.plan_code
             and a.location = v_location
             and a.part_no = cur_req.part_no;
        end if;
      end loop;
      exit;
    end loop;
  END USP_JITO_DPM_DEAL;

  --****************************************************************************
  --过程名  : USP_JITI_CAL_PKG_REQ
  --功能描述: 计算零件包装需求（厂内）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --修改记录：
  --         修改获取下一时间方法 mod by wxl 20190120
  --         修复使用落点类型记录BUG mod by wxl 20190328
  --         调整供应商名称获取关联为右关联 mod by wxl 20190402
  --         iLMS2019053001 调整多工厂 mod by wxl 20190610
  --         iLMS2019061401 优化厂内拉动-取消供应商限制 mod by wxl 20190614
  --****************************************************************************
  PROCEDURE USP_JITI_CAL_PKG_REQ(in_plan_code in varchar2) IS
    v_remain_exists_flag number(1); --零件余量是否存在
    v_start_remain       mm_jit_part_remain.part_remain%type; --期初余量
    v_end_remain         mm_jit_part_remain.part_remain%type; --期末余量
    v_safety_inventory   mm_jit_part_remain.safety_inventory%type; --安全库存
    v_end_require_flag   number(1); --截止需求是否存在
    --v_end_require_date   mm_jit_part_remain.end_require_date%type; --截止需求日期
    --v_end_require_num    mm_jit_part_remain.end_require_num%type; --截止需求量
    v_part_short_no      varchar2(10); --零件简号 ???
    v_part_name          varchar2(150); --零件名称 ???
    v_sup_factory        varchar2(20); --供应商出货地 ???
    v_supplier_no        varchar2(20); --供应商代码 ???
    v_supplier_name      varchar2(150); --供应商名称 ???
    v_ship_depot         mm_jit_part.ship_depot%type; --出货仓库
    v_arr_depot          mm_jit_part.arr_depot%type; --到货仓库
    v_distri_package     mm_jit_part.distri_package%type; --配送包装
    v_standard_package   mm_jit_part.standard_package%type; --规格包装
    v_unload_port        mm_inv_part_location.unload_port%type; --卸货口
    v_storage            mm_inv_part_location.storage%type; --库位
    v_prepare_person     mm_inv_part_location.prepare_person%type; --拣货工程
    v_carpool            mm_inv_part_location.carpool%type; --台车
    v_distri_person      mm_inv_part_location.distri_person%type; --配送工程
    v_require_num        number(10); --需求量
    v_distri_qty         number(10); --配送量
    v_work_date          date; --当前时间的工作日期(不包含时分秒)
    v_produce_time       number(10,3); --生产节拍
    v_use_location_num   mm_jit_pkg_req.use_location_num%type; --使用落点类型
    v_loc_num            mm_inv_part_location.location_num%type; --落点工程深度
    v_prepare_num        number(10);--备件流动数
    v_dispatch_num       number(10);--发车流动数
    v_delivery_num       number(10);--发货流动数
    v_arrive_num         number(10);--到货流动数
    v_distri_num         number(10);--配送流动数
    v_prepare_time       date; --备货时间
    v_dispatch_time      date; --发车时间
    v_delivery_time      date; --发货时间
    v_arrive_time        date; --到货时间
    v_distri_time        date; --配送时间
    v_assemble_time      date; --装配时间
    v_prepare_product_seqno  number(19); --备件批次产品流水号
    v_dispatch_product_seqno number(19); --发车批次产品流水号
    v_delivery_product_seqno number(19); --发货批次产品流水号
    v_arrive_product_seqno   number(19); --到货批次产品流水号
    v_distri_product_seqno   number(19); --配送批次产品流水号
    v_assemble_product_seqno number(19); --装配批次产品流水号
    v_remain_record_flag number(1); --截止产品零件余量记录标识
    v_is_finish_p        number(1); --截止产品零件余量记录完成标识
    err_num              number(10); --错误代码
    err_msg              varchar2(200); --错误信息
  BEGIN
    --不良品处理
    USP_JITI_DPM_DEAL(in_plan_code);
    --按净需求生成包装需求
    for cur_req in (select a.plan_code, a.factory_code, a.workcenter, b.part_no, b.location
                      from mm_pub_plan_code a, mm_jit_net_req b
                     where a.plan_code = b.plan_code
                       and b.plan_code = in_plan_code
                     group by a.plan_code, a.factory_code, a.workcenter, b.part_no, b.location
                     order by a.plan_code, a.factory_code, a.workcenter, b.part_no, b.location)
    loop
      --获取上次计算的零件余量
      v_remain_exists_flag := 0;
      v_start_remain       := 0;
      v_safety_inventory   := 0;
      v_end_require_flag   := 0;
      --v_end_require_date   := null;
      --v_end_require_num    := null;
      for cur_part_remain in (select part_remain, safety_inventory, end_require_date, end_require_num
                                from mm_jit_part_remain
                               where plan_code = cur_req.plan_code
                                 and location = cur_req.location
                                 and part_no = cur_req.part_no)
      loop
         v_remain_exists_flag := 1;
         v_start_remain := cur_part_remain.part_remain;
         v_safety_inventory := cur_part_remain.safety_inventory;
         /*
         v_end_require_date := cur_part_remain.end_require_date;
         v_end_require_num  := cur_part_remain.end_require_num;
         if v_end_require_date is not null and v_end_require_num is not null then
           v_end_require_flag := 1;
         end if;
         */
         exit;
      end loop;

      --获取零件信息
      v_part_short_no := null;
      v_part_name     := null;
      --mod by wxl 20190610
      /*
      for cur_part in (select b.part_short_no, a.part_name_cn
                         from mm_pub_part a
                         left join mm_pub_part_uda b
                           on a.part_no = b.part_no
                        where a.part_no = cur_req.part_no)
      loop
        v_part_short_no := cur_part.part_short_no;
        v_part_name     := cur_part.part_name_cn;
        exit;
      end loop;
      */
      for cur_part1 in (select a.part_name_cn
                         from mm_pub_part a
                        where a.factory_code = cur_req.factory_code
                          and a.part_no = cur_req.part_no)
      loop
        v_part_name     := cur_part1.part_name_cn;
        exit;
      end loop;
      for cur_part2 in (select a.part_short_no
                         from mm_pub_part_uda a
                        where a.factory_code = cur_req.factory_code
                          and a.part_no = cur_req.part_no)
      loop
        v_part_short_no := cur_part2.part_short_no;
        exit;
      end loop;

      --获取供应商信息???(需一个零件号只对应一个供应商）
      --mod by wxl 20190402
      v_sup_factory   := null;
      v_supplier_no   := null;
      v_supplier_name := null;
      for cur_sup in (select a.sup_factory, a.supplier_no, b.supplier_name
                        from mm_pub_part_supplier a
                        left join mm_pub_supplier b
                          on a.supplier_no  = b.supplier_no
                       where a.factory_code = cur_req.factory_code
                         and a.part_no = cur_req.part_no)
      loop
        v_sup_factory   := cur_sup.sup_factory;
        v_supplier_no   := cur_sup.supplier_no;
        v_supplier_name := cur_sup.supplier_name;
        exit;
      end loop;

      --获取拉动零件基本信息
      v_ship_depot       := null;
      v_arr_depot        := null;
      v_distri_package 	 := 0;
      v_standard_package := 0;
      v_prepare_num      := NVL(TO_NUMBER(PKG_PUB.USF_GET_SYS_PARAM(cur_req.factory_code, 'JITI_CAL', cur_req.workcenter|| '_PRE_AHEAD_PRO_NUM')),0);
      v_dispatch_num     := 0;
      v_delivery_num     := 0;
      v_arrive_num       := 0;
      v_distri_num       := NVL(TO_NUMBER(PKG_PUB.USF_GET_SYS_PARAM(cur_req.factory_code, 'JITI_CAL', cur_req.workcenter|| '_DELI_AHEAD_PRO_NUM')),0);

      --获取库位、拣货工程、台车、配送工程、落点工程深度信息???
      v_unload_port    := null;
      v_storage        := null;
      v_prepare_person := null;
      v_carpool        := null;
      v_distri_person  := null;
      v_loc_num        := 0;
      v_use_location_num := null;
      for cur_loc in (select b.unload_port,
                             b.storage,
                             b.prepare_person,
                             b.carpool,
                             b.distri_person,
                             b.location_num,
                             b.location,
                             b.ware_code
                        from mm_inv_part_location b
                       where b.factory_code = cur_req.factory_code
                         and b.workcenter   = cur_req.workcenter
                         and b.part_no      = cur_req.part_no
                         and b.location     = cur_req.location
                         --and b.supplier_no  = v_supplier_no mod by wxl 20190614
                       order by b.location_num desc)
      loop
        v_unload_port    := cur_loc.unload_port;
        v_storage        := cur_loc.storage;
        v_prepare_person := cur_loc.prepare_person;
        v_carpool        := cur_loc.carpool;
        v_distri_person  := cur_loc.distri_person;
        v_loc_num        := cur_loc.location_num;
        v_ship_depot     := cur_loc.ware_code;
        v_arr_depot      := cur_loc.ware_code;
        v_use_location_num := 'LOC';
        exit;
      end loop;
      --计算备件流动数
      v_prepare_num  := v_prepare_num+v_delivery_num+v_arrive_num+v_distri_num+v_loc_num;
      --计算发车流动数
      v_dispatch_num := v_dispatch_num+v_delivery_num+v_arrive_num+v_distri_num+v_loc_num;
      --计算发货流动数
      v_delivery_num := v_delivery_num+v_arrive_num+v_distri_num+v_loc_num;
      --计算到货流动数
      v_arrive_num   := v_arrive_num+v_distri_num+v_loc_num;
      --计算配送流动数
      v_distri_num   := v_distri_num+v_loc_num;

      --按净需求循环处理生成零件包装
      v_end_remain := v_start_remain;
      for cur_queue in (select a.require_num, a.kb_product_seqno, a.kb_time, a.model_code, a.pass_time
                          from mm_jit_net_req a
                         where a.plan_code = cur_req.plan_code
                           and a.location = cur_req.location
                           and a.part_no = cur_req.part_no
                         order by a.kb_product_seqno)
      loop
        --获取净需求
        v_require_num := cur_queue.require_num;
        /*
        --截止需求量判断，如果超过，则取需求量为截止需求量
        if v_end_require_flag = 1 then
          if v_end_require_date < sysdate then
            --如果达到截止日期，不产生新包装需求
            v_require_num := 0;
            v_end_require_num := 0;
          elsif v_require_num > v_end_require_num then
            v_require_num := v_end_require_num;
            v_end_require_num := 0;
          else
            v_end_require_num := v_end_require_num - v_require_num;
          end if;
        end if;
        */

        --零件余量 = 零件余量 - 零件需求量
        v_end_remain := v_end_remain - v_require_num;
        v_distri_qty := 0;
        --当零件余量扣减需求不能满足安全库存时产生新的配送需求
        if v_end_remain < v_safety_inventory then
          --获取规格包装数、配送包装数
          select b.standard_package
            into v_standard_package
            from mm_pkg_proposal a, mm_pkg_proposal_detail b
           where a.id = b.proposal_id
             and a.car_type = cur_queue.model_code
             and a.part_no = cur_req.part_no
             and a.supplier_no = v_supplier_no
             and a.proposal_status = 5
             and a.eff_start <= cur_queue.pass_time
             and a.eff_end > cur_queue.pass_time;
          v_distri_package := v_standard_package;

          v_distri_qty  := CEIL((v_safety_inventory-v_end_remain)/v_distri_package) * v_distri_package;
          v_end_remain := v_end_remain + v_distri_qty;

          --计算物流周期
          --获取工作日期(不包含时分秒)
          v_work_date := PKG_PUB.USF_GET_WORK_DATE(cur_req.factory_code, cur_req.workcenter, null);
          --获取生产节拍???
          v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_req.factory_code, cur_req.workcenter, null)/(24*3600);
          --计算备件时间
          v_prepare_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_prepare_num*v_produce_time);
          --计算发车时间
          v_dispatch_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_dispatch_num*v_produce_time);
          --计算发货时间
          v_delivery_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_delivery_num*v_produce_time);
          --计算到货时间
          v_arrive_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_arrive_num*v_produce_time);
          --计算配送时间
          v_distri_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_distri_num*v_produce_time);
          --计算装配时间
          v_assemble_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_loc_num*v_produce_time);
          --计算备件产品流水号
          v_prepare_product_seqno := cur_queue.kb_product_seqno-v_prepare_num;
          --计算发车产品流水号
          v_dispatch_product_seqno := cur_queue.kb_product_seqno-v_dispatch_num;
          --计算发货产品流水号
          v_delivery_product_seqno := cur_queue.kb_product_seqno-v_delivery_num;
          --计算到货产品流水号
          v_arrive_product_seqno := cur_queue.kb_product_seqno-v_arrive_num;
          --计算配送产品流水号
          v_distri_product_seqno := cur_queue.kb_product_seqno-v_distri_num;
          --计算装配产品流水号
          v_assemble_product_seqno := cur_queue.kb_product_seqno-v_loc_num;

          --写入包装需求
          insert into mm_jit_pkg_req
            (id,
             plan_code,
             part_no,
             location,
             --s_product_seqno,
             --e_product_seqno,
             require_num,
             part_short_no,
             part_name,
             sup_factory,
             supplier_no,
             supplier_name,
             ship_depot,
             arr_depot,
             distri_package,
             standard_package,
             unload_port,
             storage,
             prepare_person,
             carpool,
             distri_person,
             kb_product_seqno,
             prepare_product_seqno,
             dispatch_product_seqno,
             delivery_product_seqno,
             arrive_product_seqno,
             distri_product_seqno,
             assemble_product_seqno,
             kb_time,
             prepare_time,
             dispatch_time,
             delivery_time,
             arrive_time,
             distri_time,
             assemble_time,
             use_location_num,
             prepare_batch_seqno)
          values
            (SEQ_MM_JIT_PKG_REQ.NEXTVAL,
             cur_req.plan_code,
             cur_req.part_no,
             cur_req.location,
             v_distri_qty,
             v_part_short_no,
             v_part_name,
             v_sup_factory,
             v_supplier_no,
             v_supplier_name,
             v_ship_depot,
             v_arr_depot,
             v_distri_package,
             v_standard_package,
             v_unload_port,
             v_storage,
             v_prepare_person,
             v_carpool,
             v_distri_person,
             cur_queue.kb_product_seqno,
             v_prepare_product_seqno,
             v_dispatch_product_seqno,
             v_delivery_product_seqno,
             v_arrive_product_seqno,
             v_distri_product_seqno,
             v_assemble_product_seqno,
             cur_queue.kb_time,
             v_prepare_time,
             v_dispatch_time,
             v_delivery_time,
             v_arrive_time,
             v_distri_time,
             v_assemble_time,
             v_use_location_num,
             PKG_PUB.USF_GET_BATCHSEQ_BY_PRODSEQNO(cur_req.plan_code,
                                                   v_prepare_product_seqno));
        end if;

        --截止产品零件余量记录,0:新增 1：修改
        v_remain_record_flag := 0;
        v_is_finish_p        := 0;
        for cur_remain_prod in (select * from mm_jit_part_remain_prod a
                                 where a.plan_code = cur_req.plan_code
                                   and a.part_no = cur_req.part_no
                                   --mod by wxl 20190228
                                   and (a.location = cur_req.location or
                                       (a.location is null and cur_req.location is null))
                                   and a.is_finish = 0)
        loop
          v_remain_record_flag := 1;
          --当存在安全库存、车辆需求、配送包装发生变化时新增修改截止到上一次记录数据
          if cur_remain_prod.e_kb_product_seqno+1 <> cur_queue.kb_product_seqno or
             cur_remain_prod.safety_inventory <> v_safety_inventory or
             cur_remain_prod.distri_package <> v_distri_package or
             cur_remain_prod.require_num <> cur_queue.require_num then
            v_remain_record_flag := 0;--需新增
            update mm_jit_part_remain_prod a
               set a.is_finish = 1
             where a.plan_code = cur_req.plan_code
               and a.part_no = cur_req.part_no
               and a.location = cur_req.location
               and a.is_finish = 0;
          end if;
          --存在尾数时（截止需求量导致）
          /*
          if cur_queue.require_num <> v_require_num then
            v_remain_record_flag := 1;
            v_is_finish_p        := 1;
          end if;
          */
        end loop;
        if v_remain_record_flag = 0 then
          insert into mm_jit_part_remain_prod
            (id,
             plan_code,
             part_no,
             location,
             s_kb_product_seqno,
             e_kb_product_seqno,
             start_remain,
             end_remain,
             require_num,
             distri_package,
             safety_inventory,
             end_require_num)
          values
            (SEQ_MM_JIT_PART_REM_PROD.NEXTVAL,
             cur_req.plan_code,
             cur_req.part_no,
             cur_req.location,
             cur_queue.kb_product_seqno,
             cur_queue.kb_product_seqno,
             v_start_remain,
             v_end_remain,
             cur_queue.require_num,
             v_distri_package,
             v_safety_inventory,
             null);
        else
          update mm_jit_part_remain_prod a
             set a.e_kb_product_seqno = cur_queue.kb_product_seqno,
                 a.end_remain = v_end_remain,
                 --a.end_require_num = cur_queue.require_num-v_require_num,
                 a.is_finish = v_is_finish_p
           where a.plan_code = cur_req.plan_code
             and a.part_no = cur_req.part_no
             and a.location = cur_req.location
             and a.is_finish = 0;
        end if;

        --如果达到截止需求，不产生新包装需求，退出循环
        /*
        if v_end_require_flag = 1 and v_end_require_num = 0 then
          exit;
        end if;
        */
      end loop;

      if v_remain_exists_flag = 0 then
        --若当前零件余量不存在 则新增
        insert into mm_jit_part_remain
          (id, plan_code, location, part_no, part_remain)
        values
          (SEQ_MM_JIT_PART_REMAIN.NEXTVAL, cur_req.plan_code, cur_req.location, cur_req.part_no, v_end_remain);
      else
        --若当前零件余量存在 则更新
        update mm_jit_part_remain a
           set a.part_remain     = v_end_remain
               --a.end_require_num = v_end_require_num
         where a.plan_code = cur_req.plan_code
           and a.location = cur_req.location
           and a.part_no = cur_req.part_no;
      end if;

      --删除已经生成包装需求的零件净需求
      delete from mm_jit_net_req
       where plan_code = cur_req.plan_code
         and location = cur_req.location
         and part_no = cur_req.part_no;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JITI_CAL_PKG_REQ：'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JITI_CAL_PKG_REQ;

  --****************************************************************************
  --过程名  : USP_JITO_CAL_PKG_REQ
  --功能描述: 计算零件包装需求（厂外）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-17
  --修改记录：
  --         修改落点工程深度信息 mod by wxl 20190120
  --         修改获取下一时间方法 mod by wxl 20190120
  --         修正落点工程深度信息系统参数 mod by wxl 20190323
  --         外拉动计算卸货口以订购零件基本信息的为准 mod by wxl 20190325
  --         修复使用落点类型记录BUG mod by wxl 20190328
  --         修复零件名称、供应商名称获取逻辑 mod by wxl 20190508
  --         iLMS2019053001 调整多工厂 mod by wxl 20190610
  --****************************************************************************
  PROCEDURE USP_JITO_CAL_PKG_REQ(in_plan_code in varchar2) IS
    v_remain_exists_flag number(1); --零件余量是否存在
    v_start_remain       mm_jit_part_remain.part_remain%type; --期初余量
    v_end_remain         mm_jit_part_remain.part_remain%type; --期末余量
    v_safety_inventory   mm_jit_part_remain.safety_inventory%type; --安全库存
    v_end_require_flag   number(1); --截止需求是否存在
    --v_end_require_date   mm_jit_part_remain.end_require_date%type; --截止需求日期
    --v_end_require_num    mm_jit_part_remain.end_require_num%type; --截止需求量
    v_part_short_no      varchar2(10); --零件简号 ???
    v_part_name          varchar2(150); --零件名称 ???
    v_sup_factory        varchar2(20); --供应商出货地 ???
    v_supplier_no        varchar2(20); --供应商代码 ???
    v_supplier_name      varchar2(150); --供应商名称 ???
    v_ship_depot         mm_jit_part.ship_depot%type; --出货仓库
    v_arr_depot          mm_jit_part.arr_depot%type; --到货仓库
    v_distri_package     mm_jit_part.distri_package%type; --配送包装
    v_standard_package   mm_jit_part.standard_package%type; --规格包装
    v_unload_port        mm_inv_part_location.unload_port%type; --卸货口
    v_storage            mm_inv_part_location.storage%type; --库位
    v_prepare_person     mm_inv_part_location.prepare_person%type; --拣货工程
    v_carpool            mm_inv_part_location.carpool%type; --台车
    v_distri_person      mm_inv_part_location.distri_person%type; --配送工程
    v_require_num        number(10); --需求量
    v_distri_qty         number(10); --配送量
    v_work_date          date; --当前时间的工作日期(不包含时分秒)
    v_produce_time       number(10,3); --生产节拍
    v_use_location_num   mm_jit_pkg_req.use_location_num%type; --使用落点类型
    v_loc_num            mm_inv_part_location.location_num%type; --落点工程深度
    v_prepare_num        number(10);--备件流动数
    v_dispatch_num       number(10);--发车流动数
    v_delivery_num       number(10);--发货流动数
    v_arrive_num         number(10);--到货流动数
    v_distri_num         number(10);--配送流动数
    v_prepare_time       date; --备货时间
    v_dispatch_time      date; --发车时间
    v_delivery_time      date; --发货时间
    v_arrive_time        date; --到货时间
    v_distri_time        date; --配送时间
    v_assemble_time      date; --装配时间
    v_prepare_product_seqno  number(19); --备件批次产品流水号
    v_dispatch_product_seqno number(19); --发车批次产品流水号
    v_delivery_product_seqno number(19); --发货批次产品流水号
    v_arrive_product_seqno   number(19); --到货批次产品流水号
    v_distri_product_seqno   number(19); --配送批次产品流水号
    v_assemble_product_seqno number(19); --装配批次产品流水号
    v_remain_record_flag number(1); --截止产品零件余量记录标识
    v_is_finish_p        number(1); --截止产品零件余量记录完成标识
    err_num              number(10); --错误代码
    err_msg              varchar2(200); --错误信息
  BEGIN
    --不良品处理
    USP_JITO_DPM_DEAL(in_plan_code);
    --按净需求生成包装需求
    for cur_req in (select a.plan_code, a.factory_code, a.workcenter, b.part_no, b.location
                      from mm_pub_plan_code a, mm_jit_net_req b
                     where a.plan_code = b.plan_code
                       and b.plan_code = in_plan_code
                     group by a.plan_code, a.factory_code, a.workcenter, b.part_no, b.location)
    loop
      --获取上次计算的零件余量
      v_remain_exists_flag := 0;
      v_start_remain       := 0;
      v_safety_inventory   := 0;
      v_end_require_flag   := 0;
      --v_end_require_date   := null;
      --v_end_require_num    := null;
      for cur_part_remain in (select a.part_remain, a.safety_inventory, a.end_require_date, a.end_require_num
                                from mm_jit_part_remain a
                               where a.plan_code = cur_req.plan_code
                                 --mod by wxl 20190228
                                 and (a.location = cur_req.location or
                                     (a.location is null and cur_req.location is null))
                                 and a.part_no = cur_req.part_no)
      loop
         v_remain_exists_flag := 1;
         v_start_remain := cur_part_remain.part_remain;
         v_safety_inventory := cur_part_remain.safety_inventory;
         /*
         v_end_require_date := cur_part_remain.end_require_date;
         v_end_require_num  := cur_part_remain.end_require_num;
         if v_end_require_date is not null and v_end_require_num is not null then
           v_end_require_flag := 1;
         end if;
         */
         exit;
      end loop;

      --获取零件信息、供应商信息???
      v_part_short_no := null;
      v_part_name     := null;
      v_sup_factory   := null;
      v_supplier_no   := null;
      v_supplier_name := null;
      --mod by wxl 20190610
      for cur_part in (select a.part_short_no, a.part_name_cn, a.sup_factory, a.supplier_no, a.supplier_name
                         from mm_pub_part_uda a
                        where a.factory_code = cur_req.factory_code
                          and a.part_no = cur_req.part_no)
      loop
        --v_part_short_no := cur_part.part_short_no;
        --v_part_name     := cur_part.part_name_cn;
        v_sup_factory   := cur_part.sup_factory;
        v_supplier_no   := cur_part.supplier_no;
        --v_supplier_name := cur_part.supplier_name;
        exit;
      end loop;
      for cur_part1 in (select a.part_name_cn
                         from mm_pub_part a
                        where a.factory_code = cur_req.factory_code
                          and a.part_no = cur_req.part_no)
      loop
        v_part_name     := cur_part1.part_name_cn;
        exit;
      end loop;
      for cur_part2 in (select a.part_short_no
                         from mm_pub_part_uda a
                        where a.factory_code = cur_req.factory_code
                          and a.part_no = cur_req.part_no)
      loop
        v_part_short_no := cur_part2.part_short_no;
        exit;
      end loop;
      for cur_sup in (select a.supplier_name
                        from mm_pub_supplier a
                       where a.supplier_no = v_supplier_no)
      loop
        v_supplier_name := cur_sup.supplier_name;
        exit;
      end loop;


      --获取拉动零件基本信息
      v_ship_depot       := null;
      v_arr_depot        := null;
      v_distri_package   := 0;
      v_standard_package := 0;
      v_prepare_num      := 0;
      v_dispatch_num     := 0;
      v_delivery_num     := 0;
      v_arrive_num       := 0;
      v_distri_num       := 0;
      for cur_jit_part in (select * from mm_jit_part a
                            where a.plan_code = cur_req.plan_code
                              and a.part_no = cur_req.part_no)
      loop
        v_ship_depot       := cur_jit_part.ship_depot;
        v_arr_depot        := cur_jit_part.arr_depot;
        v_distri_package   := cur_jit_part.distri_package;
        v_standard_package := cur_jit_part.standard_package;
        v_prepare_num      := cur_jit_part.prepare_num;
        v_dispatch_num     := cur_jit_part.dispatch_num;
        v_delivery_num     := cur_jit_part.delivery_num;
        v_arrive_num       := cur_jit_part.arrive_num;
        v_distri_num       := cur_jit_part.distribution_num;
        exit;
      end loop;

      --获取库位、拣货工程、台车、配送工程、落点工程深度信息???
      v_unload_port    := null;
      v_storage        := null;
      v_prepare_person := null;
      v_carpool        := null;
      v_distri_person  := null;
      v_loc_num        := null;
      v_use_location_num := null;
      for cur_loc in (select b.unload_port,
                             b.storage,
                             b.prepare_person,
                             b.carpool,
                             b.distri_person,
                             b.location_num
                        from mm_inv_part_location b
                       where b.factory_code = cur_req.factory_code
                         and b.ware_code    = v_arr_depot
                         and b.part_no      = cur_req.part_no
                         and b.location     = cur_req.location
                       order by b.location_num desc)
      loop
        v_unload_port    := cur_loc.unload_port;
        v_storage        := cur_loc.storage;
        v_prepare_person := cur_loc.prepare_person;
        v_carpool        := cur_loc.carpool;
        v_distri_person  := cur_loc.distri_person;
        v_loc_num        := cur_loc.location_num;
        v_use_location_num := 'LOC';
        exit;
      end loop;
      --mod by wxl 20190120
      if v_loc_num is null then
        select decode(max(a.location_num), null, 0, max(a.location_num))
          into v_loc_num
          from mm_inv_part_location a
         where a.factory_code = cur_req.factory_code
           and a.workcenter = cur_req.workcenter
           and a.eff_start <= sysdate
           and a.eff_end > sysdate;
        v_use_location_num := 'WC';
      end if;
      if v_loc_num is null then
        --mod by wxl 20190323
        --v_loc_num := to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_req.factory_code, 'MAX_LOC', PKG_PUB.USF_GET_WORKCENTER_PRE(cur_req.workcenter)||'_TOTAL_PRO_NUM'));
        if PKG_PUB.USF_GET_WORKCENTER_PRE(cur_req.workcenter) = 'W' then
          v_loc_num := to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_req.factory_code, 'MAX_LOC', 'WE_TOTAL_PRO_NUM'));
        elsif PKG_PUB.USF_GET_WORKCENTER_PRE(cur_req.workcenter) = 'A' then
          v_loc_num := to_number(PKG_PUB.USF_GET_SYS_PARAM(cur_req.factory_code, 'MAX_LOC', 'AF_TOTAL_PRO_NUM'));
        end if;
        v_use_location_num := 'SYS';
      end if;
      if v_loc_num is null then
        v_loc_num := 0;
        v_use_location_num := null;
      end if;

      --获取卸货口 mod by wxl 20190325
      for cur_port in (select a.unload_port
                         from mm_pub_part_unload a
                        where a.factory_code = cur_req.factory_code
                          and a.workcenter = cur_req.workcenter
                          and a.part_no = cur_req.part_no
                          and a.logistics_model = 'JIT')
      loop
        v_unload_port := cur_port.unload_port;
      end loop;
      --计算备件流动数
      v_prepare_num  := v_prepare_num+v_delivery_num+v_arrive_num+v_distri_num+v_loc_num;
      --计算发车流动数
      v_dispatch_num := v_dispatch_num+v_delivery_num+v_arrive_num+v_distri_num+v_loc_num;
      --计算发货流动数
      v_delivery_num := v_delivery_num+v_arrive_num+v_distri_num+v_loc_num;
      --计算到货流动数
      v_arrive_num   := v_arrive_num+v_distri_num+v_loc_num;
      --计算配送流动数
      v_distri_num   := v_distri_num+v_loc_num;

      --按净需求循环处理生成零件包装
      v_end_remain := v_start_remain;
      for cur_queue in (select a.require_num, a.kb_product_seqno, a.kb_time
                          from mm_jit_net_req a
                         where a.plan_code = cur_req.plan_code
                           --mod by wxl 20190228
                           and (a.location = cur_req.location or
                               (a.location is null and cur_req.location is null))
                           and a.part_no = cur_req.part_no
                         order by a.kb_product_seqno)
      loop
        --获取净需求
        v_require_num := cur_queue.require_num;
        /*
        --截止需求量判断，如果超过，则取需求量为截止需求量
        if v_end_require_flag = 1 then
          if v_end_require_date < sysdate then
            --如果达到截止日期，不产生新包装需求
            v_require_num := 0;
            v_end_require_num := 0;
          elsif v_require_num > v_end_require_num then
            v_require_num := v_end_require_num;
            v_end_require_num := 0;
          else
            v_end_require_num := v_end_require_num - v_require_num;
          end if;
        end if;
        */

        --零件余量 = 零件余量 - 零件需求量
        v_end_remain := v_end_remain - v_require_num;
        v_distri_qty := 0;
        --当零件余量扣减需求不能满足安全库存时产生新的配送需求
        if v_end_remain < v_safety_inventory then
          v_distri_qty  := CEIL((v_safety_inventory-v_end_remain)/v_distri_package) * v_distri_package;
          v_end_remain := v_end_remain + v_distri_qty;

          --计算物流周期
          --获取工作日期(不包含时分秒)
          v_work_date := PKG_PUB.USF_GET_WORK_DATE(cur_req.factory_code, cur_req.workcenter, null);
          --获取生产节拍???
          v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_req.factory_code, cur_req.workcenter, null);
          --计算备件时间
          v_prepare_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_prepare_num*v_produce_time);
          --计算发车时间
          v_dispatch_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_dispatch_num*v_produce_time);
          --计算发货时间
          v_delivery_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_delivery_num*v_produce_time);
          --计算到货时间
          v_arrive_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_arrive_num*v_produce_time);
          --计算配送时间
          v_distri_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_distri_num*v_produce_time);
          --计算装配时间
          v_assemble_time := PKG_PUB.USF_GET_CAL_WORKTIME(cur_req.factory_code, cur_req.workcenter, cur_queue.kb_time, -v_loc_num*v_produce_time);
          --计算备件产品流水号
          v_prepare_product_seqno := cur_queue.kb_product_seqno-v_prepare_num;
          --计算发车产品流水号
          v_dispatch_product_seqno := cur_queue.kb_product_seqno-v_dispatch_num;
          --计算发货产品流水号
          v_delivery_product_seqno := cur_queue.kb_product_seqno-v_delivery_num;
          --计算到货产品流水号
          v_arrive_product_seqno := cur_queue.kb_product_seqno-v_arrive_num;
          --计算配送产品流水号
          v_distri_product_seqno := cur_queue.kb_product_seqno-v_distri_num;
          --计算装配产品流水号
          v_assemble_product_seqno := cur_queue.kb_product_seqno-v_loc_num;

          --写入包装需求
          insert into mm_jit_pkg_req
            (id,
             plan_code,
             part_no,
             location,
             --s_product_seqno,
             --e_product_seqno,
             require_num,
             part_short_no,
             part_name,
             sup_factory,
             supplier_no,
             supplier_name,
             ship_depot,
             arr_depot,
             distri_package,
             standard_package,
             unload_port,
             storage,
             prepare_person,
             carpool,
             distri_person,
             kb_product_seqno,
             prepare_product_seqno,
             dispatch_product_seqno,
             delivery_product_seqno,
             arrive_product_seqno,
             distri_product_seqno,
             assemble_product_seqno,
             kb_time,
             prepare_time,
             dispatch_time,
             delivery_time,
             arrive_time,
             distri_time,
             assemble_time,
             use_location_num,
             prepare_batch_seqno)
          values
            (SEQ_MM_JIT_PKG_REQ.NEXTVAL,
             cur_req.plan_code,
             cur_req.part_no,
             cur_req.location,
             v_distri_qty,
             v_part_short_no,
             v_part_name,
             v_sup_factory,
             v_supplier_no,
             v_supplier_name,
             v_ship_depot,
             v_arr_depot,
             v_distri_package,
             v_standard_package,
             v_unload_port,
             v_storage,
             v_prepare_person,
             v_carpool,
             v_distri_person,
             cur_queue.kb_product_seqno,
             v_prepare_product_seqno,
             v_dispatch_product_seqno,
             v_delivery_product_seqno,
             v_arrive_product_seqno,
             v_distri_product_seqno,
             v_assemble_product_seqno,
             cur_queue.kb_time,
             v_prepare_time,
             v_dispatch_time,
             v_delivery_time,
             v_arrive_time,
             v_distri_time,
             v_assemble_time,
             v_use_location_num,
             PKG_PUB.USF_GET_BATCHSEQ_BY_PRODSEQNO(cur_req.plan_code,
                                                   v_prepare_product_seqno));
        end if;

        --截止产品零件余量记录,0:新增 1：修改
        v_remain_record_flag := 0;
        v_is_finish_p        := 0;
        for cur_remain_prod in (select * from mm_jit_part_remain_prod a
                                 where a.plan_code = cur_req.plan_code
                                   and a.part_no = cur_req.part_no
                                   --mod by wxl 20190228
                                   and (a.location = cur_req.location or
                                       (a.location is null and cur_req.location is null))
                                   and a.is_finish = 0)
        loop
          v_remain_record_flag := 1;
          --当存在安全库存、车辆需求、配送包装发生变化时新增修改截止到上一次记录数据
          if cur_remain_prod.e_kb_product_seqno+1 <> cur_queue.kb_product_seqno or
             cur_remain_prod.safety_inventory <> v_safety_inventory or
             cur_remain_prod.distri_package <> v_distri_package or
             cur_remain_prod.require_num <> cur_queue.require_num then
            v_remain_record_flag := 0;--需新增
            update mm_jit_part_remain_prod a
               set a.is_finish = 1
             where a.plan_code = cur_req.plan_code
               and a.part_no = cur_req.part_no
               --mod by wxl 20190228
               and (a.location = cur_req.location or
                   (a.location is null and cur_req.location is null))
               and a.is_finish = 0;
          end if;
          --存在尾数时（截止需求量导致）
          /*
          if cur_queue.require_num <> v_require_num then
            v_remain_record_flag := 1;
            v_is_finish_p        := 1;
          end if;
          */
        end loop;

        if v_remain_record_flag = 0 then
          insert into mm_jit_part_remain_prod
            (id,
             plan_code,
             part_no,
             location,
             s_kb_product_seqno,
             e_kb_product_seqno,
             start_remain,
             end_remain,
             require_num,
             distri_package,
             safety_inventory,
             end_require_num)
          values
            (SEQ_MM_JIT_PART_REM_PROD.NEXTVAL,
             cur_req.plan_code,
             cur_req.part_no,
             cur_req.location,
             cur_queue.kb_product_seqno,
             cur_queue.kb_product_seqno,
             v_start_remain,
             v_end_remain,
             cur_queue.require_num,
             v_distri_package,
             v_safety_inventory,
             null);
        else
          update mm_jit_part_remain_prod a
             set a.e_kb_product_seqno = cur_queue.kb_product_seqno,
                 a.end_remain = v_end_remain,
                 --a.end_require_num = cur_queue.require_num-v_require_num,
                 a.is_finish = v_is_finish_p
           where a.plan_code = cur_req.plan_code
             and a.part_no = cur_req.part_no
             --mod by wxl 20190228
             and (a.location = cur_req.location or
                 (a.location is null and cur_req.location is null))
             and a.is_finish = 0;
        end if;

        --如果达到截止需求，不产生新包装需求，退出循环
        /*
        if v_end_require_flag = 1 and v_end_require_num = 0 then
          exit;
        end if;
        */
      end loop;

      if v_remain_exists_flag = 0 then
        --若当前零件余量不存在 则新增
        insert into mm_jit_part_remain
          (id, plan_code, location, part_no, part_remain)
        values
          (SEQ_MM_JIT_PART_REMAIN.NEXTVAL, cur_req.plan_code, cur_req.location, cur_req.part_no, v_end_remain);
      else
        --若当前零件余量存在 则更新
        update mm_jit_part_remain a
           set a.part_remain     = v_end_remain
               --a.end_require_num = v_end_require_num
         where a.plan_code = cur_req.plan_code
           --mod by wxl 20190228
           and (a.location = cur_req.location or
               (a.location is null and cur_req.location is null))
           and a.part_no = cur_req.part_no;
      end if;

      --删除已经生成包装需求的零件净需求
      delete from mm_jit_net_req a
       where a.plan_code = cur_req.plan_code
         --mod by wxl 20190228
         and (a.location = cur_req.location or
             (a.location is null and cur_req.location is null))
         and a.part_no = cur_req.part_no;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JITO_CAL_PKG_REQ：'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JITO_CAL_PKG_REQ;

  --****************************************************************************
  --过程名  : USP_JITD_CAL_LACK_REQ
  --功能描述: 计算零件缺件需求（厂外->厂内）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2019-06-11
  --****************************************************************************
  PROCEDURE USP_JITD_CAL_LACK_REQ(in_plan_code in varchar2) IS
    v_remain_exists_flag number(1); --零件余量是否存在
    v_start_remain       mm_jit_part_remain.part_remain%type; --期初余量
    v_end_remain         mm_jit_part_remain.part_remain%type; --期末余量
    v_safety_inventory   mm_jit_part_remain.safety_inventory%type; --安全库存
    v_loc_num            mm_inv_part_location.location_num%type; --落点工程深度
    v_prepare_num        number(10);--备件流动数
    v_dispatch_num       number(10);--发车流动数
    v_delivery_num       number(10);--发货流动数
    v_arrive_num         number(10);--到货流动数
    v_distri_num         number(10);--配送流动数
    v_prepare_product_seqno  number(19); --备件批次产品流水号
    v_kb_product_seqno       number(19); --看板批次产品流水号
    v_require_num        number(10); --需求量
    err_num              number(10); --错误代码
    err_msg              varchar2(200); --错误信息
  BEGIN
    --获取当前看板产品流水号
    v_kb_product_seqno := USF_GET_KBPRODSEQNO(in_plan_code);
    --按净需求生成包装需求
    for cur_req in (select a.plan_code, a.factory_code, a.workcenter, b.part_no, b.location
                      from mm_pub_plan_code a, mm_jit_net_req b
                     where a.plan_code = b.plan_code
                       and b.plan_code = in_plan_code
                     group by a.plan_code, a.factory_code, a.workcenter, b.part_no, b.location
                     order by a.plan_code, a.factory_code, a.workcenter, b.part_no, b.location)
    loop
      --获取上次计算的零件余量
      v_remain_exists_flag := 0;
      v_start_remain       := 0;
      v_safety_inventory   := 0;
      for cur_part_remain in (select part_remain, safety_inventory, end_require_date, end_require_num
                                from mm_jit_part_remain
                               where plan_code = cur_req.plan_code
                                 and location = cur_req.location
                                 and part_no = cur_req.part_no)
      loop
         v_remain_exists_flag := 1;
         v_start_remain := cur_part_remain.part_remain;
         v_safety_inventory := cur_part_remain.safety_inventory;
         exit;
      end loop;

      --获取拉动零件基本信息
      v_prepare_num      := NVL(TO_NUMBER(PKG_PUB.USF_GET_SYS_PARAM(cur_req.factory_code, 'JITI_CAL', cur_req.workcenter|| '_PRE_AHEAD_PRO_NUM')),0);
      v_dispatch_num     := 0;
      v_delivery_num     := 0;
      v_arrive_num       := 0;
      v_distri_num       := NVL(TO_NUMBER(PKG_PUB.USF_GET_SYS_PARAM(cur_req.factory_code, 'JITI_CAL', cur_req.workcenter|| '_DELI_AHEAD_PRO_NUM')),0);

      --获取库位、拣货工程、台车、配送工程、落点工程深度信息???
      v_loc_num        := 0;
      for cur_loc in (select b.unload_port,
                             b.storage,
                             b.prepare_person,
                             b.carpool,
                             b.distri_person,
                             b.location_num,
                             b.location,
                             b.ware_code
                        from mm_inv_part_location b
                       where b.factory_code = cur_req.factory_code
                         and b.workcenter   = cur_req.workcenter
                         and b.part_no      = cur_req.part_no
                         and b.location     = cur_req.location
                       order by b.location_num desc)
      loop
        v_loc_num        := cur_loc.location_num;
        exit;
      end loop;
      --计算备件流动数
      v_prepare_num  := v_prepare_num+v_delivery_num+v_arrive_num+v_distri_num+v_loc_num;
      --计算当前对应最大看板产品流水号
      v_prepare_product_seqno := v_kb_product_seqno+v_prepare_num;

      v_end_remain := v_start_remain;
      select NVL(sum(a.require_num),0)
        into v_require_num
        from mm_jit_net_req a
       where a.plan_code = cur_req.plan_code
         and a.location = cur_req.location
         and a.part_no = cur_req.part_no
         and a.kb_product_seqno <= v_prepare_product_seqno;
      if v_require_num > 0 then
        v_end_remain := v_end_remain - v_require_num;
      end if;
      if v_remain_exists_flag = 0 then
        --若当前零件余量不存在 则新增
        insert into mm_jit_part_remain
          (id, plan_code, location, part_no, part_remain)
        values
          (SEQ_MM_JIT_PART_REMAIN.NEXTVAL, cur_req.plan_code, cur_req.location, cur_req.part_no, v_end_remain);
      else
        --若当前零件余量存在 则更新
        update mm_jit_part_remain a
           set a.part_remain     = v_end_remain
         where a.plan_code = cur_req.plan_code
           and a.location = cur_req.location
           and a.part_no = cur_req.part_no;
      end if;

      --删除已经生成包装需求的零件净需求
      delete from mm_jit_net_req
       where plan_code = cur_req.plan_code
         and location = cur_req.location
         and part_no = cur_req.part_no
         and kb_product_seqno <= v_prepare_product_seqno;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JITD_CAL_LACK_REQ：'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JITD_CAL_LACK_REQ;

  --****************************************************************************
  --过程名  : USP_JIT_CREATE_INS
  --功能描述: 生成配送单（厂内）-按配送工程
  --参数说明:
  -- in_order_no  :物流单号
  --创建人员: wxl
  --创建时间: 2018-09-20
  --修改记录：
  --          调整单据前缀获取逻辑 mod by wxl 20190129
  --          LMS2019021302系统支持两种组单方式 mod by wxl 20190221
  --          调整判断另外出单的形式 mod by wxl 20190501
  --          增加出单排序 mod by wxl 20190502
  --          修复bug mod by wxl 20190502
  --         iLMS2019061401 优化厂内拉动-合并到同一张配送单的无法查询对应包装需求 mod by wxl 20190614
  --         iLMS2019061401 优化厂内拉动-调整已经开始备件的后续需求落在下一未 mod by wxl 20190614
  --****************************************************************************
  PROCEDURE USP_JIT_CREATE_INS1(in_order_no in varchar2) IS
    v_prepare_time       date; --备货时间
    v_delivery_time      date; --发货时间
    v_arrive_time        date; --到货时间
    v_distri_time        date; --配送时间
    v_prepare_product_seqno  number(19); --备件批次产品流水号
    v_delivery_product_seqno number(19); --发货批次产品流水号
    v_arrive_product_seqno   number(19); --到货批次产品流水号
    v_distri_product_seqno   number(19); --配送批次产品流水号
    v_factory_str        varchar2(1); --工厂
    v_order_type_str     varchar2(1); --单据类型
    v_ins_no             mm_jit_ins.ins_no%type; --配送单号
    v_ins_no_batch       mm_jit_ins.ins_no_batch%type; --配送单号(不加差异序号)
    v_ins_no_diffseq     mm_jit_ins.ins_no_diffseq%type; --配送单号差异序号
    v_ope_flag           varchar2(1); --操作标识
    v_flag               number(1); --临时标识
    --v_part_short_no      varchar2(10); --零件简号 ???
    --v_part_name          varchar2(150); --零件名称 ???
    --v_supplier_no        varchar2(20); --供应商代码 ???
    --v_supplier_name      varchar2(150); --供应商名称 ???
    --v_standard_package   mm_jit_part.standard_package%type; --规格包装
    --v_storage            mm_inv_part_location.storage%type; --库位
  BEGIN
    --按信息点、出货仓库、到货仓库、备件工程、配送工程、台车、备件批次组单
    for cur_ins in (select a.order_no,
                           a.plan_code,
                           a.ship_depot,
                           a.arr_depot,
                           a.prepare_person,
                           a.distri_person,
                           a.carpool,
                           a.prepare_batch_seqno,
                           min(a.prepare_product_seqno) prepare_product_seqno,
                           min(a.delivery_product_seqno) delivery_product_seqno,
                           min(a.arrive_product_seqno) arrive_product_seqno,
                           min(a.distri_product_seqno) distri_product_seqno,
                           min(a.prepare_time) prepare_time,
                           min(a.delivery_time) delivery_time,
                           min(a.arrive_time) arrive_time,
                           min(a.distri_time) distri_time,
                           b.factory_code
                      from mm_jit_pkg_req a, mm_pub_plan_code b
                     where a.plan_code = b.plan_code
                       and a.order_no = in_order_no
                     group by a.order_no,
                              a.plan_code,
                              a.ship_depot,
                              a.arr_depot,
                              a.prepare_person,
                              a.distri_person,
                              a.carpool,
                              a.prepare_batch_seqno,
                              b.factory_code
                     --mod by wxl 20190502
                     order by a.plan_code,
                              a.ship_depot,
                              a.arr_depot,
                              a.prepare_person,
                              a.distri_person,
                              a.carpool,
                              a.prepare_batch_seqno)
    loop
      v_prepare_time  := cur_ins.prepare_time;
      v_delivery_time := cur_ins.delivery_time;
      v_arrive_time   := cur_ins.arrive_time;
      v_distri_time   := cur_ins.distri_time;
      --mod by wxl 20190502
      --v_prepare_product_seqno  := cur_ins.prepare_batch_seqno;
      v_prepare_product_seqno  := cur_ins.prepare_product_seqno;
      v_delivery_product_seqno := cur_ins.delivery_product_seqno;
      v_arrive_product_seqno   := cur_ins.arrive_product_seqno;
      v_distri_product_seqno   := cur_ins.distri_product_seqno;

      --获取配送单单号
      --获取前缀
      v_factory_str := null;
      v_order_type_str := null;
      --mod by wxl 20190129
      for cur_prefix in (select a.factory_code_str, a.bill_group_type_str
                           from mm_pub_bill_prefix a
                          where a.bill_group = 'JIT_INS'
                            and a.plan_code = cur_ins.plan_code)
      loop
        v_factory_str := cur_prefix.factory_code_str;
        v_order_type_str := cur_prefix.bill_group_type_str;
      end loop;
      --mod by wxl 20190222
      --v_ins_no_batch := v_factory_str || v_order_type_str || cur_ins.prepare_batch_seqno || cur_ins.ship_depot || cur_ins.distri_person || cur_ins.carpool;
      v_ins_no_batch := v_factory_str || v_order_type_str || cur_ins.ship_depot || cur_ins.prepare_person|| cur_ins.distri_person || cur_ins.carpool || cur_ins.prepare_batch_seqno;
      --配送单是否存在判断处理
      v_ope_flag := null;
      select count(1)
        into v_flag
        from mm_jit_ins a
       where a.ins_no_batch = v_ins_no_batch
         and rownum = 1;
      if v_flag = 0 then
        v_ins_no         := v_ins_no_batch;
        v_ins_no_diffseq := 0;
        v_ope_flag       := 'I';
      else
        --差异配送单判断处理。如果检查到配送单号存在且已经打印，则产生差异配送单。差异订单格式为：原单号_1、原单号_2等
        for cur_last_ins in (select a.*  from mm_jit_ins a where a.ins_no_batch = v_ins_no_batch order by a.ins_no_diffseq desc)
        loop
          --mod by wxl 20190501
          --if cur_last_ins.print_status <> 0 then
          --mod by wxl 20190614
          --if cur_last_ins.print_status <> 0 or cur_last_ins.prepare_status <> 0 then
          if cur_last_ins.print_status <> 0 or cur_last_ins.prepare_status < 2 then
            v_ins_no_diffseq := cur_last_ins.ins_no_diffseq + 1;
            v_ins_no         := v_ins_no_batch || '_' || to_char(v_ins_no_diffseq);
            v_ope_flag       := 'I';
          else
            v_ins_no    := cur_last_ins.ins_no;
            --获取最小物流周期
            if v_prepare_time > cur_last_ins.prepare_time then
              v_prepare_time := cur_last_ins.prepare_time;
              v_ope_flag  := 'U';
            end if;
            if v_delivery_time > cur_last_ins.delivery_time then
              v_delivery_time := cur_last_ins.delivery_time;
              v_ope_flag  := 'U';
            end if;
            if v_arrive_time > cur_last_ins.arrive_time then
              v_arrive_time := cur_last_ins.arrive_time;
              v_ope_flag  := 'U';
            end if;
            if v_distri_time > cur_last_ins.distri_time then
              v_distri_time := cur_last_ins.distri_time;
              v_ope_flag  := 'U';
            end if;
            if v_prepare_product_seqno > cur_last_ins.prepare_product_seqno then
              v_prepare_product_seqno := cur_last_ins.prepare_product_seqno;
              v_ope_flag  := 'U';
            end if;
            if v_delivery_product_seqno > cur_last_ins.delivery_product_seqno then
              v_delivery_product_seqno := cur_last_ins.delivery_product_seqno;
              v_ope_flag  := 'U';
            end if;
            if v_arrive_product_seqno > cur_last_ins.arrive_product_seqno then
              v_arrive_product_seqno := cur_last_ins.arrive_product_seqno;
              v_ope_flag  := 'U';
            end if;
            if v_distri_product_seqno > cur_last_ins.distri_product_seqno then
              v_distri_product_seqno := cur_last_ins.distri_product_seqno;
              v_ope_flag  := 'U';
            end if;
          end if;
          exit;
        end loop;
      end if;

      --写入配送单主信息
      if v_ope_flag = 'I' then
        insert into mm_jit_ins
          (ins_no,
           plan_code,
           ship_depot,
           arr_depot,
           prepare_person,
           distri_person,
           carpool,
           gen_ins_way,--mod by wxl 20190221
           prepare_product_seqno,
           delivery_product_seqno,
           arrive_product_seqno,
           distri_product_seqno,
           ins_no_batch,
           ins_no_diffseq,
           order_no,
           prepare_batch_no,
           prepare_time,
           delivery_time,
           arrive_time,
           distri_time)
        values
          (v_ins_no,
           cur_ins.plan_code,
           cur_ins.ship_depot,
           cur_ins.arr_depot,
           cur_ins.prepare_person,
           cur_ins.distri_person,
           cur_ins.carpool,
           '1',--mod by wxl 20190221
           v_prepare_product_seqno,
           v_delivery_product_seqno,
           v_arrive_product_seqno,
           v_distri_product_seqno,
           v_ins_no_batch,
           v_ins_no_diffseq,
           cur_ins.order_no,
           PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(cur_ins.plan_code,
                                                v_prepare_product_seqno),
           v_prepare_time,
           v_delivery_time,
           v_arrive_time,
           v_distri_time);
      elsif v_ope_flag = 'U' then
        update mm_jit_ins a
           set a.prepare_product_seqno  = v_prepare_product_seqno,
               a.delivery_product_seqno = v_delivery_product_seqno,
               a.arrive_product_seqno   = v_arrive_product_seqno,
               a.distri_product_seqno   = v_distri_product_seqno,
               a.prepare_batch_no       = PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(cur_ins.plan_code,
                                                v_prepare_product_seqno),
               a.prepare_time           = v_prepare_time,
               a.delivery_time          = v_delivery_time,
               a.arrive_time            = v_arrive_time,
               a.distri_time            = v_distri_time
         where a.ins_no = v_ins_no;
      end if;
      --写入配送单明细信息
      for cur_req in (select a.plan_code,
                             a.part_no,
                             a.location,
                             min(a.part_short_no) part_short_no,
                             min(a.part_name) part_name,
                             min(a.supplier_no) supplier_no,
                             min(a.supplier_name) supplier_name,
                             min(a.standard_package) standard_package,
                             min(a.storage) storage,
                             sum(a.require_num) require_num
                        from mm_jit_pkg_req a
                       where a.order_no = cur_ins.order_no
                         and a.prepare_person = cur_ins.prepare_person
                         and a.distri_person = cur_ins.distri_person
                         and a.carpool = cur_ins.carpool
                       group by a.plan_code, a.part_no, a.location)
      loop
        select count(1)
          into v_flag
          from mm_jit_ins_detail b
         where b.ins_no = v_ins_no
           and b.part_no = cur_req.part_no
           and b.location = cur_req.location
           and rownum = 1;
        if v_flag = 1 then
          update mm_jit_ins_detail b
             set b.require_num = b.require_num + cur_req.require_num,
                 b.last_modified_time = sysdate
           where b.ins_no = v_ins_no
             and b.part_no = cur_req.part_no
             and b.location = cur_req.location;
        else
          insert into mm_jit_ins_detail
            (ins_no,
             part_no,
             location,
             require_num,
             part_short_no,
             part_name,
             supplier_no,
             supplier_name,
             standard_package,
             storage)
          values
            (v_ins_no,
             cur_req.part_no,
             cur_req.location,
             cur_req.require_num,
             cur_req.part_short_no,
             cur_req.part_name,
             cur_req.supplier_no,
             cur_req.supplier_name,
             cur_req.standard_package,
             cur_req.storage);
        end if;
      end loop;

      --更新不良品信息
      update mm_dpm_ins a
         set a.delivery_status = 1, a.delivery_order_no = v_ins_no
       where a.apply_no in
             (select t1.dpm_apply_no
                from mm_jit_pkg_req_dpm t1, mm_jit_pkg_req t2
               where t1.pkg_req_id = t2.id
                 and t2.order_no = cur_ins.order_no
                 and t2.prepare_person = cur_ins.prepare_person
                 and t2.distri_person = cur_ins.distri_person
                 and t2.carpool = cur_ins.carpool);
      delete from mm_jit_pkg_req_dpm a
       where a.pkg_req_id in
             (select t.id
                from mm_jit_pkg_req t
               where t.order_no = cur_ins.order_no
                 and t.prepare_person = cur_ins.prepare_person
                 and t.distri_person = cur_ins.distri_person
                 and t.carpool = cur_ins.carpool);
      --mod by wxl 20190614
      if v_ope_flag = 'U' then
        update mm_jit_pkg_req a
           set a.order_no =
               (select b.order_no from mm_jit_ins b where b.ins_no = v_ins_no)
         where a.order_no = cur_ins.order_no
           and a.prepare_person = cur_ins.prepare_person
           and a.distri_person = cur_ins.distri_person
           and a.carpool = cur_ins.carpool;
      end if;
    end loop;
  END USP_JIT_CREATE_INS1;

  --****************************************************************************
  --过程名  : USP_JIT_CREATE_INS2
  --功能描述: 生成配送单（厂内）-按拣货工程
  --参数说明:
  -- in_order_no  :物流单号
  --创建人员: wxl
  --创建时间: 2019-02-22
  --修改记录：
  --          调整判断另外出单的形式 mod by wxl 20190501
  --          增加出单排序 mod by wxl 20190502
  --          修复bug mod by wxl 20190502
  --         iLMS2019061401 优化厂内拉动-合并到同一张配送单的无法查询对应包装需求 mod by wxl 20190614
  --****************************************************************************
  PROCEDURE USP_JIT_CREATE_INS2(in_order_no in varchar2) IS
    v_prepare_time       date; --备货时间
    v_delivery_time      date; --发货时间
    v_arrive_time        date; --到货时间
    v_distri_time        date; --配送时间
    v_prepare_product_seqno  number(19); --备件批次产品流水号
    v_delivery_product_seqno number(19); --发货批次产品流水号
    v_arrive_product_seqno   number(19); --到货批次产品流水号
    v_distri_product_seqno   number(19); --配送批次产品流水号
    v_factory_str        varchar2(1); --工厂
    v_order_type_str     varchar2(1); --单据类型
    v_ins_no             mm_jit_ins.ins_no%type; --配送单号
    v_ins_no_batch       mm_jit_ins.ins_no_batch%type; --配送单号(不加差异序号)
    v_ins_no_diffseq     mm_jit_ins.ins_no_diffseq%type; --配送单号差异序号
    v_ope_flag           varchar2(1); --操作标识
    v_flag               number(1); --临时标识
    --v_part_short_no      varchar2(10); --零件简号 ???
    --v_part_name          varchar2(150); --零件名称 ???
    --v_supplier_no        varchar2(20); --供应商代码 ???
    --v_supplier_name      varchar2(150); --供应商名称 ???
    --v_standard_package   mm_jit_part.standard_package%type; --规格包装
    --v_storage            mm_inv_part_location.storage%type; --库位
  BEGIN
    --按信息点、出货仓库、到货仓库、备件工程、配送工程、台车、备件批次组单
    for cur_ins in (select a.order_no,
                           a.plan_code,
                           a.ship_depot,
                           a.arr_depot,
                           a.prepare_person,
                           --a.distri_person,
                           --a.carpool,
                           a.prepare_batch_seqno,
                           min(a.prepare_product_seqno) prepare_product_seqno,
                           min(a.delivery_product_seqno) delivery_product_seqno,
                           min(a.arrive_product_seqno) arrive_product_seqno,
                           min(a.distri_product_seqno) distri_product_seqno,
                           min(a.prepare_time) prepare_time,
                           min(a.delivery_time) delivery_time,
                           min(a.arrive_time) arrive_time,
                           min(a.distri_time) distri_time,
                           b.factory_code
                      from mm_jit_pkg_req a, mm_pub_plan_code b
                     where a.plan_code = b.plan_code
                       and a.order_no = in_order_no
                     group by a.order_no,
                              a.plan_code,
                              a.ship_depot,
                              a.arr_depot,
                              a.prepare_person,
                              --a.distri_person,
                              --a.carpool,
                              a.prepare_batch_seqno,
                              b.factory_code
                     --mod by wxl 20190502
                     order by a.plan_code,
                              a.ship_depot,
                              a.arr_depot,
                              a.prepare_person,
                              --a.distri_person,
                              --a.carpool,
                              a.prepare_batch_seqno)
    loop
      v_prepare_time  := cur_ins.prepare_time;
      v_delivery_time := cur_ins.delivery_time;
      v_arrive_time   := cur_ins.arrive_time;
      v_distri_time   := cur_ins.distri_time;
      --mod by wxl 20190502
      --v_prepare_product_seqno  := cur_ins.prepare_batch_seqno;
      v_prepare_product_seqno  := cur_ins.prepare_product_seqno;
      v_delivery_product_seqno := cur_ins.delivery_product_seqno;
      v_arrive_product_seqno   := cur_ins.arrive_product_seqno;
      v_distri_product_seqno   := cur_ins.distri_product_seqno;

      --获取配送单单号
      --获取前缀
      v_factory_str := null;
      v_order_type_str := null;
      --mod by wxl 20190129
      for cur_prefix in (select a.factory_code_str, a.bill_group_type_str
                           from mm_pub_bill_prefix a
                          where a.bill_group = 'JIT_INS'
                            and a.plan_code = cur_ins.plan_code)
      loop
        v_factory_str := cur_prefix.factory_code_str;
        v_order_type_str := cur_prefix.bill_group_type_str;
      end loop;
      v_ins_no_batch := v_factory_str || v_order_type_str || cur_ins.ship_depot || cur_ins.prepare_person || cur_ins.prepare_batch_seqno;
      --配送单是否存在判断处理
      v_ope_flag := null;
      select count(1)
        into v_flag
        from mm_jit_ins a
       where a.ins_no_batch = v_ins_no_batch
         and rownum = 1;
      if v_flag = 0 then
        v_ins_no         := v_ins_no_batch;
        v_ins_no_diffseq := 0;
        v_ope_flag       := 'I';
      else
        --差异配送单判断处理。如果检查到配送单号存在且已经打印，则产生差异配送单。差异订单格式为：原单号_1、原单号_2等
        for cur_last_ins in (select a.*  from mm_jit_ins a where a.ins_no_batch = v_ins_no_batch order by a.ins_no_diffseq desc)
        loop
          --mod by wxl 20190501
          --if cur_last_ins.print_status <> 0 then
          --mod by wxl 20190614
          --if cur_last_ins.print_status <> 0 or cur_last_ins.prepare_status <> 0 then
          if cur_last_ins.print_status <> 0 or cur_last_ins.prepare_status < 2 then
            v_ins_no_diffseq := cur_last_ins.ins_no_diffseq + 1;
            v_ins_no         := v_ins_no_batch || '_' || to_char(v_ins_no_diffseq);
            v_ope_flag       := 'I';
          else
            v_ins_no    := cur_last_ins.ins_no;
            --获取最小物流周期
            if v_prepare_time > cur_last_ins.prepare_time then
              v_prepare_time := cur_last_ins.prepare_time;
              v_ope_flag  := 'U';
            end if;
            if v_delivery_time > cur_last_ins.delivery_time then
              v_delivery_time := cur_last_ins.delivery_time;
              v_ope_flag  := 'U';
            end if;
            if v_arrive_time > cur_last_ins.arrive_time then
              v_arrive_time := cur_last_ins.arrive_time;
              v_ope_flag  := 'U';
            end if;
            if v_distri_time > cur_last_ins.distri_time then
              v_distri_time := cur_last_ins.distri_time;
              v_ope_flag  := 'U';
            end if;
            if v_prepare_product_seqno > cur_last_ins.prepare_product_seqno then
              v_prepare_product_seqno := cur_last_ins.prepare_product_seqno;
              v_ope_flag  := 'U';
            end if;
            if v_delivery_product_seqno > cur_last_ins.delivery_product_seqno then
              v_delivery_product_seqno := cur_last_ins.delivery_product_seqno;
              v_ope_flag  := 'U';
            end if;
            if v_arrive_product_seqno > cur_last_ins.arrive_product_seqno then
              v_arrive_product_seqno := cur_last_ins.arrive_product_seqno;
              v_ope_flag  := 'U';
            end if;
            if v_distri_product_seqno > cur_last_ins.distri_product_seqno then
              v_distri_product_seqno := cur_last_ins.distri_product_seqno;
              v_ope_flag  := 'U';
            end if;
          end if;
          exit;
        end loop;
      end if;

      --写入配送单主信息
      if v_ope_flag = 'I' then
        insert into mm_jit_ins
          (ins_no,
           plan_code,
           ship_depot,
           arr_depot,
           prepare_person,
           distri_person,
           carpool,
           gen_ins_way,
           prepare_product_seqno,
           delivery_product_seqno,
           arrive_product_seqno,
           distri_product_seqno,
           ins_no_batch,
           ins_no_diffseq,
           order_no,
           prepare_batch_no,
           prepare_time,
           delivery_time,
           arrive_time,
           distri_time)
        values
          (v_ins_no,
           cur_ins.plan_code,
           cur_ins.ship_depot,
           cur_ins.arr_depot,
           cur_ins.prepare_person,
           null,
           null,
           '2',
           v_prepare_product_seqno,
           v_delivery_product_seqno,
           v_arrive_product_seqno,
           v_distri_product_seqno,
           v_ins_no_batch,
           v_ins_no_diffseq,
           cur_ins.order_no,
           PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(cur_ins.plan_code,
                                                v_prepare_product_seqno),
           v_prepare_time,
           v_delivery_time,
           v_arrive_time,
           v_distri_time);
      elsif v_ope_flag = 'U' then
        update mm_jit_ins a
           set a.prepare_product_seqno  = v_prepare_product_seqno,
               a.delivery_product_seqno = v_delivery_product_seqno,
               a.arrive_product_seqno   = v_arrive_product_seqno,
               a.distri_product_seqno   = v_distri_product_seqno,
               a.prepare_batch_no       = PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(cur_ins.plan_code,
                                                v_prepare_product_seqno),
               a.prepare_time           = v_prepare_time,
               a.delivery_time          = v_delivery_time,
               a.arrive_time            = v_arrive_time,
               a.distri_time            = v_distri_time
         where a.ins_no = v_ins_no;
      end if;
      --写入配送单明细信息
      for cur_req in (select a.plan_code,
                             a.part_no,
                             a.distri_person,
                             a.carpool,
                             a.location,
                             min(a.part_short_no) part_short_no,
                             min(a.part_name) part_name,
                             min(a.supplier_no) supplier_no,
                             min(a.supplier_name) supplier_name,
                             min(a.standard_package) standard_package,
                             min(a.storage) storage,
                             sum(a.require_num) require_num
                        from mm_jit_pkg_req a
                       where a.order_no = cur_ins.order_no
                         and a.prepare_person = cur_ins.prepare_person
                         --and a.distri_person = cur_ins.distri_person
                         --and a.carpool = cur_ins.carpool
                       group by a.plan_code,
                                a.part_no,
                                a.location,
                                a.distri_person,
                                a.carpool)
      loop
        select count(1)
          into v_flag
          from mm_jit_ins_detail b
         where b.ins_no = v_ins_no
           and b.part_no = cur_req.part_no
           and b.location = cur_req.location
           and rownum = 1;
        if v_flag = 1 then
          update mm_jit_ins_detail b
             set b.require_num = b.require_num + cur_req.require_num,
                 b.last_modified_time = sysdate
           where b.ins_no = v_ins_no
             and b.part_no = cur_req.part_no
             and b.location = cur_req.location;
        else
          insert into mm_jit_ins_detail
            (ins_no,
             part_no,
             location,
             distri_person,
             carpool,
             require_num,
             part_short_no,
             part_name,
             supplier_no,
             supplier_name,
             standard_package,
             storage)
          values
            (v_ins_no,
             cur_req.part_no,
             cur_req.location,
             cur_req.distri_person,
             cur_req.carpool,
             cur_req.require_num,
             cur_req.part_short_no,
             cur_req.part_name,
             cur_req.supplier_no,
             cur_req.supplier_name,
             cur_req.standard_package,
             cur_req.storage);
        end if;
      end loop;

      --更新不良品信息
      update mm_dpm_ins a
         set a.delivery_status = 1, a.delivery_order_no = v_ins_no
       where a.apply_no in
             (select t1.dpm_apply_no
                from mm_jit_pkg_req_dpm t1, mm_jit_pkg_req t2
               where t1.pkg_req_id = t2.id
                 and t2.order_no = cur_ins.order_no
                 and t2.prepare_person = cur_ins.prepare_person
                 --and t2.distri_person = cur_ins.distri_person
                 --and t2.carpool = cur_ins.carpool
                 );
      delete from mm_jit_pkg_req_dpm a
       where a.pkg_req_id in
             (select t.id
                from mm_jit_pkg_req t
               where t.order_no = cur_ins.order_no
                 and t.prepare_person = cur_ins.prepare_person
                 --and t.distri_person = cur_ins.distri_person
                 --and t.carpool = cur_ins.carpool
                 );
      --mod by wxl 20190614
      if v_ope_flag = 'U' then
        update mm_jit_pkg_req a
           set a.order_no =
               (select b.order_no from mm_jit_ins b where b.ins_no = v_ins_no)
         where a.order_no = cur_ins.order_no
           and a.prepare_person = cur_ins.prepare_person;
      end if;
    end loop;
  END USP_JIT_CREATE_INS2;

  --****************************************************************************
  --过程名  : USP_JITI_CREATE_ORDER
  --功能描述: 生成配送单（厂内）
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-21
  --修改记录：
  --          LMS2019021302系统支持两种组单方式 mod by wxl 20190221
  --          修改bug:获取组单提前台套数错误 mod by wxl 20190308
  --          修改bug:插入订单表数据错误 mod by wxl 20190313
  --          优化订单号 mod by wxl 20190403
  --****************************************************************************
  PROCEDURE USP_JITI_CREATE_ORDER(in_plan_code in varchar2) IS
    v_factory_code       mm_pub_plan_code.factory_code%type; --工厂代码
    v_workcenter         mm_pub_plan_code.workcenter%type; --工作中心
    v_gen_ins_way	       varchar2(1);--组配送单方式：1 按配送工程 2 按拣货工程
    v_ahead_product_num  number(19); --组单提前台套数
    v_e_prepare_product_seqno number(19); --组单最小备件批次产品流水号
    v_order_no           mm_jit_order.order_no%type; --物流单号
    v_order_no_batch     mm_jit_order.order_no_batch%type; --物流单(不包含差异序号)
    v_order_no_diffseq   mm_jit_order.order_no_diffseq%type; --单号差异序号
    v_factory_str        varchar2(1); --工厂 mod by wxl 20190403
    v_order_type_str     varchar2(1); --单据类型 mod by wxl 20190403
    err_num              number(10); --错误代码
    err_msg              varchar2(200); --错误信息
  BEGIN
    --获取组单提前台套数
    select a.factory_code, a.workcenter
      into v_factory_code, v_workcenter
      from mm_pub_plan_code a
     where a.plan_code = in_plan_code;
    v_gen_ins_way := NVL(TO_NUMBER(PKG_PUB.USF_GET_SYS_PARAM(v_factory_code, 'JITI_CAL', v_workcenter || '_GEN_INS_WAY')),0);
    v_ahead_product_num := NVL(TO_NUMBER(PKG_PUB.USF_GET_SYS_PARAM(v_factory_code, 'JITI_CAL', v_workcenter || '_ORDER_PRO_NUM')),0);
    --v_ahead_product_num := 10000;
    --获取当前可组单最大备件批次产品流水号
    select b.product_seqno
      into v_e_prepare_product_seqno
      from mm_pub_plan_code a, mm_mon_kb b
     where a.kb_id = b.id
       and a.plan_code = in_plan_code;
    v_e_prepare_product_seqno := v_e_prepare_product_seqno + v_ahead_product_num;

    --按信息点、出货仓库、到货仓库、备件批次组单
    for cur_config in (select a.plan_code,
                              a.ship_depot,
                              a.arr_depot,
                              a.prepare_batch_seqno
                         from mm_jit_pkg_req a
                        where a.order_deal_flag = 0
                          and a.plan_code = in_plan_code
                          and a.prepare_product_seqno <= v_e_prepare_product_seqno
                        group by a.plan_code,
                                 a.ship_depot,
                                 a.arr_depot,
                                 a.prepare_batch_seqno)
    loop
      --mod by wxl 20190403
      --v_order_no       := in_plan_code || cur_config.ship_depot ||cur_config.arr_depot|| cur_config.prepare_batch_seqno;
      --v_order_no_batch := in_plan_code || cur_config.ship_depot ||cur_config.arr_depot|| cur_config.prepare_batch_seqno;
      --获取前缀
      v_factory_str := null;
      v_order_type_str := null;
      for cur_prefix in (select a.factory_code_str, a.bill_group_type_str
                           from mm_pub_bill_prefix a
                          where a.bill_group = 'JIT_INS'
                            and a.plan_code = in_plan_code)
      loop
        v_factory_str := cur_prefix.factory_code_str;
        v_order_type_str := cur_prefix.bill_group_type_str;
      end loop;
      v_order_no       := v_factory_str || v_order_type_str || cur_config.ship_depot ||cur_config.arr_depot|| cur_config.prepare_batch_seqno;
      v_order_no_batch := v_factory_str || v_order_type_str || cur_config.ship_depot ||cur_config.arr_depot|| cur_config.prepare_batch_seqno;

      v_order_no_diffseq:=0;
      --检索该订单号之前是否已创建，如果已创建则生成差异订单号
      for cur_order in(select * from mm_jit_ins_in_order a where a.order_no_batch = v_order_no_batch order by order_no_diffseq desc)
      loop
        v_order_no_diffseq := cur_order.order_no_diffseq+1;
        v_order_no         := v_order_no_batch|| '_' || to_char(v_order_no_diffseq);
        exit;
      end loop;

      --写入配送单订单信息
      --写入order_no_batch mod by wxl 20190313
      insert into mm_jit_ins_in_order
        (order_no,
         order_no_batch,
         order_no_diffseq)
      values
        (v_order_no, v_order_no_batch, v_order_no_diffseq);
      --更新已生成订单的包装需求为已处理
      update mm_jit_pkg_req a
         set a.order_deal_flag = 1,
             a.order_no        = v_order_no,
             a.order_deal_time = sysdate
       where a.order_deal_flag = 0
         and a.plan_code = cur_config.plan_code
         and a.ship_depot = cur_config.ship_depot
         and a.arr_depot = cur_config.arr_depot
         and a.prepare_batch_seqno >= cur_config.prepare_batch_seqno
         and a.prepare_batch_seqno <= cur_config.prepare_batch_seqno;
      --生成配送单
      if v_gen_ins_way = '1' then
        USP_JIT_CREATE_INS1(v_order_no);
      elsif v_gen_ins_way = '2' then
        USP_JIT_CREATE_INS2(v_order_no);
      end if;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JITI_CREATE_ORDER：'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JITI_CREATE_ORDER;

  --****************************************************************************
  --过程名  : USP_JIT_CREATE_LABEL
  --功能描述: 根据订单号生成拉动零件标签(子过程)
  --参数说明:
  -- in_order_no  :物流单号
  --创建人员: wxl
  --创建时间: 2018-09-20
  --****************************************************************************
  PROCEDURE USP_JIT_CREATE_LABEL(in_order_no in varchar2) IS
    v_label_rowno       mm_jit_label.label_rowno%type; --标签行号
    v_label_part_rowno  mm_jit_label.label_part_rowno%type; --标签零件行号
    v_part_no           mm_jit_pkg_req.part_no%type; --零件编号
    v_label_num         number; --零件标签张数
    v_require_num       mm_jit_pkg_req.require_num%type; --需求量
    v_standard_package  mm_jit_pkg_req.standard_package%type; --零件规格包装数
    v_label_req_num     mm_jit_label.require_num%type; --标签的零件数量
  BEGIN
    --获取当前订单标签最大行号
    select NVL(sum(a.label_rowno), 0) into v_label_rowno from mm_jit_label a where a.order_no = in_order_no;
    --按配送包装生成限度看板指示票
    for cur_req in(select * from mm_jit_pkg_req a where a.order_no = in_order_no order by a.part_no, a.id)
    loop
      if v_part_no is null or v_part_no <> cur_req.part_no then
        select NVL(sum(a.label_rowno), 0) into v_label_part_rowno from mm_jit_label a where a.order_no = in_order_no and a.part_no = cur_req.part_no;
      end if;

      v_require_num := cur_req.require_num;
      v_standard_package := cur_req.standard_package;
      v_label_num := CEIL(v_require_num/v_standard_package);

      for var_i in 1 .. v_label_num
      loop
        --判断如果需求数小于规格包装数，看板需求数为剩余需求数，否则为包装数
        if v_require_num > v_standard_package then
           v_label_req_num := v_standard_package;
        else
           v_label_req_num := v_require_num;
        end if;
        v_require_num := v_require_num - v_label_req_num;
        v_label_rowno := v_label_rowno + 1;
        v_label_part_rowno := v_label_part_rowno + 1;

        --写入零件标签信息
        insert into mm_jit_label
          (order_no,
           label_rowno,
           plan_code,
           part_no,
           location,
           require_num,
           part_short_no,
           part_name,
           supplier_no,
           supplier_name,
           ship_depot,
           arr_depot,
           standard_package,
           distri_package,
           unload_port,
           storage,
           prepare_person,
           distri_person,
           kb_product_seqno,
           prepare_product_seqno,
           dispatch_product_seqno,
           delivery_product_seqno,
           arrive_product_seqno,
           distri_product_seqno,
           assemble_product_seqno,
           kb_time,
           prepare_time,
           dispatch_time,
           delivery_time,
           arrive_time,
           distri_time,
           assemble_time,
           prepare_batch_no,
           kb_batch_no,
           label_part_rowno)
        values
          (cur_req.order_no,
           v_label_rowno,
           cur_req.plan_code,
           cur_req.part_no,
           cur_req.location,
           v_label_req_num,
           cur_req.part_short_no,
           cur_req.part_name,
           cur_req.supplier_no,
           cur_req.supplier_name,
           cur_req.ship_depot,
           cur_req.arr_depot,
           cur_req.standard_package,
           cur_req.distri_package,
           cur_req.unload_port,
           cur_req.storage,
           cur_req.prepare_person,
           cur_req.distri_person,
           cur_req.kb_product_seqno,
           cur_req.prepare_product_seqno,
           cur_req.dispatch_product_seqno,
           cur_req.delivery_product_seqno,
           cur_req.arrive_product_seqno,
           cur_req.distri_product_seqno,
           cur_req.assemble_product_seqno,
           cur_req.kb_time,
           cur_req.prepare_time,
           cur_req.dispatch_time,
           cur_req.delivery_time,
           cur_req.arrive_time,
           cur_req.distri_time,
           cur_req.assemble_time,
           PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(cur_req.plan_code, cur_req.prepare_product_seqno),
           PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(cur_req.plan_code, cur_req.kb_product_seqno),
           v_label_part_rowno);
      end loop;
    end loop;
  END USP_JIT_CREATE_LABEL;

  --****************************************************************************
  --过程名  : USP_JITO_CREATE_ORDER_SUP
  --功能描述: 生成供应商拉动订单
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-19
  --          差异单新增时间记录 mod by wxl 20190323
  --****************************************************************************
  PROCEDURE USP_JITO_CREATE_ORDER_SUP(in_plan_code in varchar2) IS
    v_kb_product_seqno   number(19); --当前看板产品流水号
    v_s_prepare_product_seqno number(19); --开始备件批次产品流水号
    v_e_prepare_product_seqno number(19); --结束备件批次产品流水号
    v_sup_count          number(1); --判断是否有数据可生成订单(按供应商代码)
    --v_depot_count        number(1); --判断是否有数据可生成订单(按出货仓库代码)
    v_mod_num            number(19); --余数
    v_exists_order_flag  number(1); --备件批次范围是否存在订单
    v_supplier_name      mm_jit_order.supplier_name%type; --供应商名称???
    v_prepare_time       date; --备货时间
    v_dispatch_time      date; --发车时间
    v_delivery_time      date; --发货时间
    v_arrive_time        date; --到货时间
    v_distri_time        date; --配送时间
    v_dispatch_product_seqno number(19); --发车批次产品流水号
    v_delivery_product_seqno number(19); --发货批次产品流水号
    v_arrive_product_seqno   number(19); ---到货批次产品流水号
    v_s_prepare_batch_no mm_jit_order.s_prepare_batch_no%type; --开始备件批次
    v_e_prepare_batch_no mm_jit_order.e_prepare_batch_no%type; --结束备件批次
    v_delivery_batch_no  mm_jit_order.delivery_batch_no%type; --发货批次
    v_order_no           mm_jit_order.order_no%type; --物流单号
    v_order_no_diffseq   mm_jit_order.order_no_diffseq%type; --单号差异序号
    v_order_rowno        mm_jit_order_detail.order_rowno%type; --物流单行号
    v_part_short_no      mm_jit_order_detail.part_short_no%type; --零件简号
    v_part_name          mm_jit_order_detail.part_name%type; --零件名称
    v_standard_package   mm_jit_order_detail.standard_package%type; --规格包装
    err_num              number(10); --错误代码
    err_msg              varchar2(200); --错误信息
  BEGIN
    --获取当前看板产品流水号
    v_kb_product_seqno := USF_GET_KBPRODSEQNO(in_plan_code);
    --v_kb_product_seqno := v_kb_product_seqno + 500;

    --获取待组单的组单信息
    for cur_config in (select a.plan_code,
                              a.ship_depot,
                              a.arr_depot,
                              a.ship_depot_type,
                              a.sup_factory,
                              a.supplier_no,
                              a.ahead_product_num,
                              a.order_product_num,
                              a.s_prepare_product_seqno,
                              min(prepare_product_seqno) min_prepare_product_seqno,
                              max(prepare_product_seqno) max_prepare_product_seqno
                          from mm_jit_order_config a, mm_jit_pkg_req b
                         where a.plan_code = in_plan_code
                           and a.ship_depot_type = 'SUP'
                           --去掉开始批次不为空过滤 mod by wxl 20190120
                           --and a.s_prepare_product_seqno is not null
                           and b.order_deal_flag = 0
                           and b.plan_code = a.plan_code
                           and b.ship_depot = a.ship_depot
                           and b.arr_depot = a.arr_depot
                           and b.prepare_product_seqno <= v_kb_product_seqno + a.ahead_product_num
                         group by a.plan_code,
                                  a.ship_depot,
                                  a.arr_depot,
                                  a.ship_depot_type,
                                  a.sup_factory,
                                  a.supplier_no,
                                  a.ahead_product_num,
                                  a.order_product_num,
                                  a.s_prepare_product_seqno)
    loop
      --获取待组单起始备件批次产品流水号
      v_s_prepare_product_seqno := cur_config.min_prepare_product_seqno;
      if cur_config.s_prepare_product_seqno is not null then
        v_mod_num := mod(cur_config.s_prepare_product_seqno-v_s_prepare_product_seqno, cur_config.order_product_num);
        if v_mod_num > 0 then
          v_s_prepare_product_seqno := v_s_prepare_product_seqno - (cur_config.order_product_num-v_mod_num);
        end if;
      end if;

      --从组单起始进度值开始按组单进度基数依次循环判断订单生成
      while v_s_prepare_product_seqno + cur_config.order_product_num - 1 <= v_kb_product_seqno + cur_config.ahead_product_num
      loop
        --获取待组单结束备件批次产品流水号
        v_e_prepare_product_seqno := v_s_prepare_product_seqno + cur_config.order_product_num - 1;

        --判断是否有数据可生成订单(按供应商代码)
        select count(1)
          into v_sup_count
          from mm_jit_pkg_req a
         where a.order_deal_flag = 0
           and a.plan_code = cur_config.plan_code
           and a.ship_depot = cur_config.ship_depot
           and a.arr_depot = cur_config.arr_depot
           and a.supplier_no = cur_config.supplier_no
           and a.prepare_product_seqno >= v_s_prepare_product_seqno
           and a.prepare_product_seqno <= v_e_prepare_product_seqno
           and rownum = 1;
        --修改组单逻辑，没有供应商的数据不进行组单 mod by wxl 20190121
        /*
        --判断是否有数据可生成订单(按出货仓库代码)
        select count(1)
          into v_depot_count
          from mm_jit_pkg_req a
         where a.order_deal_flag = 0
           and a.plan_code = cur_config.plan_code
           and a.ship_depot = cur_config.ship_depot
           and a.arr_depot = cur_config.arr_depot
           and a.prepare_product_seqno >= v_s_prepare_product_seqno
           and a.prepare_product_seqno <= v_e_prepare_product_seqno
           and rownum = 1;
        if v_sup_count > 0 or v_depot_count > 0 then
        */
        if v_sup_count > 0 then

          v_exists_order_flag := 0;
          --获取供应商名称???
          v_supplier_name := null;
          for cur_sup in (select a.supplier_name
                            from mm_jit_pkg_req a
                           where a.order_deal_flag = 0
                             and a.plan_code = cur_config.plan_code
                             and a.ship_depot = cur_config.ship_depot
                             and a.arr_depot = cur_config.arr_depot
                             and a.supplier_no = cur_config.supplier_no
                             and a.prepare_product_seqno >= v_s_prepare_product_seqno
                             and a.prepare_product_seqno <= v_e_prepare_product_seqno)
          loop
            v_supplier_name := cur_sup.supplier_name;
            exit;
          end loop;
          --获取物流周期
          v_prepare_time           := null;
          v_dispatch_time          := null;
          v_delivery_time          := null;
          v_arrive_time            := null;
          v_distri_time            := null;
          v_dispatch_product_seqno := 0;
          v_delivery_product_seqno := 0;
          v_arrive_product_seqno   := 0;
          v_s_prepare_batch_no     := 0;
          v_e_prepare_batch_no     := 0;
          v_delivery_batch_no      := 0;
          --修改组急件逻辑 mod by wxl 20190121
          --v_order_no_diffseq       := 0;
          if v_e_prepare_product_seqno + cur_config.order_product_num < v_kb_product_seqno + cur_config.ahead_product_num then
            v_order_no_diffseq       := 1;
          else
            v_order_no_diffseq       := 0;
          end if;
          --差异单处理逻辑
          --mod by wxl 20190323
          for cur_order in (select a.order_no_diffseq,
                                   a.supplier_name,
                                   a.prepare_time,
                                   a.dispatch_time,
                                   a.delivery_time,
                                   a.arrive_time,
                                   a.dispatch_product_seqno,
                                   a.delivery_product_seqno,
                                   a.arrive_product_seqno,
                                   a.s_prepare_batch_no,
                                   a.e_prepare_batch_no,
                                   a.delivery_batch_no
                              from mm_jit_order a
                             where a.plan_code = cur_config.plan_code
                               and a.ship_depot = cur_config.ship_depot
                               and a.arr_depot = cur_config.arr_depot
                               and a.supplier_no = cur_config.supplier_no
                               and a.s_prepare_product_seqno >= v_s_prepare_product_seqno
                               and a.e_prepare_product_seqno <= v_e_prepare_product_seqno
                             order by a.creation_time desc, a.order_no_diffseq desc)
          loop
            v_exists_order_flag      := 1;
            v_order_no_diffseq       := cur_order.order_no_diffseq + 1;
            v_supplier_name          := cur_order.supplier_name;
            v_prepare_time           := cur_order.prepare_time;
            v_dispatch_time          := cur_order.dispatch_time;
            v_delivery_time          := cur_order.delivery_time;
            v_arrive_time            := cur_order.arrive_time;
            v_dispatch_product_seqno := cur_order.dispatch_product_seqno;
            v_delivery_product_seqno := cur_order.delivery_product_seqno;
            v_arrive_product_seqno   := cur_order.arrive_product_seqno;
            v_s_prepare_batch_no     := cur_order.s_prepare_batch_no;
            v_e_prepare_batch_no     := cur_order.e_prepare_batch_no;
            v_delivery_batch_no      := cur_order.delivery_batch_no;
            exit;
          end loop;
          --修改组单逻辑，没有供应商的数据不进行组单 mod by wxl 20190121
          --if v_sup_count > 0 and v_exists_order_flag = 0 then
          if v_exists_order_flag = 0 then
            select min(a.prepare_time),
                   min(a.dispatch_time),
                   min(a.delivery_time),
                   min(a.arrive_time),
                   min(a.distri_time),
                   min(a.dispatch_product_seqno),
                   min(a.delivery_product_seqno),
                   min(a.arrive_product_seqno)
              into v_prepare_time,
                   v_dispatch_time,
                   v_delivery_time,
                   v_arrive_time,
                   v_distri_time,
                   v_dispatch_product_seqno,
                   v_delivery_product_seqno,
                   v_arrive_product_seqno
              from mm_jit_pkg_req a
             where a.order_deal_flag = 0
               and a.plan_code = cur_config.plan_code
               and a.ship_depot = cur_config.ship_depot
               and a.arr_depot = cur_config.arr_depot
               and a.supplier_no = cur_config.supplier_no
               and a.prepare_product_seqno >= v_s_prepare_product_seqno
               and a.prepare_product_seqno <= v_e_prepare_product_seqno;
            v_s_prepare_batch_no := PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(cur_config.plan_code, v_s_prepare_product_seqno);
            v_e_prepare_batch_no := PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(cur_config.plan_code, v_e_prepare_product_seqno);
            v_delivery_batch_no  := PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(cur_config.plan_code, v_delivery_product_seqno);
          end if;

          --生成物流单号
          v_order_no := PKG_PUB.USF_GET_ORDER_NO(cur_config.plan_code);
          --写入订单主信息
          insert into mm_jit_order
            (order_no,
             plan_code,
             ship_depot,
             arr_depot,
             ship_depot_type,
             sup_factory,
             supplier_no,
             supplier_name,
             s_prepare_product_seqno,
             e_prepare_product_seqno,
             dispatch_product_seqno,
             delivery_product_seqno,
             arrive_product_seqno,
             prepare_time,
             dispatch_time,
             delivery_time,
             arrive_time,
             s_prepare_batch_no,
             e_prepare_batch_no,
             delivery_batch_no,
             order_no_batch,
             order_no_diffseq,
             purchase_orderno)
          values
            (v_order_no,
             cur_config.plan_code,
             cur_config.ship_depot,
             cur_config.arr_depot,
             cur_config.ship_depot_type,
             cur_config.sup_factory,
             cur_config.supplier_no,
             v_supplier_name,
             v_s_prepare_product_seqno,
             v_e_prepare_product_seqno,
             v_dispatch_product_seqno,
             v_delivery_product_seqno,
             v_arrive_product_seqno,
             v_prepare_time,
             v_dispatch_time,
             v_delivery_time,
             v_arrive_time,
             v_s_prepare_batch_no,
             v_e_prepare_batch_no,
             v_delivery_batch_no,
             null,
             v_order_no_diffseq,
             v_order_no);
          --写入订单明细信息
          v_order_rowno := 0;
          for cur_req in (select a.part_no, a.location, sum(a.require_num) require_num
                            from mm_jit_pkg_req a
                           where a.order_deal_flag = 0
                             and a.plan_code = cur_config.plan_code
                             and a.ship_depot = cur_config.ship_depot
                             and a.arr_depot = cur_config.arr_depot
                             --添加供应商 mod by wxl 20190120
                             and a.supplier_no = cur_config.supplier_no
                             and a.prepare_product_seqno >= v_s_prepare_product_seqno
                             and a.prepare_product_seqno <= v_e_prepare_product_seqno
                           group by a.part_no, a.location)
          loop
            v_order_rowno := v_order_rowno + 10;

            --获取零件信息???
            v_standard_package := null;
            v_part_short_no    := null;
            v_part_name        := null;
            for cur_part in (select a.standard_package, a.part_short_no, a.part_name
                               from mm_jit_pkg_req a
                              where a.order_deal_flag = 0
                                and a.plan_code = cur_config.plan_code
                                and a.ship_depot = cur_config.ship_depot
                                and a.arr_depot = cur_config.arr_depot
                                and a.part_no = cur_req.part_no
                                --mod by wxl 20190228
                                and (a.location = cur_req.location or
                                    (a.location is null and cur_req.location is null))
                                and a.prepare_product_seqno >= v_s_prepare_product_seqno
                                and a.prepare_product_seqno <= v_e_prepare_product_seqno)
            loop
              v_standard_package := cur_part.standard_package;
              v_part_short_no    := cur_part.part_short_no;
              v_part_name        := cur_part.part_name;
              exit;
            end loop;

            insert into mm_jit_order_detail
              (order_no,
               order_rowno,
               part_no,
               location,
               require_num,
               part_short_no,
               part_name,
               standard_package,
               box_num,
               supplier_no,
               supplier_name,
               purchase_orderno)
            values
              (v_order_no,
               v_order_rowno,
               cur_req.part_no,
               cur_req.location,
               cur_req.require_num,
               v_part_short_no,
               v_part_name,
               v_standard_package,
               CEIL(cur_req.require_num/v_standard_package),
               cur_config.supplier_no,
               v_supplier_name,
               v_order_no);
          end loop;

          --更新不良品信息
          update mm_dpm_ins a
             set a.order_status = 1, a.cal_order_no = v_order_no
           where a.apply_no in
                 (select t1.dpm_apply_no
                    from mm_jit_pkg_req_dpm t1, mm_jit_pkg_req t2
                   where t1.pkg_req_id = t2.id
                     and t2.order_deal_flag = 0
                     and t2.plan_code = cur_config.plan_code
                     and t2.ship_depot = cur_config.ship_depot
                     and t2.arr_depot = cur_config.arr_depot
                     --添加供应商 mod by wxl 20190120
                     and t2.supplier_no = cur_config.supplier_no
                     and t2.prepare_product_seqno >= v_s_prepare_product_seqno
                     and t2.prepare_product_seqno <= v_e_prepare_product_seqno);
          delete from mm_jit_pkg_req_dpm a
           where a.pkg_req_id in
                 (select t.id
                    from mm_jit_pkg_req t
                   where t.order_deal_flag = 0
                     and t.plan_code = cur_config.plan_code
                     and t.ship_depot = cur_config.ship_depot
                     and t.arr_depot = cur_config.arr_depot
                     --添加供应商 mod by wxl 20190120
                     and t.supplier_no = cur_config.supplier_no
                     and t.prepare_product_seqno >= v_s_prepare_product_seqno
                     and t.prepare_product_seqno <= v_e_prepare_product_seqno);

          --更新已生成订单的包装需求为已处理
          update mm_jit_pkg_req a
             set a.order_deal_flag = 1,
                 a.order_no        = v_order_no,
                 a.order_deal_time = sysdate
           where a.order_deal_flag = 0
             and a.plan_code = cur_config.plan_code
             and a.ship_depot = cur_config.ship_depot
             and a.arr_depot = cur_config.arr_depot
             --添加供应商 mod by wxl 20190120
             and a.supplier_no = cur_config.supplier_no
             and a.prepare_product_seqno >= v_s_prepare_product_seqno
             and a.prepare_product_seqno <= v_e_prepare_product_seqno;
          --生成零件标签
          USP_JIT_CREATE_LABEL(v_order_no);
        end if;

        --计算下一次组单开始备件产品流水号
        v_s_prepare_product_seqno := v_s_prepare_product_seqno + cur_config.order_product_num;
      end loop;

      --更新组单配置信息
      v_e_prepare_product_seqno := v_s_prepare_product_seqno + cur_config.order_product_num - 1;
      update mm_jit_order_config a
         set a.s_prepare_product_seqno = v_s_prepare_product_seqno,
             a.e_prepare_product_seqno = v_e_prepare_product_seqno
       where a.plan_code = cur_config.plan_code
         and a.ship_depot = cur_config.ship_depot
         and a.arr_depot = cur_config.arr_depot;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JITO_CREATE_ORDER_SUP：'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JITO_CREATE_ORDER_SUP;

  --****************************************************************************
  --过程名  : USP_JIT_CAL_EXEC
  --功能描述: 执行拉动推算
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-20
  --修改记录：
  --         LMS2019032201 新增脱批车计算 mod by wxl 20190611
  --****************************************************************************
  PROCEDURE USP_JIT_CAL_EXEC(in_plan_code in varchar2) IS
    v_exec_start_time  date; --存储过程执行开始时间点
    v_produce_time     number(10,3); --生产节拍
    excep1             exception; --自定义异常1
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    for cur_plancode in (select a.is_auto_exec, a.exec_state, a.plan_code_type, a.factory_code, a.workcenter
                           from mm_pub_plan_code a
                          where a.plan_code = in_plan_code
                            --mod by wxl 20190611
                            --and a.plan_code_type in ('JITO', 'JITI')
                            and a.plan_code_type in ('JITO', 'JITI', 'JITD')
                            and a.is_enable = 1
                            and a.is_auto_exec = 1
                            and a.exec_state = 0)
    loop
      --获取生产节拍???
      v_produce_time := PKG_PUB.USF_GET_PRODUCE_TIME(cur_plancode.factory_code, cur_plancode.workcenter, null);
      if v_produce_time is null then
        raise excep1;
      end if;
      --更新执行标识位为执行中
      update mm_pub_plan_code a
         set a.exec_state = 1
       where a.plan_code = in_plan_code;
      commit;

      v_exec_start_time := sysdate;
      --获取推算队列
      USP_JIT_GET_PASS_QUEUE(in_plan_code);

      if cur_plancode.plan_code_type in ('JITI') then
        --展开零件净需求
        USP_JITI_CAL_NET_REQ(in_plan_code);
        --展开包装需求
        USP_JITI_CAL_PKG_REQ(in_plan_code);
        --组票
        USP_JITI_CREATE_ORDER(in_plan_code);
      --mod by wxl 20190611
      elsif cur_plancode.plan_code_type in ('JITD') then
        --展开零件净需求
        USP_JITD_CAL_NET_REQ(in_plan_code);
        --展开包装需求
        USP_JITD_CAL_LACK_REQ(in_plan_code);
      else
        --展开零件净需求
        USP_JITO_CAL_NET_REQ(in_plan_code);
        --展开包装需求
        USP_JITO_CAL_PKG_REQ(in_plan_code);
        --组供应商订单
        USP_JITO_CREATE_ORDER_SUP(in_plan_code);
      end if;
      --未组单的包装需求处理状态标识为2
      update mm_jit_pkg_req a
         set a.order_deal_flag = 2
       where a.plan_code = in_plan_code
         and a.order_deal_flag = 0
         and not exists (select 1
                from mm_jit_order_config t1
               where t1.plan_code = a.plan_code
                 and t1.ship_depot = a.ship_depot
                 and t1.arr_depot = a.arr_depot)
         and cur_plancode.plan_code_type = 'JITO';


      --更新执行标识位为未执行
      update mm_pub_plan_code a
         set a.exec_state = 0, a.last_exec_time = v_exec_start_time
       where a.plan_code = in_plan_code;

      --统计存储过程执行消耗时间
      insert into mm_pub_exec_time_log
        (exec_code, exec_desc, start_time, end_time)
      values
        ('USP_JIT_CAL_EXEC：'||in_plan_code, '执行拉动推算', v_exec_start_time, sysdate);
    end loop;

    COMMIT;
    EXCEPTION
      WHEN excep1 THEN
        ROLLBACK;
        err_num := 1;
        err_msg := '生产节拍未维护';
        insert into mm_pub_pro_error
        	(id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JIT_CAL_EXEC：'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
        	(id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JIT_CAL_EXEC：'||in_plan_code, err_num, err_msg, sysdate,'');

        --更新执行标识位为未执行
        update mm_pub_plan_code a
           set a.exec_state = 0
         where a.plan_code = in_plan_code;
        COMMIT;
  END USP_JIT_CAL_EXEC;
end PKG_JIT;
/

prompt
prompt Creating package body PKG_JIT_BASIC
prompt ===================================
prompt
create or replace package body PKG_JIT_BASIC is

  --****************************************************************************
  --过程名  : USP_JIT_INVEN_COMP
  --功能描述: 拉动库存对比计算
  --参数说明:
  --in_uuid 导入UUID
  --out_num_result 存储过程执行结果
  --out_err_msg 存储过程执行错误信息
  --创建人员: wxl
  --创建时间: 2019-02-25
  --****************************************************************************
 PROCEDURE USP_JIT_INVEN_COMP(in_uuid          in VARCHAR2,
                              out_num_result   out NUMBER,
                              out_err_msg      out VARCHAR2) is
    v_arr_pro_seqno    mm_jit_inven_comp.check_arr_pro_seqno%type; --盘点最新到货批次进度流水号
    v_cal_vin          mm_jit_inven_comp.check_cal_vin%type; --当前已推算最新车身号
    v_cal_kb_pro_seqno mm_jit_inven_comp.check_cal_kb_pro_seqno%type; --当前已推算看板批次产品流水号
    v_order_no         if_veh_pro_plan.order_no%type; --订单号
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    --更新零件信息
    for cur_part in (select a.part_no,
                            c.part_short_no,
                            b.part_name_cn
                       from mm_jit_inven_comp a
                       join mm_pub_part b
                         on a.part_no = b.part_no
                       left join mm_pub_part_uda c
                         on b.part_no = c.part_no
                      where a.imp_uuid = in_uuid
                        and a.check_result is null)
    loop
      update mm_jit_inven_comp t
         set t.check_part_short_no = cur_part.part_short_no,
             t.check_part_name = cur_part.part_name_cn
       where t.part_no =  cur_part.part_no;
    end loop;
    out_num_result := 1;
    out_err_msg := '';
    for cur_cal in(select distinct a.imp_uuid,
                          a.plan_code,
                          b.factory_code,
                          b.workcenter,
                          b.station_code,
                          c.is_plan,
                          c.max_pass_time,
                          a.vin,
                          to_number(a.arr_batch_no) arr_batch_no,
                          to_number(a.arr_process_no) arr_process_no
                      from mm_jit_inven_comp a
                      left join mm_pub_plan_code b
                        on a.plan_code = b.plan_code
                       and b.plan_code_type = 'JITO'
                      left join mm_jit_queue_config c
                        on b.plan_code = c.plan_code
                     where a.imp_uuid = in_uuid
                       and a.check_result is null)
    loop
      err_num := null;
      err_msg := null;
      --判断信息点合法性
      if cur_cal.factory_code is null then
        err_num := 0;
        err_msg := '信息点不存在；';
      end if;
      --获取盘点最新到货批次进度流水号
      v_arr_pro_seqno := PKG_PUB.USF_GET_PRODSEQNO_BY_BATCH(cur_cal.plan_code, cur_cal.arr_batch_no, cur_cal.arr_process_no);
      --判断批次合法性
      if err_num is null and v_arr_pro_seqno is null then
        err_num := 0;
        err_msg := '下一到货批次进度数据错误；';
      end if;
      --判断车辆合法性
      v_order_no := null;
      for cur_veh in (select a.order_no
                        from if_veh_lock_plan a
                       where a.factory_code = cur_cal.factory_code
                         and a.vin = cur_cal.vin
                         and a.order_status not in (0, 30)
                       order by a.weon_time desc)
      loop
        v_order_no := cur_veh.order_no;
        exit;
      end loop;
      if v_order_no is null then
        err_num := 0;
        err_msg := err_msg || '车辆不存在或未上线；';
      end if;
      if err_num = 0 then
        --更新错误信息
        update mm_jit_inven_comp t
           set t.check_result = err_num, t.check_info = err_msg
         where t.imp_uuid = cur_cal.imp_uuid
           and t.plan_code = cur_cal.plan_code
           and t.vin = cur_cal.vin
           and t.arr_batch_no = cur_cal.arr_batch_no
           and t.arr_process_no = cur_cal.arr_process_no;
        continue;
      end if;

      --获取信息点当前已推算最新车身号、当前已推算看板批次产品流水号
      select a.vin, a.kb_product_seqno
        into v_cal_vin, v_cal_kb_pro_seqno
        from mm_jit_veh_queue a
       where a.pass_time = cur_cal.max_pass_time
         and a.plan_code = cur_cal.plan_code;

      --装配需求:盘点车身号至当前信息点已推算最新车身号区间在制车辆
      for cur_veh_wip in (select distinct order_no, erp_order_no
                            from (--1、盘点车身号至当前最近上线车身号区间车辆信息；
                                  with temp1 as
                                   (select t.*, rank() over(partition by station_code order by pass_time) sn
                                      from (select a.order_no, a.erp_order_no, a.station_code, max(a.pass_time) pass_time
                                              from mm_pub_veh_pass a
                                              join if_veh_lock_plan b
                                                on a.factory_code = b.factory_code
                                               and a.order_no = b.order_no
                                               and b.order_status = 15 --已过合车点
                                              left join mm_pub_data_dict c
                                                on c.factory_code = a.factory_code
                                               and c.code_value = a.station_code
                                               and c.code_type = 'MON_KB_STATION'
                                             where a.factory_code = cur_cal.factory_code
                                               --为拉动计算生产阶段
                                               and a.phase in
                                                   (select t2.code_value
                                                      from mm_pub_sys_param t1, mm_pub_data_dict t2
                                                     where t1.factory_code = t2.factory_code
                                                       and t1.param_val = t2.code_value_name
                                                       and t2.code_type = 'PUB_PHASE'
                                                       and t1.param_group = 'JIT_CAL'
                                                       and t1.param_code like 'JIT_CAL_PHASE%'
                                                       and t1.factory_code = a.factory_code)
                                               --都已经过信息点进行零件计算
                                               and (cur_cal.is_plan = 1 or exists
                                                    (select 1
                                                       from mm_pub_veh_pass t3
                                                      where t3.factory_code = a.factory_code
                                                        and t3.order_no = a.order_no
                                                        and t3.station_code = cur_cal.station_code))
                                             group by a.order_no, a.erp_order_no, a.station_code)t)
                                  select distinct k1.order_no, k1.erp_order_no
                                    from temp1 k1, temp1 k2
                                   where k1.station_code = k2.station_code
                                     and k1.sn >= nvl(k2.sn, 0)
                                     and k2.order_no = v_order_no
                                  --2、盘点车身号至当前信息点已推算最新车身号区间未上线车辆信息
                                  union
                                  select a.order_no, a.erp_order_no
                                    from if_veh_lock_plan a
                                   where a.factory_code = cur_cal.factory_code
                                     and a.order_status in (0,10) --未过合车点
                                     and a.phase in (select t2.code_value
                                                       from mm_pub_sys_param t1, mm_pub_data_dict t2
                                                      where t1.factory_code = t2.factory_code
                                                        and t1.param_val = t2.code_value_name
                                                        and t2.code_type = 'PUB_PHASE'
                                                        and t1.param_group = 'JIT_CAL'
                                                        and t1.param_code like 'JIT_CAL_PHASE%'
                                                        and t1.factory_code = a.factory_code)
                                     and cur_cal.is_plan = 1))
      loop
        --从bom匹配零件净需求
        for cur_net_req in(select a.part_no, sum(a.num) assembly_qty
                             from mm_pub_order_bom a, mm_jit_inven_comp b
                            where a.part_no = b.part_no
                              and b.imp_uuid = cur_cal.imp_uuid
                              and b.plan_code = cur_cal.plan_code
                              and b.vin = cur_cal.vin
                              and b.arr_batch_no = cur_cal.arr_batch_no
                              and b.arr_process_no = cur_cal.arr_process_no
                              and a.factory_code = cur_cal.factory_code
                              and a.workcenter = cur_cal.workcenter
                              and a.order_no = cur_veh_wip.erp_order_no
                            group by a.part_no)
        loop
           --更新车辆的装配需求到库存对比表
           update mm_jit_inven_comp t
              set t.check_assembly_qty = t.check_assembly_qty +
                                         cur_net_req.assembly_qty
            where t.imp_uuid = cur_cal.imp_uuid
              and t.part_no = cur_net_req.part_no
              and t.plan_code = cur_cal.plan_code
              and t.vin = cur_cal.vin
              and t.arr_batch_no = cur_cal.arr_batch_no
              and t.arr_process_no = cur_cal.arr_process_no;
        end loop;
      end loop;

      --计划到货：下一到货批次进度到当前计算车辆
      for cur_rec_plan in(select sum(plan_qty) plan_qty, part_no
                            from (select a.part_no, sum(a.require_num) plan_qty
                                    from mm_jit_pkg_req a, mm_jit_inven_comp b
                                   where a.plan_code = b.plan_code
                                     and a.part_no = b.part_no
                                     and b.imp_uuid = cur_cal.imp_uuid
                                     and b.plan_code = cur_cal.plan_code
                                     and b.vin = cur_cal.vin
                                     and b.arr_batch_no = cur_cal.arr_batch_no
                                     and b.arr_process_no = cur_cal.arr_process_no
                                     and a.order_deal_flag = 0
                                   group by a.part_no
                                  union all
                                  select b.part_no, sum(b.require_num) plan_qty
                                    from mm_jit_order a, mm_jit_order_detail b, mm_jit_inven_comp c
                                   where a.order_no = b.order_no
                                     and a.arrive_product_seqno >= v_arr_pro_seqno
                                     and a.s_prepare_product_seqno >= v_arr_pro_seqno
                                     and a.plan_code = c.plan_code
                                     and b.part_no = c.part_no
                                     and c.imp_uuid = cur_cal.imp_uuid
                                     and c.plan_code = cur_cal.plan_code
                                     and c.vin = cur_cal.vin
                                     and c.arr_batch_no = cur_cal.arr_batch_no
                                     and c.arr_process_no = cur_cal.arr_process_no
                                   group by b.part_no)
                           group by part_no)
      loop
        --更新车辆的计划到货到库存对比表
        update mm_jit_inven_comp t
           set t.check_plan_qty = cur_rec_plan.plan_qty
         where t.imp_uuid = cur_cal.imp_uuid
           and t.part_no = cur_rec_plan.part_no
           and t.plan_code = cur_cal.plan_code
           and t.vin = cur_cal.vin
           and t.arr_batch_no = cur_cal.arr_batch_no
           and t.arr_process_no = cur_cal.arr_process_no;
      end loop;

      --计划零件余量
      for cur_remain_plan in(select b.part_no, sum(a.part_remain) part_remain
                               from mm_jit_part_remain a, mm_jit_inven_comp b
                              where a.plan_code = b.plan_code
                                and a.part_no = b.part_no
                                and b.imp_uuid = cur_cal.imp_uuid
                                and b.plan_code = cur_cal.plan_code
                                and b.vin = cur_cal.vin
                                and b.arr_batch_no = cur_cal.arr_batch_no
                                and b.arr_process_no = cur_cal.arr_process_no
                              group by b.part_no)
      loop
        --更新计划零件余量到库存对比表
        update mm_jit_inven_comp t
           set t.check_part_remain = cur_remain_plan.part_remain
         where t.imp_uuid = cur_cal.imp_uuid
           and t.part_no = cur_remain_plan.part_no
           and t.plan_code = cur_cal.plan_code;
      end loop;

      --更新及计算(差异量 = 当前余量-安全库存+计划到货量-装配需求-计划零件余量)
      update mm_jit_inven_comp t
         set t.check_arr_pro_seqno     = v_arr_pro_seqno,
             t.check_cal_vin           = v_cal_vin,
             t.check_cal_kb_pro_seqno  = v_cal_kb_pro_seqno,
             t.check_inventory_diffqty = t.curr_inventory -
                                         t.safety_inventory +
                                         t.check_plan_qty -
                                         t.check_assembly_qty -
                                         t.check_part_remain,
             t.check_result            = 1
       where t.imp_uuid = cur_cal.imp_uuid
         and t.plan_code = cur_cal.plan_code
         and t.vin = cur_cal.vin
         and t.arr_batch_no = cur_cal.arr_batch_no
         and t.arr_process_no = cur_cal.arr_process_no;
    end loop;

  COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      out_num_result := 0;
      out_err_msg    := '系统错误,请联系管理员！';
      err_num := SQLCODE;
      err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
      insert into MM_PUB_PRO_ERROR
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (seq_pub_pro_error.nextval, 'USP_JIT_INVEN_COMP', err_num, err_msg, sysdate, '拉动库存对比报表计算异常');
      commit;
  END USP_JIT_INVEN_COMP;
 
--****************************************************************************
  --过程名  : USP_JIT_PART_LACK_QUERY
  --功能描述: 拉动缺件处理查询
  --参数说明:
  --in_uuid 导入UUID
  --out_num_result 存储过程执行结果
  --out_err_msg 存储过程执行错误信息
  --创建人员: wxl
  --创建时间: 2019-04-12
  --****************************************************************************
 PROCEDURE USP_JIT_PART_LACK_QUERY(in_uuid          in VARCHAR2,
                                   in_factory_code  in VARCHAR2,
                                   out_num_result   out NUMBER,
                                   out_err_msg      out VARCHAR2) is
    v_exec_start_time  date; --存储过程执行开始时间点
    v_lack_num         number(10); --待处理欠品数
    v_distri_num       number(10); --调配数
    v_standard_package number(10); --规格包装数
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN   
    v_exec_start_time := sysdate; 
    --查找未处理的拉动缺件记录
    for cur_plancode in (select a.factory_code,
                                a.workcenter,
                                a.plan_code,
                                b.process_cycle_num,
                                ceil(b.product_seqno/b.process_cycle_num)*b.process_cycle_num kb_product_seqno
                           from mm_pub_plan_code a, mm_mon_kb b
                          where a.kb_id = b.id
                            and a.plan_code_type = 'JITD'
                            and a.factory_code = in_factory_code)
    loop
      --查找未处理的拉动缺件记录
      for cur_lack in (select b.plan_code,
                              b.part_no,
                              b.location,
                              b.part_remain,
                              c.part_name_cn,
                              d.part_short_no
                         from mm_jit_part_remain b
                         left join mm_pub_part c
                           on c.factory_code = cur_plancode.factory_code
                          and c.part_no = b.part_no
                         left join mm_pub_part_uda d
                           on d.factory_code = cur_plancode.factory_code
                          and d.part_no = b.part_no
                         where b.plan_code = cur_plancode.plan_code)
      loop
        v_lack_num := 0-cur_lack.part_remain;
        v_standard_package := 1;
        
        --待处理掏件信息
        if v_lack_num > 0 then
          for cur_bj in (select NVL(sum(a.distri_num),0) distri_num
                           from mm_jit_part_lack a
                          where a.deal_flag = 0
                            and a.part_no = cur_lack.plan_code
                            and a.part_no = cur_lack.part_no
                            and a.location = cur_lack.location)
          loop
            v_lack_num := v_lack_num-cur_bj.distri_num;
          end loop;
        end if;
        --掏零件指示
        if v_lack_num > 0 then
          for cur_sh in (select a.plan_code,
                                a.part_no,
                                a.location,
                                pkg_pub.USF_GET_BATCHSEQ_BY_PRODSEQNO(a.plan_code, a.distri_product_seqno) distri_batch_seqno,
                                sum(a.require_num) require_num,
                                min(a.standard_package) standard_package
                           from mm_jit_label a,
                                mm_pub_plan_code b,
                                mm_pda_label_scan_log c
                          where a.bar_uuid = c.bar_uuid
                            and c.type = 1 --已收货
                            and b.factory_code = cur_plancode.factory_code
                            and b.workcenter = cur_plancode.workcenter
                            and b.plan_code_type = 'JITO'
                            and a.plan_code = b.plan_code
                            and a.part_no = cur_lack.part_no
                            and a.location = cur_lack.location
                            and a.distri_product_seqno > cur_plancode.kb_product_seqno
                            and a.actual_distri_product_seqno is null
                          group by a.plan_code,
                                   a.part_no,
                                   a.location,
                                   pkg_pub.USF_GET_BATCHSEQ_BY_PRODSEQNO(a.plan_code, a.distri_product_seqno)
                          order by pkg_pub.USF_GET_BATCHSEQ_BY_PRODSEQNO(a.plan_code, a.distri_product_seqno))
          loop
            v_standard_package := cur_sh.standard_package;
            if cur_sh.require_num >= v_lack_num then
              v_distri_num := v_lack_num;
              v_lack_num   := 0;
            else
              v_distri_num := cur_sh.require_num;
              v_lack_num   := v_lack_num - v_distri_num;
            end if;
            
            --插入处理指导
            insert into mm_jit_part_lack_imp
              (id,
               plan_code,
               part_no,
               location,
               part_short_no,
               part_name,
               s_prepare_product_seqno,
               e_prepare_product_seqno,
               s_distri_product_seqno,
               e_distri_product_seqno,
               require_num,
               box_num,
               imp_uuid)
            values
              (SEQ_MM_PUB_IMPORT.NEXTVAL,
               cur_lack.plan_code,
               cur_lack.part_no,
               cur_lack.location,
               cur_lack.part_short_no,
               cur_lack.part_name_cn,
               cur_plancode.kb_product_seqno - cur_plancode.process_cycle_num + 1,
               cur_plancode.kb_product_seqno,
               cur_sh.distri_batch_seqno * cur_plancode.process_cycle_num - cur_plancode.process_cycle_num + 1,
               cur_sh.distri_batch_seqno * cur_plancode.process_cycle_num,
               v_distri_num,
               CEIL(v_distri_num/v_standard_package),
               in_uuid);
               
            --如果不缺件，退出
            if v_lack_num <= 0 then
              exit;
            end if;
          end loop;
        end if;
        --补充无法供给的缺件信息
        if v_lack_num > 0 then
          --插入处理指导
          insert into mm_jit_part_lack_imp
            (id,
             plan_code,
             part_no,
             location,
             part_short_no,
             part_name,
             s_prepare_product_seqno,
             e_prepare_product_seqno,
             s_distri_product_seqno,
             e_distri_product_seqno,
             require_num,
             box_num,
             imp_uuid)
          values
            (SEQ_MM_PUB_IMPORT.NEXTVAL,
             cur_lack.plan_code,
             cur_lack.part_no,
             cur_lack.location,
             cur_lack.part_short_no,
             cur_lack.part_name_cn,
             cur_plancode.kb_product_seqno - cur_plancode.process_cycle_num + 1,
             cur_plancode.kb_product_seqno,
             null,
             null,
             v_lack_num,
             CEIL(v_distri_num/v_standard_package),
             in_uuid);
        end if;
      end loop;
    end loop;
      
    --统计存储过程执行消耗时间
    insert into mm_pub_exec_time_log
      (exec_code, exec_desc, start_time, end_time)
    values
      ('USP_JIT_PART_LACK_QUERY', '拉动缺件处理查询', v_exec_start_time, sysdate);
      
  COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      out_num_result := 0;
      out_err_msg    := '系统错误,请联系管理员！';
      err_num := SQLCODE;
      err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_JIT_PART_LACK_QUERY：'||in_uuid, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_JIT_PART_LACK_QUERY;

end PKG_JIT_BASIC;
/

prompt
prompt Creating package body PKG_MON
prompt =============================
prompt
create or replace package body PKG_MON is

  --****************************************************************************
  --过程名  : USP_MON_KB_UPDATE
  --功能描述: 看板更新
  --参数说明:
  --创建人员: wxl
  --创建时间: 2018-11-21
  --修改记录：
  --          修复厂外同步看板异常 mod by wxl 20190507
  --****************************************************************************
  PROCEDURE USP_MON_KB_UPDATE IS
    v_exec_start_time  date; --存储过程执行开始时间点
    v_update_flag      number(1); --看板更新标识
    v_product_seqno    number(10); --看板产品流水号
    v_max_pass_time    date; --最近过点时间
    v_curr_batch_no    mm_mon_kb.curr_batch_no%type;
    v_curr_process_no  mm_mon_kb.curr_process_no%type;
    v_curr_batch_seqno mm_mon_kb.curr_batch_seqno%type;
    v_flag             number(1); --临时标识
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    v_exec_start_time := sysdate;

    --遍历更新看板
    for cur_kb in (select a.id,
                          a.factory_code,
                          a.workcenter,
                          a.station_code,
                          a.product_seqno,
                          a.max_pass_time,
                          a.is_edit
                     from mm_mon_kb a
                    order by a.id) loop
      v_update_flag   := 0;
      --mod by wxl 20190507
      --v_product_seqno := cur_kb.product_seqno;
      if cur_kb.product_seqno is null then
        v_product_seqno := 1;
      else
        v_product_seqno := cur_kb.product_seqno;
      end if;
      v_max_pass_time := cur_kb.max_pass_time;

      --1）看板工位过点更新看板
      for cur_veh in (select *
                        from mm_pub_veh_pass b
                       where b.factory_code = cur_kb.factory_code
                         and b.station_code = cur_kb.station_code
                         and b.pass_time > cur_kb.max_pass_time
                       order by b.pass_time)

       loop
        if cur_kb.is_edit = 0 then
          --拉动看板需判断是否进行拉动计算
          select count(1)
            into v_flag
            from mm_jit_veh_queue m
           where m.order_no = cur_veh.order_no
             and m.plan_code in
                 (select plan_code
                    from mm_pub_plan_code
                   where kb_id = cur_kb.id
                     and plan_code_type in ('JITO', 'JITI', 'JIT'))
             and rownum = 1;
          if v_flag = 1 then
            insert into mm_jit_real_kb_batch
              (plan_code, order_no, real_kb_time, real_kb_product_seqno)
              select a.plan_code,
                     cur_veh.order_no,
                     sysdate,
                     v_product_seqno
                from mm_pub_plan_code a
               where a.kb_id = cur_kb.id;

            v_update_flag   := 1;
            v_product_seqno := v_product_seqno + 1;
            v_max_pass_time := cur_veh.pass_time;
          end if;
        else
          v_update_flag   := 1;
          v_product_seqno := v_product_seqno + 1;
          v_max_pass_time := cur_veh.pass_time;
        end if;
        --如果看板存在安灯信息，达到出发条件时，写入看板出发记录
        if v_update_flag = 1 then
          for cur_kb_detail in (select id, run_process_no, limit_delay
                                  from mm_kb_ip_config a
                                 where a.kb_id = cur_kb.id
                                   and a.distri_person is not null
                                 order by run_process_no) loop
            if cur_kb_detail.run_process_no =
               PKG_PUB.USF_GET_PROCESSNO_BY_PRODSEQNO(cur_kb.id,
                                                      v_product_seqno) then
              insert into mm_mon_distribution_log
                (id, kb_detail_id, distri_product_seqno, limit_delay)
              values
                (SEQ_MM_MON_DISTRIBUTION_LOG.NEXTVAL,
                 cur_kb_detail.id,
                 v_product_seqno,
                 cur_kb_detail.limit_delay);
            end if;
          end loop;
        end if;
      end loop;
      --2）如果是拉动看板需要处理报废车辆
      /*
      if cur_kb.is_edit = 0 then
        for cur_scarp in(select *
                           from mm_jit_veh_scrap b
                          where b.factory_code = cur_kb.factory_code
                            and b.adjust_kb_state = 1)
        loop
          --拉动看板需判断是否进行拉动计算
          select count(1)
            into v_flag
            from mm_jit_veh_queue m
           where m.order_no = cur_scarp.order_no
             and m.plan_code in
                 (select plan_code
                    from mm_pub_plan_code
                   where kb_id = cur_kb.id
                     and plan_code_type in ('JITO', 'JITI', 'JIT'));
          if v_flag = 1 then
            if PKG_PUB.USF_GET_WORKCENTER_PRE(cur_scarp.scrap_workcenter) = 'W' then
              v_update_flag := 1;
              v_product_seqno := v_product_seqno + 1;
            end if;
            if PKG_PUB.USF_GET_WORKCENTER_PRE(cur_scarp.scrap_workcenter) in ('T','A')
               and PKG_PUB.USF_GET_WORKCENTER_PRE(cur_kb.workcenter) = 'A' then
              v_update_flag := 1;
              v_product_seqno := v_product_seqno + 1;
            end if;
          end if;
        end loop;
      end if;
      */
      --如果看板需更新
      if v_update_flag = 1 then
        v_curr_batch_no    := PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(cur_kb.id,
                                                                   v_product_seqno);
        v_curr_process_no  := PKG_PUB.USF_GET_PROCESSNO_BY_PRODSEQNO(cur_kb.id,
                                                                     v_product_seqno);
        v_curr_batch_seqno := PKG_PUB.USF_GET_BATCHSEQ_BY_PRODSEQNO(cur_kb.id,
                                                                    v_product_seqno);
        --更新看板
        update mm_mon_kb a
           set a.product_seqno    = v_product_seqno,
               a.curr_batch_no    = v_curr_batch_no,
               a.curr_process_no  = v_curr_process_no,
               a.curr_batch_seqno = v_curr_batch_seqno,
               a.max_pass_time    = v_max_pass_time
         where a.id = cur_kb.id;
      end if;
    end loop;

    --统计存储过程执行消耗时间
    insert into mm_pub_exec_time_log
      (exec_code, exec_desc, start_time, end_time)
    values
      ('USP_MON_KB_UPDATE', '执行看板更新', v_exec_start_time, sysdate);

    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_MON_KB_UPDATE',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_MON_KB_UPDATE;

  --****************************************************************************
  --过程名  : USP_MON_KB_QUERYKB_DETAIL
  --功能描述: 看板显示详情查询
  --参数说明:
  --IN_KB_IP:现场看板IP地址
  --IN_KB_CODE:看板代码
  --IN_DISTRI_PERSON:工程
  --IN_FACTORY_CODE:工厂
  --OUT_CURR_BACTH_NO:当前批次
  --OUT_PROCESS_CYCLE_NUM:进度循环基数
  --OUT_RUN_PROCESS_NO:当前进度
  --OUT_KB_STATUS:看板状态
  --OUT_RUN_DELAY_FLAG:看板延迟状态
  --OUT_CURR_BATCH_SEQNO:当前批次流水号
  --创建人员: zmj
  --创建时间: 2019-02-18
  --****************************************************************************

  PROCEDURE USP_MON_KB_QUERYKB_DETAIL(IN_KB_IP              IN VARCHAR2,
                                      IN_KB_CODE            IN VARCHAR2,
                                      IN_DISTRI_PERSON      IN VARCHAR2,
                                      IN_FACTORY_CODE       IN VARCHAR2,
                                      OUT_CURR_BACTH_NO     OUT VARCHAR2,
                                      OUT_PROCESS_CYCLE_NUM OUT VARCHAR2,
                                      OUT_RUN_PROCESS_NO    OUT VARCHAR2,
                                      OUT_KB_STATUS         OUT VARCHAR2,
                                      OUT_RUN_DELAY_FLAG    OUT VARCHAR2,
                                      OUT_CURR_BATCH_SEQNO  OUT VARCHAR2) AS
    --产品批次流水
    V_PRODUCT_SEQNO NUMBER(19);
    --允许延迟时间(分钟)
    V_LIMIT_DELAY NUMBER(5);
    --计数
    V_TEMP_COUNT NUMBER(19);
    --偏移量
    V_SHIFT_SCHEDULE NUMBER(19);

    V_OUT_CURR_BACTH_NO     VARCHAR2(19);
    V_OUT_PROCESS_CYCLE_NUM VARCHAR2(19);
    V_OUT_RUN_PROCESS_NO    VARCHAR2(19);
    V_OUT_KB_STATUS         VARCHAR2(1);
    V_OUT_RUN_DELAY_FLAG    VARCHAR2(1);
    V_OUT_CURR_BATCH_SEQNO  VARCHAR2(19);

    ERR_FLAG NUMBER(19);
    ERR_MSG  VARCHAR2(500);

  BEGIN

    --如果IP不为空,贼为现场看板,根据绑定IP地址查询看板数据
    IF IN_KB_IP IS NOT NULL THEN

      --获取偏移进度
      SELECT NVL(MKI.SHIT_SCHEDULE, 0)
        INTO V_SHIFT_SCHEDULE
        FROM MM_KB_IP_CONFIG MKI
       WHERE MKI.KB_IP = IN_KB_IP;

      --统计未配送数量
      SELECT COUNT(1)
        INTO V_TEMP_COUNT
        FROM MM_MON_DISTRIBUTION_LOG MMDL
        LEFT JOIN MM_KB_IP_CONFIG MKI
          ON MKI.ID = MMDL.KB_DETAIL_ID
        LEFT JOIN MM_MON_KB MMK
          ON MMK.ID = MKI.KB_ID
       WHERE MMDL.STATUS = 0
         AND MKI.KB_IP = IN_KB_IP;

      --有未配送显示最小批次流水未配送
      IF V_TEMP_COUNT > 0 THEN
        SELECT DISTRI_PRODUCT_SEQNO, LIMIT_DELAY
          INTO V_PRODUCT_SEQNO, V_LIMIT_DELAY
          FROM (SELECT MMDL.DISTRI_PRODUCT_SEQNO, MMDL.LIMIT_DELAY
                  FROM MM_MON_DISTRIBUTION_LOG MMDL
                  LEFT JOIN MM_KB_IP_CONFIG MKI
                    ON MKI.ID = MMDL.KB_DETAIL_ID
                  LEFT JOIN MM_MON_KB MMK
                    ON MMK.ID = MKI.KB_ID
                 WHERE MKI.KB_IP = IN_KB_IP
                   AND MMDL.STATUS = 0
                 ORDER BY MMDL.DISTRI_PRODUCT_SEQNO)
         WHERE rownum <= 1;

        --数据显示查询(未配送)
        SELECT RUNPROCESSNO,
               PROCESSCYCLENUM,
               CURRBATCHNO,
               KBSTATUS,
               DELAYSTATUS
          INTO V_OUT_RUN_PROCESS_NO,
               V_OUT_PROCESS_CYCLE_NUM,
               V_OUT_CURR_BACTH_NO,
               V_OUT_KB_STATUS,
               V_OUT_RUN_DELAY_FLAG
          FROM (SELECT MMK.CURR_PROCESS_NO RUNPROCESSNO,
                       MMK.PROCESS_CYCLE_NUM PROCESSCYCLENUM,
                       MMK.CURR_BATCH_NO CURRBATCHNO,
                       CASE
                         WHEN MMDL.STATUS = 0 OR MMDL.STATUS = 1 THEN
                          1
                         ELSE
                          MMDL.STATUS
                       END AS KBSTATUS,
                       CASE
                         WHEN MMDL.CREATION_TIME + MMDL.LIMIT_DELAY / 24 / 60 <
                              SYSDATE AND MMDL.STATUS != 2 THEN
                          1
                         ELSE
                          0
                       END AS DELAYSTATUS
                  FROM MM_MON_DISTRIBUTION_LOG MMDL
                  LEFT JOIN MM_KB_IP_CONFIG MKI
                    ON MKI.ID = MMDL.KB_DETAIL_ID
                  LEFT JOIN MM_MON_KB MMK
                    ON MMK.ID = MKI.KB_ID
                 WHERE MKI.KB_IP = IN_KB_IP
                   AND MMDL.STATUS = 0
                 ORDER BY MMDL.DISTRI_PRODUCT_SEQNO)
         WHERE ROWNUM <= 1;
      ELSE
        --数据显示查询(全部配送)
        SELECT RUNPROCESSNO,
               PROCESSCYCLENUM,
               CURRBATCHNO,
               KBSTATUS,
               DELAYSTATUS
          INTO V_OUT_RUN_PROCESS_NO,
               V_OUT_PROCESS_CYCLE_NUM,
               V_OUT_CURR_BACTH_NO,
               V_OUT_KB_STATUS,
               V_OUT_RUN_DELAY_FLAG
          FROM (SELECT MMK.CURR_PROCESS_NO RUNPROCESSNO,
                       MMK.PROCESS_CYCLE_NUM PROCESSCYCLENUM,
                       MMK.CURR_BATCH_NO CURRBATCHNO,
                       CASE
                         WHEN MMDL.STATUS = 0 OR MMDL.STATUS = 1 THEN
                          1
                         ELSE
                          MMDL.STATUS
                       END AS KBSTATUS,
                       CASE
                         WHEN MMDL.CREATION_TIME + MMDL.LIMIT_DELAY / 24 / 60 <
                              SYSDATE AND MMDL.STATUS != 2 THEN
                          1
                         ELSE
                          0
                       END AS DELAYSTATUS
                  FROM MM_MON_DISTRIBUTION_LOG MMDL
                  LEFT JOIN MM_KB_IP_CONFIG MKI
                    ON MKI.ID = MMDL.KB_DETAIL_ID
                  LEFT JOIN MM_MON_KB MMK
                    ON MMK.ID = MKI.KB_ID
                 WHERE MKI.KB_IP = IN_KB_IP
                   AND MMDL.STATUS = 2
                 ORDER BY MMDL.DISTRI_PRODUCT_SEQNO DESC)
         WHERE ROWNUM <= 1;
      END IF;

      --IP为空则为系统用户选择查看
    ELSE

      SELECT COUNT(1)
        INTO V_TEMP_COUNT
        FROM MM_MON_DISTRIBUTION_LOG MMDL
        LEFT JOIN MM_KB_IP_CONFIG MKI
          ON MKI.ID = MMDL.KB_DETAIL_ID
        LEFT JOIN MM_MON_KB MMK
          ON MMK.ID = MKI.KB_ID
       WHERE MMDL.STATUS = 0
         AND MMK.KB_CODE = IN_KB_CODE
         AND MMK.FACTORY_CODE = IN_FACTORY_CODE
         AND MKI.DISTRI_PERSON = IN_DISTRI_PERSON;

      SELECT NVL(MIN(MKI.SHIT_SCHEDULE), 0)
        INTO V_SHIFT_SCHEDULE
        FROM MM_KB_IP_CONFIG MKI
        LEFT JOIN MM_MON_KB MMK
          ON MMK.ID = MKI.KB_ID
       WHERE MMK.KB_CODE = IN_KB_CODE
         AND MMK.FACTORY_CODE = IN_FACTORY_CODE
         AND MKI.DISTRI_PERSON = IN_DISTRI_PERSON;

      IF 0 < V_TEMP_COUNT THEN

        SELECT RUNPROCESSNO,
               PROCESSCYCLENUM,
               CURRBATCHNO,
               KBSTATUS,
               DELAYSTATUS
          INTO V_OUT_RUN_PROCESS_NO,
               V_OUT_PROCESS_CYCLE_NUM,
               V_OUT_CURR_BACTH_NO,
               V_OUT_KB_STATUS,
               V_OUT_RUN_DELAY_FLAG
          FROM (SELECT MMK.CURR_PROCESS_NO RUNPROCESSNO,
                       MMK.PROCESS_CYCLE_NUM PROCESSCYCLENUM,
                       MMK.CURR_BATCH_NO CURRBATCHNO,
                       CASE
                         WHEN MMDL.STATUS = 0 OR MMDL.STATUS = 1 THEN
                          1
                         ELSE
                          MMDL.STATUS
                       END AS KBSTATUS,
                       CASE
                         WHEN MMDL.CREATION_TIME + MMDL.LIMIT_DELAY / 24 / 60 <
                              SYSDATE AND MMDL.STATUS != 2 THEN
                          1
                         ELSE
                          0
                       END AS DELAYSTATUS
                  FROM MM_MON_DISTRIBUTION_LOG MMDL
                  LEFT JOIN MM_KB_IP_CONFIG MKI
                    ON MKI.ID = MMDL.KB_DETAIL_ID
                  LEFT JOIN MM_MON_KB MMK
                    ON MMK.ID = MKI.KB_ID
                 WHERE MMK.KB_CODE = IN_KB_CODE
                   AND MKI.DISTRI_PERSON = IN_DISTRI_PERSON
                   AND MMDL.STATUS = 0
                 ORDER BY MMDL.DISTRI_PRODUCT_SEQNO)
         WHERE ROWNUM <= 1;

      END IF;

      IF 0 = V_TEMP_COUNT THEN
        SELECT RUNPROCESSNO,
               PROCESSCYCLENUM,
               CURRBATCHNO,
               KBSTATUS,
               DELAYSTATUS
          INTO V_OUT_RUN_PROCESS_NO,
               V_OUT_PROCESS_CYCLE_NUM,
               V_OUT_CURR_BACTH_NO,
               V_OUT_KB_STATUS,
               V_OUT_RUN_DELAY_FLAG
          FROM (SELECT MMK.CURR_PROCESS_NO RUNPROCESSNO,
                       MMK.PROCESS_CYCLE_NUM PROCESSCYCLENUM,
                       MMK.CURR_BATCH_NO CURRBATCHNO,
                       CASE
                         WHEN MMDL.STATUS = 0 OR MMDL.STATUS = 1 THEN
                          1
                         ELSE
                          MMDL.STATUS
                       END AS KBSTATUS,
                       CASE
                         WHEN MMDL.CREATION_TIME + MMDL.LIMIT_DELAY / 24 / 60 <
                              SYSDATE AND MMDL.STATUS != 2 THEN
                          1
                         ELSE
                          0
                       END AS DELAYSTATUS
                  FROM MM_MON_DISTRIBUTION_LOG MMDL
                  LEFT JOIN MM_KB_IP_CONFIG MKI
                    ON MKI.ID = MMDL.KB_DETAIL_ID
                  LEFT JOIN MM_MON_KB MMK
                    ON MMK.ID = MKI.KB_ID
                 WHERE MMK.KB_CODE = IN_KB_CODE
                   AND MKI.DISTRI_PERSON = IN_DISTRI_PERSON
                   AND MMDL.STATUS = 2
                 ORDER BY MMDL.DISTRI_PRODUCT_SEQNO DESC)
         WHERE ROWNUM <= 1;
      END IF;
    END IF;

    OUT_CURR_BACTH_NO     := V_OUT_CURR_BACTH_NO;
    OUT_RUN_PROCESS_NO    := V_OUT_RUN_PROCESS_NO;
    OUT_KB_STATUS         := V_OUT_KB_STATUS;
    OUT_PROCESS_CYCLE_NUM := V_OUT_PROCESS_CYCLE_NUM;
    OUT_RUN_DELAY_FLAG    := V_OUT_RUN_DELAY_FLAG;
    OUT_CURR_BATCH_SEQNO  := V_OUT_CURR_BATCH_SEQNO;

    /*  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      ERR_FLAG := sqlcode;
      ERR_MSG  := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                         1,
                         200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MON.USP_MON_KB_QUERYKB_DETAIL',
         ERR_FLAG,
         ERR_MSG,
         SYSDATE,
         '');*/
    COMMIT;

  END USP_MON_KB_QUERYKB_DETAIL;
end PKG_MON;
/

prompt
prompt Creating package body PKG_MP_CHECK
prompt ==================================
prompt
create or replace package body PKG_MP_CHECK is

  --***************************************************************************
  --存储过程名：USP_MP_RESIDUAL_CHECK
  --功能描述：推算监控开启
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: linzhuo
  --创建时间： 2018/09/10

  PROCEDURE USP_MP_RESIDUAL_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                  IN_VAR_USERNAME   IN VARCHAR2,
                                  IN_VAR_OPEIP      IN VARCHAR2,
                                  OUT_ERROR_FLAG    OUT VARCHAR2,
                                  OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

    V_TEMP_NUM   number;
    V_CHECK_INFO varchar2(300);
  BEGIN

    UPDATE MM_MP_RESIDUAL_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '数据不存在;'
     WHERE NOT EXISTS (SELECT 1
              FROM MM_MP_PART B
             WHERE A.PART_NO = B.PART_NO
               AND A.SUPPLIER_NO = B.SUPPLIER_NO
               AND A.SUP_FACTORY = B.SUP_FACTORY
               AND A.FACTORY_CODE = B.FACTORY_CODE
               AND A.UNLOAD_PORT = B.UNLOAD_PORT)
       AND A.IMP_UUID = IN_VAR_UUID;

    --校验计算队列是否存在
    UPDATE MM_MP_RESIDUAL_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '计算队列不存在;'
     WHERE NOT EXISTS
     (SELECT 1 FROM MM_MP_PART B WHERE A.UNLOAD_PORT = B.UNLOAD_PORT)
       AND A.IMP_UUID = IN_VAR_UUID;

    --校验该零件是否失效
    UPDATE MM_MP_RESIDUAL_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '零件已失效;'
     WHERE EXISTS (SELECT 1
              FROM MM_MP_PART B
             WHERE A.PART_NO = B.PART_NO
               AND A.SUPPLIER_NO = B.SUPPLIER_NO
               AND A.SUP_FACTORY = B.SUP_FACTORY
               AND A.FACTORY_CODE = B.FACTORY_CODE
               AND A.UNLOAD_PORT = B.UNLOAD_PORT
                  --未生效或者已失效的数据
               AND (B.EFF_START > SYSDATE OR B.EFF_END < SYSDATE))
       AND A.IMP_UUID = IN_VAR_UUID;

    --EXCEL是否重复
    update MM_MP_RESIDUAL_IMP siglt
       set siglt.check_result = '0',
           siglt.check_info  =
           (nvl(siglt.check_info, '') || 'Excel数据重复;')
     where siglt.Pk_Id in
           (select distinct T.PK_ID
              from MM_MP_RESIDUAL_IMP t,
                   (select factory_Code,
                           part_No,
                           supplier_No,
                           sup_Factory,
                           unload_Port
                      from (select count(*) count,
                                   siglt.factory_Code,
                                   siglt.part_No,
                                   siglt.supplier_No,
                                   siglt.sup_Factory,
                                   siglt.unload_Port
                              from MM_MP_RESIDUAL_IMP siglt
                             where siglt.imp_uuid = in_var_uuid
                               and siglt.import_status = '0'
                             group by siglt.factory_Code,
                                      siglt.part_No,
                                      siglt.supplier_No,
                                      siglt.sup_Factory,
                                      siglt.unload_Port)
                     where count > 1) b
             where t.factory_Code = b.factory_Code
               and t.part_No = b.part_No
               and t.supplier_No = b.supplier_No
               and t.sup_Factory = b.sup_Factory
               and t.unload_Port = b.unload_Port);

    --主表中是否已存在该条记录
    MERGE INTO MM_MP_RESIDUAL_IMP A
    USING (SELECT B.PK_ID, C.ID
             FROM MM_MP_RESIDUAL C, MM_MP_RESIDUAL_IMP B
            WHERE B.CHECK_RESULT = 1
              AND B.IMP_UUID = in_var_uuid
              AND B.PART_NO = C.PART_NO
              AND B.SUPPLIER_NO = C.SUPPLIER_NO
              AND B.FACTORY_CODE = C.FACTORY_CODE
              AND B.SUP_FACTORY = C.SUP_FACTORY
              AND B.UNLOAD_PORT = C.UNLOAD_PORT
              AND B.CHECK_RESULT = 1) D
    ON (A.PK_ID = D.PK_ID AND A.IMP_UUID = in_var_uuid)
    WHEN MATCHED THEN
      UPDATE
         SET A.BUSI_ID    = D.ID,
             A.OPE_TYPE   = 'U',
             A.CHECK_INFO = A.CHECK_INFO || ';' || '数据已存在';

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_IMP_DEMO.USP_DEMO_TEST',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_MP_RESIDUAL_CHECK;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_ORDER_RECORD_CHECK
  --功能描述：订单履历导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: linzhuo
  --创建时间： 2018/09/10

  PROCEDURE USP_MP_ORDER_RECORD_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                      IN_VAR_USERNAME   IN VARCHAR2,
                                      IN_VAR_OPEIP      IN VARCHAR2,
                                      OUT_ERROR_FLAG    OUT VARCHAR2,
                                      OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

    V_TEMP_NUM   number;
    V_CHECK_INFO varchar2(300);
  BEGIN

    /*UPDATE MM_MP_ORDER_RECORD_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '数据不存在;'
     WHERE NOT EXISTS (SELECT 1
              FROM MM_MP_PART B
             WHERE A.PART_NO = B.PART_NO
               AND A.SUPPLIER_NO = B.SUPPLIER_NO
               AND A.SUP_FACTORY = B.SUP_FACTORY
               AND A.FACTORY_CODE = B.FACTORY_CODE
               AND A.UNLOAD_PORT = B.UNLOAD_PORT)
       AND A.IMP_UUID = IN_VAR_UUID;

    --校验计算队列是否存在
    UPDATE MM_MP_ORDER_RECORD_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '计算队列不存在;'
     WHERE NOT EXISTS
     (SELECT 1 FROM MM_MP_PART B WHERE A.UNLOAD_PORT = B.UNLOAD_PORT)
       AND A.IMP_UUID = IN_VAR_UUID;

    --校验该零件是否失效
    UPDATE MM_MP_ORDER_RECORD_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '零件已失效;'
     WHERE EXISTS (SELECT 1
              FROM MM_MP_PART B
             WHERE A.PART_NO = B.PART_NO
               AND A.SUPPLIER_NO = B.SUPPLIER_NO
               AND A.SUP_FACTORY = B.SUP_FACTORY
               AND A.FACTORY_CODE = B.FACTORY_CODE
               AND A.UNLOAD_PORT = B.UNLOAD_PORT
                  --未生效或者已失效的数据
               AND (B.EFF_START > SYSDATE OR B.EFF_END < SYSDATE))
       AND A.IMP_UUID = IN_VAR_UUID;*/

    --EXCEL是否重复
    update MM_MP_ORDER_RECORD_IMP siglt
       set siglt.check_result = '0',
           siglt.check_info  =
           (nvl(siglt.check_info, '') || 'Excel数据重复;')
     where siglt.PLAN_ORDER_ID in
           (select distinct T.PLAN_ORDER_ID
              from MM_MP_ORDER_RECORD_IMP t,
                   (select factory_Code,
                           part_No,
                           supplier_No,
                           sup_Factory,
                           unload_Port,
                           logistics_Order,
                           group_Id,
                           order_No
                      from (select count(*) count,
                                   siglt.factory_Code,
                                   siglt.part_No,
                                   siglt.supplier_No,
                                   siglt.sup_Factory,
                                   siglt.unload_Port,
                                   siglt.logistics_Order,
                                   siglt.group_Id,
                                   siglt.order_No
                              from MM_MP_ORDER_RECORD_IMP siglt
                             where siglt.imp_uuid = in_var_uuid
                               and siglt.import_status = '0'
                             group by siglt.factory_Code,
                                      siglt.part_No,
                                      siglt.supplier_No,
                                      siglt.sup_Factory,
                                      siglt.unload_Port,
                                      siglt.logistics_Order,
                                      siglt.group_Id,
                                      siglt.order_No)
                     where count > 1) b
             where t.factory_Code = b.factory_Code
               and t.part_No = b.part_No
               and t.supplier_No = b.supplier_No
               and t.sup_Factory = b.sup_Factory
               and t.unload_Port = b.unload_Port
               and t.logistics_Order = b.logistics_Order
               and t.group_Id = b.group_Id
               and t.order_No = b.order_No)
       and siglt.imp_uuid = in_var_uuid
       and siglt.import_status = 0;

    --校验在订单履历MM_MP_ORDER_RECORD是否存在
    UPDATE MM_MP_ORDER_RECORD_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '数据不存在;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND NOT EXISTS (SELECT 1
              FROM MM_MP_ORDER_RECORD B
             WHERE A.FACTORY_CODE = B.FACTORY_CODE
               AND A.SUPPLIER_NO = B.SUPPLIER_NO
               AND A.SUP_FACTORY = B.SUP_FACTORY
               AND A.UNLOAD_PORT = B.UNLOAD_PORT
               AND A.PART_NO = B.PART_NO
               AND A.LOGISTICS_ORDER = B.LOGISTICS_ORDER
               AND A.GROUP_ID = B.GROUP_ID);

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_MP_ORDER_RECORD_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END USP_MP_ORDER_RECORD_CHECK;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_TRIAL_PLAN_CHECK
  --功能描述：推算监控开启
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: linzhuo
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_TRIAL_PLAN_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                    IN_VAR_USERNAME   IN VARCHAR2,
                                    IN_VAR_OPEIP      IN VARCHAR2,
                                    OUT_ERROR_FLAG    OUT VARCHAR2,
                                    OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

    V_TEMP_NUM   number;
    V_CHECK_INFO varchar2(300);
  BEGIN

    UPDATE MM_MP_TRIAL_PLAN_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '订单号不存在;'
     WHERE NOT EXISTS (SELECT 1
              FROM MM_PUB_ORDER_BOM B
             WHERE A.ORDER_NO = B.ORDER_NO
               AND A.FACTORY_CODE = B.FACTORY_CODE)
       AND A.IMP_UUID = IN_VAR_UUID;

    UPDATE MM_MP_TRIAL_PLAN_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '只能导入试制车计划;'
     WHERE A.PRO_PHASE NOT IN ('6', '2', '3', '4')
       AND A.IMP_UUID = IN_VAR_UUID;

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_IMP_DEMO.USP_DEMO_TEST',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_MP_TRIAL_PLAN_CHECK;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_TRIAL_DEMAND_CHECK
  --功能描述：新车型需求计算导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: wangyu
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_TRIAL_DEMAND_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                      IN_VAR_USERNAME   IN VARCHAR2,
                                      IN_VAR_OPEIP      IN VARCHAR2,
                                      OUT_ERROR_FLAG    OUT VARCHAR2,
                                      OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
  BEGIN
    /*UPDATE MM_MP_TRIAL_DEMAND_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '零件号不存在;'
     WHERE NOT EXISTS
     (SELECT 1 FROM MM_PUB_PART B WHERE A.PART_NO = B.PART_NO)
       AND A.IMP_UUID = IN_VAR_UUID;

    UPDATE MM_MP_TRIAL_DEMAND_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '供应商代码不存在;'
     WHERE NOT EXISTS (SELECT 1
              FROM MM_PUB_SUPPLIER B
             WHERE A.SUPPLIER_NO = B.SUPPLIER_NO)
       AND A.IMP_UUID = IN_VAR_UUID;

    UPDATE MM_MP_TRIAL_DEMAND_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '零件供应商关系不存在;'
     WHERE NOT EXISTS (SELECT 1
              FROM MM_PUB_PART_SUPPLIER B
             WHERE A.PART_NO = B.PART_NO
               AND A.SUPPLIER_NO = B.SUPPLIER_NO
               AND A.SUP_FACTORY = B.SUP_FACTORY)
       AND A.IMP_UUID = IN_VAR_UUID;

    UPDATE MM_MP_TRIAL_DEMAND_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '例外需求数量小于0;'
     WHERE NOT EXISTS
     (SELECT 1 FROM MM_MP_TRIAL_DEMAND_IMP B WHERE B.EXC_ORDER_NUM < 0)
       AND A.IMP_UUID = IN_VAR_UUID;*/

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_MP_EXC_ORDER_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_MP_TRIAL_DEMAND_CHECK;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_EXC_ORDER_CHECK
  --功能描述：例外订单导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: wangyu
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_EXC_ORDER_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                   IN_VAR_USERNAME   IN VARCHAR2,
                                   IN_VAR_OPEIP      IN VARCHAR2,
                                   OUT_ERROR_FLAG    OUT VARCHAR2,
                                   OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
  BEGIN

    --需求人不能为空
    UPDATE MM_MP_EXCEP_ORDER_DEMAND_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '需求人不能为空;'
     WHERE A.DEMANDER IS NULL
       AND A.IMP_UUID = IN_VAR_UUID;

    --到货仓库不存在
    UPDATE MM_MP_EXCEP_ORDER_DEMAND_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '到货仓库不存在;'
     WHERE NOT EXISTS
     (SELECT 1 FROM MM_INV_WAREHOUSE B WHERE A.STORAGE = B.WARE_CODE)
       AND A.IMP_UUID = IN_VAR_UUID;
    --零件号不存在
    UPDATE MM_MP_EXCEP_ORDER_DEMAND_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '零件号不存在;'
     WHERE NOT EXISTS (SELECT 1
              FROM (SELECT B.PART_NO FROM MM_PUB_PART B) E
             WHERE E.PART_NO = A.PART_NO)
       AND A.IMP_UUID = IN_VAR_UUID;

    UPDATE MM_MP_EXCEP_ORDER_DEMAND_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '供应商代码不存在;'
     WHERE NOT EXISTS (SELECT 1
              FROM MM_PUB_SUPPLIER B
             WHERE A.SUPPLIER_NO = B.SUPPLIER_NO)
       AND A.IMP_UUID = IN_VAR_UUID;

    /*UPDATE MM_MP_EXCEP_ORDER_DEMAND_IMP A
      SET A.CHECK_RESULT = '0',
          A.CHECK_INFO   = A.CHECK_INFO || '零件供应商关系不存在;'
    WHERE NOT EXISTS (SELECT 1
             FROM MM_PUB_PART_SUPPLIER B
            WHERE A.PART_NO = B.PART_NO
              AND A.SUPPLIER_NO = B.SUPPLIER_NO)
      AND A.IMP_UUID = IN_VAR_UUID;*/

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_MP_EXC_ORDER_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_MP_EXC_ORDER_CHECK;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_ADJ_ORDER_CHECK
  --功能描述：例外订单导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: wangyu
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_ADJ_ORDER_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                   IN_VAR_USERNAME   IN VARCHAR2,
                                   IN_VAR_OPEIP      IN VARCHAR2,
                                   OUT_ERROR_FLAG    OUT VARCHAR2,
                                   OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
  BEGIN

    --校验供应商数据为空
    UPDATE MM_MP_PLAN_DIFF_TEMP_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '供应商代码不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.SUPPLIER_NO IS NULL;

    --校验零件数据为空
    UPDATE MM_MP_PLAN_DIFF_TEMP_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '零件不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.PART_NO IS NULL;

    --校验出货地数据为空
    UPDATE MM_MP_PLAN_DIFF_TEMP_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '出货地不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.SUP_FACTORY IS NULL;

    --计算队列不能为空
    UPDATE MM_MP_PLAN_DIFF_TEMP_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '计算队列不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.UNLOAD_PORT IS NULL;

    --校验是否存在
    UPDATE MM_MP_PLAN_DIFF_TEMP_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '数据不存在;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND NOT EXISTS (SELECT 1
              FROM MM_MP_PLAN_DIFF_TEMP B
             WHERE A.SUPPLIER_NO = B.SUPPLIER_NO
               AND A.SUP_FACTORY = B.SUP_FACTORY
               AND A.UNLOAD_PORT = B.UNLOAD_PORT
               AND A.PART_NO = B.PART_NO
               AND A.FACTORY_CODE = B.FACTORY_CODE);

    --EXCEL重复
    UPDATE MM_MP_PLAN_DIFF_TEMP_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || 'EXCEL重复;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND EXISTS (SELECT 1
              FROM (SELECT B.SUPPLIER_NO,
                           B.SUP_FACTORY,
                           B.UNLOAD_PORT,
                           B.PART_NO,
                           B.FACTORY_CODE
                      FROM MM_MP_PLAN_DIFF_TEMP_IMP B
                     WHERE B.IMP_UUID = IN_VAR_UUID
                       AND B.IMPORT_STATUS = 0
                     GROUP BY B.SUPPLIER_NO,
                              B.SUP_FACTORY,
                              B.UNLOAD_PORT,
                              B.PART_NO,
                              B.FACTORY_CODE
                    HAVING COUNT(1) > 1) C
             WHERE A.SUPPLIER_NO = C.SUPPLIER_NO
               AND A.SUP_FACTORY = C.SUP_FACTORY
               AND A.UNLOAD_PORT = C.UNLOAD_PORT
               AND A.PART_NO = C.PART_NO
               AND A.FACTORY_CODE = C.FACTORY_CODE);

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_MP_ADJ_ORDER_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_MP_ADJ_ORDER_CHECK;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_DEMANDFORCAST_CHECK
  --功能描述：月预测数据导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: wangyu
  --创建时间： 2019/4/20
  PROCEDURE USP_MP_DEMANDFORCAST_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                       IN_VAR_USERNAME   IN VARCHAR2,
                                       IN_VAR_OPEIP      IN VARCHAR2,
                                       OUT_ERROR_FLAG    OUT VARCHAR2,
                                       OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

    V_TEMP_NUM   number;
    V_CHECK_INFO varchar2(300);
  BEGIN

    --零件号不能为空
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '零件号不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.PART_NO IS NULL;

    --支给件需求数量不能为null或者<=0
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '需求数量需要为正整数;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND (A.ORDER_QTY IS NULL OR A.ORDER_QTY <= 0);

    --一级件号不能为空
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '一级件不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.PARTF_ID IS NULL;

    --一级件需求数量不能为null或者0
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '一级件需求数量需要为正整数;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND (A.PARTF_ORDER_QTY IS NULL OR A.PARTF_ORDER_QTY <= 0);

    --到货日期不能为空
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '到货日期不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.PLAN_DELIVERY IS NULL;

    --发布月份不能为空
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '发布月份不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.FORE_TYPE = 1
       AND A.PUBLISH_MONTH IS NULL;

    --对象月份不能为空
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '对象周次不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.FORE_TYPE = 1
       AND A.OBJ_MONTH IS NULL;

    --发布周不能为空
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '发布周不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.FORE_TYPE = 2
       AND A.PUBLISH_WEEK IS NULL;

    --对象周不能为空
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '对象周不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.FORE_TYPE = 2
       AND A.OBJ_WEEK IS NULL;

    --开始时间不能为空
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '开始时间不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.START_DATE IS NULL;

    --结束时间不能为空
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '结束时间不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.END_DATE IS NULL;

    --车型不能为空
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '车型不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.MODEL_CODE IS NULL;

    --版本号不能为空
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '版本号不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.VERSION IS NULL;

    --更新物流模式
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '物流模式不正确;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODE IS NOT NULL
       AND NOT EXISTS (SELECT 1
              FROM MM_PUB_DATA_DICT B
             WHERE B.CODE_TYPE = 'PUB_MM_MODEL'
               AND A.LOGISTICS_MODE = B.CODE_VALUE_NAME
               AND A.FACTORY_CODE = B.FACTORY_CODE);

    --更新生产阶段
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.PHASE =
           (SELECT B.CODE_VALUE
              FROM MM_PUB_DATA_DICT B
             WHERE A.PHASE = B.CODE_VALUE_NAME
               AND A.FACTORY_CODE = B.FACTORY_CODE
               AND B.CODE_TYPE = 'SW_PHASE')
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0;

    --生产阶段不能为空
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '生产阶段不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.PHASE IS NULL;

    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '版本号不存在'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND NOT EXISTS (SELECT 1
              FROM MM_SW_DEMAND_FORECAST_SUPPORT B
             WHERE A.VERSION = B.VERSION
               AND A.FORE_TYPE = B.FORE_TYPE
               AND A.FACTORY_CODE = B.FACTORY_CODE);

    --供应商
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '供应商不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.SUPPLIER_NO IS NULL;

    /*    --判断是否为支给件
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '该零件不是支给件;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.PART_NO IS NOT NULL
       AND NOT EXISTS (SELECT 1
              FROM MM_PUB_SUPPORTING_PART B
             WHERE A.PART_NO = B.PART_NO
               AND A.FACTORY_CODE = B.FACTORY_CODE);

    --判断父件是否是总成件
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '该零件不是一级件;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.PARTF_ID IS NOT NULL
       AND NOT EXISTS (SELECT 1
              FROM MM_PUB_SUPPORTING_PART B
             WHERE A.PARTF_ID = B.PARTF_ID
               AND A.FACTORY_CODE = B.FACTORY_CODE);*/

    --判断该一级件和二级件的对应关系是否存在
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '该一级件和二级件的对应关系不存在'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.PART_NO IS NOT NULL
       AND A.PARTF_ID IS NOT NULL
       AND NOT EXISTS (SELECT 1
              FROM MM_PUB_SUPPORTING_PART B
             WHERE A.PART_NO = B.PART_NO
               AND A.PARTF_ID = B.PARTF_ID
               AND A.FACTORY_CODE = B.FACTORY_CODE);

    --同一次导入的数据版本号需要一致
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '版本号不一致;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND EXISTS (SELECT 1
              FROM (SELECT C.IMP_UUID
                      FROM (SELECT B.IMP_UUID, B.VERSION
                              FROM MM_SW_DEMAND_FORECAST_SUPPIMP B
                             WHERE B.IMP_UUID = IN_VAR_UUID
                               AND B.IMPORT_STATUS = 0
                             GROUP BY B.IMP_UUID, B.VERSION) C
                     GROUP BY C.IMP_UUID
                    HAVING COUNT(1) > 1) D
             WHERE A.IMP_UUID = D.IMP_UUID);

    --EXCEL数据重复
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || 'EXCEL数据重复'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND EXISTS (SELECT 1
              FROM (SELECT B.ID
                      FROM MM_SW_DEMAND_FORECAST_SUPPIMP B
                     WHERE B.IMP_UUID = IN_VAR_UUID
                       AND B.IMPORT_STATUS = 0
                     GROUP BY B.ID
                    HAVING COUNT(1) > 1) C
             WHERE A.ID = C.ID);

    --找到ID不为空的数据,判断ID是否存在
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '数据不存在;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.ID IS NOT NULL
       AND A.CHECK_RESULT = '1'
       AND NOT EXISTS (SELECT 1
              FROM MM_SW_DEMAND_FORECAST_SUPPORT B
             WHERE A.ID = B.ID
            /*AND B.FORE_TYPE = 1*/
            );

    --判断版本号是否已经发布，已经发布无法修改
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '版本已发布'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.CHECK_RESULT = '1'
       AND EXISTS (SELECT 1
              FROM MM_SW_DEMAND_FORECAST B
             WHERE A.FORE_TYPE = B.FORE_TYPE
               AND A.VERSION = B.VERSION
               AND B.P_SUPPLIER IS NOT NULL
               AND A.FACTORY_CODE = B.FACTORY_CODE);

    --更新生产阶段
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.LOGISTICS_MODE =
           (SELECT B.CODE_VALUE
              FROM MM_PUB_DATA_DICT B
             WHERE A.LOGISTICS_MODE = B.CODE_VALUE_NAME
               AND A.FACTORY_CODE = B.FACTORY_CODE
               AND B.CODE_TYPE = 'PUB_MM_MODEL')
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.CHECK_RESULT = 1
       AND A.LOGISTICS_MODE IS NOT NULL;

    --已存在，导入更新
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_INFO = NVL(A.CHECK_INFO, '') || '已存在，导入更新',
           A.OPE_TYPE   = 'U'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.CHECK_RESULT = 1
       AND A.ID IS NOT NULL;

    --不存在存在，导入新增
    UPDATE MM_SW_DEMAND_FORECAST_SUPPIMP A
       SET A.CHECK_INFO = NVL(A.CHECK_INFO, '') || '不存在，导入新增',
           A.OPE_TYPE   = 'I'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.CHECK_RESULT = 1
       AND A.ID IS NULL;

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_MP_DEMANDFORCAST_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_MP_DEMANDFORCAST_CHECK;
  --***************************************************************************

end PKG_MP_CHECK;
/

prompt
prompt Creating package body PKG_MP_MAIN
prompt =================================
prompt
create or replace package body PKG_MP_MAIN is

  --***************************************************************************
  --存储过程名：USP_MP_GEN_ORDER_BOM
  --功能描述：生成订购单车BOM
  --参数说明：
  --in_opeId 操作人
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2019/04/11
  PROCEDURE USP_MP_GEN_ORDER_BOM(in_arr_factory in VARCHAR2,
                                 in_opeId       in VARCHAR2,
                                 out_code       out VARCHAR2) AS
  
    err_num number;
    err_msg varchar2(200);
  
  BEGIN
    --删除订购订单BOM
    EXECUTE IMMEDIATE 'truncate table MM_MP_ORDER_BOM';
  
    INSERT INTO MM_MP_ORDER_BOM
      (FACTORY_CODE,
       ORDER_NO,
       MODEL_CODE,
       PART_ROWNO,
       VEHICLE_PART_NO,
       PART_NO,
       WORKCENTER,
       STATION_CODE,
       NUM,
       USAGE_AMOUNT_UNIT,
       PURCHASE_TYPE,
       PARTF_ID,
       CREATION_TIME,
       CREATION_USER)
    --找到未计算的订单
      SELECT D.FACTORY_CODE,
             CONNECT_BY_ROOT(D.ORDER_NO) ORDER_NO,
             CONNECT_BY_ROOT(D.MODEL_CODE) MODEL_CODE,
             D. PART_ROWNO,
             CONNECT_BY_ROOT(D.VEHICLE_PART_NO) VEHICLE_PART_NO,
             D.PART_NO,
             D.WORKCENTER,
             D.STATION_CODE,
             MY_EVAL_NUMBER(1 || SYS_CONNECT_BY_PATH(D.NUM, '*')) NUM,
             D.USAGE_AMOUNT_UNIT,
             D.PURCHASE_TYPE,
             D. PARTF_ID,
             SYSDATE,
             in_opeId
        FROM (SELECT A.FACTORY_CODE,
                     A.ORDER_NO,
                     A.MODEL_CODE,
                     A.PART_ROWNO,
                     A.VEHICLE_PART_NO,
                     A.PART_NO,
                     A.WORKCENTER,
                     A.STATION_CODE,
                     A.NUM,
                     A.USAGE_AMOUNT_UNIT,
                     A.PURCHASE_TYPE,
                     NULL PARTF_ID
                FROM MM_PUB_ORDER_BOM A
               WHERE EXISTS (SELECT 1
                        FROM MM_MP_VEH_PLAN B
                       WHERE B.CAL_STATUS = 0
                         AND A.ORDER_NO = B.ORDER_NO
                         AND A.FACTORY_CODE = B.FACTORY_CODE)
              UNION ALL
              SELECT C.FACTORY_CODE,
                     NULL                  ORDER_NO,
                     NULL                  MODEL_CODE,
                     NULL                  PART_ROWNO,
                     NULL                  VEHICLE_PART_NO,
                     C.PART_NO,
                     C.NEXT_PLACEMENT,
                     C.LINE_STATION,
                     C.NUM,
                     C.USE_AGE_AMOUNT_UNIT,
                     C.PURCHASE_TYPE,
                     C.PARTF_ID
                FROM MM_PUB_SUPPORTING_PART C
               WHERE C.FACTORY_CODE = in_arr_factory) D
       START WITH D.ORDER_NO IS NOT NULL
      CONNECT BY NOCYCLE PRIOR D.PART_NO = D.PARTF_ID;
  
    COMMIT;
    out_code := '0';
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_GEN_ORDER_BOM',
           err_num,
           err_msg,
           sysdate,
           '生成订购单车BOM');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_GEN_ORDER_BOM;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_ZSB
  --功能描述：净需求总成
  --参数说明：
  --in_uuid uuid
  --in_opeId 操作人
  --in_type 类型 需求计算，采购订单生成
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_ZSB(in_uuid        in VARCHAR2,
                       in_opeId       in VARCHAR2,
                       in_type        in VARCHAR2,
                       in_arr_factory in VARCHAR2,
                       out_code       out number) AS
  
    err_num number;
    err_msg varchar2(200);
  
  BEGIN
    USP_MP_WATCH_OPEN(in_uuid, in_opeId, in_type, in_arr_factory);
    USP_MP_ZSB_MAIN(in_arr_factory);
    USP_MP_ZSB_DEAL_PACK(in_arr_factory);
    USP_MP_ZSB_DEAL_STATUS(in_arr_factory);
    USP_MP_WATCH_COLSE(in_uuid, in_opeId, in_type, in_arr_factory);
    out_code := 2;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_ZSB',
           err_num,
           err_msg,
           sysdate,
           '净需求总成');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_ZSB;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_WATCH_OPEN
  --功能描述：推算监控开启
  --参数说明：
  --in_arr_factory 工厂代码
  --in_opeId 操作人
  --in_type 类型 需求计算，采购订单生成
  --in_arr_factory 工厂
  --创建人员: wangyu
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_WATCH_OPEN(in_uuid        varchar2,
                              in_opeid       varchar2,
                              in_type        in VARCHAR2,
                              in_arr_factory in VARCHAR2) AS
  
  BEGIN
    UPDATE MM_MP_CAL_LOCK d
       SET d.is_lock            = 1,
           d.last_modified_user = 'system',
           d.last_modified_time = sysdate
     WHERE d.cal_type = in_type
       AND d.factory_code = in_arr_factory;
    INSERT INTO MM_MP_CAL_LOG
      (CAL_TYPE,
       IS_LOCK,
       CREATION_USER,
       UUID,
       CAL_START_TIME,
       FACTORY_CODE)
    VALUES
      (in_type, 0, in_opeid, in_uuid, sysdate, in_arr_factory);
    commit;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
  end;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_ZSB_MAIN
  --功能描述：净需求计算主体
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_ZSB_MAIN(in_arr_factory IN VARCHAR2) AS
    -- 需要订购的供应商
    CURSOR cux_supplier_list(in_arr_factory VARCHAR2) IS
      SELECT DISTINCT MP.FACTORY_CODE,
                      MP.SUPPLIER_NO,
                      MP.SUP_FACTORY,
                      MP.UNLOAD_PORT,
                      MP.MODEL_CODE        CAR_TYPE,
                      MP.ORDER_PRODUCT_NUM SUP_CAL_NUM,
                      MP.WORKCENTER
        FROM MM_MP_PART MP
       WHERE MP.ORDER_PRODUCT_NUM > 0
         AND MP.FACTORY_CODE = in_arr_factory
         AND MP.EFF_START <= SYSDATE
         AND MP.EFF_END > SYSDATE;
  
    v_sort_num                 NUMBER := 0;
    v_vch_num                  NUMBER := 0;
    v_tact                     NUMBER := 0;
    v_group_qty                NUMBER;
    v_purchase_type            varchar2(20);
    v_location_num             NUMBER;
    v_group_id                 NUMBER := 0;
    v_afoff_time_start         DATE;
    v_afoff_time_end           DATE;
    v_int                      NUMBER := 0;
    v_supplier_id_tmp          VARCHAR2(100);
    v_factory_id_tmp           VARCHAR2(100);
    v_aog_factory_tmp          VARCHAR2(100);
    v_unload_port_tmp          VARCHAR2(100);
    v_part_id_tmp              VARCHAR2(100);
    v_underline_time_start_tmp VARCHAR2(100);
    v_logistics_order          VARCHAR2(100);
    v_new_logistics_order      VARCHAR2(100);
    v_af_max_loc               NUMBER;
    v_pa_max_loc               NUMBER;
    v_we_max_loc               NUMBER;
    v_wbs_max_loc              NUMBER;
    v_pbs_max_loc              NUMBER;
    v_arrive_time              date;
    v_workcenter_count         NUMBER;
  
  BEGIN
    EXECUTE IMMEDIATE 'truncate table MM_MP_PART_SORT_temp';
    EXECUTE IMMEDIATE 'truncate table MM_MP_ORDER_RECORD';
    EXECUTE IMMEDIATE 'truncate table MM_MP_SUPPLIER_SORT_TEMP';
    EXECUTE IMMEDIATE 'truncate table MM_MP_CAR_TYPE_NODE';
    --初始化供应商分组，零件分组最大值
    USP_MP_REQ_ZSB_INIT(in_arr_factory);
  
    --历史车型起算点
    INSERT INTO MM_MP_CAR_TYPE_NODE
      (FACTORY_CODE, SORT_ID, MULTI_CAR_TYPE)
      SELECT CTQ.FACTORY_CODE, CTQ.SORT_ID, CTQ.MULTI_CAR_TYPE
        FROM MM_MP_CAR_TYPE_QUEUE CTQ
       WHERE CTQ.CAR_TYPE_SORT_ID =
             (SELECT NVL(MAX(real_end_sort_id), 0)
                FROM MM_MP_PART_SORT_MAX CPS,
                     (SELECT DISTINCT MP.SUPPLIER_NO,
                                      MP.SUP_FACTORY,
                                      MP.FACTORY_CODE,
                                      MP.UNLOAD_PORT,
                                      MP.MODEL_CODE CAR_TYPE
                        FROM MM_MP_PART MP
                       WHERE MP.FACTORY_CODE = in_arr_factory
                         AND MP.ORDER_PRODUCT_NUM > 0
                         AND MP.EFF_START <= SYSDATE
                         AND MP.EFF_END > SYSDATE) MS
               WHERE CPS.SUPPLIER_NO = MS.SUPPLIER_NO
                 AND CPS.SUP_FACTORY = MS.SUP_FACTORY
                 AND CPS.FACTORY_CODE = MS.FACTORY_CODE
                 AND CPS.UNLOAD_PORT = MS.UNLOAD_PORT
                 AND CPS.FACTORY_CODE = in_arr_factory
                 AND MS.CAR_TYPE = NVL(CTQ.MULTI_CAR_TYPE, '%'));
  
    COMMIT;
  
    --新车型起算点,在历史零件分组中导入新车型的零件分组处理
    MERGE INTO MM_MP_CAR_TYPE_NODE
    USING (SELECT MAX(T.real_end_sort_id) real_end_sort_id, T.CAR_TYPE
             FROM (SELECT NVL(MAX(CPS.REAL_END_SORT_ID), 0) real_end_sort_id,
                          CPS.SUPPLIER_NO,
                          CPS.SUP_FACTORY,
                          CPS.UNLOAD_PORT,
                          CPS.FACTORY_CODE,
                          MS.CAR_TYPE
                     FROM MM_MP_PART_SORT_MAX CPS,
                          (SELECT DISTINCT MP.SUPPLIER_NO,
                                           MP.SUP_FACTORY,
                                           MP.FACTORY_CODE,
                                           MP.UNLOAD_PORT,
                                           MP.MODEL_CODE CAR_TYPE
                             FROM MM_MP_PART MP
                            WHERE MP.FACTORY_CODE = in_arr_factory
                              AND MP.ORDER_PRODUCT_NUM > 0
                              AND MP.EFF_START <= SYSDATE
                              AND MP.EFF_END > SYSDATE) MS
                    WHERE CPS.SUPPLIER_NO = MS.SUPPLIER_NO
                      AND CPS.SUP_FACTORY = MS.SUP_FACTORY
                      AND CPS.FACTORY_CODE = MS.FACTORY_CODE
                      AND CPS.UNLOAD_PORT = MS.UNLOAD_PORT
                      AND CPS.FACTORY_CODE = in_arr_factory
                      AND MS.FACTORY_CODE = in_arr_factory
                    GROUP BY CPS.SUPPLIER_NO,
                             CPS.SUP_FACTORY,
                             CPS.UNLOAD_PORT,
                             CPS.FACTORY_CODE,
                             MS.CAR_TYPE) T
            GROUP BY T.CAR_TYPE) TT
    ON (FACTORY_CODE = in_arr_factory AND MULTI_CAR_TYPE = TT.CAR_TYPE)
    WHEN NOT MATCHED THEN
      INSERT
        (SORT_ID, MULTI_CAR_TYPE, FACTORY_CODE)
      VALUES
        (TT.real_end_sort_id, TT.CAR_TYPE, in_arr_factory);
    COMMIT;
  
    --找到零件分组最大值中的最大真实结束SORT_ID
    SELECT MAX(A.REAL_END_SORT_ID)
      INTO v_sort_num
      FROM MM_MP_PART_SORT_MAX A
     WHERE A.FACTORY_CODE = in_arr_factory;
  
    --在路线中新维护的车型设置该车型的起始值为1
    INSERT INTO MM_MP_CAR_TYPE_NODE
      (SORT_ID, MULTI_CAR_TYPE, FACTORY_CODE)
      (SELECT distinct 1, car_type, in_arr_factory
         FROM (SELECT DISTINCT MP.SUPPLIER_NO,
                               MP.SUP_FACTORY,
                               MP.FACTORY_CODE,
                               MP.UNLOAD_PORT,
                               MP.MODEL_CODE CAR_TYPE
                 FROM MM_MP_PART MP
                WHERE MP.FACTORY_CODE = in_arr_factory
                  AND MP.ORDER_PRODUCT_NUM > 0
                  AND MP.EFF_START <= SYSDATE
                  AND MP.EFF_END > SYSDATE) A
        WHERE A.CAR_TYPE NOT IN
              (SELECT DISTINCT S.MULTI_CAR_TYPE
                 FROM MM_MP_CAR_TYPE_QUEUE S,
                      (SELECT DISTINCT MP.SUPPLIER_NO,
                                       MP.SUP_FACTORY,
                                       MP.FACTORY_CODE,
                                       MP.UNLOAD_PORT,
                                       MP.MODEL_CODE CAR_TYPE
                         FROM MM_MP_PART MP
                        WHERE MP.FACTORY_CODE = in_arr_factory
                          AND MP.ORDER_PRODUCT_NUM > 0
                          AND MP.EFF_START <= SYSDATE
                          AND MP.EFF_END > SYSDATE) O
                WHERE O.CAR_TYPE = S.MULTI_CAR_TYPE
                  AND O.FACTORY_CODE = S.FACTORY_CODE
                  AND O.FACTORY_CODE = in_arr_factory
                  AND S.SORT_ID <= v_sort_num));
  
    COMMIT;
    --当零件分组数据量为0的时候将所有路线所有的所有存在起始SORT_ID的数据写入
    SELECT COUNT(*)
      INTO v_vch_num
      FROM MM_MP_PART_SORT S
     WHERE S.FACTORY_CODE = in_arr_factory;
    IF v_vch_num = 0 THEN
      INSERT INTO MM_MP_CAR_TYPE_NODE
        (SORT_ID, MULTI_CAR_TYPE, FACTORY_CODE)
        (SELECT DISTINCT 1, O.CAR_TYPE, O.FACTORY_CODE
           FROM (SELECT DISTINCT MP.SUPPLIER_NO,
                                 MP.SUP_FACTORY,
                                 MP.FACTORY_CODE,
                                 MP.UNLOAD_PORT,
                                 MP.MODEL_CODE CAR_TYPE
                   FROM MM_MP_PART MP
                  WHERE MP.FACTORY_CODE = in_arr_factory
                    AND MP.ORDER_PRODUCT_NUM > 0
                    AND MP.EFF_START <= SYSDATE
                    AND MP.EFF_END > SYSDATE) O
          WHERE O.FACTORY_CODE = in_arr_factory);
      COMMIT;
    END IF;
  
    --删除分车型队列中比上次计算每个车型的截止sort_id大的数据
    DELETE FROM MM_MP_CAR_TYPE_QUEUE A
     WHERE EXISTS (SELECT 1
              FROM MM_MP_CAL_END B
             WHERE A.MULTI_CAR_TYPE = B.CAR_TYPE
               AND A.CAR_TYPE_SORT_ID > B.CAL_POINT);
  
    --根据车型判断删除不存在于上次计算并生成采购订单的所有车型的分车型数据
    DELETE FROM MM_MP_CAR_TYPE_QUEUE A
     WHERE NOT EXISTS (SELECT 1
              FROM MM_MP_CAL_END B
             WHERE A.MULTI_CAR_TYPE = B.CAR_TYPE);
  
    --节拍标识
    SELECT PRODUCE_TIME
      INTO v_tact
      FROM (SELECT A.PRODUCE_TIME, COUNT(1) NUM
              FROM MM_PUB_TACT_TIME A
             WHERE A.WORKCENTER = 'A1'
               AND A.PRODUCTION_LINE = 'AF_MAIN'
             GROUP BY A.PRODUCE_TIME
             ORDER BY NUM DESC)
     WHERE ROWNUM = 1;
  
    --MODIFY 2019-05-31
    --将获取车间最大值放到循环外面
    --表明没有维护这个零件，工位的工深数据,查询当前车间的最大工深数据
    BEGIN
      --判断如果是总装
      SELECT NVL(A.PARAM_VAL, 0)
        INTO v_af_max_loc
        FROM MM_PUB_SYS_PARAM A
       WHERE A.PARAM_GROUP = 'MAX_LOC'
         AND A.FACTORY_CODE = in_arr_factory
         AND A.PARAM_CODE = 'AF_TOTAL_PRO_NUM';
    
      --判断如果是焊装
      SELECT NVL(A.PARAM_VAL, 0)
        INTO v_we_max_loc
        FROM MM_PUB_SYS_PARAM A
       WHERE A.PARAM_GROUP = 'MAX_LOC'
         AND A.FACTORY_CODE = in_arr_factory
         AND A.PARAM_CODE = 'WE_TOTAL_PRO_NUM';
    
      --判断如果是涂装
      SELECT NVL(A.PARAM_VAL, 0)
        INTO v_pa_max_loc
        FROM MM_PUB_SYS_PARAM A
       WHERE A.PARAM_GROUP = 'MAX_LOC'
         AND A.FACTORY_CODE = in_arr_factory
         AND A.PARAM_CODE = 'PA_TOTAL_PRO_NUM';
      --判断如果是涂装
      SELECT NVL(A.PARAM_VAL, 0)
        INTO v_wbs_max_loc
        FROM MM_PUB_SYS_PARAM A
       WHERE A.PARAM_GROUP = 'MAX_LOC'
         AND A.FACTORY_CODE = in_arr_factory
         AND A.PARAM_CODE = 'WBS_TOTAL_PRO_NUM';
    
      --判断如果是涂装
      SELECT NVL(A.PARAM_VAL, 0)
        INTO v_pbs_max_loc
        FROM MM_PUB_SYS_PARAM A
       WHERE A.PARAM_GROUP = 'MAX_LOC'
         AND A.FACTORY_CODE = in_arr_factory
         AND A.PARAM_CODE = 'PBS_TOTAL_PRO_NUM';
    END;
  
    --分车型调整
    USP_MP_VEH_STANDARD(in_arr_factory);
  
    --历史路线已计算路线上新增一个零件，该零件从该路线最大分组开始计算
    FOR v_group_list IN (SELECT A.PART_NO,
                                A.SUPPLIER_NO,
                                A.SUP_FACTORY,
                                A.FACTORY_CODE,
                                A.UNLOAD_PORT,
                                --这个会作为计算起始点，所以需要减一
                                --Modify 20190429
                                A.FIRST_SORT_ID - 1 FIRST_SORT_ID
                           FROM MM_MP_PART A
                         --在BOM里面存在这个零件
                          WHERE EXISTS
                          (SELECT 1
                                   FROM MM_PUB_ORDER_BOM T
                                  WHERE T.NUM > 0
                                    AND A.PART_NO = T.PART_NO
                                    AND A.FACTORY_CODE = in_arr_factory)
                               --并且不存在该条路线上这个零件不存在于历史零件分组
                            AND NOT EXISTS
                          (SELECT 1
                                   FROM MM_MP_PART_SORT C
                                  WHERE A.PART_NO = C.PART_NO
                                    AND A.SUPPLIER_NO = C.SUPPLIER_NO
                                    AND A.SUP_FACTORY = C.SUP_FACTORY
                                    AND A.FACTORY_CODE = C.FACTORY_CODE
                                    AND A.UNLOAD_PORT = C.UNLOAD_PORT)
                               --并且存在该条路线是有数据存在于零件分
                            AND EXISTS
                          (SELECT 1
                                   FROM MM_MP_PART_SORT D
                                  WHERE A.SUPPLIER_NO = D.SUPPLIER_NO
                                    AND A.FACTORY_CODE = D.FACTORY_CODE
                                    AND A.SUP_FACTORY = D.SUP_FACTORY
                                    AND A.UNLOAD_PORT = D.UNLOAD_PORT)) LOOP
      BEGIN
        INSERT INTO MM_MP_PART_SORT
          (PART_NO,
           GROUP_ID,
           DR_SORT_ID_START,
           DR_SORT_ID_END,
           LR_SORT_ID_START,
           LR_SORT_ID_END,
           FINAL_UNDERLINE_TIME_START,
           FINAL_UNDERLINE_TIME_END,
           FINAL_UNDERLINE_TIME_START_NEW,
           FINAL_UNDERLINE_TIME_END_NEW,
           SUPPLIER_NO,
           SUP_FACTORY,
           ORDER_PACKAGE,
           STANDARD_PACKAGE,
           SUPPLY_RATE,
           FACTORY_CODE,
           UNLOAD_PORT,
           ID,
           GROUP_QTY,
           CAL_STATUS,
           LOGISTICS_ORDER,
           GROUP_QTY_NEW,
           WORKCENTER,
           GROUP_QTY_DIFF,
           ITEM_CALCULATE_NUM,
           ARRIVE_TIME,
           LINE_SIDE_TIME,
           LINE_SIDE_SORT_ID,
           USE_RANGE_SORT_ID_START,
           USE_RANGE_SORT_ID_END,
           REAL_END_SORT_ID,
           CAR_TYPE)
          SELECT v_group_list.PART_NO,
                 A.GROUP_ID,
                 A.DR_SORT_ID_START,
                 A.DR_SORT_ID_END,
                 A.LR_SORT_ID_START,
                 A.LR_SORT_ID_END,
                 A.FINAL_UNDERLINE_TIME_START,
                 A.FINAL_UNDERLINE_TIME_END,
                 A.FINAL_UNDERLINE_TIME_START_NEW,
                 A.FINAL_UNDERLINE_TIME_END_NEW,
                 A.SUPPLIER_NO,
                 A.SUP_FACTORY,
                 --Modify 2019-05-29
                 /*A.ORDER_PACKAGE,*/
                 NVL(B.ORDER_PACKAGE, 1),
                 NVL(B.STANDARD_PACKAGE, 1),
                 A.SUPPLY_RATE,
                 A.FACTORY_CODE,
                 A.UNLOAD_PORT,
                 SEQ_MM_MP_PART_SORT.nextval,
                 A.GROUP_QTY,
                 A.CAL_STATUS,
                 A.LOGISTICS_ORDER,
                 A.GROUP_QTY_NEW,
                 A.WORKCENTER,
                 A.GROUP_QTY_DIFF,
                 A.ITEM_CALCULATE_NUM,
                 A.ARRIVE_TIME,
                 A.LINE_SIDE_TIME,
                 A.LINE_SIDE_SORT_ID,
                 A.USE_RANGE_SORT_ID_START,
                 A.USE_RANGE_SORT_ID_END,
                 --Modify 2019-05-27 
                 --直接去其他零件计算的最大值作为起算值
                 /*NVL(v_group_list.FIRST_SORT_ID, A.REAL_END_SORT_ID),*/
                 NVL(A.REAL_END_SORT_ID, v_group_list.FIRST_SORT_ID),
                 A.CAR_TYPE
            FROM MM_MP_PART_SORT A
            LEFT JOIN MM_MP_PART B
              ON A.FACTORY_CODE = B.FACTORY_CODE
             AND A.SUPPLIER_NO = B.SUPPLIER_NO
             AND A.SUP_FACTORY = B.SUP_FACTORY
             AND A.PART_NO = B.PART_NO
             AND A.UNLOAD_PORT = B.UNLOAD_PORT
             AND B.PART_NO = v_group_list.PART_NO
           WHERE A.SUPPLIER_NO = v_group_list.SUPPLIER_NO
             AND A.SUP_FACTORY = v_group_list.SUP_FACTORY
             AND A.FACTORY_CODE = v_group_list.FACTORY_CODE
             AND A.UNLOAD_PORT = v_group_list.UNLOAD_PORT
             AND B.PART_NO = v_group_list.PART_NO
             AND A.GROUP_ID =
                 (SELECT MAX(B.GROUP_ID)
                    FROM MM_MP_PART_SORT B
                   WHERE B.SUPPLIER_NO = v_group_list.SUPPLIER_NO
                     AND B.SUP_FACTORY = v_group_list.SUP_FACTORY
                     AND B.FACTORY_CODE = v_group_list.FACTORY_CODE
                     AND B.UNLOAD_PORT = v_group_list.UNLOAD_PORT)
             AND ROWNUM = 1;
      EXCEPTION
        WHEN OTHERS THEN
          NULL;
      END;
    END LOOP;
  
    --初始化供应商分组，零件分组最大值
    USP_MP_REQ_ZSB_INIT(in_arr_factory);
  
    -- 需要订购的供应商
    FOR v_supplier_list IN cux_supplier_list(in_arr_factory) LOOP
    
      --寻找路线历史最大分组
      SELECT NVL(MAX(A.GROUP_ID), 0)
        INTO v_group_id
        FROM MM_MP_SUPPLIER_SORT_MAX A
       WHERE A.SUPPLIER_NO = v_supplier_list.Supplier_No
         AND A.SUP_FACTORY = v_supplier_list.Sup_Factory
         AND A.UNLOAD_PORT = v_supplier_list.Unload_Port
         AND A.FACTORY_CODE = v_supplier_list.Factory_Code;
    
      --本次计算的供应商分组
      FOR v_supplier_group_list IN (SELECT CEIL(RN /
                                                v_supplier_list.SUP_CAL_NUM) GROUP_ID,
                                           MIN(SORT_ID) START_SORT_ID,
                                           MAX(SORT_ID) +
                                           (v_supplier_list.SUP_CAL_NUM -
                                            decode(MOD((MAX(SORT_ID) -
                                                       MIN(SORT_ID) + 1),
                                                       v_supplier_list.SUP_CAL_NUM),
                                                   0,
                                                   v_supplier_list.SUP_CAL_NUM,
                                                   MOD((MAX(SORT_ID) -
                                                       MIN(SORT_ID) + 1),
                                                       v_supplier_list.SUP_CAL_NUM))) END_SORT_ID,
                                           in_arr_factory FACTORY_CODE
                                      FROM (SELECT CTS.CAR_TYPE_SORT_ID SORT_ID,
                                                   ROW_NUMBER() OVER(ORDER BY CTS.CAR_TYPE_SORT_ID) RN
                                              FROM MM_MP_CAR_TYPE_QUEUE CTS
                                             WHERE NVL(CTS.MULTI_CAR_TYPE,
                                                       '%') =
                                                   NVL(v_supplier_list.CAR_TYPE,
                                                       '%')
                                               AND CTS.FACTORY_CODE =
                                                   in_arr_factory
                                               AND CTS.CAR_TYPE_SORT_ID >
                                                   (NVL((SELECT MAX(A.DR_SORT_ID_END)
                                                          FROM MM_MP_SUPPLIER_SORT_MAX A
                                                         WHERE A.SUPPLIER_NO =
                                                               v_supplier_list.SUPPLIER_NO
                                                           AND A.SUP_FACTORY =
                                                               v_supplier_list.SUP_FACTORY
                                                           AND A.FACTORY_CODE =
                                                               v_supplier_list.FACTORY_CODE
                                                           AND A.UNLOAD_PORT =
                                                               v_supplier_list.UNLOAD_PORT),
                                                        (SELECT NVL(B.FIRST_SORT_ID,
                                                                    1) - 1
                                                           FROM (SELECT DISTINCT MP.SUPPLIER_NO,
                                                                                 MP.SUP_FACTORY,
                                                                                 MP.FACTORY_CODE,
                                                                                 MP.UNLOAD_PORT,
                                                                                 MP.MODEL_CODE   CAR_TYPE,
                                                                                 1               FIRST_SORT_ID
                                                                   FROM MM_MP_PART MP
                                                                  WHERE MP.FACTORY_CODE =
                                                                        in_arr_factory
                                                                    AND MP.ORDER_PRODUCT_NUM > 0
                                                                    AND MP.EFF_START <=
                                                                        SYSDATE
                                                                    AND MP.EFF_END >
                                                                        SYSDATE) B
                                                          WHERE B.SUPPLIER_NO =
                                                                v_supplier_list.SUPPLIER_NO
                                                            AND B.SUP_FACTORY =
                                                                v_supplier_list.SUP_FACTORY
                                                            AND B.FACTORY_CODE =
                                                                v_supplier_list.FACTORY_CODE
                                                            AND B.UNLOAD_PORT =
                                                                v_supplier_list.UNLOAD_PORT))))
                                     GROUP BY CEIL(RN /
                                                   v_supplier_list.SUP_CAL_NUM)
                                     ORDER BY CEIL(RN /
                                                   v_supplier_list.SUP_CAL_NUM)) LOOP
      
        --找出该供应商分组中最早下线时间和最晚下线时间
        SELECT MIN(NVL(T2.ADJ_AFOFF_TIME, NVL(T2.AFOFF_TIME, SYSDATE))) AFOFF_TIME_START,
               MAX(NVL(T2.ADJ_AFOFF_TIME, NVL(T2.AFOFF_TIME, SYSDATE))) AFOFF_TIME_END
          INTO v_afoff_time_start, v_afoff_time_end
          FROM MM_MP_CAR_TYPE_QUEUE T2
         WHERE NVL(T2.MULTI_CAR_TYPE, '%') =
               NVL(v_supplier_list.Car_Type, '%')
           AND T2.CAR_TYPE_SORT_ID BETWEEN
               v_supplier_group_list.START_SORT_ID AND
               v_supplier_group_list.END_SORT_ID
           AND T2.FACTORY_CODE = v_supplier_list.Factory_Code;
      
        --将该供应商分组写入临时表
        INSERT INTO MM_MP_SUPPLIER_SORT_TEMP
          (SUPPLIER_NO,
           SUP_FACTORY,
           FACTORY_CODE,
           UNLOAD_PORT,
           GROUP_ID,
           DR_SORT_ID_START,
           DR_SORT_ID_END,
           CAL_STATUS,
           FINAL_UNDERLINE_TIME_START,
           FINAL_UNDERLINE_TIME_END)
        VALUES
          (v_supplier_list.SUPPLIER_NO,
           v_supplier_list.SUP_FACTORY,
           v_supplier_list.FACTORY_CODE,
           v_supplier_list.UNLOAD_PORT,
           v_group_id + v_supplier_group_list.GROUP_ID,
           v_supplier_group_list.START_SORT_ID,
           v_supplier_group_list.END_SORT_ID,
           '0',
           v_afoff_time_start,
           v_afoff_time_end);
      END LOOP;
      COMMIT;
    
      --查找该供应商分组下的零件分组数据，包括本次新增的零件分组数据和差异单的零件分组数据
      FOR v_part_group_list IN (SELECT PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                                    DECODE(CC.WORKCENTER,
                                                                           'A1',
                                                                           'A1',
                                                                           'W1',
                                                                           'W1',
                                                                           'T1',
                                                                           'T1',
                                                                           'A1'),
                                                                    TO_DATE(TO_CHAR(CC.ASSEMBLE_TIME,
                                                                                    'YYYY-MM-DD HH24:MI:SS'),
                                                                            'YYYY-MM-DD HH24:MI:SS'),
                                                                    - (CC.ADVANCE_ARR_NUM *
                                                                      v_tact)) ARRIVE_TIME,
                                       CC.*
                                  FROM (SELECT PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                                            DECODE(AA.WORKCENTER,
                                                                                   'A1',
                                                                                   'A1',
                                                                                   'W1',
                                                                                   'W1',
                                                                                   'T1',
                                                                                   'T1',
                                                                                   'A1'),
                                                                            TO_DATE(BB.FINAL_UNDERLINE_TIME,
                                                                                    'YYYY-MM-DD HH24:MI:SS'),
                                                                            --这里不能传0，传0会导致算不出时间
                                                                            0) ASSEMBLE_TIME,
                                               TO_DATE(BB.FINAL_UNDERLINE_TIME,
                                                       'YYYY-MM-DD HH24:MI:SS') LINE_SIDE_TIME,
                                               AA.*,
                                               --查询每个分组的真实截止SORT_ID
                                               (SELECT MAX(MCTQ.CAR_TYPE_SORT_ID) CAR_TYPE_SORT_ID
                                                  FROM MM_MP_CAR_TYPE_QUEUE MCTQ
                                                 WHERE NVL(MCTQ.MULTI_CAR_TYPE,
                                                           '%') =
                                                       NVL(v_supplier_list.CAR_TYPE,
                                                           '%')
                                                   AND MCTQ.CAR_TYPE_SORT_ID BETWEEN
                                                       AA.START_SORT_ID_NEW AND
                                                       AA.END_SORT_ID_NEW
                                                   AND MCTQ.FACTORY_CODE =
                                                       in_arr_factory) REAL_END_SORT_ID
                                          FROM (SELECT DECODE(GROUP_ID,
                                                              1,
                                                              (SELECT MCTQ.SORT_ID
                                                                 FROM MM_MP_CAR_TYPE_QUEUE MCTQ
                                                                WHERE NVL(MCTQ.MULTI_CAR_TYPE,
                                                                          '%') =
                                                                      NVL(v_supplier_list.CAR_TYPE,
                                                                          '%')
                                                                  AND MCTQ.CAR_TYPE_SORT_ID =
                                                                     --找出这个供应商分组下最大的截止SORT_ID
                                                                     --所以算装配时间用最后这台车的下线时间减去，这条路线的台套数加上工程深度
                                                                      (NVL((SELECT MAX(A.END_SORT_ID_NEW)
                                                                             FROM MM_MP_PART_SORT_MAX MPSM
                                                                            WHERE MPSM.PART_NO =
                                                                                  A.PART_NO
                                                                              AND MPSM.SUPPLIER_NO =
                                                                                  A.SUPPLIER_NO
                                                                              AND MPSM.SUP_FACTORY =
                                                                                  A.SUP_FACTORY
                                                                              AND MPSM.UNLOAD_PORT =
                                                                                  A.UNLOAD_PORT
                                                                              AND MPSM.FACTORY_CODE =
                                                                                  A.FACTORY_CODE),
                                                                           --当END_SORT_ID_NEW为空的时候，判断ITEM_FIRST_SORT_ID是否大于0
                                                                           --如果大于0使用ITEM_FIRST_SORT_ID关联分车型表得到这台车的生产排序号
                                                                           CASE
                                                                             WHEN A.FIRST_SORT_ID > 0 THEN
                                                                              A.FIRST_SORT_ID
                                                                             ELSE
                                                                             --否则使用1关联分车型表得到这台车的生产排序号
                                                                              1
                                                                           END))
                                                                  AND MCTQ.FACTORY_CODE =
                                                                      in_arr_factory),
                                                              --LINE_SIDE_SORT_ID记录的是分组中首台车生产排序号
                                                              B.SORT_ID) LINE_SIDE_SORT_ID,
                                                       A.*
                                                  FROM (SELECT MMS.SUPPLIER_NO,
                                                               MMS.SUP_FACTORY,
                                                               MMS.FACTORY_CODE,
                                                               MMS.UNLOAD_PORT,
                                                               MMS.WORKCENTER,
                                                               MMS.PART_NO,
                                                               '' LOGISTICS_ORDER,
                                                               AA.GROUP_ID,
                                                               AA.DR_SORT_ID_END,
                                                               AA.DR_SORT_ID_START,
                                                               AA.DR_SORT_ID_END END_SORT_ID_DR_NEW,
                                                               --如果该供应商分组是第一个组，则判断有没有在零件分组中插入该条路线某个零件的零件分组数据
                                                               --若有则使用该分组数据的零件分组结束点作为起始点
                                                               --若无判断零件订购主数据中是否有维护起始SORT_ID如果有维护并且大于0使用维护的起始SORT_ID作为起始点
                                                               --若没有维护或者小于等于0使用1作为起始SORT_ID
                                                               DECODE(AA.GROUP_ID,
                                                                      1,
                                                                      NVL((SELECT MAX(B.LR_SORT_ID_END)
                                                                            FROM MM_MP_PART_SORT_MAX B
                                                                           WHERE B.PART_NO =
                                                                                 MMS.PART_NO
                                                                             AND B.SUPPLIER_NO =
                                                                                 MMS.SUPPLIER_NO
                                                                             AND B.SUP_FACTORY =
                                                                                 MMS.SUP_FACTORY
                                                                             AND B.UNLOAD_PORT =
                                                                                 MMS.UNLOAD_PORT
                                                                             AND B.FACTORY_CODE =
                                                                                 MMS.FACTORY_CODE),
                                                                          CASE
                                                                            WHEN MMS.FIRST_SORT_ID > 0 THEN
                                                                             MMS.FIRST_SORT_ID
                                                                            ELSE
                                                                             1
                                                                          END),
                                                                      AA.DR_SORT_ID_START) START_SORT_ID_DR_NEW,
                                                               AA.DR_SORT_ID_END END_SORT_ID_NEW,
                                                               --如果该供应商分组是第一个组，则判断有没有在零件分组中插入该条路线某个零件的零件分组数据
                                                               --若有则使用该分组数据的零件分组结束点作为起始点
                                                               --若无判断零件订购主数据中是否有维护起始SORT_ID如果有维护并且大于0使用维护的起始SORT_ID作为起始点
                                                               --若没有维护或者小于等于0使用1作为起始SORT_ID
                                                               DECODE(AA.GROUP_ID,
                                                                      1,
                                                                      NVL((SELECT MAX(C.LR_SORT_ID_END)
                                                                            FROM MM_MP_PART_SORT_MAX C
                                                                           WHERE C.PART_NO =
                                                                                 MMS.PART_NO
                                                                             AND C.SUPPLIER_NO =
                                                                                 MMS.SUPPLIER_NO
                                                                             AND C.SUP_FACTORY =
                                                                                 MMS.SUP_FACTORY
                                                                             AND C.UNLOAD_PORT =
                                                                                 MMS.UNLOAD_PORT
                                                                             AND C.FACTORY_CODE =
                                                                                 MMS.FACTORY_CODE),
                                                                          CASE
                                                                            WHEN MMS.FIRST_SORT_ID > 0 THEN
                                                                             MMS.FIRST_SORT_ID
                                                                            ELSE
                                                                             1
                                                                          END),
                                                                      AA.DR_SORT_ID_START) START_SORT_ID_NEW,
                                                               AA.DR_SORT_ID_END USE_RANGE_SORT_ID_END,
                                                               AA.DR_SORT_ID_START USE_RANGE_SORT_ID_START,
                                                               --判断订购包装是否为空null '' 或者0 如果不为取订购包装，不然取标准包装
                                                               DECODE(MMS.ORDER_PACKAGE,
                                                                      0,
                                                                      DECODE(MMS.STANDARD_PACKAGE,
                                                                             0,
                                                                             1,
                                                                             '',
                                                                             1,
                                                                             MMS.STANDARD_PACKAGE),
                                                                      '',
                                                                      DECODE(MMS.STANDARD_PACKAGE,
                                                                             0,
                                                                             1,
                                                                             '',
                                                                             1,
                                                                             MMS.STANDARD_PACKAGE),
                                                                      NULL,
                                                                      DECODE(MMS.STANDARD_PACKAGE,
                                                                             0,
                                                                             1,
                                                                             '',
                                                                             1,
                                                                             MMS.STANDARD_PACKAGE),
                                                                      MMS.ORDER_PACKAGE) AS PACK_QUANTITY,
                                                               NVL(MMS.STANDARD_PACKAGE,
                                                                   0) STANDARD_PACKAGE,
                                                               MMS.SUPPLY_RATE,
                                                               --这里先往前推一个工程深度，因为这里推0会有问题
                                                               0 LOC_DEPTH,
                                                               NVL(MMS.DISTRIBUTION_NUM,
                                                                   0) +
                                                               NVL(MMS.ARRIVE_NUM,
                                                                   0) ADVANCE_ARR_NUM,
                                                               MMS.FIRST_SORT_ID
                                                        --本次计算需要新增的供应商分组找到下面对应的零件分组
                                                          FROM MM_MP_SUPPLIER_SORT_TEMP AA,
                                                               MM_MP_PART               MMS
                                                         WHERE AA.SUPPLIER_NO =
                                                               MMS.SUPPLIER_NO
                                                           AND AA.SUP_FACTORY =
                                                               MMS.SUP_FACTORY
                                                           AND AA.CAL_STATUS = 0
                                                           AND AA.FACTORY_CODE =
                                                               in_arr_factory
                                                           AND MMS.FACTORY_CODE =
                                                               in_arr_factory
                                                           AND AA.UNLOAD_PORT =
                                                               MMS.UNLOAD_PORT
                                                           AND AA.SUPPLIER_NO =
                                                               v_supplier_list.SUPPLIER_NO
                                                           AND AA.SUP_FACTORY =
                                                               v_supplier_list.SUP_FACTORY
                                                           AND AA.FACTORY_CODE =
                                                               v_supplier_list.FACTORY_CODE
                                                           AND AA.UNLOAD_PORT =
                                                               v_supplier_list.UNLOAD_PORT
                                                           AND MMS.EFF_START <=
                                                               SYSDATE
                                                           AND MMS.EFF_END >
                                                               SYSDATE
                                                        UNION ALL
                                                        SELECT CGPS.SUPPLIER_NO,
                                                               CGPS.SUP_FACTORY,
                                                               CGPS.FACTORY_CODE,
                                                               CGPS.UNLOAD_PORT,
                                                               CGPS.WORKCENTER,
                                                               CGPS.PART_NO,
                                                               --判断订单履历的单号长度为14 将前面1到13位截取然后拼接上后面-1 的1 加上 1 等于2 20180829001Q-2
                                                               CASE
                                                                 WHEN LENGTH(CGPS.LOGISTICS_ORDER) = 14 THEN
                                                                  SUBSTR(CGPS.LOGISTICS_ORDER,
                                                                         1,
                                                                         13) ||
                                                                  TO_CHAR(TO_NUMBER(SUBSTR(CGPS.LOGISTICS_ORDER,
                                                                                           -1) + 1))
                                                                 ELSE
                                                                  CGPS.LOGISTICS_ORDER || '-1'
                                                               END LOGISTICS_ORDER,
                                                               CGPS.GROUP_ID,
                                                               CGPS.DR_SORT_ID_END,
                                                               CGPS.DR_SORT_ID_START,
                                                               CGPS.DR_SORT_ID_END,
                                                               CGPS.DR_SORT_ID_START,
                                                               (SELECT MAX(CTVS.CAR_TYPE_SORT_ID) CAR_TYPE_SORT_ID
                                                                  FROM MM_MP_CAR_TYPE_QUEUE CTVS
                                                                 WHERE NVL(CTVS.MULTI_CAR_TYPE,
                                                                           '%') =
                                                                       NVL(v_supplier_list.CAR_TYPE,
                                                                           '%')
                                                                   AND CTVS.CAR_TYPE_SORT_ID BETWEEN
                                                                       CGPS.USE_RANGE_SORT_ID_START AND
                                                                       CGPS.USE_RANGE_SORT_ID_END
                                                                   AND CTVS.FACTORY_CODE =
                                                                       v_supplier_list.FACTORY_CODE) LINE_SIDE_RANGE_SORT_ID_END,
                                                               CGPS.REAL_END_SORT_ID + 1 LINE_SIDE_RANGE_SORT_ID_START,
                                                               CGPS.USE_RANGE_SORT_ID_END,
                                                               CGPS.USE_RANGE_SORT_ID_START,
                                                               --MODIFY 2019-05-29 
                                                               NVL(MP2.ORDER_PACKAGE,
                                                                   1),
                                                               NVL(MP2.STANDARD_PACKAGE,
                                                                   1),
                                                               /*CGPS.ORDER_PACKAGE,
                                                               CGPS.STANDARD_PACKAGE,*/
                                                               CGPS.SUPPLY_RATE,
                                                               CGPS.ITEM_CALCULATE_NUM,
                                                               NVL(CGPS.IN_PLAN_FORWARD_TIME,
                                                                   0),
                                                               1
                                                          FROM MM_MP_PART_SORT CGPS
                                                        --MODIFY 2019-05-29关联订购零件基础信息表取包装数
                                                          LEFT JOIN MM_MP_PART MP2
                                                            ON CGPS.FACTORY_CODE =
                                                               MP2.FACTORY_CODE
                                                           AND CGPS.SUPPLIER_NO =
                                                               MP2.SUPPLIER_NO
                                                           AND CGPS.SUP_FACTORY =
                                                               MP2.SUP_FACTORY
                                                           AND CGPS.PART_NO =
                                                               MP2.PART_NO
                                                           AND CGPS.UNLOAD_PORT =
                                                               MP2.UNLOAD_PORT
                                                        --判断实际截止SORT_ID是否小于组截止SORT_ID如果小说明会产生差异订单
                                                         WHERE CGPS.REAL_END_SORT_ID <
                                                               CGPS.USE_RANGE_SORT_ID_END
                                                           AND CGPS.REAL_END_SORT_ID =
                                                               (SELECT MAX(D.REAL_END_SORT_ID)
                                                                  FROM MM_MP_PART_SORT_MAX D
                                                                 WHERE D.GROUP_ID =
                                                                       CGPS.GROUP_ID
                                                                   AND D.SUPPLIER_NO =
                                                                       CGPS.SUPPLIER_NO
                                                                   AND D.SUP_FACTORY =
                                                                       CGPS.SUP_FACTORY
                                                                   AND D.FACTORY_CODE =
                                                                       CGPS.FACTORY_CODE
                                                                   AND D.UNLOAD_PORT =
                                                                       CGPS.UNLOAD_PORT
                                                                   AND D.PART_NO =
                                                                       CGPS.PART_NO)
                                                           AND EXISTS
                                                        --并且在当前的分车型里面该车型中存在分车型排序号比真实截止SORT_ID大的车
                                                         (SELECT 1
                                                                  FROM MM_MP_CAR_TYPE_QUEUE E
                                                                 WHERE NVL(E.MULTI_CAR_TYPE,
                                                                           '%') =
                                                                       NVL(v_supplier_list.CAR_TYPE,
                                                                           '%')
                                                                   AND E.CAR_TYPE_SORT_ID BETWEEN
                                                                       CGPS.USE_RANGE_SORT_ID_START AND
                                                                       CGPS.USE_RANGE_SORT_ID_END
                                                                   AND E.CAR_TYPE_SORT_ID >
                                                                       CGPS.REAL_END_SORT_ID
                                                                   AND E.FACTORY_CODE =
                                                                       v_supplier_list.FACTORY_CODE)
                                                           AND CGPS.SUPPLIER_NO =
                                                               v_supplier_list.SUPPLIER_NO
                                                           AND CGPS.SUP_FACTORY =
                                                               v_supplier_list.SUP_FACTORY
                                                           AND CGPS.FACTORY_CODE =
                                                               v_supplier_list.FACTORY_CODE
                                                           AND CGPS.UNLOAD_PORT =
                                                               v_supplier_list.UNLOAD_PORT) A,
                                                       (SELECT CTQ.CAR_TYPE_SORT_ID CAR_TYPE_SORT_ID,
                                                               CTQ.SORT_ID,
                                                               NVL(CTQ.ADJ_AFOFF_TIME,
                                                                   NVL(CTQ.AFOFF_TIME,
                                                                       SYSDATE)) FINAL_UNDERLINE_TIME
                                                          FROM MM_MP_CAR_TYPE_QUEUE CTQ
                                                         WHERE NVL(CTQ.MULTI_CAR_TYPE,
                                                                   '%') =
                                                               NVL(v_supplier_list.CAR_TYPE,
                                                                   '%')
                                                           AND CTQ.FACTORY_CODE =
                                                               in_arr_factory) B
                                                 WHERE A.START_SORT_ID_NEW =
                                                       B.CAR_TYPE_SORT_ID(+)) AA,
                                               (SELECT CTQ1.CAR_TYPE_SORT_ID CAR_TYPE_SORT_ID,
                                                       CTQ1.SORT_ID,
                                                       TO_CHAR(NVL(CTQ1.ADJ_AFOFF_TIME,
                                                                   CTQ1.AFOFF_TIME),
                                                               'YYYY-MM-DD HH24:MI:SS') FINAL_UNDERLINE_TIME
                                                  FROM MM_MP_CAR_TYPE_QUEUE CTQ1
                                                 WHERE NVL(CTQ1.MULTI_CAR_TYPE,
                                                           '%') =
                                                       NVL(v_supplier_list.CAR_TYPE,
                                                           '%')
                                                   AND CTQ1.FACTORY_CODE =
                                                       in_arr_factory) BB
                                         WHERE AA.LINE_SIDE_SORT_ID =
                                               BB.SORT_ID) CC
                                 ORDER BY SUPPLIER_NO,
                                          SUP_FACTORY,
                                          UNLOAD_PORT,
                                          PART_NO,
                                          GROUP_ID) LOOP
        BEGIN
        
          --表明是厂内的零件查询车间的最大工深
          --取该零件的车间最大工深
          SELECT NVL(MAX(MIPL.LOCATION_NUM), 0)
            INTO v_location_num
            FROM MM_INV_PART_LOCATION MIPL
           WHERE MIPL.EFF_START <= SYSDATE
             AND MIPL.EFF_END > SYSDATE
             AND MIPL.PART_NO = v_part_group_list.PART_NO
             AND MIPL.SUPPLIER_NO = v_supplier_list.SUPPLIER_NO
             AND MIPL.WORKCENTER = v_supplier_list.WORKCENTER
           GROUP BY MIPL.WORKCENTER, MIPL.PART_NO, MIPL.FACTORY_CODE;
        
        EXCEPTION
          WHEN OTHERS THEN
            v_location_num := 0;
        END;
      
        --MODFIY 2019-06-05 修改，修改写法，效率
        /*--取得每个分组的组用量，以及该零件的采购层级
        SELECT NVL(CEIL(SUM(NVL(CCD.NUM, 0)) *
                        (NVL(v_part_group_list.SUPPLY_RATE, 100) / 100)),
                   0),
               MAX(CCD.PURCHASE_TYPE)
          INTO v_group_qty, v_purchase_type
          FROM MM_MP_CAR_TYPE_QUEUE CVS,
               (SELECT MML.*,
                       (SELECT A.SUPPLIER_NO
                          FROM MM_MP_PART A
                         WHERE A.PART_NO = MML.PART_NO
                           AND MML.FACTORY_CODE = in_arr_factory
                           AND A.PART_NO = v_part_group_list.PART_NO
                           AND A.EFF_START <= SYSDATE
                           AND A.EFF_END > SYSDATE
                           AND ROWNUM = 1) SUPPLIER_NO
                --加入支给件逻辑
                  FROM MM_MP_ORDER_BOM MML
                 WHERE MML.PURCHASE_TYPE IN ('W', 'AW', 'FW')
                   AND MML.PART_NO = v_part_group_list.PART_NO
                   AND MML.WORKCENTER = v_supplier_list.WORKCENTER) CCD
         WHERE CVS.CAR_TYPE_SORT_ID BETWEEN
               v_part_group_list.START_SORT_ID_NEW AND
               v_part_group_list.END_SORT_ID_NEW
           AND NVL(CVS.MULTI_CAR_TYPE, '%') =
               NVL(v_supplier_list.CAR_TYPE, '%')
           AND CVS.FACTORY_CODE = in_arr_factory
           AND CVS.ORDER_NO = CCD.ORDER_NO
           AND CCD.PART_NO = v_part_group_list.PART_NO
           AND CCD.WORKCENTER = v_supplier_list.WORKCENTER
           AND CCD.SUPPLIER_NO = v_supplier_list.SUPPLIER_NO;*/
      
        SELECT NVL(CEIL(SUM(NVL(CCD.NUM, 0)) *
                        (NVL(v_part_group_list.SUPPLY_RATE, 100) / 100)),
                   0),
               MAX(CCD.PURCHASE_TYPE)
          INTO v_group_qty, v_purchase_type
          FROM MM_MP_CAR_TYPE_QUEUE CVS, Mm_Mp_Order_Bom CCD
         WHERE CVS.CAR_TYPE_SORT_ID BETWEEN
               v_part_group_list.START_SORT_ID_NEW AND
               v_part_group_list.END_SORT_ID_NEW
           AND NVL(CVS.MULTI_CAR_TYPE, '%') =
               NVL(v_supplier_list.CAR_TYPE, '%')
           AND CVS.FACTORY_CODE = in_arr_factory
           AND CCD.FACTORY_CODE = CVS.FACTORY_CODE
           AND CVS.ORDER_NO = CCD.ORDER_NO
           AND CCD.PART_NO = v_part_group_list.PART_NO
           AND CCD.WORKCENTER = v_supplier_list.WORKCENTER
           AND CCD.PURCHASE_TYPE IN ('W', 'AW', 'FW')
           AND CCD.PART_NO IN
               (SELECT A.PART_NO
                  FROM MM_MP_PART A
                 WHERE A.FACTORY_CODE = CCD.FACTORY_CODE
                   AND A.PART_NO = CCD.PART_NO
                   AND A.SUPPLIER_NO = v_supplier_list.SUPPLIER_NO
                   AND A.EFF_START <= SYSDATE
                   AND A.EFF_END > SYSDATE);
      
        --物流订单号排序
        IF (v_supplier_id_tmp = v_supplier_list.SUPPLIER_NO AND
           v_factory_id_tmp = v_supplier_list.SUP_FACTORY AND
           v_aog_factory_tmp = v_supplier_list.FACTORY_CODE AND
           v_unload_port_tmp = v_supplier_list.UNLOAD_PORT AND
           v_underline_time_start_tmp =
           TO_CHAR(TRUNC(v_part_group_list.ARRIVE_TIME), 'YYYYMMDD') AND
           v_part_group_list.LOGISTICS_ORDER IS NULL AND
           v_part_id_tmp = v_part_group_list.PART_NO) THEN
          v_int := v_int + 1;
        ELSE
          v_int := 0;
        END IF;
      
        --Modify 2019-05-31
        --将获取车间最大值放到循环外面
        /*--表明没有维护这个零件，工位的工深数据,查询当前车间的最大工深数据
        BEGIN
          --判断如果是总装
          SELECT NVL(A.PARAM_VAL, 0)
            INTO v_af_max_loc
            FROM MM_PUB_SYS_PARAM A
           WHERE A.PARAM_GROUP = 'MAX_LOC'
             AND A.FACTORY_CODE = in_arr_factory
             AND A.PARAM_CODE = 'AF_TOTAL_PRO_NUM';
        
          --判断如果是焊装
          SELECT NVL(A.PARAM_VAL, 0)
            INTO v_we_max_loc
            FROM MM_PUB_SYS_PARAM A
           WHERE A.PARAM_GROUP = 'MAX_LOC'
             AND A.FACTORY_CODE = in_arr_factory
             AND A.PARAM_CODE = 'WE_TOTAL_PRO_NUM';
        
          --判断如果是涂装
          SELECT NVL(A.PARAM_VAL, 0)
            INTO v_pa_max_loc
            FROM MM_PUB_SYS_PARAM A
           WHERE A.PARAM_GROUP = 'MAX_LOC'
             AND A.FACTORY_CODE = in_arr_factory
             AND A.PARAM_CODE = 'PA_TOTAL_PRO_NUM';
          --判断如果是涂装
          SELECT NVL(A.PARAM_VAL, 0)
            INTO v_wbs_max_loc
            FROM MM_PUB_SYS_PARAM A
           WHERE A.PARAM_GROUP = 'MAX_LOC'
             AND A.FACTORY_CODE = in_arr_factory
             AND A.PARAM_CODE = 'WBS_TOTAL_PRO_NUM';
        
          --判断如果是涂装
          SELECT NVL(A.PARAM_VAL, 0)
            INTO v_pbs_max_loc
            FROM MM_PUB_SYS_PARAM A
           WHERE A.PARAM_GROUP = 'MAX_LOC'
             AND A.FACTORY_CODE = in_arr_factory
             AND A.PARAM_CODE = 'PBS_TOTAL_PRO_NUM';
        END;*/
      
        --工深计算
        IF v_supplier_list.WORKCENTER = 'A1' AND NVL(v_location_num, 0) = 0 THEN
          v_location_num := v_af_max_loc;
        ELSIF v_supplier_list.WORKCENTER = 'A1' AND
              NVL(v_location_num, 0) != 0 THEN
          v_location_num := NVL(v_location_num, 0);
        ELSIF v_supplier_list.WORKCENTER = 'T1' AND
              NVL(v_location_num, 0) = 0 THEN
          v_location_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc;
        ELSIF v_supplier_list.WORKCENTER = 'T1' AND
              NVL(v_location_num, 0) != 0 THEN
          v_location_num := v_af_max_loc + v_pbs_max_loc +
                            NVL(v_location_num, 0);
        ELSIF v_supplier_list.WORKCENTER = 'W1' AND
              NVL(v_location_num, 0) = 0 THEN
          v_location_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc +
                            v_wbs_max_loc + v_we_max_loc;
        ELSIF v_supplier_list.WORKCENTER = 'W1' AND
              NVL(v_location_num, 0) != 0 THEN
          v_location_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc +
                            v_wbs_max_loc + NVL(v_location_num, 0);
        ELSE
          --支给件使用总装最大工深计算
          v_location_num := v_af_max_loc;
        END IF;
      
        IF v_supplier_list.WORKCENTER IN ('A1', 'W1', 'T1') THEN
          --计算到货时间
          v_arrive_time := PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                        v_supplier_list.WORKCENTER,
                                                        v_part_group_list.ARRIVE_TIME,
                                                        - (v_location_num *
                                                          v_tact));
        ELSE
          --计算到货时间
          v_arrive_time := PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                        'A1',
                                                        v_part_group_list.ARRIVE_TIME,
                                                        - (v_location_num *
                                                          v_tact));
        END IF;
      
        --获取物流订单号
        IF v_part_group_list.LOGISTICS_ORDER IS NULL THEN
          SELECT USP_MM_MP_CUX_GET_LOG_ORDER(v_supplier_list.Supplier_No,
                                             v_supplier_list.Sup_Factory,
                                             v_supplier_list.Factory_Code,
                                             v_supplier_list.Unload_Port,
                                             TO_CHAR(TRUNC(v_arrive_time),
                                                     'YYYYMMDD')) + v_int || 'Q' LOGISTICS_ORDER
            INTO v_logistics_order
            FROM DUAL;
        ELSE
          v_logistics_order := v_part_group_list.LOGISTICS_ORDER;
        END IF;
        --将零件分组写入临时表
        INSERT INTO MM_MP_PART_SORT_TEMP
          (ID,
           SUPPLIER_NO,
           SUP_FACTORY,
           FACTORY_CODE,
           UNLOAD_PORT,
           WORKCENTER,
           PART_NO,
           GROUP_ID,
           LOGISTICS_ORDER,
           DR_SORT_ID_START,
           DR_SORT_ID_END,
           LR_SORT_ID_START,
           LR_SORT_ID_END,
           FINAL_UNDERLINE_TIME_START,
           FINAL_UNDERLINE_TIME_START_NEW,
           GROUP_QTY,
           ORDER_PACKAGE,
           STANDARD_PACKAGE,
           SUPPLY_RATE,
           CAL_STATUS,
           ITEM_CALCULATE_NUM,
           ARRIVE_TIME,
           LINE_SIDE_TIME,
           LINE_SIDE_SORT_ID,
           USE_RANGE_SORT_ID_START,
           USE_RANGE_SORT_ID_END,
           REAL_END_SORT_ID,
           PURCHASE_TYPE,
           CAR_TYPE,
           IN_PLAN_FORWARD_TIME)
        VALUES
          (SEQ_MM_MP_PART_SORT.NEXTVAL,
           v_supplier_list.SUPPLIER_NO,
           v_supplier_list.SUP_FACTORY,
           v_supplier_list.FACTORY_CODE,
           v_supplier_list.UNLOAD_PORT,
           v_supplier_list.WORKCENTER,
           v_part_group_list.PART_NO,
           v_part_group_list.GROUP_ID,
           v_logistics_order,
           v_part_group_list.DR_SORT_ID_START,
           v_part_group_list.DR_SORT_ID_END,
           v_part_group_list.START_SORT_ID_NEW,
           v_part_group_list.END_SORT_ID_NEW,
           v_part_group_list.LINE_SIDE_TIME,
           v_arrive_time,
           v_group_qty,
           v_part_group_list.PACK_QUANTITY,
           v_part_group_list.STANDARD_PACKAGE,
           v_part_group_list.SUPPLY_RATE,
           '0',
           v_location_num,
           v_arrive_time,
           --v_part_group_list.ARRIVE_TIME,
           v_arrive_time,
           v_part_group_list.LINE_SIDE_SORT_ID,
           v_part_group_list.USE_RANGE_SORT_ID_START,
           v_part_group_list.USE_RANGE_SORT_ID_END,
           v_part_group_list.REAL_END_SORT_ID,
           v_purchase_type,
           v_supplier_list.CAR_TYPE,
           v_part_group_list.ADVANCE_ARR_NUM);
      
        IF (LENGTH(v_logistics_order) = 14) THEN
          v_part_id_tmp := 'RE';
        ELSE
          v_supplier_id_tmp          := v_supplier_list.SUPPLIER_NO;
          v_factory_id_tmp           := v_supplier_list.Sup_Factory;
          v_aog_factory_tmp          := v_supplier_list.Factory_Code;
          v_unload_port_tmp          := v_supplier_list.Unload_Port;
          v_part_id_tmp              := v_part_group_list.PART_NO;
          v_underline_time_start_tmp := TO_CHAR(TRUNC(v_part_group_list.ARRIVE_TIME),
                                                'YYYYMMDD');
        END IF;
      
        COMMIT;
      
      END LOOP;
    
      -- 删除没有产生零件分组的供应商分组数据
      DELETE FROM MM_MP_SUPPLIER_SORT_TEMP SST
       WHERE NOT EXISTS
       (SELECT 1
                FROM MM_MP_PART_SORT_TEMP PST
               WHERE PST.SUPPLIER_NO = SST.SUPPLIER_NO
                 AND PST.UNLOAD_PORT = SST.UNLOAD_PORT
                 AND PST.GROUP_ID = SST.GROUP_ID
                 AND PST.FACTORY_CODE = SST.FACTORY_CODE)
         AND SST.SUPPLIER_NO = v_supplier_list.SUPPLIER_NO
         AND SST.UNLOAD_PORT = v_supplier_list.UNLOAD_PORT
         AND SST.SUP_FACTORY = v_supplier_list.SUP_FACTORY
         AND SST.FACTORY_CODE = v_supplier_list.FACTORY_CODE;
    
    END LOOP;
    COMMIT;
  
    --净需求订单处理
    USP_MP_ZSB_MAIN_ORDER(in_arr_factory);
  
  END;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_REQ_ZSB_INIT
  --功能描述：初始化供应商分组，零件分组最大值
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/10
  PROCEDURE USP_MP_REQ_ZSB_INIT(in_arr_factory IN VARCHAR2) AS
  
  BEGIN
    DELETE FROM MM_MP_SUPPLIER_SORT_MAX A
     WHERE A.FACTORY_CODE = in_arr_factory;
  
    DELETE FROM MM_MP_PART_SORT_MAX A
     WHERE A.FACTORY_CODE = in_arr_factory;
  
    --初始化供应商分组最大值
    INSERT INTO MM_MP_SUPPLIER_SORT_MAX
      (SUPPLIER_NO,
       SUP_FACTORY,
       FACTORY_CODE,
       UNLOAD_PORT,
       DR_SORT_ID_START,
       DR_SORT_ID_END,
       GROUP_ID)
      SELECT A.SUPPLIER_NO,
             A.SUP_FACTORY,
             A.FACTORY_CODE,
             A.UNLOAD_PORT,
             MAX(A.DR_SORT_ID_START),
             MAX(A.DR_SORT_ID_END),
             MAX(A.GROUP_ID)
        FROM MM_MP_SUPPLIER_SORT A
       WHERE A.FACTORY_CODE = in_arr_factory
       GROUP BY A.SUPPLIER_NO, A.SUP_FACTORY, A.UNLOAD_PORT, A.FACTORY_CODE;
  
    --初始化零件分组最大值
    INSERT INTO MM_MP_PART_SORT_MAX
      (SUPPLIER_NO,
       SUP_FACTORY,
       FACTORY_CODE,
       UNLOAD_PORT,
       PART_NO,
       GROUP_ID,
       REAL_END_SORT_ID,
       DR_SORT_ID_START,
       DR_SORT_ID_END,
       LINE_SIDE_SORT_ID,
       LR_SORT_ID_END)
      SELECT A.SUPPLIER_NO,
             A.SUP_FACTORY,
             A.FACTORY_CODE,
             A.UNLOAD_PORT,
             A.PART_NO,
             MAX(A.GROUP_ID),
             MAX(A.REAL_END_SORT_ID),
             MAX(A.DR_SORT_ID_START),
             MAX(A.DR_SORT_ID_END),
             MAX(A.LINE_SIDE_SORT_ID),
             MAX(A.LR_SORT_ID_END)
        FROM MM_MP_PART_SORT A
       WHERE A.FACTORY_CODE = in_arr_factory
         AND A.GROUP_ID IS NOT NULL
       GROUP BY A.SUPPLIER_NO,
                A.SUP_FACTORY,
                A.FACTORY_CODE,
                A.UNLOAD_PORT,
                A.PART_NO;
  
    COMMIT;
  END;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_VEH_STANDARD
  --功能描述：分车型调整
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/12
  PROCEDURE USP_MP_VEH_STANDARD(in_arr_factory IN VARCHAR2) AS
  
    CURSOR CUX_SUPPLIER_CARTYPE_LIST IS
      SELECT DISTINCT A.SORT_ID        real_car_sort_id,
                      A.MULTI_CAR_TYPE car_type,
                      A.FACTORY_CODE   factory_code
        FROM MM_MP_CAR_TYPE_NODE A
       WHERE A.FACTORY_CODE = in_arr_factory
       ORDER BY A.MULTI_CAR_TYPE;
  
    v_car_type_sort_id NUMBER := 0;
  BEGIN
    FOR V_CAR_TYPE_LIST IN CUX_SUPPLIER_CARTYPE_LIST LOOP
      BEGIN
        BEGIN
          --从上次计算的分车型队列中找到每个车型的最大分车型号
          --用这个分车型号加上本次SN得到该辆车在该车型的分车型号
          SELECT NVL(MAX(A.CAR_TYPE_SORT_ID), 0)
            INTO v_car_type_sort_id
            FROM MM_MP_CAR_TYPE_QUEUE A
           WHERE NVL(A.MULTI_CAR_TYPE, '%') =
                 NVL(V_CAR_TYPE_LIST.CAR_TYPE, '%')
             AND A.FACTORY_CODE = V_CAR_TYPE_LIST.FACTORY_CODE;
        EXCEPTION
          WHEN OTHERS THEN
            v_car_type_sort_id := 0;
        END;
        --插入分车型
        INSERT INTO MM_MP_CAR_TYPE_QUEUE
          (FACTORY_CODE,
           CAR_TYPE_SORT_ID,
           MULTI_CAR_TYPE,
           SORT_ID,
           ORDER_NO,
           PLAN_NUM,
           AFOFF_TIME,
           ADJ_AFOFF_TIME,
           CAR_TYPE,
           CREATION_USER,
           CREATION_TIME)
          SELECT MES.FACTORY_CODE,
                 --使用当前车型最大的分车型号加上该辆车在该车型队列排序号得到这辆车在该车型排序里面的分车型排序号
                 v_car_type_sort_id + BB.SN,
                 V_CAR_TYPE_LIST.CAR_TYPE,
                 MES.SORT_ID,
                 MES.ORDER_NO,
                 1,
                 MES.AFOFF_TIME,
                 MES.AFOFF_TIME,
                 MES.CAR_TYPE,
                 'admin',
                 sysdate
            FROM MM_MP_VEH_PLAN MES,
                 (SELECT MES.SORT_ID BK,
                         --按照SORT_ID排序给定增长值为SN
                         ROW_NUMBER() OVER(ORDER BY MES.SORT_ID ASC) SN,
                         MES.CAR_TYPE
                    FROM MM_MP_VEH_PLAN MES
                   WHERE NOT EXISTS
                  --根据车型和sort_id将MM_MP_VEH_PLAN中不存在于当前循环的分车型队列，并且车型能匹配上的车辆找出
                   (SELECT 1
                            FROM MM_MP_CAR_TYPE_QUEUE A
                           WHERE MES.SORT_ID = A.SORT_ID
                             AND NVL(A.MULTI_CAR_TYPE, '%') =
                                 NVL(V_CAR_TYPE_LIST.CAR_TYPE, '%')
                             AND A.FACTORY_CODE =
                                 V_CAR_TYPE_LIST.FACTORY_CODE)
                     AND MES.FACTORY_CODE = V_CAR_TYPE_LIST.FACTORY_CODE
                        --车型匹配，因为在分车型队列中存在A16,A28这种数据
                        --所以在这种队列中需要将MM_MP_VEH_PLAN中满足条件的A16和A28找出并按照sort_id排序
                     AND (',' || NVL(V_CAR_TYPE_LIST.CAR_TYPE,
                                     NVL(MES.CAR_TYPE, '%')) || ',' LIKE
                         '%' || NVL(MES.CAR_TYPE, '%') || '%')
                   ORDER BY MES.SORT_ID) BB
           WHERE MES.SORT_ID = BB.BK
             AND MES.FACTORY_CODE = V_CAR_TYPE_LIST.FACTORY_CODE
             AND NOT EXISTS
           (SELECT 1
                    FROM MM_MP_CAR_TYPE_QUEUE C
                   WHERE MES.SORT_ID = SORT_ID
                     AND NVL(C.MULTI_CAR_TYPE, '%') =
                         NVL(V_CAR_TYPE_LIST.CAR_TYPE, '%')
                     AND C.CAR_TYPE_SORT_ID >
                         V_CAR_TYPE_LIST.REAL_CAR_SORT_ID
                     AND C.FACTORY_CODE = V_CAR_TYPE_LIST.FACTORY_CODE)
           ORDER BY MES.SORT_ID;
      
        --更新分车型排序号
        UPDATE MM_MP_CAR_TYPE_QUEUE A
           SET A.CAR_TYPE_SORT_ID =
               (WITH TMP AS (SELECT ROW_NUMBER() OVER(ORDER BY MES.SORT_ID ASC) SN,
                                    MES.SORT_ID
                               FROM MM_MP_VEH_PLAN MES
                              WHERE MES.FACTORY_CODE =
                                    V_CAR_TYPE_LIST.FACTORY_CODE
                                AND (',' ||
                                    NVL(V_CAR_TYPE_LIST.CAR_TYPE,
                                         NVL(MES.CAR_TYPE, '%')) || ',' LIKE
                                    '%' || NVL(MES.CAR_TYPE, '%') || ',%'))
                 SELECT TMP.SN
                   FROM TMP TMP
                  WHERE A.SORT_ID = TMP.SORT_ID)
                  WHERE EXISTS
                  (SELECT 1
                           FROM (SELECT MES.SORT_ID BK,
                                        ROW_NUMBER() OVER(ORDER BY MES.SORT_ID ASC) SN,
                                        MES.CAR_TYPE
                                   FROM MM_MP_VEH_PLAN MES
                                  WHERE MES.FACTORY_CODE =
                                        V_CAR_TYPE_LIST.FACTORY_CODE
                                    AND (',' ||
                                        NVL(V_CAR_TYPE_LIST.CAR_TYPE,
                                             NVL(MES.CAR_TYPE, '%')) || ',' LIKE
                                        '%,' || NVL(MES.CAR_TYPE, '%') || ',%')
                                  ORDER BY MES.SORT_ID) B
                          WHERE A.SORT_ID = B.BK
                            AND NVL(A.CAR_TYPE_SORT_ID, 0) != B.SN
                            AND A.FACTORY_CODE = V_CAR_TYPE_LIST.FACTORY_CODE)
                       --当前循环的车型等于车型队列里面的车型
                    AND NVL(A.MULTI_CAR_TYPE, '%') =
                        NVL(V_CAR_TYPE_LIST.CAR_TYPE, '%')
                    AND A.CAR_TYPE_SORT_ID >
                        V_CAR_TYPE_LIST.REAL_CAR_SORT_ID
                    AND A.FACTORY_CODE = V_CAR_TYPE_LIST.FACTORY_CODE;
      
      
      END;
    END LOOP;
  END USP_MP_VEH_STANDARD;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_ZSB_MAIN_ORDER
  --功能描述：订单处理
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/014
  PROCEDURE USP_MP_ZSB_MAIN_ORDER(in_arr_factory IN VARCHAR2) AS
    v_tact NUMBER := 0;
  BEGIN
    --节拍标识
    SELECT PRODUCE_TIME
      INTO v_tact
      FROM (SELECT A.PRODUCE_TIME, COUNT(1) NUM
              FROM MM_PUB_TACT_TIME A
             WHERE A.WORKCENTER = 'A1'
               AND A.PRODUCTION_LINE = 'AF_MAIN'
             GROUP BY A.PRODUCE_TIME
             ORDER BY NUM DESC)
     WHERE ROWNUM = 1;
  
    --写入订单履历临时表
    INSERT INTO MM_MP_ORDER_RECORD
      (PLAN_ORDER_ID,
       SUPPLIER_NO,
       SUP_FACTORY,
       FACTORY_CODE,
       UNLOAD_PORT,
       PART_NO,
       PART_UNIT,
       DEFECT_NUM,
       SAFE_NUM,
       ADJ_DIFF_NUM,
       NECESSARY_NET_NUM,
       NECESSARY_ORDER_RESIDUAL,
       NECESSARY_REAL_ORDER_NUM,
       NECESSARY_PLAN_NUM,
       NECESSARY_REAL_RESIDUAL_NUM,
       ORDER_NUM,
       TOTAL_ORDER_NUM,
       TOTAL_ORDER_BOX,
       ADJ_BOX,
       ADJ_ORDER_NUM,
       ARRIVE_TIME,
       LOGISTICS_FLAG,
       LOGISTICS_ORDER,
       ORDER_STATUS,
       ORDER_ISSUE_DATE,
       SHIPMENT_DATE,
       PREPARE_TIME,
       DR_SORT_ID_START,
       DR_SORT_ID_END,
       LR_SORT_ID_START,
       LR_SORT_ID_END,
       PART_GROUP_ID,
       GROUP_ID,
       ORDER_PACKAGE,
       STANDARD_PACKAGE,
       PURCHASE_TYPE,
       ORDER_DEPOT)
      SELECT NVL((SELECT MAX(C.PLAN_ORDER_ID) + 1
                   FROM (SELECT A.PLAN_ORDER_ID
                           FROM MM_MP_ORDER_RECORD A
                          WHERE A.FACTORY_CODE = in_arr_factory
                         UNION
                         SELECT B.PLAN_ORDER_ID
                           FROM MM_MP_ORDER_RECORD_HIS B
                          WHERE B.FACTORY_CODE = in_arr_factory) C
                  WHERE SUBSTR(C.PLAN_ORDER_ID, 1, 8) =
                        TO_CHAR(SYSDATE, 'YYYYMMDD')
                  GROUP BY SUBSTR(C.PLAN_ORDER_ID, 1, 8)),
                 TO_CHAR(SYSDATE, 'YYYYMMDD') || '00001') + ROWNUM - 1,
             CGP.SUPPLIER_NO,
             CGP.SUP_FACTORY,
             CGP.FACTORY_CODE,
             CGP.UNLOAD_PORT,
             CGP.PART_NO,
             (SELECT D.PART_UNIT
                FROM MM_PUB_PART D
               WHERE D.PART_NO = CGP.PART_NO
                 AND ROWNUM = 1),
             0, --不良品数量
             0, --安全库存
             0, --计划调整差异量
             CGP.GROUP_QTY, --净需求
             0, --订购前余量
             0, --必要数实际订购数量
             0, --必要数计划数量
             0, --必要数实际剩余量
             CGP.GROUP_QTY, --订购数量
             0, --总订购数量
             0, --总订购箱数
             0, --调整箱数
             0, --调整总订购数量
             CGP.ARRIVE_TIME,
             MP.LOGISTICS_FLAG,
             CGP.LOGISTICS_ORDER,
             '3', --订单状态
             --?????
             SYSDATE, --订单发行日等于到货时间减去供应商准备时间和运输时间，现在没维护数据
             --??????
             CASE
               WHEN MP.WORKCENTER IN ('A1', 'T1', 'W1') THEN
                PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                             MP.WORKCENTER,
                                             CGP.ARRIVE_TIME,
                                             - (NVL(MP.DELIVERY_NUM, 0) *
                                               v_tact))
               ELSE
               --支给件按照总装计算
                PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                             'A1',
                                             CGP.ARRIVE_TIME,
                                             - (NVL(MP.DELIVERY_NUM, 0) *
                                               v_tact))
             END plan_delivery_time,
             /*PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
             MP.WORKCENTER,
             CGP.ARRIVE_TIME,
             - (NVL(MP.DELIVERY_NUM, 0) * v_tact)) plan_delivery_time, --供应商出货时间等于到货时间减去发货提前台套数*节拍*/
             --??????
             CASE
               WHEN MP.WORKCENTER IN ('A1', 'T1', 'W1') THEN
                PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                             MP.WORKCENTER,
                                             CGP.ARRIVE_TIME,
                                             - ((NVL(MP.DELIVERY_NUM, 0) +
                                               NVL(MP.PREPARE_NUM, 0)) *
                                               v_tact))
               ELSE
                PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                             'A1',
                                             CGP.ARRIVE_TIME,
                                             - ((NVL(MP.DELIVERY_NUM, 0) +
                                               NVL(MP.PREPARE_NUM, 0)) *
                                               v_tact))
             END plan_prepare_time,
             /*PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
             MP.WORKCENTER,
             CGP.ARRIVE_TIME,
             - ((NVL(MP.DELIVERY_NUM, 0) +
               NVL(MP.PREPARE_NUM, 0)) * v_tact)) plan_prepare_time, */ --供应商出货时间等于到货时间减去(发货提前台套数+备件提前台套数)*节拍
             CGP.DR_SORT_ID_START,
             CGP.DR_SORT_ID_END,
             CGP.LR_SORT_ID_START,
             CGP.LR_SORT_ID_END,
             CGP.ID, --零件分组唯一标识
             CGP.GROUP_ID,
             CGP.ORDER_PACKAGE,
             CGP.STANDARD_PACKAGE,
             CGP.PURCHASE_TYPE,
             MP.ORDER_DEPOT
        FROM MM_MP_PART_SORT_TEMP CGP, MM_MP_PART MP
       WHERE CGP.GROUP_QTY != 0
         AND CGP.DR_SORT_ID_START IS NOT NULL
         AND CGP.SUPPLIER_NO = MP.SUPPLIER_NO
         AND CGP.SUP_FACTORY = MP.SUP_FACTORY
         AND CGP.FACTORY_CODE = MP.FACTORY_CODE
         AND CGP.UNLOAD_PORT = MP.UNLOAD_PORT
         AND CGP.PART_NO = MP.PART_NO
         AND CGP.FACTORY_CODE = in_arr_factory;
  END USP_MP_ZSB_MAIN_ORDER;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_ZSB_DEAL_PACK
  --功能描述：包装处理
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/15
  PROCEDURE USP_MP_ZSB_DEAL_PACK(in_arr_factory IN VARCHAR2) AS
  
    --定义订单履历游标
    CURSOR cur_order_list(in_arr_factory VARCHAR2) IS
      SELECT *
        FROM MM_MP_ORDER_RECORD A
       WHERE A.ORDER_STATUS = '3'
         AND A.FACTORY_CODE = in_arr_factory
       ORDER BY A.SUPPLIER_NO,
                A.SUP_FACTORY,
                A.FACTORY_CODE,
                A.UNLOAD_PORT,
                A.PART_NO,
                A.GROUP_ID ASC;
  
    -- 必要数订购剩余量
    var_necessary_order_residual NUMBER(9, 0) := 0;
    -- 计划调整差异数量
    var_adj_diff_num NUMBER(9, 0) := 0;
    -- 不良净数量
    var_def_num NUMBER(9, 0) := 0;
    --安全库存
    var_safe_num NUMBER(9, 0) := 0;
    --使用安全库存量
    /*var_use_safe_num NUMBER(9, 0) := 0;*/
  
    -- 包装数量
    var_pack_num NUMBER(9, 0) := 0;
    -- 必要数净数量
    var_necessary_net_num NUMBER(9, 0) := 0;
    -- 必要数计划数量
    var_necessary_plan_num NUMBER(9, 0) := 0;
    -- 必要数实际订购数量
    var_necessary_real_order_num NUMBER(9, 0) := 0;
    -- 必要数订购剩余量
    var_to_update_necessary_count NUMBER(9, 0) := 0;
  
    v_count_flag         NUMBER := 0;
    var_item_flag        VARCHAR2(100);
    var_supplierid_flag  VARCHAR2(100);
    var_factoryid_flag   VARCHAR2(100);
    var_factorycode_flag VARCHAR2(100);
    var_unloadport_flag  VARCHAR2(100);
    cur_date             date;
  
  BEGIN
    --调用存储计算计划差异
    /*USP_MP_ZSB_DIFF_PLAN(in_arr_factory);*/
  
    --先将不良品中使用状态为1的数据使用状态更新为0
    UPDATE MM_DPM_INS A
       SET A.USE_FLAG = 0
     WHERE A.USE_FLAG = 1
       AND A.ORDER_STATUS = 0
       AND A.FACTORY_CODE = in_arr_factory;
  
    -- 循环开始(第一层）
    --判断是不是和上一次循环的零件，供应商，出货地，卸货口，工厂是否相同，若相同则使用上一个组的剩余量
    FOR order_vo IN cur_order_list(in_arr_factory) LOOP
    
      --每个组都把安全库存查询出来
      BEGIN
        SELECT A.SAFE_NUM
          INTO var_safe_num
          FROM MM_MP_PART A
         WHERE A.PART_NO = order_vo.PART_NO
           AND A.FACTORY_CODE = in_arr_factory
           AND A.EFF_START <= SYSDATE
           AND A.EFF_END > SYSDATE
           AND A.SUPPLIER_NO = order_vo.SUPPLIER_NO
           AND A.SUP_FACTORY = order_vo.SUP_FACTORY
           AND A.FACTORY_CODE = order_vo.FACTORY_CODE
           AND A.UNLOAD_PORT = order_vo.Unload_Port;
      EXCEPTION
        WHEN OTHERS THEN
          var_safe_num := 0;
      END;
    
      IF v_count_flag != 0 AND var_item_flag = ORDER_VO.PART_NO AND
         var_item_flag IS NOT NULL AND
         var_unloadport_flag = order_vo.UNLOAD_PORT AND
         var_factoryid_flag = order_vo.SUP_FACTORY AND
         var_supplierid_flag = order_vo.SUPPLIER_NO AND
         var_factorycode_flag = order_vo.FACTORY_CODE THEN
        var_necessary_order_residual := var_to_update_necessary_count;
      ELSE
        BEGIN
          --若不相同则从零件剩余量表中查询剩余量
          SELECT NVL(A.MANU_RESIDUAL, NVL(A.REAL_RESIDUAL_NUM, 0))
            INTO var_necessary_order_residual
            FROM MM_MP_RESIDUAL A
           WHERE A.SUPPLIER_NO = order_vo.SUPPLIER_NO
             AND A.SUP_FACTORY = order_vo.SUP_FACTORY
             AND A.FACTORY_CODE = order_vo.FACTORY_CODE
             AND A.UNLOAD_PORT = order_vo.Unload_Port
             AND A.PART_NO = order_vo.PART_NO;
        EXCEPTION
          WHEN OTHERS THEN
            var_necessary_order_residual := 0;
        END;
        BEGIN
          --若不相同则从差异量表中获取该路线该零件的差异量
          SELECT NVL(A.ADJ_DIFF_NUM, 0)
            INTO var_adj_diff_num
            FROM MM_MP_PLAN_DIFF_TEMP A
           WHERE A.SUPPLIER_NO = order_vo.SUPPLIER_NO
             AND A.SUP_FACTORY = order_vo.SUP_FACTORY
             AND A.FACTORY_CODE = order_vo.FACTORY_CODE
             AND A.UNLOAD_PORT = order_vo.Unload_Port
             AND A.PART_NO = order_vo.PART_NO;
        EXCEPTION
          WHEN OTHERS THEN
            var_adj_diff_num := 0;
        END;
      
        --找出当前不良品中状态为未处理的不良品数据
        FOR cur_def IN (SELECT B.APPLY_NO, B.DPM_NUM, B.FACTORY_CODE
                          FROM MM_DPM_INS B,
                               (SELECT A.SUPPLIER_NO, A.CAR_TYPE
                                  FROM (SELECT DISTINCT MP.SUPPLIER_NO,
                                                        MP.SUP_FACTORY,
                                                        MP.FACTORY_CODE,
                                                        MP.UNLOAD_PORT,
                                                        MP.MODEL_CODE CAR_TYPE
                                          FROM MM_MP_PART MP
                                         WHERE MP.FACTORY_CODE =
                                               in_arr_factory
                                           AND MP.ORDER_PRODUCT_NUM > 0
                                           AND MP.EFF_START <= SYSDATE
                                           AND MP.EFF_END > SYSDATE) A
                                 WHERE A.SUPPLIER_NO = order_vo.SUPPLIER_NO
                                   AND A.SUP_FACTORY = order_vo.SUP_FACTORY
                                   AND A.UNLOAD_PORT = order_vo.UNLOAD_PORT
                                   AND A.FACTORY_CODE = in_arr_factory
                                      --取第一行
                                   AND ROWNUM = 1) C
                        --订单生成状态为未生成
                         WHERE B.ORDER_STATUS = 0
                              --表单状态不是未提交
                           AND B.INS_STATUS = 2
                           AND B.EXCEP_STATUS = 0
                           AND B.PART_NO = order_vo.PART_NO
                           AND B.FACTORY_CODE = in_arr_factory
                           AND B.SUPPLIER_NO = C.SUPPLIER_NO
                           AND C.CAR_TYPE LIKE '%' || B.MODEL_CODE || '%') LOOP
          --将不良品数量累加
          var_def_num := var_def_num + cur_def.DPM_NUM;
        
          UPDATE MM_DPM_INS A
             SET A.USE_FLAG = 1
           WHERE A.APPLY_NO = cur_def.APPLY_NO
             AND A.FACTORY_CODE = cur_def.FACTORY_CODE;
        END LOOP;
      END IF;
    
      -- 包装数量
      var_pack_num := NVL(order_vo.ORDER_PACKAGE, 1);
    
      --必要数相关处理
      IF (order_vo.NECESSARY_NET_NUM IS NOT NULL AND
         order_vo.NECESSARY_NET_NUM != 0) THEN
        -- 必要数净数量
        var_necessary_net_num := order_vo.NECESSARY_NET_NUM;
      
        IF (var_necessary_net_num + var_def_num + var_adj_diff_num <=
           var_necessary_order_residual) THEN
          -- 必要数计划数量
          var_necessary_plan_num := 0;
          -- 必要数实际订购数量
          var_necessary_real_order_num := 0;
          -- 必要数实际剩余量
          var_to_update_necessary_count := var_necessary_order_residual -
                                           var_necessary_net_num -
                                           var_def_num - var_adj_diff_num;
        
        ELSE
          -- 必要数计划数量
          var_necessary_plan_num := var_necessary_net_num + var_def_num +
                                    var_adj_diff_num -
                                    var_necessary_order_residual;
          -- 必要数实际订购数量
          var_necessary_real_order_num := ceil(var_necessary_plan_num /
                                               var_pack_num) * var_pack_num;
          -- 必要数订购剩余量
          var_to_update_necessary_count := var_necessary_real_order_num -
                                           var_necessary_plan_num;
        
        END IF;
      
        --判断当前组的余量是否比安全库存大，如果小于安全库存则需要另外订购安全库存的数量
        IF var_to_update_necessary_count < var_safe_num THEN
          -- 必要数实际订购数量
          var_necessary_real_order_num  := var_necessary_real_order_num +
                                           ceil((var_safe_num -
                                                var_to_update_necessary_count) /
                                                var_pack_num) *
                                           var_pack_num;
          var_to_update_necessary_count := var_to_update_necessary_count +
                                           ceil((var_safe_num -
                                                var_to_update_necessary_count) /
                                                var_pack_num) *
                                           var_pack_num;
          --var_use_safe_num              := var_safe_num;
        END IF;
      
        --更新订单履历
        UPDATE MM_MP_ORDER_RECORD A
           SET A.NECESSARY_PLAN_NUM          = var_necessary_plan_num, --必要数计划数量,
               A.NECESSARY_REAL_ORDER_NUM    = var_necessary_real_order_num, --必要数实际订购数量
               A.NECESSARY_ORDER_RESIDUAL    = var_necessary_order_residual, --上一个分组剩下的余量
               A.NECESSARY_REAL_RESIDUAL_NUM = var_to_update_necessary_count, --该订单履历产生的零件剩余量
               A.DEFECT_NUM                  = var_def_num, --使用不良品数量
               A.SAFE_NUM                    = var_safe_num, --安全库存使用量
               A.ADJ_DIFF_NUM                = var_adj_diff_num, --计划调整差异量
               A.ORDER_NUM                   = var_necessary_real_order_num,
               A.TOTAL_ORDER_NUM             = var_necessary_real_order_num,
               A.TOTAL_ORDER_BOX             = ceil((var_necessary_real_order_num) /
                                                    var_pack_num),
               A.ORDER_STATUS                = NULL,
               A.CREATION_TIME               = SYSDATE,
               A.CREATION_USER               = 'SYSTEM'
         WHERE A.PLAN_ORDER_ID = order_vo.PLAN_ORDER_ID
           AND A.FACTORY_CODE = in_arr_factory;
      
      END IF;
    
      --这条路线这个零件循环完成过后将数据置为0
      var_necessary_plan_num       := 0;
      var_necessary_real_order_num := 0;
      var_necessary_order_residual := 0;
      /*var_use_safe_num             := 0;*/
      var_safe_num     := 0;
      var_adj_diff_num := 0;
      var_def_num      := 0;
      var_pack_num     := 0;
    
      -- 循环结束(第一层）
      v_count_flag         := v_count_flag + 1;
      var_item_flag        := order_vo.PART_NO;
      var_supplierid_flag  := order_vo.SUPPLIER_NO;
      var_factoryid_flag   := order_vo.SUP_FACTORY;
      var_factorycode_flag := order_vo.FACTORY_CODE;
      var_unloadport_flag  := order_vo.UNLOAD_PORT;
    
    END LOOP;
  
  END USP_MP_ZSB_DEAL_PACK;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_ZSB_DIFF_PLAN
  --功能描述：生成W+1,W+2计划差异数据
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2019/01/15
  /* PROCEDURE USP_MP_ZSB_DIFF_PLAN(in_arr_factory IN VARCHAR2,
                                 out_code       OUT NUMBER) AS
    --拿到当前时间
    cur_date date;
    --组用量
    group_qty number;
  
    err_num number;
    err_msg varchar2(200);
  BEGIN
    cur_date := SYSDATE;
  
    --删除该工厂临时计划数据
    DELETE FROM MM_MP_DIFF_NUM_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
    COMMIT;
  
    --根据工厂删除临时表的W+1和W+2数据
    DELETE FROM MM_MP_PRO_PLAN_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
    COMMIT;
  
    --找到W+1和W+2的数据写入到临时表
    INSERT INTO MM_MP_PRO_PLAN_TEMP
      (FACTORY_CODE,
       ORDER_NO,
       ORDER_TYPE,
       WEON_TIME,
       AFOFF_TIME,
       SORT_ID,
       MODEL_CODE,
       PHASE,
       CREATION_TIME)
      SELECT FACTORY_CODE,
             ORDER_NO,
             ORDER_TYPE,
             WEON_TIME,
             AFOFF_TIME,
             SORT_ID,
             MODEL_CODE,
             PHASE,
             SYSDATE
        FROM MM_PUB_PRO_PLAN A
       WHERE A.AFOFF_TIME >= (select trunc(cur_date, 'iw') from dual)
         AND A.AFOFF_TIME <=
             (select trunc(cur_date + 7, 'iw') + 6 from dual)
         AND A.FACTORY_CODE = in_arr_factory
         AND A.PHASE = '5';
  
    --计算计划调整产生的差异
    --将W+1 和 W+2旧计划写入差异临时表
    INSERT INTO MM_MP_DIFF_NUM_TEMP
      (FACTORY_CODE, ORDER_NO, NUM, TYPE, MODEL_CODE, CREATION_TIME)
      SELECT A.FACTORY_CODE,
             A.ORDER_NO,
             COUNT(1) NUM,
             'O',
             MIN(A.CAR_TYPE),
             SYSDATE
        FROM MM_MP_VEH_PLAN A
       WHERE A.PRO_PHASE = '5'
         AND A.CAL_STATUS = 1
         AND A.FACTORY_CODE = in_arr_factory
         AND A.AFOFF_TIME >= (select trunc(cur_date, 'iw') from dual)
         AND A.AFOFF_TIME <=
             (select trunc(cur_date + 7, 'iw') + 6 from dual)
       GROUP BY A.FACTORY_CODE, A.ORDER_NO;
    COMMIT;
  
    --将W+1 和W+2新计划写入差异临时表
    INSERT INTO MM_MP_DIFF_NUM_TEMP
      (FACTORY_CODE, ORDER_NO, NUM, TYPE, MODEL_CODE, CREATION_TIME)
      SELECT A.FACTORY_CODE,
             A.ORDER_NO,
             COUNT(1) NUM,
             'N',
             MIN(A.MODEL_CODE),
             SYSDATE
        FROM MM_MP_PRO_PLAN_TEMP A
       WHERE A.FACTORY_CODE = in_arr_factory
         AND A.PHASE = '5'
       GROUP BY A.FACTORY_CODE, A.ORDER_NO;
    COMMIT;
  
    --操作成功
    out_code := 0;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_ZSB_DIFF_PLAN',
           err_num,
           err_msg,
           sysdate,
           '调整差异');
        COMMIT;
  
      END;
  END USP_MP_ZSB_DIFF_PLAN;*/
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_ZSB_DIFF
  --功能描述：使用差异计划生成计划变更差异
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/16
  PROCEDURE USP_MP_ZSB_DIFF(in_arr_factory IN VARCHAR2,
                            out_code       OUT NUMBER) AS
    --拿到当前时间
    cur_date date;
    --组用量
    group_qty number;
  
    err_num number;
    err_msg varchar2(200);
  BEGIN
    cur_date := SYSDATE;
  
    --删除该工厂下所有差异量数据
    DELETE FROM MM_MP_PLAN_DIFF_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
    COMMIT;
  
    --每次计算删除W+1 W+2历史表中版本号为空的数据
    DELETE FROM MM_MP_PRO_PLAN_HIS A
     WHERE A.VERSION IS NULL
       AND A.FACTORY_CODE = in_arr_factory;
  
    --将最大版本的的W+1 和 W+2数据写入到差异表，为旧计划
    INSERT INTO MM_MP_DIFF_NUM_TEMP
      (FACTORY_CODE, ORDER_NO, NUM, TYPE, MODEL_CODE, CREATION_TIME)
      SELECT A.FACTORY_CODE,
             A.ORDER_NO,
             COUNT(1) NUM,
             'O',
             MIN(A.CAR_TYPE),
             SYSDATE
        FROM MM_MP_PRO_PLAN_TEMP A
       WHERE A.PRO_PHASE IN ('4', '5')
         AND A.VERSION IS NOT NULL
         AND A.FACTORY_CODE = in_arr_factory
         AND A.AFOFF_TIME >= (select trunc(cur_date, 'iw') from dual)
         AND A.AFOFF_TIME <=
             (select trunc(cur_date + 7, 'iw') + 7 from dual)
       GROUP BY A.FACTORY_CODE, A.ORDER_NO;
    COMMIT;
    --******************************************************************************
  
    --将版本号为空的W+1 和W+2新计划写入差异临时表，为新计划
    INSERT INTO MM_MP_DIFF_NUM_TEMP
      (FACTORY_CODE, ORDER_NO, NUM, TYPE, MODEL_CODE, CREATION_TIME)
      SELECT A.FACTORY_CODE,
             A.ORDER_NO,
             COUNT(1) NUM,
             'N',
             MIN(A.CAR_TYPE),
             SYSDATE
        FROM MM_MP_PRO_PLAN_TEMP A
       WHERE A.FACTORY_CODE = in_arr_factory
         AND A.PRO_PHASE IN ('4', '5')
         AND A.AFOFF_TIME >= (select trunc(cur_date, 'iw') from dual)
         AND A.AFOFF_TIME <=
             (select trunc(cur_date + 7, 'iw') + 7 from dual)
         AND A.VERSION IS NULL
       GROUP BY A.FACTORY_CODE, A.ORDER_NO;
    COMMIT;
  
    --计算零件产生的差异
    --循环差异的有哪些车型
    FOR model_list IN (SELECT A.MODEL_CODE
                         FROM MM_MP_DIFF_NUM_TEMP A
                        WHERE A.FACTORY_CODE = in_arr_factory
                        GROUP BY A.MODEL_CODE) LOOP
      --找到该车型下对应的路线，有哪些零件需要订购
      /*      FOR part_list IN (SELECT A.FACTORY_CODE,
            A.SUPPLIER_NO,
            A.SUP_FACTORY,
            A.UNLOAD_PORT,
            A.CAR_TYPE,
            B.WORKCENTER,
            B.PART_NO
       FROM (SELECT DISTINCT MP.SUPPLIER_NO,
                             MP.SUP_FACTORY,
                             MP.FACTORY_CODE,
                             MP.UNLOAD_PORT,
                             MP.MODEL_CODE        CAR_TYPE,
                             MP.ORDER_PRODUCT_NUM SUP_CAL_NUM
               FROM MM_MP_PART MP
              WHERE MP.FACTORY_CODE = in_arr_factory
                AND MP.ORDER_PRODUCT_NUM > 0
                AND MP.EFF_START <= SYSDATE
                AND MP.EFF_END > SYSDATE) A
       LEFT JOIN MM_MP_PART B
         ON A.SUPPLIER_NO = B.SUPPLIER_NO
        AND A.SUP_FACTORY = B.SUP_FACTORY
        AND A.UNLOAD_PORT = B.UNLOAD_PORT
        AND A.FACTORY_CODE = B.FACTORY_CODE
        AND B.EFF_START <= SYSDATE
        AND B.EFF_END > SYSDATE
      WHERE A.CAR_TYPE LIKE
            '%' || model_list.MODEL_CODE || '%'
        AND A.SUP_CAL_NUM > 0
        AND A.FACTORY_CODE = in_arr_factory
        AND B.EFF_START <= SYSDATE
        AND B.EFF_END > SYSDATE) LOOP*/
    
      --记录差异数量到临时表
      INSERT INTO MM_MP_PLAN_DIFF_TEMP
        (FACTORY_CODE,
         SUPPLIER_NO,
         SUP_FACTORY,
         UNLOAD_PORT,
         WORKCENTER,
         MODEL_CODE,
         PART_NO,
         ADJ_DIFF_NUM,
         CREATION_USER,
         CREATION_TIME)
        (SELECT E.FACTORY_CODE,
                E.SUPPLIER_NO,
                E.SUP_FACTORY,
                E.UNLOAD_PORT,
                E.WORKCENTER,
                E.CAR_TYPE,
                E.PART_NO,
                SUM(D.NUM * C.NUM),
                'SYSTEM',
                SYSDATE
           FROM (SELECT A.ORDER_NO,- (A.NUM) NUM, A.MODEL_CODE
                   FROM MM_MP_DIFF_NUM_TEMP A
                  WHERE A.TYPE = 'O'
                       --存在于旧计划而不存在于新计划
                    AND NOT EXISTS
                  (SELECT 1
                           FROM MM_MP_DIFF_NUM_TEMP B
                          WHERE A.ORDER_NO = B.ORDER_NO
                            AND B.TYPE = 'N'
                            AND B.FACTORY_CODE = in_arr_factory)
                    AND A.FACTORY_CODE = in_arr_factory
                    AND A.MODEL_CODE = model_list.MODEL_CODE
                 UNION ALL
                 SELECT A.ORDER_NO, A.NUM, A.MODEL_CODE
                   FROM MM_MP_DIFF_NUM_TEMP A
                  WHERE A.TYPE = 'N'
                       --存在于新计划而不存在于旧计划
                    AND NOT EXISTS
                  (SELECT 1
                           FROM MM_MP_DIFF_NUM_TEMP B
                          WHERE A.ORDER_NO = B.ORDER_NO
                            AND B.TYPE = 'O'
                            AND B.FACTORY_CODE = in_arr_factory)
                    AND A.FACTORY_CODE = in_arr_factory
                    AND A.MODEL_CODE = model_list.MODEL_CODE
                 UNION ALL
                 --两版计划都存在，但是数量不相等
                 SELECT A.ORDER_NO, C.NUM - A.NUM, A.MODEL_CODE
                   FROM MM_MP_DIFF_NUM_TEMP A,
                        (SELECT B.ORDER_NO, B.NUM
                           FROM MM_MP_DIFF_NUM_TEMP B
                          WHERE B.TYPE = 'N'
                            AND B.FACTORY_CODE = in_arr_factory
                            AND B.MODEL_CODE = model_list.MODEL_CODE) C
                  WHERE A.TYPE = 'O'
                    AND A.MODEL_CODE = model_list.MODEL_CODE
                    AND A.ORDER_NO = C.ORDER_NO
                    AND A.NUM != C.NUM
                    AND A.FACTORY_CODE = in_arr_factory) C,
                MM_PUB_ORDER_BOM D,
                (SELECT A.FACTORY_CODE,
                        A.SUPPLIER_NO,
                        A.SUP_FACTORY,
                        A.UNLOAD_PORT,
                        A.CAR_TYPE,
                        B.WORKCENTER,
                        B.PART_NO
                   FROM (SELECT DISTINCT MP.SUPPLIER_NO,
                                         MP.SUP_FACTORY,
                                         MP.FACTORY_CODE,
                                         MP.UNLOAD_PORT,
                                         MP.MODEL_CODE CAR_TYPE
                           FROM MM_MP_PART MP
                          WHERE MP.FACTORY_CODE = in_arr_factory
                            AND MP.ORDER_PRODUCT_NUM > 0
                            AND MP.EFF_START <= SYSDATE
                            AND MP.EFF_END > SYSDATE) A
                   LEFT JOIN MM_MP_PART B
                     ON A.SUPPLIER_NO = B.SUPPLIER_NO
                    AND A.SUP_FACTORY = B.SUP_FACTORY
                    AND A.UNLOAD_PORT = B.UNLOAD_PORT
                    AND A.FACTORY_CODE = B.FACTORY_CODE
                    AND B.EFF_START <= SYSDATE
                    AND B.EFF_END > SYSDATE
                  WHERE A.CAR_TYPE LIKE '%' || model_list.MODEL_CODE || '%'
                    AND A.FACTORY_CODE = in_arr_factory
                    AND B.EFF_START <= SYSDATE
                    AND B.EFF_END > SYSDATE) E
          WHERE C.ORDER_NO = D.ORDER_NO
            AND D.PART_NO = E.PART_NO
            AND D.WORKCENTER = E.WORKCENTER
            AND D.FACTORY_CODE = in_arr_factory
          GROUP BY E.PART_NO,
                   E.WORKCENTER,
                   E.FACTORY_CODE,
                   E.SUPPLIER_NO,
                   E.SUP_FACTORY,
                   E.UNLOAD_PORT,
                   E.CAR_TYPE);
      /* END LOOP;*/
    END LOOP;
  
    --将本次用于对比的W+1 和W+2数据写入到历史表但是没有版本号
    INSERT INTO MM_MP_PRO_PLAN_HIS
      (SORT_ID,
       FACTORY_CODE,
       CAR_TYPE,
       ORDER_NO,
       WEON_TIME,
       AFOFF_TIME,
       PRO_PHASE,
       CAL_STATUS,
       CREATION_USER,
       IS_AUTOED,
       CREATION_TIME)
      SELECT A.SORT_ID,
             A.FACTORY_CODE,
             A.CAR_TYPE,
             A.ORDER_NO,
             A.WEON_TIME,
             A.AFOFF_TIME,
             A.PRO_PHASE,
             0,
             'SYSTEM',
             '1',
             SYSDATE
        FROM MM_MP_PRO_PLAN_TEMP A
      --取W+2的数据
       WHERE A.AFOFF_TIME >= (select trunc(cur_date + 7, 'iw') from dual)
         AND A.AFOFF_TIME <=
             (select trunc(cur_date + 7, 'iw') + 7 from dual)
         AND A.FACTORY_CODE = in_arr_factory
         AND A.PRO_PHASE IN ('4', '5')
         AND A.VERSION IS NULL
      UNION ALL
      SELECT TO_NUMBER(B.MES_SORT_ID),
             B.FACTORY_CODE,
             B.CAR_TYPE,
             B.ORDER_NO,
             B.WEON_TIME,
             B.AFOFF_TIME,
             B.PRO_PHASE,
             0,
             'SYSTEM',
             '1',
             SYSDATE
        FROM MM_MP_VEH_PLAN B
       WHERE B.AFOFF_TIME >= (select trunc(cur_date + 14, 'iw') from dual)
         AND B.AFOFF_TIME <=
             (select trunc(cur_date + 14, 'iw') + 7 from dual)
         AND B.FACTORY_CODE = in_arr_factory
         AND B.PRO_PHASE IN ('4', '5');
    COMMIT;
    --操作成功
    out_code := 0;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_ZSB_DIFF',
           err_num,
           err_msg,
           sysdate,
           '调整差异');
        COMMIT;
      
      END;
  END USP_MP_ZSB_DIFF;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_ZSB_DEAL_STATUS
  --功能描述：订单状态处理
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/16
  PROCEDURE USP_MP_ZSB_DEAL_STATUS(in_arr_factory IN VARCHAR2) AS
  
  BEGIN
    FOR VO IN (SELECT PLAN_ORDER_ID, TOTAL_ORDER_NUM
                 FROM MM_MP_ORDER_RECORD
                WHERE ORDER_STATUS IS NULL
                  AND FACTORY_CODE = in_arr_factory) LOOP
    
      UPDATE MM_MP_ORDER_RECORD A
         SET A.ORDER_STATUS = '0' -----订单状态 0：已计划
       WHERE PLAN_ORDER_ID = VO.PLAN_ORDER_ID
         AND FACTORY_CODE = in_arr_factory;
    
    END LOOP;
    COMMIT;
  
    /**
        2019-01-30新增
    **/
    --并且删除之前生成的订单履历和订单的关系数据
    DELETE FROM MM_MP_PUR_ORDER_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
    COMMIT;
  
  END USP_MP_ZSB_DEAL_STATUS;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_EXC_PO_ZSB
  --功能描述：例外订购组单
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/16
  PROCEDURE USP_MP_WATCH_COLSE(in_uuid        varchar2,
                               in_opeid       varchar2,
                               in_type        in VARCHAR2,
                               in_arr_factory in VARCHAR2) AS
  
  BEGIN
    UPDATE MM_MP_CAL_LOCK D
       SET D.IS_LOCK            = 0,
           D.LAST_MODIFIED_USER = 'SYSTEM',
           D.LAST_MODIFIED_TIME = SYSDATE
     WHERE D.CAL_TYPE = in_type
       AND D.FACTORY_CODE = in_arr_factory;
  
    UPDATE MM_MP_CAL_LOG A
       SET A.CAL_END_TIME = SYSDATE, A.IS_LOCK = 1
     WHERE A.UUID = in_uuid
       AND A.CREATION_USER = in_opeId;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
  END USP_MP_WATCH_COLSE;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_GEN_ORDER_NO
  --功能描述：采购订单号生成
  --参数说明：
  --in_uuid
  --in_opeId 操作人
  --in_type 类型 需求计算，采购订单生成, 采购订单号生成
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2019/01/29
  PROCEDURE USP_MP_GEN_ORDER_NO(in_uuid        in varchar2,
                                in_opeid       in varchar2,
                                in_type        in VARCHAR2,
                                in_arr_factory in VARCHAR2,
                                out_code       out number) AS
    err_num number;
    err_msg varchar2(200);
  BEGIN
    USP_MP_WATCH_OPEN(in_uuid, in_opeId, in_type, in_arr_factory);
    USP_MP_GEN_MAIN(in_arr_factory, in_opeid);
    USP_MP_WATCH_COLSE(in_uuid, in_opeId, in_type, in_arr_factory);
    out_code := 2;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_GEN_ORDER_NO',
           err_num,
           err_msg,
           sysdate,
           '订单号生成');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_GEN_ORDER_NO;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_GEN_MAIN
  --功能描述：订单号生成总成
  --参数说明：
  --in_arr_factory 工厂
  --创建人员: wangyu
  --创建时间： 2018/09/17
  PROCEDURE USP_MP_GEN_MAIN(in_arr_factory IN VARCHAR2,
                            in_opeid       in varchar2) AS
  
    --GAM订单号
    V_GAM_ORDER VARCHAR2(30);
    --到货日期
    V_GAM_ARRIVE_TIME DATE;
  BEGIN
    --每次生成订单号都先删除上次生成的订单号
    DELETE FROM MM_MP_PUR_ORDER_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
  
    COMMIT;
  
    --删除MM_MP_GAM_PUR_ORDER之前的数据
    DELETE FROM MM_MP_GAM_PUR_ORDER A
     WHERE A.FACTORY_CODE = in_arr_factory;
  
    COMMIT;
  
    --将订单行进行统计插入采购订单明细表
    INSERT INTO MM_MP_GAM_PUR_ORDER
      (PLAN_ORDER_ID,
       SUPPLIER_NO,
       SUP_FACTORY,
       UNLOAD_PORT,
       FACTORY_CODE,
       PART_NO,
       PART_UNIT,
       ORDER_NUM,
       TOTAL_ORDER_BOX,
       LOGISTICS_FLAG,
       LOGISTICS_ORDER,
       ORDER_STATUS,
       ORDER_ISSUE_DATE,
       SHIPMENT_DATE,
       PREPARE_TIME,
       GROUP_ID,
       PURCHASE_TYPE,
       ARRIVE_TIME,
       ORDER_DEPOT,
       ORDER_PACKAGE,
       STANDARD_PACKAGE,
       CREATION_USER,
       CREATION_TIME,
       LAST_MODIFIED_USER,
       LAST_MODIFIED_TIME,
       SEQID)
      SELECT E.*,
             'SYSTEM',
             SYSDATE,
             'SYSTEM',
             SYSDATE,
             LPAD(SEQ_MP_GAM_ORDER_LINE_NO.NEXTVAL, 20, 0)
        FROM (SELECT DISTINCT B.PLAN_ORDER_ID,
                              C.SUPPLIER_NO,
                              C.SUP_FACTORY,
                              C.UNLOAD_PORT,
                              C.FACTORY_CODE,
                              C.PART_NO,
                              C.PART_UNIT,
                              B.TOTAL_ORDER_NUM,
                              C.TOTAL_ORDER_BOX,
                              C.LOGISTICS_FLAG,
                              C.LOGISTICS_ORDER,
                              C.ORDER_STATUS,
                              C.ORDER_ISSUE_DATE,
                              C.SHIPMENT_DATE,
                              C.PREPARE_TIME,
                              C.GROUP_ID,
                              C.PURCHASE_TYPE,
                              C.ARRIVE_TIME,
                              C.ORDER_DEPOT,
                              C.ORDER_PACKAGE,
                              C.STANDARD_PACKAGE
                FROM MM_MP_ORDER_RECORD C,
                     (SELECT D.SUPPLIER_NO,
                             D.SUP_FACTORY,
                             D.FACTORY_CODE,
                             D.UNLOAD_PORT,
                             D.PART_NO,
                             D.LOGISTICS_ORDER,
                             MIN(D.PLAN_ORDER_ID) PLAN_ORDER_ID,
                             SUM(D.TOTAL_ORDER_NUM) TOTAL_ORDER_NUM
                        FROM MM_MP_ORDER_RECORD D
                       GROUP BY D.SUPPLIER_NO,
                                D.SUP_FACTORY,
                                D.FACTORY_CODE,
                                D.UNLOAD_PORT,
                                D.PART_NO,
                                D.LOGISTICS_ORDER) B
               WHERE C.SUPPLIER_NO = B.SUPPLIER_NO
                 AND C.SUP_FACTORY = B.SUP_FACTORY
                 AND C.FACTORY_CODE = B.FACTORY_CODE
                 AND C.UNLOAD_PORT = B.UNLOAD_PORT
                 AND B.PART_NO = C.PART_NO
                 AND B.LOGISTICS_ORDER = C.LOGISTICS_ORDER
                 AND C.LOGISTICS_FLAG = 'GAM'
                 AND B.TOTAL_ORDER_NUM <> 0
                 AND C.PART_NO IS NOT NULL
                 AND B.FACTORY_CODE = in_arr_factory
               ORDER BY C.LOGISTICS_ORDER) E;
    COMMIT;
  
    --循环订单头
    FOR VO IN (SELECT DISTINCT A.SUPPLIER_NO,
                               A.LOGISTICS_ORDER,
                               A.SUP_FACTORY,
                               A.UNLOAD_PORT,
                               A.GROUP_ID
                 FROM MM_MP_GAM_PUR_ORDER A
                WHERE A.FACTORY_CODE = in_arr_factory
                ORDER BY A.SUPPLIER_NO,
                         A.SUP_FACTORY,
                         A.LOGISTICS_ORDER,
                         A.GROUP_ID,
                         A.UNLOAD_PORT) LOOP
    
      --订单号中的到货日期
      SELECT MIN(A.ARRIVE_TIME)
        INTO V_GAM_ARRIVE_TIME
        FROM MM_MP_GAM_PUR_ORDER A
       WHERE A.UNLOAD_PORT = VO.unload_port
         AND A.LOGISTICS_ORDER = VO.logistics_order
         AND A.SUPPLIER_NO = VO.SUPPLIER_NO
         AND A.SUP_FACTORY = VO.SUP_FACTORY
         AND A.GROUP_ID = VO.GROUP_ID
         AND A.FACTORY_CODE = in_arr_factory
       GROUP BY A.SUPPLIER_NO, A.SUP_FACTORY, A.GROUP_ID;
    
      V_GAM_ORDER := PKG_PUB.USF_GET_ORDER_NO_BY_DATE(in_arr_factory,
                                                      'SW',
                                                      V_GAM_ARRIVE_TIME);
      --写入订单和PLAN_ORDER_ID的关系
      INSERT INTO MM_MP_PUR_ORDER_TEMP
        (ORDER_NO,
         PURCHASE_NO,
         FACTORY_CODE,
         SUP_FACTORY,
         SUPPLIER_NO,
         UNLOAD_PORT,
         GROUP_ID,
         LOGISTICS_ORDER,
         CREATION_TIME)
        SELECT DISTINCT V_GAM_ORDER,
                        V_GAM_ORDER,
                        in_arr_factory,
                        A.SUP_FACTORY,
                        A.SUPPLIER_NO,
                        A.UNLOAD_PORT,
                        A.GROUP_ID,
                        A.LOGISTICS_ORDER,
                        SYSDATE
          FROM MM_MP_GAM_PUR_ORDER A
         WHERE A.UNLOAD_PORT = VO.UNLOAD_PORT
           AND A.LOGISTICS_ORDER = VO.LOGISTICS_ORDER
           AND A.SUP_FACTORY = VO.SUP_FACTORY
           AND A.SUPPLIER_NO = VO.SUPPLIER_NO
           AND A.GROUP_ID = VO.GROUP_ID
           AND A.FACTORY_CODE = in_arr_factory;
    
      --删除GAM订单
      DELETE FROM MM_MP_GAM_PUR_ORDER A
       WHERE A.LOGISTICS_ORDER = VO.LOGISTICS_ORDER
         AND A.SUP_FACTORY = VO.SUP_FACTORY
         AND A.SUPPLIER_NO = VO.SUPPLIER_NO
         AND A.UNLOAD_PORT = VO.UNLOAD_PORT
         AND A.GROUP_ID = VO.GROUP_ID
         AND A.FACTORY_CODE = in_arr_factory;
    
    END LOOP;
    COMMIT;
  
  END USP_MP_GEN_MAIN;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_PO
  --功能描述：采购订单生成总成
  --参数说明：
  --in_uuid uuid
  --in_opeId 操作人
  --in_type 类型 需求计算，采购订单生成
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2018/09/07
  PROCEDURE USP_MP_PO(in_uuid        in varchar2,
                      in_opeid       in varchar2,
                      in_type        in VARCHAR2,
                      in_arr_factory in VARCHAR2,
                      out_code       out number) AS
    err_num number;
    err_msg varchar2(200);
  BEGIN
    USP_MP_WATCH_OPEN(in_uuid, in_opeId, in_type, in_arr_factory);
    USP_MP_PO_GEN(in_arr_factory);
    USP_MP_PO_GAM_NEW(in_arr_factory, in_opeId);
    USP_MP_WATCH_COLSE(in_uuid, in_opeId, in_type, in_arr_factory);
    out_code := 2;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_PO',
           err_num,
           err_msg,
           sysdate,
           '采购订单生成');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_PO;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_PO_GEN
  --功能描述：采购订单生成
  --参数说明：
  --in_arr_factory 工厂
  --创建人员: wangyu
  --创建时间： 2018/09/17
  PROCEDURE USP_MP_PO_GEN(in_arr_factory IN VARCHAR2) AS
  
    --上次订购剩余量
    v_residual_num number(10);
  
  BEGIN
    FOR vo IN (SELECT D.PART_NO,
                      D.SUPPLIER_NO,
                      D.SUP_FACTORY,
                      D.FACTORY_CODE,
                      D.UNLOAD_PORT,
                      SUM(D.NECESSARY_NET_NUM) NECESSARY_NET_NUM,
                      SUM(D.TOTAL_ORDER_NUM) TOTAL_ORDER_NUM,
                      MIN(D.SAFE_NUM) SAFE_NUM,
                      SUM(D.DEFECT_NUM) DEFECT_NUM,
                      SUM(D.ADJ_DIFF_NUM) ADJ_DIFF_NUM
                 FROM MM_MP_ORDER_RECORD D
                WHERE D.FACTORY_CODE = in_arr_factory
                GROUP BY D.PART_NO,
                         D.SUPPLIER_NO,
                         D.SUP_FACTORY,
                         D.FACTORY_CODE,
                         D.UNLOAD_PORT) LOOP
    
      --每一条剩余量记录初始化剩余量为0
      v_residual_num := 0;
      --查询该条路线计算之前剩余量
      BEGIN
        SELECT NVL(A.MANU_RESIDUAL, NVL(A.REAL_RESIDUAL_NUM, 0))
          INTO v_residual_num
          FROM MM_MP_RESIDUAL A
         WHERE A.PART_NO = vo.PART_NO
           AND A.SUPPLIER_NO = vo.SUPPLIER_NO
           AND A.SUP_FACTORY = vo.SUP_FACTORY
           AND A.UNLOAD_PORT = vo.UNLOAD_PORT
           AND A.FACTORY_CODE = vo.FACTORY_CODE;
      EXCEPTION
        WHEN OTHERS THEN
          v_residual_num := 0;
      END;
    
      MERGE INTO MM_MP_RESIDUAL A
      USING (SELECT COUNT(1) AS NUM
               FROM MM_MP_RESIDUAL B
              WHERE vo.PART_NO = B.PART_NO
                AND vo.SUPPLIER_NO = B.SUPPLIER_NO
                AND vo.SUP_FACTORY = B.SUP_FACTORY
                AND vo.UNLOAD_PORT = B.UNLOAD_PORT
                AND vo.FACTORY_CODE = B.FACTORY_CODE) D
      ON (D.NUM > 0)
      WHEN MATCHED THEN
      --如果存在于剩余量表则更新剩余量表数据
        UPDATE
           SET A.NECESSARY_ORDER_NUM = vo.NECESSARY_NET_NUM,
               A.ORDER_NUM           = vo.TOTAL_ORDER_NUM,
               A.SAFE_NUM            = vo.SAFE_NUM,
               A.DEFECT_NUM          = vo.DEFECT_NUM,
               A.REAL_RESIDUAL_NUM   = vo.TOTAL_ORDER_NUM -
                                       vo.NECESSARY_NET_NUM + v_residual_num,
               A.PRE_RESIDUAL_NUM    = v_residual_num,
               A.ADJ_DIFF_NUM        = vo.Adj_Diff_Num,
               A.LAST_MODIFIED_TIME  = SYSDATE,
               A.LAST_MODIFIED_USER  = 'SYSTEM',
               A.MANU_RESIDUAL       = NULL
         WHERE A.PART_NO = vo.PART_NO
           AND A.SUPPLIER_NO = vo.SUPPLIER_NO
           AND A.SUP_FACTORY = vo.SUP_FACTORY
           AND A.UNLOAD_PORT = vo.UNLOAD_PORT
           AND A.FACTORY_CODE = vo.FACTORY_CODE
        --如果不存在则新增剩余量数据
        
      
      WHEN NOT MATCHED THEN
        INSERT
          (A.ID,
           A.FACTORY_CODE,
           A.PART_NO,
           A.SUPPLIER_NO,
           A.SUP_FACTORY,
           A.UNLOAD_PORT,
           A.ORDER_NUM,
           A.NECESSARY_ORDER_NUM,
           A.REAL_RESIDUAL_NUM,
           A.PRE_RESIDUAL_NUM,
           A.ADJ_DIFF_NUM,
           A.SAFE_NUM,
           A.DEFECT_NUM,
           A.MANU_RESIDUAL,
           A.CREATION_USER,
           A.CREATION_TIME)
        VALUES
          (SEQ_MM_MP_RESIDUAL.NEXTVAL,
           in_arr_factory,
           vo.PART_NO,
           vo.SUPPLIER_NO,
           vo.SUP_FACTORY,
           vo.UNLOAD_PORT,
           vo.TOTAL_ORDER_NUM,
           vo.NECESSARY_NET_NUM,
           vo.TOTAL_ORDER_NUM - vo.NECESSARY_NET_NUM,
           0,
           vo.ADJ_DIFF_NUM,
           vo.SAFE_NUM,
           vo.DEFECT_NUM,
           NULL,
           'SYSTEM',
           SYSDATE);
    END LOOP;
  
    COMMIT;
    USP_MP_PO_ADJUST(in_arr_factory);
  
  END USP_MP_PO_GEN;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_PO_GEN
  --功能描述：订购后订单调整
  --参数说明：
  --in_arr_factory 工厂
  --创建人员: wangyu
  --创建时间： 2018/09/17
  PROCEDURE USP_MP_PO_ADJUST(in_arr_factory IN VARCHAR2) AS
  
  BEGIN
    FOR v_supplier_list IN (SELECT A.SUPPLIER_NO,
                                   A.SUP_FACTORY,
                                   A.FACTORY_CODE,
                                   A.UNLOAD_PORT,
                                   A.GROUP_ID
                              FROM MM_MP_PART_SORT_TEMP A
                            --循环不存在于历史供应商分组的数据
                             WHERE NOT EXISTS
                             (SELECT 1
                                      FROM MM_MP_SUPPLIER_SORT B
                                     WHERE A.SUPPLIER_NO = B.SUPPLIER_NO
                                       AND A.SUP_FACTORY = B.SUP_FACTORY
                                       AND A.UNLOAD_PORT = B.UNLOAD_PORT
                                       AND A.GROUP_ID = B.GROUP_ID
                                       AND A.FACTORY_CODE = in_arr_factory)
                               AND A.FACTORY_CODE = in_arr_factory
                             ORDER BY A.SUPPLIER_NO,
                                      A.UNLOAD_PORT,
                                      A.GROUP_ID) LOOP
      --把供应商分组从临时表写入正式表
      INSERT INTO MM_MP_SUPPLIER_SORT
        (SUPPLIER_NO,
         SUP_FACTORY,
         FACTORY_CODE,
         UNLOAD_PORT,
         DR_SORT_ID_START,
         DR_SORT_ID_END,
         GROUP_ID,
         CAL_STATUS,
         FINAL_UNDERLINE_TIME_START,
         FINAL_UNDERLINE_TIME_END,
         CREATION_TIME)
        SELECT A.SUPPLIER_NO,
               A.SUP_FACTORY,
               A.FACTORY_CODE,
               A.UNLOAD_PORT,
               A.DR_SORT_ID_START,
               A.DR_SORT_ID_END,
               A.GROUP_ID,
               A.CAL_STATUS,
               A.FINAL_UNDERLINE_TIME_START,
               A.FINAL_UNDERLINE_TIME_END,
               SYSDATE
          FROM MM_MP_SUPPLIER_SORT_TEMP A
         WHERE A.SUPPLIER_NO = v_supplier_list.SUPPLIER_NO
           AND A.SUP_FACTORY = v_supplier_list.SUP_FACTORY
           AND A.FACTORY_CODE = v_supplier_list.FACTORY_CODE
           AND A.UNLOAD_PORT = v_supplier_list.UNLOAD_PORT
           AND A.GROUP_ID = v_supplier_list.GROUP_ID;
    
      --删除供应商分组临时表数据
      DELETE FROM MM_MP_SUPPLIER_SORT_TEMP A
       WHERE A.SUPPLIER_NO = v_supplier_list.SUPPLIER_NO
         AND A.SUP_FACTORY = v_supplier_list.SUP_FACTORY
         AND A.FACTORY_CODE = v_supplier_list.FACTORY_CODE
         AND A.UNLOAD_PORT = v_supplier_list.UNLOAD_PORT
         AND A.GROUP_ID = v_supplier_list.GROUP_ID;
    
    END LOOP;
    COMMIT;
  
    --循环零件分组临时表数据
    FOR v_part_list IN (SELECT *
                          FROM MM_MP_PART_SORT_TEMP TMP
                         WHERE NOT EXISTS
                         (SELECT 1
                                  FROM MM_MP_PART_SORT A
                                 WHERE TMP.SUPPLIER_NO = A.SUPPLIER_NO
                                   AND TMP.SUP_FACTORY = A.SUP_FACTORY
                                   AND TMP.FACTORY_CODE = A.FACTORY_CODE
                                   AND TMP.UNLOAD_PORT = A.UNLOAD_PORT
                                   AND TMP.GROUP_ID = A.GROUP_ID
                                   AND TMP.PART_NO = A.PART_NO
                                   AND TMP.LOGISTICS_ORDER =
                                       A.LOGISTICS_ORDER
                                   AND TMP.FACTORY_CODE = in_arr_factory)
                           AND TMP.FACTORY_CODE = in_arr_factory) LOOP
      --将临时的零件分组数据写入到正式零件分组
      INSERT INTO MM_MP_PART_SORT
        (ID,
         FACTORY_CODE,
         LOGISTICS_ORDER,
         SUPPLIER_NO,
         SUP_FACTORY,
         UNLOAD_PORT,
         PART_NO,
         GROUP_ID,
         DR_SORT_ID_START,
         DR_SORT_ID_END,
         LR_SORT_ID_START,
         LR_SORT_ID_END,
         REAL_END_SORT_ID,
         FINAL_UNDERLINE_TIME_START,
         FINAL_UNDERLINE_TIME_END,
         FINAL_UNDERLINE_TIME_START_NEW,
         FINAL_UNDERLINE_TIME_END_NEW,
         ORDER_PACKAGE,
         STANDARD_PACKAGE,
         GROUP_QTY,
         CAL_STATUS,
         GROUP_QTY_NEW,
         WORKCENTER,
         GROUP_QTY_DIFF,
         ITEM_CALCULATE_NUM,
         ARRIVE_TIME,
         LINE_SIDE_TIME,
         LINE_SIDE_SORT_ID,
         USE_RANGE_SORT_ID_START,
         USE_RANGE_SORT_ID_END,
         CREATION_TIME,
         SUPPLY_RATE,
         PURCHASE_TYPE,
         CAR_TYPE,
         IN_PLAN_FORWARD_TIME)
        SELECT A.ID,
               A.FACTORY_CODE,
               A.LOGISTICS_ORDER,
               A.SUPPLIER_NO,
               A.SUP_FACTORY,
               A.UNLOAD_PORT,
               A.PART_NO,
               A.GROUP_ID,
               A.DR_SORT_ID_START,
               A.DR_SORT_ID_END,
               A.LR_SORT_ID_START,
               A.LR_SORT_ID_END,
               A.REAL_END_SORT_ID,
               A.FINAL_UNDERLINE_TIME_START,
               A.FINAL_UNDERLINE_TIME_END,
               A.FINAL_UNDERLINE_TIME_START_NEW,
               A.FINAL_UNDERLINE_TIME_END_NEW,
               A.ORDER_PACKAGE,
               A.STANDARD_PACKAGE,
               A.GROUP_QTY,
               1,
               A.GROUP_QTY_NEW,
               A.WORKCENTER,
               A.GROUP_QTY_DIFF,
               A.ITEM_CALCULATE_NUM,
               A.ARRIVE_TIME,
               A.LINE_SIDE_TIME,
               A.LINE_SIDE_SORT_ID,
               A.USE_RANGE_SORT_ID_START,
               A.USE_RANGE_SORT_ID_END,
               SYSDATE,
               A.SUPPLY_RATE,
               A.PURCHASE_TYPE,
               A.CAR_TYPE,
               A.IN_PLAN_FORWARD_TIME
          FROM MM_MP_PART_SORT_TEMP A
         WHERE A.ID = v_part_list.ID
           AND A.FACTORY_CODE = v_part_list.FACTORY_CODE;
    
      DELETE FROM MM_MP_PART_SORT_TEMP A
       WHERE A.ID = v_part_list.ID
         AND A.FACTORY_CODE = in_arr_factory;
    
    END LOOP;
    COMMIT;
  
  END;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：MP_PO_GAM_NEW
  --功能描述：订单生成
  --参数说明：
  --in_arr_factory 工厂
  --创建人员: wangyu
  --创建时间： 2018/09/17
  PROCEDURE USP_MP_PO_GAM_NEW(in_arr_factory IN VARCHAR2,
                              in_opeid       in varchar2) AS
  
    --GAM订单号
    V_GAM_ORDER VARCHAR2(30);
    --订单行号
    V_GAM_LINE_NO NUMBER := 1;
    --到货日期
    V_GAM_ARRIVE_TIME DATE;
  
    v_max_version NUMBER;
  
  BEGIN
    --将订单行进行统计插入采购订单明细表
    INSERT INTO MM_MP_GAM_PUR_ORDER
      (PLAN_ORDER_ID,
       SUPPLIER_NO,
       SUP_FACTORY,
       UNLOAD_PORT,
       FACTORY_CODE,
       PART_NO,
       PART_UNIT,
       ORDER_NUM,
       TOTAL_ORDER_BOX,
       LOGISTICS_FLAG,
       LOGISTICS_ORDER,
       ORDER_STATUS,
       ORDER_ISSUE_DATE,
       SHIPMENT_DATE,
       PREPARE_TIME,
       GROUP_ID,
       PURCHASE_TYPE,
       ARRIVE_TIME,
       ORDER_DEPOT,
       ORDER_PACKAGE,
       STANDARD_PACKAGE,
       CREATION_USER,
       CREATION_TIME,
       LAST_MODIFIED_USER,
       LAST_MODIFIED_TIME,
       SEQID)
      SELECT E.*,
             'SYSTEM',
             SYSDATE,
             'SYSTEM',
             SYSDATE,
             LPAD(SEQ_MP_GAM_ORDER_LINE_NO.NEXTVAL, 20, 0)
        FROM (SELECT DISTINCT B.PLAN_ORDER_ID,
                              C.SUPPLIER_NO,
                              C.SUP_FACTORY,
                              C.UNLOAD_PORT,
                              C.FACTORY_CODE,
                              C.PART_NO,
                              C.PART_UNIT,
                              B.TOTAL_ORDER_NUM,
                              C.TOTAL_ORDER_BOX,
                              C.LOGISTICS_FLAG,
                              C.LOGISTICS_ORDER,
                              C.ORDER_STATUS,
                              C.ORDER_ISSUE_DATE,
                              C.SHIPMENT_DATE,
                              C.PREPARE_TIME,
                              C.GROUP_ID,
                              C.PURCHASE_TYPE,
                              C.ARRIVE_TIME,
                              C.ORDER_DEPOT,
                              C.ORDER_PACKAGE,
                              C.STANDARD_PACKAGE
                FROM MM_MP_ORDER_RECORD C,
                     (SELECT D.SUPPLIER_NO,
                             D.SUP_FACTORY,
                             D.FACTORY_CODE,
                             D.UNLOAD_PORT,
                             D.PART_NO,
                             D.LOGISTICS_ORDER,
                             MIN(D.PLAN_ORDER_ID) PLAN_ORDER_ID,
                             SUM(D.TOTAL_ORDER_NUM) TOTAL_ORDER_NUM,
                             --mod by zmj 2019-06-26
                             D.GROUP_ID
                        FROM MM_MP_ORDER_RECORD D
                       GROUP BY D.SUPPLIER_NO,
                                D.SUP_FACTORY,
                                D.FACTORY_CODE,
                                D.UNLOAD_PORT,
                                D.PART_NO,
                                D.LOGISTICS_ORDER,
                                --mod by zmj 2019-06-26
                                D.GROUP_ID) B
               WHERE C.SUPPLIER_NO = B.SUPPLIER_NO
                 AND C.SUP_FACTORY = B.SUP_FACTORY
                 AND C.FACTORY_CODE = B.FACTORY_CODE
                 AND C.UNLOAD_PORT = B.UNLOAD_PORT
                 AND B.PART_NO = C.PART_NO
                 AND B.LOGISTICS_ORDER = C.LOGISTICS_ORDER
                 AND C.LOGISTICS_FLAG = 'GAM'
                 AND B.TOTAL_ORDER_NUM <> 0
                 AND C.PART_NO IS NOT NULL
                 AND B.FACTORY_CODE = in_arr_factory
                    --mod by zmj 2019-06-26
                 AND C.GROUP_ID = B.GROUP_ID
               ORDER BY C.LOGISTICS_ORDER) E;
    COMMIT;
  
    --插入订单履历历史表
    INSERT INTO MM_MP_ORDER_RECORD_HIS
      (FACTORY_CODE,
       PART_NO,
       SUPPLIER_NO,
       SUP_FACTORY,
       UNLOAD_PORT,
       LOGISTICS_ORDER,
       LOGISTICS_FLAG,
       GROUP_ID,
       DR_SORT_ID_START,
       DR_SORT_ID_END,
       LR_SORT_ID_START,
       LR_SORT_ID_END,
       DEFECT_NUM,
       SAFE_NUM,
       ADJ_DIFF_NUM,
       NECESSARY_NET_NUM,
       NECESSARY_ORDER_RESIDUAL,
       NECESSARY_REAL_ORDER_NUM,
       NECESSARY_PLAN_NUM,
       NECESSARY_REAL_RESIDUAL_NUM,
       ORDER_NUM,
       TOTAL_ORDER_NUM,
       TOTAL_ORDER_BOX,
       ADJ_BOX,
       ADJ_ORDER_NUM,
       ARRIVE_TIME,
       ORDER_STATUS,
       ORDER_ISSUE_DATE,
       SHIPMENT_DATE,
       PREPARE_TIME,
       ORDER_DEPOT,
       CALCULATE_NUM,
       CREATION_USER,
       CREATION_TIME,
       PART_UNIT,
       PLAN_ORDER_ID,
       ORDER_PACKAGE,
       STANDARD_PACKAGE,
       PURCHASE_TYPE,
       PART_GROUP_ID)
      SELECT A.FACTORY_CODE,
             A.PART_NO,
             A.SUPPLIER_NO,
             A.SUP_FACTORY,
             A.UNLOAD_PORT,
             A.LOGISTICS_ORDER,
             A.LOGISTICS_FLAG,
             A.GROUP_ID,
             A.DR_SORT_ID_START,
             A.DR_SORT_ID_END,
             A.LR_SORT_ID_START,
             A.LR_SORT_ID_END,
             A.DEFECT_NUM,
             A.SAFE_NUM,
             A.ADJ_DIFF_NUM,
             A.NECESSARY_NET_NUM,
             A.NECESSARY_ORDER_RESIDUAL,
             A.NECESSARY_REAL_ORDER_NUM,
             A.NECESSARY_PLAN_NUM,
             A.NECESSARY_REAL_RESIDUAL_NUM,
             A.ORDER_NUM,
             A.TOTAL_ORDER_NUM,
             A.TOTAL_ORDER_BOX,
             A.ADJ_BOX,
             A.ADJ_ORDER_NUM,
             A.ARRIVE_TIME,
             '9',
             A.ORDER_ISSUE_DATE,
             A.SHIPMENT_DATE,
             A.PREPARE_TIME,
             A.ORDER_DEPOT,
             A.CALCULATE_NUM,
             A.CREATION_USER,
             A.CREATION_TIME,
             A.PART_UNIT,
             A.PLAN_ORDER_ID,
             A.ORDER_PACKAGE,
             A.STANDARD_PACKAGE,
             A.PURCHASE_TYPE,
             A.PART_GROUP_ID
        FROM MM_MP_ORDER_RECORD A
        LEFT JOIN (SELECT B.SUPPLIER_NO,
                          B.SUP_FACTORY,
                          B.FACTORY_CODE,
                          B.UNLOAD_PORT,
                          B.PART_NO,
                          B.LOGISTICS_ORDER,
                          MIN(B.PLAN_ORDER_ID) PLAN_ORDER_ID
                     FROM MM_MP_ORDER_RECORD B
                    GROUP BY B.SUPPLIER_NO,
                             B.SUP_FACTORY,
                             B.FACTORY_CODE,
                             B.UNLOAD_PORT,
                             B.PART_NO,
                             B.LOGISTICS_ORDER) C
          ON A.SUPPLIER_NO = C.SUPPLIER_NO
         AND A.SUP_FACTORY = C.SUP_FACTORY
         AND A.FACTORY_CODE = C.FACTORY_CODE
         AND A.UNLOAD_PORT = C.UNLOAD_PORT
         AND (A.PART_NO IS NULL OR C.PART_NO IS NULL OR
             A.PART_NO = C.PART_NO)
         AND A.LOGISTICS_ORDER = C.LOGISTICS_ORDER
       WHERE A.LOGISTICS_FLAG = 'GAM'
         AND A.FACTORY_CODE = in_arr_factory
         AND (A.PART_NO IS NOT NULL)
          OR (A.PART_NO IS NULL AND A.ARRIVE_TIME < ADD_MONTHS(SYSDATE, -1));
  
    COMMIT;
  
    --删除订单履历临时表表
    DELETE FROM MM_MP_ORDER_RECORD A
     WHERE A.LOGISTICS_FLAG = 'GAM'
       AND A.FACTORY_CODE = in_arr_factory
       AND (A.PART_NO IS NOT NULL)
        OR (A.PART_NO IS NULL AND A.ARRIVE_TIME < ADD_MONTHS(SYSDATE, -1));
  
    COMMIT;
  
    --循环订单头
    FOR VO IN (SELECT DISTINCT A.SUPPLIER_NO,
                               A.LOGISTICS_ORDER,
                               A.SUP_FACTORY,
                               A.UNLOAD_PORT,
                               A.GROUP_ID
                 FROM MM_MP_GAM_PUR_ORDER A
                WHERE A.FACTORY_CODE = in_arr_factory
                ORDER BY A.SUPPLIER_NO,
                         A.SUP_FACTORY,
                         A.LOGISTICS_ORDER,
                         A.GROUP_ID,
                         A.UNLOAD_PORT) LOOP
    
      --订单号中的到货日期
      SELECT MIN(A.ARRIVE_TIME)
        INTO V_GAM_ARRIVE_TIME
        FROM MM_MP_GAM_PUR_ORDER A
       WHERE A.UNLOAD_PORT = VO.unload_port
         AND A.LOGISTICS_ORDER = VO.logistics_order
         AND A.SUP_FACTORY = VO.SUP_FACTORY
         AND A.SUPPLIER_NO = VO.SUPPLIER_NO
         AND A.GROUP_ID = VO.GROUP_ID
         AND A.FACTORY_CODE = in_arr_factory
       GROUP BY A.SUPPLIER_NO,
                A.SUP_FACTORY,
                A.UNLOAD_PORT,
                A.FACTORY_CODE,
                A.GROUP_ID,
                A.LOGISTICS_ORDER;
    
      --订单号
      /*V_GAM_ORDER := PKG_PUB.USF_GET_ORDER_NO_BY_DATE(in_arr_factory,
      'SW',
      V_GAM_ARRIVE_TIME);*/
      --从临时表查询出订单号
      SELECT B.ORDER_NO
        INTO V_GAM_ORDER
        FROM MM_MP_PUR_ORDER_TEMP B
       WHERE B.UNLOAD_PORT = VO.unload_port
         AND B.LOGISTICS_ORDER = VO.logistics_order
         AND B.SUP_FACTORY = VO.SUP_FACTORY
         AND B.SUPPLIER_NO = VO.SUPPLIER_NO
         AND B.GROUP_ID = VO.GROUP_ID
         AND B.FACTORY_CODE = in_arr_factory;
    
      --更新不良品状态 将使用状态为1的数据订单状态改为已生成,并更新订单号
      UPDATE MM_DPM_INS A
         SET A.CAL_ORDER_NO = V_GAM_ORDER, A.ORDER_STATUS = 1
       WHERE EXISTS
       (SELECT 1
                FROM (SELECT C.APPLY_NO, C.FACTORY_CODE
                        FROM MM_DPM_INS C
                        LEFT JOIN (SELECT B.SUPPLIER_NO, B.CAR_TYPE
                                    FROM (SELECT DISTINCT MP.SUPPLIER_NO,
                                                          MP.SUP_FACTORY,
                                                          MP.FACTORY_CODE,
                                                          MP.UNLOAD_PORT,
                                                          MP.MODEL_CODE CAR_TYPE
                                            FROM MM_MP_PART MP
                                           WHERE MP.FACTORY_CODE =
                                                 in_arr_factory
                                             AND MP.ORDER_PRODUCT_NUM > 0
                                             AND MP.EFF_START <= SYSDATE
                                             AND MP.EFF_END > SYSDATE) B
                                   WHERE B.SUPPLIER_NO = VO.SUPPLIER_NO
                                     AND B.SUP_FACTORY = VO.SUP_FACTORY
                                     AND B.UNLOAD_PORT = VO.UNLOAD_PORT
                                     AND B.FACTORY_CODE = in_arr_factory
                                     AND ROWNUM = 1) D
                          ON C.SUPPLIER_NO = D.SUPPLIER_NO
                         AND D.CAR_TYPE LIKE '%' || C.MODEL_CODE || '%'
                       WHERE C.USE_FLAG = 1
                         AND C.CAL_ORDER_NO IS NULL
                         AND C.FACTORY_CODE = in_arr_factory) E
               WHERE A.APPLY_NO = E.APPLY_NO
                 AND A.FACTORY_CODE = E.FACTORY_CODE)
         AND A.FACTORY_CODE = in_arr_factory;
    
      --写入订单头表 ??? 总成供应商代码
      INSERT INTO MM_MP_PUR_ORDER
        (ORDER_NO,
         PURCHASE_NO,
         FACTORY_CODE,
         SUP_FACTORY,
         SUPPLIER_NO,
         ISSUE_DATE,
         ARRIVE_DATE,
         PREPARE_TIME,
         PLAN_ORDER_ID,
         ORDER_TYPE,
         CREATION_TIME)
        SELECT V_GAM_ORDER,
               V_GAM_ORDER,
               in_arr_factory,
               A.SUP_FACTORY,
               A.SUPPLIER_NO,
               MIN(ORDER_ISSUE_DATE),
               MIN(A.ARRIVE_TIME),
               MIN(A.PREPARE_TIME),
               MIN(A.PLAN_ORDER_ID),
               '1',
               SYSDATE
          FROM MM_MP_GAM_PUR_ORDER A
         WHERE A.UNLOAD_PORT = VO.UNLOAD_PORT
           AND A.LOGISTICS_ORDER = VO.LOGISTICS_ORDER
           AND A.SUP_FACTORY = VO.SUP_FACTORY
           AND A.SUPPLIER_NO = VO.SUPPLIER_NO
           AND A.GROUP_ID = VO.GROUP_ID
           AND A.FACTORY_CODE = in_arr_factory
         GROUP BY A.SUPPLIER_NO, A.SUP_FACTORY, A.GROUP_ID;
    
      --写入订单行
      FOR LINE IN (SELECT ROWNUM AS RN,
                          A.PLAN_ORDER_ID,
                          A.PART_NO,
                          A.ORDER_NUM,
                          A.PART_UNIT,
                          A.LOGISTICS_FLAG,
                          A.ORDER_DEPOT,
                          A.ARRIVE_TIME,
                          A.LOGISTICS_ORDER,
                          A.UNLOAD_PORT,
                          A.SHIPMENT_DATE,
                          A.SEQID,
                          A.TOTAL_ORDER_BOX,
                          A.ORDER_PACKAGE,
                          A.STANDARD_PACKAGE,
                          A.PURCHASE_TYPE
                     FROM MM_MP_GAM_PUR_ORDER A
                    WHERE A.UNLOAD_PORT = VO.UNLOAD_PORT
                      AND A.LOGISTICS_ORDER = VO.LOGISTICS_ORDER
                      AND A.SUP_FACTORY = VO.SUP_FACTORY
                      AND A.SUPPLIER_NO = VO.SUPPLIER_NO
                      AND A.GROUP_ID = VO.GROUP_ID
                      AND A.FACTORY_CODE = in_arr_factory) LOOP
      
        FOR LINE_TT IN (SELECT ROWNUM AS RN,
                               A.PLAN_ORDER_ID,
                               A.PART_NO,
                               A.ORDER_NUM,
                               A.PART_UNIT,
                               A.LOGISTICS_FLAG,
                               A.ORDER_DEPOT,
                               A.ARRIVE_TIME,
                               A.LOGISTICS_ORDER,
                               A.UNLOAD_PORT,
                               A.SHIPMENT_DATE,
                               A.SEQID,
                               A.TOTAL_ORDER_BOX,
                               A.ORDER_PACKAGE,
                               A.STANDARD_PACKAGE,
                               A.PURCHASE_TYPE
                          FROM MM_MP_GAM_PUR_ORDER A
                         WHERE A.UNLOAD_PORT = VO.UNLOAD_PORT
                           AND A.LOGISTICS_ORDER = VO.LOGISTICS_ORDER
                           AND A.SUP_FACTORY = VO.SUP_FACTORY
                           AND A.SUPPLIER_NO = VO.SUPPLIER_NO
                           AND A.GROUP_ID = VO.GROUP_ID
                           AND A.SEQID = LINE.SEQID
                           AND A.FACTORY_CODE = in_arr_factory) LOOP
          --写入订单明细表 ???支给总成标识
          INSERT INTO MM_MP_PUR_ORDER_DETAIL
            (ORDER_NO,
             PURCHASE_NO,
             ROW_NO,
             PART_NO,
             TOTAL_ORDER_NUM,
             PART_UNIT,
             ARRIVE_TIME,
             SHIPMENT_TIME,
             ORDER_DEPOT,
             LOGISTICS_FLAG,
             UNLOAD_PORT,
             LOGISTICS_ORDER,
             ORDER_PACKAGE,
             STANDARD_PACKAGE,
             PURCHASE_TYPE)
          VALUES
            (V_GAM_ORDER,
             V_GAM_ORDER,
             V_GAM_LINE_NO * 10,
             LINE_TT.PART_NO,
             LINE_TT.ORDER_NUM,
             LINE_TT.PART_UNIT,
             LINE_TT.ARRIVE_TIME,
             LINE_TT.SHIPMENT_DATE,
             LINE_TT.ORDER_DEPOT,
             LINE_TT.LOGISTICS_FLAG,
             LINE_TT.UNLOAD_PORT,
             LINE_TT.LOGISTICS_ORDER,
             LINE_TT.ORDER_PACKAGE,
             LINE_TT.STANDARD_PACKAGE,
             LINE_TT.PURCHASE_TYPE);
        END LOOP;
        V_GAM_LINE_NO := V_GAM_LINE_NO + 1;
      END LOOP;
      V_GAM_LINE_NO := 1;
    
      --删除GAM订单
      DELETE FROM MM_MP_GAM_PUR_ORDER A
       WHERE A.LOGISTICS_ORDER = VO.LOGISTICS_ORDER
         AND A.SUP_FACTORY = VO.SUP_FACTORY
         AND A.SUPPLIER_NO = VO.SUPPLIER_NO
         AND A.UNLOAD_PORT = VO.UNLOAD_PORT
         AND A.GROUP_ID = VO.GROUP_ID
         AND A.FACTORY_CODE = in_arr_factory;
    
    END LOOP;
  
    --更新车型代码
    UPDATE MM_MP_PART_SORT A
       SET A.CAR_TYPE =
           (SELECT B.CAR_TYPE
              FROM (SELECT DISTINCT MP.SUPPLIER_NO,
                                    MP.SUP_FACTORY,
                                    MP.FACTORY_CODE,
                                    MP.UNLOAD_PORT,
                                    MP.MODEL_CODE CAR_TYPE
                      FROM MM_MP_PART MP
                     WHERE MP.FACTORY_CODE = in_arr_factory
                       AND MP.ORDER_PRODUCT_NUM > 0
                       AND MP.EFF_START <= SYSDATE
                       AND MP.EFF_END > SYSDATE) B
             WHERE A.SUPPLIER_NO = B.SUPPLIER_NO
               AND A.SUP_FACTORY = B.SUP_FACTORY
               AND A.UNLOAD_PORT = B.UNLOAD_PORT)
     WHERE A.CAR_TYPE IS NULL;
  
    --记录每次结束点日志
    INSERT INTO MM_MP_CAL_END_LOG
      (CAL_POINT, CAR_TYPE, SORT_ID)
      SELECT A.CAL_POINT, A.CAR_TYPE, B.SORT_ID
        FROM MM_MP_CAL_END A
        LEFT JOIN MM_MP_CAR_TYPE_QUEUE B
          ON A.CAR_TYPE = B.MULTI_CAR_TYPE
         AND A.CAL_POINT = B.CAR_TYPE_SORT_ID;
    COMMIT;
  
    --更新计划中的计算状态
    UPDATE MM_MP_VEH_PLAN A
       SET A.CAL_STATUS = 1
     WHERE EXISTS (SELECT 1
              FROM MM_MP_VEH_PLAN B
              LEFT JOIN (SELECT *
                          FROM MM_MP_CAR_TYPE_QUEUE T
                         WHERE T.MULTI_CAR_TYPE = T.CAR_TYPE
                           AND T.CAR_TYPE IS NOT NULL) C
                ON B.SORT_ID = C.SORT_ID
              LEFT JOIN MM_MP_CAL_END CE
                ON CE.CAR_TYPE = C.MULTI_CAR_TYPE
             WHERE A.SORT_ID = B.SORT_ID
               AND C.CAR_TYPE_SORT_ID <= CE.CAL_POINT)
       AND A.FACTORY_CODE = in_arr_factory;
  
    COMMIT;
  
    --生成订单删除本次MM_MP_PUR_ORDER_TEMP数据
    DELETE FROM MM_MP_PUR_ORDER_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
    COMMIT;
  
    --查询W+1 和W+2最大版本号
    BEGIN
      SELECT NVL(MAX(A.VERSION), 0)
        INTO v_max_version
        FROM MM_MP_PRO_PLAN_HIS A
       WHERE A.VERSION IS NOT NULL
         AND A.FACTORY_CODE = in_arr_factory;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        v_max_version := 0;
    END;
    --将更新用于对比的W+1 和 W+2数据状态更新为最新的班并且写入时间更新
    UPDATE MM_MP_PRO_PLAN_HIS A
       SET A.VERSION = v_max_version + 1, A.WRITE_TIME = SYSDATE
     WHERE A.VERSION IS NULL
       AND A.FACTORY_CODE = in_arr_factory;
  
  END USP_MP_PO_GAM_NEW;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_GET_ADJ_PLAN
  --功能描述：获取调整计划
  --参数说明：
  --in_arr_factory 工厂代码
  --in_start_date 开始日期
  --in_end_date 结束日期
  --创建人员: wangyu
  --创建时间： 2018/09/21
  PROCEDURE USP_MP_GET_ADJ_PLAN(in_arr_factory IN VARCHAR2,
                                in_start_date  IN VARCHAR2,
                                in_end_date    IN VARCHAR2,
                                out_code       OUT NUMBER) AS
    err_num number;
    err_msg varchar2(200);
  BEGIN
    --先删除上次获取的调整计划
    DELETE FROM MM_MP_ADJ_PLAN A WHERE A.FACTORY_CODE = in_arr_factory;
  
    COMMIT;
  
    --获取调整计划
    INSERT INTO MM_MP_ADJ_PLAN
      (ID,
       FACTORY_CODE,
       CAR_TYPE,
       DIFF_NUM,
       ADJ_DATE,
       CREATION_USER,
       CREATION_TIME)
      SELECT A.ID,
             A.FACTORY_CODE,
             A.CAR_TYPE,
             A.DIFF_NUM,
             A.ADJ_DATE,
             A.CREATION_USER,
             SYSDATE
        FROM MM_MP_ADJ_PLAN_HIS A
       WHERE A.FACTORY_CODE = in_arr_factory
         AND A.ADJ_DATE >=
             NVL(TO_DATE(in_start_date, 'YYYY-MM-DD'),
                 TO_DATE('1970-01-01', 'YYYY-MM-DD'))
         AND A.ADJ_DATE <=
             NVL(TO_DATE(in_end_date, 'YYYY-MM-DD'),
                 TO_DATE('9999-12-31', 'YYYY-MM-DD'));
  
    COMMIT;
  
    --执行成功
    out_code := 0;
  
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_GET_ADJ_PLAN',
           err_num,
           err_msg,
           sysdate,
           '获取调整计划');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_GET_ADJ_PLAN;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_ADJ_DIFF_MAIN
  --功能描述：调整计划差异对比
  --参数说明：
  --in_arr_factory 工厂代码
  --in_opeid 操作人
  --创建人员: wangyu
  --创建时间： 2018/09/25
  PROCEDURE USP_MP_ADJ_DIFF_MAIN(in_arr_factory IN VARCHAR2,
                                 in_opeid       IN VARCHAR2,
                                 out_code       OUT NUMBER) AS
    err_num number;
    err_msg varchar2(200);
  BEGIN
    --删除上次计算的结果
    DELETE FROM MM_MP_ADJ_ORDER_DIFF A
     WHERE A.FACTORY_CODE = in_arr_factory;
  
    --删除上次计算临时表数据
    DELETE FROM MM_MP_ADJ_ORDER_DIFF_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
  
    COMMIT;
  
    --根据调整计划和调整计划的BOM算差异
    FOR PLAN IN (SELECT A.ADJ_DATE,
                        B.PART_ID,
                        (A.DIFF_NUM * B.NUM) TOTAL_NUM
                   FROM MM_MP_ADJ_PLAN A
                   LEFT JOIN MM_MP_ADJ_BOM B
                     ON A.FACTORY_CODE =
                        PKG_IF_REC.USF_TRANS_ERP_FACTORY(B.COMP)
                    AND A.CAR_TYPE = B.CAR_TYPE
                    AND TRUNC(A.ADJ_DATE) = TRUNC(B.ADJ_DATE)
                  WHERE A.FACTORY_CODE = in_arr_factory) LOOP
      --将需求写入临时表
      INSERT INTO MM_MP_ADJ_ORDER_DIFF_TEMP
        (PART_NO,
         ADJ_DATE,
         CAL_DIFF_NUM,
         FACTORY_CODE,
         CREATION_USER,
         CREATION_TIME)
      VALUES
        (PLAN.PART_ID,
         PLAN.ADJ_DATE,
         PLAN.TOTAL_NUM,
         in_arr_factory,
         'SYSTEM',
         SYSDATE);
    END LOOP;
    COMMIT;
  
    --将临时需求分组写入正式表
    INSERT INTO MM_MP_ADJ_ORDER_DIFF
      (ID,
       SUPPLIER_NO,
       PART_NO,
       ADJ_DATE,
       CAL_DIFF_NUM,
       ADJ_DIFF_NUM,
       FACTORY_CODE,
       CREATION_USER,
       CREATION_TIME)
      SELECT SEQ_MM_MP_ADJ_ORDER_DIFF.NEXTVAL,
             C.SUPPLIER_NO,
             C.PART_NO,
             C.ADJ_DATE,
             C.CAL_DIFF_NUM,
             0,
             in_arr_factory,
             'SYSTEM',
             SYSDATE
        FROM (SELECT MIN(D.SUPPLIER_NO) SUPPLIER_NO,
                     A.PART_NO,
                     A.ADJ_DATE,
                     SUM(A.CAL_DIFF_NUM) CAL_DIFF_NUM
                FROM MM_MP_ADJ_ORDER_DIFF_TEMP A
                LEFT JOIN (SELECT B.PART_NO,
                                 MIN(B.SUPPLIER_NO) SUPPLIER_NO,
                                 B.FACTORY_CODE
                            FROM MM_PUB_PART_SUPPLIER B
                           WHERE B.FACTORY_CODE = in_arr_factory
                           GROUP BY B.PART_NO, B.FACTORY_CODE) D
                  ON A.PART_NO = D.PART_NO
                 AND D.FACTORY_CODE = A.FACTORY_CODE
               WHERE A.FACTORY_CODE = in_arr_factory
               GROUP BY A.PART_NO, A.ADJ_DATE) C;
  
    COMMIT;
  
    --记录操作日志
    INSERT INTO MM_MP_OPE_LOG
      (OPE_TYPE, OPE_USER, OPE_TIME, CREATION_USER, CREATION_TIME)
    VALUES
      (0, in_opeid, SYSDATE, 'SYSTEM', SYSDATE);
  
    COMMIT;
  
    --执行成功
    out_code := 0;
  
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_ADJ_DIFF_MAIN',
           err_num,
           err_msg,
           sysdate,
           '调整计划差异对比');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_ADJ_DIFF_MAIN;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_GET_TRIAL_PLAN
  --功能描述：获取试制计划
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/26
  PROCEDURE USP_MP_GET_TRIAL_PLAN(in_arr_factory IN VARCHAR2,
                                  out_code       OUT NUMBER) AS
    v_sort_id number;
    err_num   number;
    err_msg   varchar2(200);
  BEGIN
    --更新W+3周中使用状态使用计算状态为未计算的
    UPDATE MM_PUB_PRO_PLAN A
       SET A.USE_FLAG = 0
     WHERE A.CAL_STATUS = 0
       AND A.PHASE IN ('6', '2', '3', '4')
       AND A.USE_FLAG = 1
       AND A.FACTORY_CODE = in_arr_factory;
  
    --获取新车型计划之前将试制计划中为未订购的数据删除
    DELETE FROM MM_MP_TRIAL_PLAN A
     WHERE A.CAL_STATUS = 0
       AND A.FACTORY_CODE = in_arr_factory;
  
    COMMIT;
  
    --将数据写入到新车型计划
    --先获取新车型的最大SORT_ID
    SELECT NVL(MAX(A.SORT_ID), 0)
      INTO v_sort_id
      FROM MM_MP_TRIAL_PLAN A
     WHERE A.CAL_STATUS = 1
       AND A.FACTORY_CODE = in_arr_factory;
  
    --循环W+3周中未计算的试制车计划
    FOR PLAN IN (SELECT A.*, ROW_NUMBER() OVER(ORDER BY A.CREATION_TIME) RN
                   FROM MM_PUB_PRO_PLAN A
                  WHERE A.PHASE IN ('6', '2', '3', '4')
                    AND A.CAL_STATUS = 0
                    AND A.FACTORY_CODE = in_arr_factory
                  ORDER BY A.CREATION_TIME) LOOP
    
      --往试制车计划表写入数据
      INSERT INTO MM_MP_TRIAL_PLAN
        (SORT_ID,
         FACTORY_CODE,
         CAR_TYPE,
         ORDER_NO,
         AFOFF_DATE,
         WEON_TIME,
         PRO_PHASE,
         CREATION_USER,
         CREATION_TIME,
         CAL_STATUS)
      VALUES
        (v_sort_id + PLAN.RN,
         in_arr_factory,
         PLAN.MODEL_CODE,
         PLAN.ORDER_NO,
         PLAN.AFOFF_TIME,
         PLAN.WEON_TIME,
         PLAN.PHASE,
         'SYSTEM',
         SYSDATE,
         0);
    
      --更新W+3周计划状态为已使用
      UPDATE MM_PUB_PRO_PLAN B
         SET B.USE_FLAG = 1
       WHERE B.FACTORY_CODE = in_arr_factory
         AND TRUNC(B.AFOFF_TIME) = TRUNC(PLAN.AFOFF_TIME)
         AND B.SORT_ID = PLAN.SORT_ID;
    END LOOP;
  
    COMMIT;
  
    --执行成功
    out_code := 0;
  
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_GET_TRIAL_PLAN',
           err_num,
           err_msg,
           sysdate,
           '获取试制计划');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_GET_TRIAL_PLAN;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_TRIAL_ZSB
  --功能描述：计算试制车计划需求
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/27
  PROCEDURE USP_MP_TRIAL_ZSB(in_arr_factory IN VARCHAR2,
                             out_code       OUT NUMBER) AS
    err_num           number;
    err_msg           varchar2(200);
    v_logistics_order varchar2(25);
  BEGIN
    --计算之前先删除临时需求数据
    DELETE FROM MM_MP_TRIAL_DEMAND_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
  
    --本次计算先删除上次需求表里面状态为未生成的数据
    DELETE FROM MM_MP_TRIAL_DEMAND A
     WHERE A.REL_STATUS = 0
       AND A.FACTORY_CODE = in_arr_factory;
  
    COMMIT;
  
    FOR PLAN IN (SELECT A.AFOFF_DATE,
                        MIN(A.WEON_TIME) WEON_TIME,
                        A.ORDER_NO,
                        COUNT(1) NUM
                   FROM MM_MP_TRIAL_PLAN A
                  WHERE A.FACTORY_CODE = in_arr_factory
                    AND A.CAL_STATUS = 0
                  GROUP BY A.AFOFF_DATE, A.ORDER_NO) LOOP
    
      --新增试制需求到临时表
      INSERT INTO MM_MP_TRIAL_DEMAND_TEMP
        (PART_NO,
         ARRIVE_TIME,
         ORDER_NUM,
         CREATION_USER,
         CREATION_TIME,
         WORKCENTER,
         FACTORY_CODE,
         PURCHASE_TYPE)
        SELECT B.PART_NO,
               CASE
               --判断如果是焊装的零件，则使用焊装上线日期往前推一周
                 WHEN B.WORKCENTER = 'W1' THEN
                  TO_DATE(TO_CHAR(PLAN.WEON_TIME - 7,
                                  'YYYY-MM-DD HH24:MI:SS'),
                          'YYYY-MM-DD HH24:MI:SS')
                 ELSE
                 --否则使用总装下线日期往前推一周
                  TO_DATE(TO_CHAR(PLAN.AFOFF_DATE - 7,
                                  'YYYY-MM-DD HH24:MI:SS'),
                          'YYYY-MM-DD HH24:MI:SS')
               END,
               B.NUM * PLAN.NUM,
               'SYSTEM',
               SYSDATE,
               B.WORKCENTER,
               in_arr_factory,
               B.PURCHASE_TYPE
          FROM MM_PUB_ORDER_BOM B
         WHERE B.ORDER_NO = PLAN.ORDER_NO
           AND B.FACTORY_CODE = in_arr_factory
           AND B.PURCHASE_TYPE IS NOT NULL;
    END LOOP;
    COMMIT;
  
    --统计临时表需求写入正式表
    INSERT INTO MM_MP_TRIAL_DEMAND
      (ID,
       SUPPLIER_NO,
       SUP_FACTORY,
       PART_NO,
       ARRIVE_TIME,
       ORDER_NUM,
       EXC_ORDER_NUM,
       TOTAL_ORDER_NUM,
       FACTORY_CODE,
       WORKCENTER,
       PURCHASE_TYPE,
       CREATION_USER,
       CREATION_TIME)
      SELECT SEQ_MM_MP_TRIAL_DEMAND.NEXTVAL,
             D.SUPPLIER_NO,
             D.SUP_FACTORY,
             D.PART_NO,
             D.ARRIVE_TIME,
             D.ORDER_NUM,
             0,
             D.ORDER_NUM,
             D.FACTORY_CODE,
             D.WORKCENTER,
             D.PURCHASE_TYPE,
             'SYSTEM',
             SYSDATE
        FROM (SELECT C.SUPPLIER_NO,
                     C.SUP_FACTORY,
                     B.PART_NO PART_NO,
                     TO_CHAR(B.ARRIVE_TIME, 'IW'),
                     MIN(B.ARRIVE_TIME) ARRIVE_TIME,
                     SUM(B.ORDER_NUM) ORDER_NUM,
                     MIN(B.FACTORY_CODE) FACTORY_CODE,
                     B.WORKCENTER,
                     MIN(B.PURCHASE_TYPE) PURCHASE_TYPE
                FROM MM_MP_TRIAL_DEMAND_TEMP B
                LEFT JOIN MM_PUB_PART_UDA C
                  ON B.PART_NO = C.PART_NO
                    /*                 AND C.EFF_START <= SYSDATE
                    AND C.EFF_END > SYSDATE*/
                 AND C.FACTORY_CODE = B.FACTORY_CODE
               WHERE B.FACTORY_CODE = in_arr_factory
               GROUP BY B.PART_NO,
                        C.SUPPLIER_NO,
                        C.SUP_FACTORY,
                        TO_CHAR(B.ARRIVE_TIME, 'IW'),
                        B.WORKCENTER) D;
  
    --把没有供应商的需求数据删除
    DELETE FROM MM_MP_TRIAL_DEMAND A
     WHERE A.SUPPLIER_NO IS NULL
       AND A.FACTORY_CODE = in_arr_factory;
  
    COMMIT;
  
    --执行成功
    out_code := 0;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_TRIAL_ZSB',
           err_num,
           err_msg,
           sysdate,
           '计算试制车计划需求');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_TRIAL_ZSB;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_TRIAL_PO
  --功能描述：试制车订单生成
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/28
  PROCEDURE USP_MP_TRIAL_PO(in_arr_factory IN VARCHAR2,
                            in_opeid       IN VARCHAR2,
                            out_code       OUT NUMBER) AS
    err_num         number;
    err_msg         varchar2(200);
    min_arrive_time date;
  
    --物流订单号
    v_order varchar2(50);
  BEGIN
    --循环订单头
    FOR HEAD IN (SELECT A.SUPPLIER_NO, A.ARRIVE_TIME, A.FACTORY_CODE
                   FROM MM_MP_TRIAL_DEMAND A
                  WHERE A.FACTORY_CODE = in_arr_factory
                    AND A.TOTAL_ORDER_NUM > 0
                    AND A.REL_STATUS = 0
                  GROUP BY A.SUPPLIER_NO, A.ARRIVE_TIME, A.FACTORY_CODE) LOOP
      --获取物流订单号
      v_order := PKG_PUB.USF_GET_ORDER_NO_BY_DATE(in_arr_factory,
                                                  'TRIAL',
                                                  HEAD.ARRIVE_TIME);
      --写入订单头表
      INSERT INTO MM_MP_TRIAL_ORDER
        (ORDER_NO,
         PURCHASE_NO,
         FACTORY_CODE,
         SUPPLIER_NO,
         SUP_FACTORY,
         ARRIVE_DATE,
         CREATION_USER,
         CREATION_TIME,
         ID)
        SELECT v_order,
               v_order,
               B.FACTORY_CODE,
               B.SUPPLIER_NO,
               MIN(B.SUP_FACTORY),
               B.ARRIVE_TIME,
               MIN(B.CREATION_USER),
               SYSDATE,
               PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_MP_TRIAL_ORDER')
          FROM MM_MP_TRIAL_DEMAND B
         WHERE B.SUPPLIER_NO = HEAD.SUPPLIER_NO
           AND B.ARRIVE_TIME = HEAD.ARRIVE_TIME
           AND B.FACTORY_CODE = HEAD.FACTORY_CODE
         GROUP BY B.SUPPLIER_NO, B.ARRIVE_TIME, B.FACTORY_CODE;
    
      /* VALUES(v_order,
      v_order,
      HEAD.FACTORY_CODE,
      HEAD.SUPPLIER_NO,
      HEAD.SUP_FACTORY,
      HEAD.ARRIVE_TIME,
      in_opeid,
      SYSDATE,
      HEAD.ID);*/
    
      --写入订单明细表
      INSERT INTO MM_MP_TRIAL_ORDER_DETAIL
        (ORDER_NO, ROW_NO, PART_NO, ORDER_NUM, PURCHASE_TYPE, ORDER_DEPOT)
        SELECT v_order,
               ROW_NUMBER() OVER(ORDER BY B.PART_NO) * 10,
               B.PART_NO,
               B.TOTAL_ORDER_NUM,
               B.PURCHASE_TYPE,
               CASE B.WORKCENTER
                 WHEN 'A1' THEN
                  '3402'
                 WHEN 'W1' THEN
                  '3202'
                 ELSE
                  B.WORKCENTER
               END
          FROM MM_MP_TRIAL_DEMAND B
         WHERE B.SUPPLIER_NO = HEAD.SUPPLIER_NO
           AND B.ARRIVE_TIME = HEAD.ARRIVE_TIME
           AND B.FACTORY_CODE = HEAD.FACTORY_CODE;
      /*      VALUES
      (v_order,
       10,
       HEAD.PART_NO,
       HEAD.TOTAL_ORDER_NUM,
       HEAD.PURCHASE_TYPE,
       CASE HEAD.WORKCENTER WHEN 'A1' THEN '3402' WHEN 'W1' THEN '3202' ELSE
       HEAD.WORKCENTER END);*/
    
      --记录订单和需求的对应关系
      INSERT INTO MM_MP_TRIAL_OD_RELATION
        (DEMAND_ID, ORDER_NO, CREATION_USER, CREATION_TIME, FACTORY_CODE)
        SELECT B.ID, v_order, B.CREATION_USER, SYSDATE, B.FACTORY_CODE
          FROM MM_MP_TRIAL_DEMAND B
         WHERE B.SUPPLIER_NO = HEAD.SUPPLIER_NO
           AND B.ARRIVE_TIME = HEAD.ARRIVE_TIME
           AND B.FACTORY_CODE = HEAD.FACTORY_CODE;
    
      --更新需求中的生成状态
      UPDATE MM_MP_TRIAL_DEMAND B
         SET B.REL_STATUS = 9, B.REL_TIME = SYSDATE
       WHERE B.SUPPLIER_NO = HEAD.SUPPLIER_NO
         AND B.ARRIVE_TIME = HEAD.ARRIVE_TIME
         AND B.FACTORY_CODE = HEAD.FACTORY_CODE;
    END LOOP;
  
    COMMIT;
  
    ---更新W+3周计划中的计算状态
    UPDATE MM_PUB_PRO_PLAN A
       SET A.CAL_STATUS = 1, A.USE_FLAG = 0
     WHERE A.USE_FLAG = 1
       AND A.FACTORY_CODE = in_arr_factory
       AND A.PHASE IN ('6', '2', '3', '4');
    COMMIT;
  
    --更新试制车计划的计算状态
    UPDATE MM_MP_TRIAL_PLAN A
       SET A.CAL_STATUS = 1
     WHERE A.FACTORY_CODE = in_arr_factory;
    COMMIT;
  
    --执行成功
    out_code := 0;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_TRIAL_PO',
           err_num,
           err_msg,
           sysdate,
           '试制车订单生成');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_TRIAL_PO;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_EXC_ZSB
  --功能描述：统计例外订单需求
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/28
  /*  PROCEDURE USP_MP_EXC_ZSB(in_arr_factory IN VARCHAR2,
                           out_code       OUT INTEGER) AS
    err_num number;
    err_msg varchar2(200);
    v_count number;
  BEGIN
    --先判断在MM_MP_EXCEP_ORDER_DEMAND是否存在有使用状态为1的数据，如果有为1的数据
    SELECT count(1)
      INTO v_count
      FROM MM_MP_EXCEP_ORDER_DEMAND A
     WHERE A.FACTORY_CODE = in_arr_factory
       AND A.USE_FLAG = 1;
  
    IF v_count > 0 THEN
      out_code := 0;
    ELSE
      --先删除历史表中未计算的需求数据
      DELETE FROM MM_MP_EXCEP_ORDER_DEMAND_HIS A
       WHERE A.FACTORY_CODE = in_arr_factory
         AND A.CAL_STATUS = 0;
  
      COMMIT;
  
      --将导入的需求根据零件，出货地和到货日期分组写入到需求历史表，计算状态为0
      INSERT INTO MM_MP_EXCEP_ORDER_DEMAND_HIS
        (ID,
         SUPPLIER_NO,
         SUP_FACTORY,
         PART_NO,
         ORDER_NUM,
         ARRIVE_DATE,
         FACTORY_CODE,
         CREATION_USER,
         CREATION_TIME)
        SELECT SEQ_MM_MP_EXC_DEMAND_HIS.NEXTVAL,
               D.SUPPLIER_NO,
               D.SUP_FACTORY,
               D.PART_NO,
               D.ORDER_NUM,
               D.ARRIVE_DATE,
               D.FACTORY_CODE,
               'SYSTEM',
               SYSDATE
          FROM (SELECT MIN(A.SUPPLIER_NO) SUPPLIER_NO,
                       A.SUP_FACTORY,
                       A.PART_NO,
                       MIN(A.ARRIVE_DATE) ARRIVE_DATE,
                       SUM(A.ORDER_NUM) ORDER_NUM,
                       MIN(A.FACTORY_CODE) FACTORY_CODE
                  FROM MM_MP_EXCEP_ORDER_DEMAND A
                 WHERE A.FACTORY_CODE = in_arr_factory
                 GROUP BY A.SUP_FACTORY, A.PART_NO, TRUNC(A.ARRIVE_DATE), A.) D;
  
      --根据工厂更新例外需求使用状态为1   后台需要判断如果需求中存在使用状态为1的就不能执行生成操作
      UPDATE MM_MP_EXCEP_ORDER_DEMAND A
         SET A.USE_FLAG = 1
       WHERE A.FACTORY_CODE = in_arr_factory;
  
      out_code := 2;
  
    END IF;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num  := sqlcode;
        out_code := 1;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_EXC_ZSB',
           err_num,
           err_msg,
           sysdate,
           '统计例外订单需求');
        COMMIT;
  
      END;
  END USP_MP_EXC_ZSB;*/
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_EXC_PO_ZSB
  --功能描述：例外订购组单
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/28
  PROCEDURE USP_MP_EXC_PO(in_arr_factory IN VARCHAR2,
                          in_opeid       IN VARCHAR2,
                          out_code       OUT NUMBER) AS
    err_num number;
    err_msg varchar2(200);
  
    min_arrive_time date;
  
    --物流订单号
    v_order varchar2(50);
  BEGIN
    --将需求写入历史需求表
    INSERT INTO MM_MP_EXCEP_ORDER_DEMAND_HIS
      (ID,
       SUPPLIER_NO,
       SUP_FACTORY,
       PART_NO,
       ORDER_NUM,
       ARRIVE_DATE,
       FACTORY_CODE,
       CREATION_USER,
       CREATION_TIME,
       CAL_STATUS,
       STORAGE,
       USE,
       DEMAND_DEPARTMENT,
       DEMANDER,
       CON_NUMBER,
       OPT_USER,
       OPT_TIME)
      SELECT D.ID,
             D.SUPPLIER_NO,
             D.SUP_FACTORY,
             D.PART_NO,
             D.ORDER_NUM,
             D.ARRIVE_DATE,
             D.FACTORY_CODE,
             'SYSTEM',
             SYSDATE,
             '0',
             D.STORAGE,
             D.USE,
             D.DEMAND_DEPARTMENT,
             D.DEMANDER,
             D.CON_NUMBER,
             D.OPT_USER,
             D.OPT_TIME
        FROM MM_MP_EXCEP_ORDER_DEMAND D;
  
    --删除临时的需求数据
    DELETE FROM MM_MP_EXCEP_ORDER_DEMAND A
     WHERE A.FACTORY_CODE = in_arr_factory;
  
    --循环订单头
    FOR HEAD IN (SELECT A.SUP_FACTORY,
                        TRUNC(A.ARRIVE_DATE) ARRIVE_DATE,
                        A.STORAGE,
                        A.SUPPLIER_NO,
                        A.DEMANDER
                   FROM MM_MP_EXCEP_ORDER_DEMAND_HIS A
                  WHERE A.CAL_STATUS = 0
                    AND A.FACTORY_CODE = in_arr_factory
                  GROUP BY A.SUP_FACTORY,
                           TRUNC(A.ARRIVE_DATE),
                           A.STORAGE,
                           A.SUPPLIER_NO,
                           A.DEMANDER
                  ORDER BY TRUNC(A.ARRIVE_DATE) ASC) LOOP
    
      --查询最小的到达时间
      SELECT MIN(A.ARRIVE_DATE)
        INTO min_arrive_time
        FROM MM_MP_EXCEP_ORDER_DEMAND_HIS A
       WHERE A.FACTORY_CODE = in_arr_factory
         AND A.SUP_FACTORY = HEAD.SUP_FACTORY
         AND A.SUPPLIER_NO = HEAD.SUPPLIER_NO
         AND A.DEMANDER = HEAD.DEMANDER
         AND A.CAL_STATUS = 0
         AND TRUNC(A.ARRIVE_DATE) = HEAD.ARRIVE_DATE
         AND A.STORAGE = HEAD.STORAGE;
    
      --获取物流订单号
      v_order := PKG_PUB.USF_GET_ORDER_NO_BY_DATE(in_arr_factory,
                                                  'EXC',
                                                  min_arrive_time);
      --写入订单头表
      INSERT INTO MM_MP_EXCEP_ORDER
        (ORDER_NO,
         PURCHASE_NO,
         SUPPLIER_NO,
         SUP_FACTORY,
         ARRIVE_DATE,
         FACTORY_CODE,
         FLAG,
         CREATION_USER,
         CREATION_TIME)
      VALUES
        (v_order,
         v_order,
         HEAD.SUPPLIER_NO,
         HEAD.SUP_FACTORY,
         min_arrive_time,
         in_arr_factory,
         0,
         in_opeid,
         SYSDATE);
    
      --循环订单行
      FOR LINE IN (SELECT A.*, ROWNUM RN
                     FROM MM_MP_EXCEP_ORDER_DEMAND_HIS A
                    WHERE A.SUP_FACTORY = HEAD.SUP_FACTORY
                      AND A.SUPPLIER_NO = HEAD.SUPPLIER_NO
                      AND A.DEMANDER = HEAD.DEMANDER
                      AND TRUNC(A.ARRIVE_DATE) = HEAD.ARRIVE_DATE
                      AND A.STORAGE = HEAD.STORAGE
                      AND A.FACTORY_CODE = in_arr_factory
                      AND A.CAL_STATUS = 0
                    ORDER BY A.PART_NO) LOOP
      
        --写入订单行
        INSERT INTO MM_MP_EXCEP_ORDER_DETAIL
          (ORDER_NO,
           ROW_NO,
           PART_NO,
           ORDER_NUM,
           ORDER_DEPOT,
           USE,
           DEMAND_DEPARTMENT,
           DEMANDER,
           CON_NUMBER,
           OPT_USER,
           OPT_TIME)
        VALUES
          (v_order,
           LINE.RN * 10,
           LINE.PART_NO,
           LINE.ORDER_NUM,
           LINE.STORAGE,
           LINE.USE,
           LINE.DEMAND_DEPARTMENT,
           LINE.DEMANDER,
           LINE.CON_NUMBER,
           LINE.OPT_USER,
           LINE.OPT_TIME);
      
        --更新历史订购需求的状态
        UPDATE MM_MP_EXCEP_ORDER_DEMAND_HIS A
           SET A.CAL_STATUS = 1, A.CAL_TIME = SYSDATE
         WHERE A.ID = LINE.ID
           AND A.FACTORY_CODE = LINE.FACTORY_CODE;
      
        --记录订单和需求的对应关系
        INSERT INTO MM_MP_EXC_OD_RELATION
          (DEMAND_ID, ORDER_NO, CREATION_USER, CREATION_TIME, FACTORY_CODE)
        VALUES
          (LINE.ID, v_order, 'SYSTEM', SYSDATE, in_arr_factory);
      
      --将现在
      END LOOP;
    END LOOP;
  
    COMMIT;
  
    --执行成功
    out_code := 0;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_EXC_PO',
           err_num,
           err_msg,
           sysdate,
           '例外订购组单');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_EXC_PO;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_GEN_SW_PARTLABEL
  --功能描述：生成协同标签
  --参数说明：
  --in_order 订单号
  --创建人员: wangyu
  --创建时间： 2018/10/16
  PROCEDURE USP_GEN_SW_PARTLABEL(in_order IN VARCHAR2) AS
  BEGIN
    FOR cur_part IN (SELECT B.PART_NO || '#' || B.STANDARD_PACKAGE || '#' ||
                            A.PURCHASE_NO || '#' || B.PURCHASE_ROWNO || '#' ||
                            A.ORDER_NO || '#' || C.PART_SHORT_NO || '#' ||
                            A.ORDER_TYPE || '##' || A.SUPPLIER_NO || '##' ||
                            B.STANDARD_PACKAGE || '#' || SYS_GUID() AS STR
                       FROM MM_SW_ORDER A
                       LEFT JOIN MM_SW_ORDER_DETAIL B
                         ON A.PURCHASE_NO = B.PURCHASE_NO
                       LEFT JOIN MM_PUB_PART C
                         ON B.PART_NO = C.PART_NO
                      WHERE A.ORDER_NO = in_order) LOOP
      DBMS_OUTPUT.PUT_LINE(cur_part.STR);
    END LOOP;
  END USP_GEN_SW_PARTLABEL;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MM_MP_INIT_WEEK_PLAN
  --功能描述：每个月第一天初始化这个月的周计划
  --根据MES下发的工作日历初始化
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/12/09
  PROCEDURE USP_MM_MP_INIT_WEEK_PLAN(in_arr_factory IN VARCHAR2) AS
    err_num      number;
    err_msg      varchar2(200);
    v_year_month varchar2(10);
    v_cur_day    date;
  BEGIN
    --赋予当前日期
    v_cur_day := SYSDATE;
  
    --获取当前的年月
    v_year_month := TO_CHAR(v_cur_day, 'YYYY-MM');
  
    --先删除临时的工作日历
    DELETE FROM MM_MP_WORK_CALENDAR A
     WHERE A.FACTORY_CODE = in_arr_factory;
  
    COMMIT;
  
    --将MES当前下发的最大工作日工作日抓取过来
    INSERT INTO MM_MP_WORK_CALENDAR
      SELECT *
        FROM MM_PUB_WORK_CALENDAR A
       WHERE A.WORKCENTER = 'A1'
         AND A.FACTORY_CODE = in_arr_factory
         AND A.WORK_DATE > SYSDATE
         AND A.WORK_DATE <=
             (SELECT MAX(A.WORK_DATE)
                FROM MM_PUB_WORK_CALENDAR A
               WHERE A.WORKCENTER = 'A1'
                 AND A.FACTORY_CODE = in_arr_factory);
  
    COMMIT;
  
    --写入周次计划表
    MERGE INTO MM_MP_WEEK_PLAN A
    USING (SELECT TO_CHAR(C.WORK_DATE, 'IW') WEEK,
                  TO_CHAR(C.WORK_DATE, 'YYYY') YEAR,
                  CASE
                    WHEN TO_CHAR(MAX(C.WORK_DATE), 'D') = 1 THEN
                     7
                    ELSE
                     TO_CHAR(MAX(C.WORK_DATE), 'D') - 1
                  END DAY,
                  TRUNC(MAX(C.WORK_DATE), 'd') + 1 START_DAY,
                  TRUNC(MAX(C.WORK_DATE) + 7, 'd') END_DAY
             FROM MM_MP_WORK_CALENDAR C
            WHERE TO_NUMBER(TO_CHAR(C.WORK_DATE, 'D')) < 7
              AND TO_NUMBER(TO_CHAR(C.WORK_DATE, 'D')) > 1
            GROUP BY TO_CHAR(C.WORK_DATE, 'IW'),
                     TO_CHAR(C.WORK_DATE, 'YYYY')
            ORDER BY TO_CHAR(C.WORK_DATE, 'YYYY'),
                     TO_CHAR(C.WORK_DATE, 'IW')) B
    ON (A.YEAR = B.YEAR AND A.WEEK = TO_NUMBER(B.WEEK) AND A.FACTORY_CODE = in_arr_factory)
    WHEN NOT MATCHED THEN
      INSERT
        (A.ID,
         A.YEAR,
         A.WEEK,
         A.START_DAY,
         A.END_DAY,
         A.DAY,
         A.WEEK_NUM,
         A.CREATION_USER,
         A.CREATION_TIME,
         A.FACTORY_CODE)
      VALUES
        (PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_MP_WEEK_PLAN'),
         B.YEAR,
         B.WEEK,
         B.START_DAY,
         B.END_DAY,
         B.DAY,
         3,
         'SYSTEM',
         SYSDATE,
         in_arr_factory);
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MM_MP_INIT_WEEK_PLAN',
           err_num,
           err_msg,
           sysdate,
           '每个月第一天初始化这个月的周计划');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MM_MP_INIT_WEEK_PLAN;
  --***************************************************************************
  /*
    --***************************************************************************
    --存储过程名：USP_MP_GET_PLAN_TEMP
    --功能描述：每天12点根据工作日历和周计划获取生产计划到临时表
    --参数说明：
    --in_arr_factory 工厂代码
    --创建人员: wangyu
    --创建时间： 2018/12/09
    PROCEDURE USP_MP_GET_PLAN_TEMP(in_arr_factory IN VARCHAR2) AS
      err_num number;
      err_msg varchar2(200);
      --年份
      v_year varchar2(10);
      --当前周的第几天
      v_day_num number;
      --当前天是今年的第几周
      v_week number;
      --周几获取数据
      v_day number;
      --获取几周的数据
      v_num number;
      --当前天到维护的这周第几天获取计划之间有几天是工作日
      v_work_day_num number;
      --当前天是不是工作日
      v_is_work_day number;
      cur_date      date;
      v_max_version number;
    BEGIN
      cur_date := SYSDATE;
      --拿到当前天是今年的第几周
      SELECT TO_NUMBER(TO_CHAR(cur_date, 'iw')),
             TO_CHAR(cur_date, 'YYYY'),
             DECODE(TO_CHAR(cur_date, 'd'), 1, 7, to_char(cur_date, 'd') - 1)
        INTO v_week, v_year, v_day_num
        FROM DUAL;
    
      --在周计划中找到这周的数据
      SELECT A.DAY, A.WEEK_NUM
        INTO v_day, v_num
        FROM MM_MP_WEEK_PLAN A
       WHERE A.FACTORY_CODE = in_arr_factory
         AND A.YEAR = v_year
         AND A.WEEK = v_week;
    
      IF v_day_num > v_day THEN
        --当当前周的第几天大于维护的这周第几天获取计划直接返回
        RETURN;
      ELSE
        --判断当前天到这周第几天获取计划之间有没有是工作日的
        SELECT COUNT(1)
          INTO v_work_day_num
          FROM MM_PUB_WORK_CALENDAR A
         WHERE TO_CHAR(A.WORK_DATE, 'YYYY-MM-DD') >
               TO_CHAR(cur_date, 'YYYY-MM-DD')
           AND TO_CHAR(A.WORK_DATE, 'YYYY-MM-DD') <=
               TO_CHAR(cur_date + v_day - v_day_num, 'YYYY-MM-DD')
           AND A.FACTORY_CODE = in_arr_factory;
      
        IF v_work_day_num > 0 THEN
          --表明存在工作日，则往后推
          RETURN;
        ELSE
          --表明不存在工作日,则判断当前天是否是工作日
          SELECT COUNT(1)
            INTO v_is_work_day
            FROM MM_PUB_WORK_CALENDAR A
           WHERE TO_CHAR(A.WORK_DATE, 'YYYY-MM-DD') =
                 TO_CHAR(cur_date, 'YYYY-MM-DD')
             AND A.FACTORY_CODE = in_arr_factory;
        
          IF v_is_work_day > 0 THEN
            --==========================================处理W+1 W+2数据开始========================================
            --删除该工厂临时计划数据
            DELETE FROM MM_MP_DIFF_NUM_TEMP A
             WHERE A.FACTORY_CODE = in_arr_factory;
            COMMIT;
          
            --根据工厂删除临时表的W+1和W+2数据
            DELETE FROM MM_MP_PRO_PLAN_TEMP A
             WHERE A.FACTORY_CODE = in_arr_factory;
            COMMIT;
          
            --找到新W+1和W+2的数据写入到临时表
            INSERT INTO MM_MP_PRO_PLAN_TEMP
              (SORT_ID,
               FACTORY_CODE,
               CAR_TYPE,
               ORDER_NO,
               WEON_TIME,
               AFOFF_TIME,
               PRO_PHASE,
               CAL_STATUS,
               CREATION_USER,
               IS_AUTOED,
               CREATION_TIME)
              SELECT A.SORT_ID,
                     A.FACTORY_CODE,
                     A.MODEL_CODE,
                     A.ORDER_NO,
                     A.WEON_TIME,
                     A.AFOFF_TIME,
                     A.PHASE,
                     0,
                     'SYSTEM',
                     '1',
                     SYSDATE
                FROM MM_PUB_PRO_PLAN A
               WHERE A.AFOFF_TIME >= (select trunc(cur_date, 'iw') from dual)
                 AND A.AFOFF_TIME <=
                     (select trunc(cur_date + 7, 'iw') + 7 from dual)
                 AND A.FACTORY_CODE = in_arr_factory
                 AND A.PHASE IN ('4', '5');
          
            --计算计划调整产生的差异
            --***************************************************************************
            --修改说明：从MM_MP_PRO_PLAN_TEMP中取最高版本的W+1 和 W+2周计划写入差异表
            --修改人: wangyu
            --修改时间： 2019/01/26
          
            --先查询MM_MP_DIFF_NUM_TEMP中的最高版本
            BEGIN
              SELECT MAX(A.VERSION)
                INTO v_max_version
                FROM MM_MP_PRO_PLAN_TEMP A
               WHERE A.VERSION IS NOT NULL
                 AND A.FACTORY_CODE = in_arr_factory;
            EXCEPTION
              WHEN OTHERS THEN
                v_max_version := 1;
            END;
          
            --找到旧W+1 和W+2的数据写入临时表
            INSERT INTO MM_MP_PRO_PLAN_TEMP
              (SORT_ID,
               FACTORY_CODE,
               CAR_TYPE,
               ORDER_NO,
               WEON_TIME,
               AFOFF_TIME,
               PRO_PHASE,
               CAL_STATUS,
               CREATION_USER,
               IS_AUTOED,
               CREATION_TIME,
               VERSION,
               WRITE_TIME)
              SELECT A.SORT_ID,
                     A.FACTORY_CODE,
                     A.CAR_TYPE,
                     A.ORDER_NO,
                     A.WEON_TIME,
                     A.AFOFF_TIME,
                     A.PRO_PHASE,
                     0,
                     'SYSTEM',
                     '1',
                     SYSDATE,
                     A.VERSION,
                     A.WRITE_TIME
                FROM MM_MP_PRO_PLAN_HIS A
               WHERE A.AFOFF_TIME >= (select trunc(cur_date, 'iw') from dual)
                 AND A.AFOFF_TIME <=
                     (select trunc(cur_date + 7, 'iw') + 7 from dual)
                 AND A.FACTORY_CODE = in_arr_factory
                 AND A.PRO_PHASE IN ('4', '5')
                 AND A.VERSION = v_max_version;
          
            --==========================================处理W+1 W+2数据结束========================================--==========================================处理W+1 W+2数据开始========================================
            --删除该工厂临时计划数据
            DELETE FROM MM_MP_DIFF_NUM_TEMP A
             WHERE A.FACTORY_CODE = in_arr_factory;
            COMMIT;
          
            --根据工厂删除临时表的W+1和W+2数据
            DELETE FROM MM_MP_PRO_PLAN_TEMP A
             WHERE A.FACTORY_CODE = in_arr_factory;
            COMMIT;
          
            --找到新W+1和W+2的数据写入到临时表
            INSERT INTO MM_MP_PRO_PLAN_TEMP
              (SORT_ID,
               FACTORY_CODE,
               CAR_TYPE,
               ORDER_NO,
               WEON_TIME,
               AFOFF_TIME,
               PRO_PHASE,
               CAL_STATUS,
               CREATION_USER,
               IS_AUTOED,
               CREATION_TIME)
              SELECT A.SORT_ID,
                     A.FACTORY_CODE,
                     A.MODEL_CODE,
                     A.ORDER_NO,
                     A.WEON_TIME,
                     A.AFOFF_TIME,
                     A.PHASE,
                     0,
                     'SYSTEM',
                     '1',
                     SYSDATE
                FROM MM_PUB_PRO_PLAN A
               WHERE A.AFOFF_TIME >= (select trunc(cur_date, 'iw') from dual)
                 AND A.AFOFF_TIME <=
                     (select trunc(cur_date + 7, 'iw') + 7 from dual)
                 AND A.FACTORY_CODE = in_arr_factory
                 AND A.PHASE IN ('4', '5');
          
            --计算计划调整产生的差异
            --***************************************************************************
            --修改说明：从MM_MP_PRO_PLAN_TEMP中取最高版本的W+1 和 W+2周计划写入差异表
            --修改人: wangyu
            --修改时间： 2019/01/26
          
            --先查询MM_MP_DIFF_NUM_TEMP中的最高版本
            BEGIN
              SELECT MAX(A.VERSION)
                INTO v_max_version
                FROM MM_MP_PRO_PLAN_TEMP A
               WHERE A.VERSION IS NOT NULL
                 AND A.FACTORY_CODE = in_arr_factory;
            EXCEPTION
              WHEN OTHERS THEN
                v_max_version := 1;
            END;
          
            --找到旧W+1 和W+2的数据写入临时表
            INSERT INTO MM_MP_PRO_PLAN_TEMP
              (SORT_ID,
               FACTORY_CODE,
               CAR_TYPE,
               ORDER_NO,
               WEON_TIME,
               AFOFF_TIME,
               PRO_PHASE,
               CAL_STATUS,
               CREATION_USER,
               IS_AUTOED,
               CREATION_TIME,
               VERSION,
               WRITE_TIME)
              SELECT A.SORT_ID,
                     A.FACTORY_CODE,
                     A.CAR_TYPE,
                     A.ORDER_NO,
                     A.WEON_TIME,
                     A.AFOFF_TIME,
                     A.PRO_PHASE,
                     0,
                     'SYSTEM',
                     '1',
                     SYSDATE,
                     A.VERSION,
                     A.WRITE_TIME
                FROM MM_MP_PRO_PLAN_HIS A
               WHERE A.AFOFF_TIME >= (select trunc(cur_date, 'iw') from dual)
                 AND A.AFOFF_TIME <=
                     (select trunc(cur_date + 7, 'iw') + 7 from dual)
                 AND A.FACTORY_CODE = in_arr_factory
                 AND A.PRO_PHASE IN ('4', '5')
                 AND A.VERSION = v_max_version;
          
            --==========================================处理W+1 W+2数据结束========================================
          
            --==========================================处理W+3数据开始========================================
            DELETE FROM MM_MP_VEH_PLAN_TEMP A
             WHERE A.FACTORY_CODE = in_arr_factory;
          
            COMMIT;
            --将W+3的数据写入到车辆计划临时表
            INSERT INTO MM_MP_VEH_PLAN_TEMP
              (SORT_ID,
               FACTORY_CODE,
               CAR_TYPE,
               ORDER_NO,
               WEON_TIME,
               AFOFF_TIME,
               PRO_PHASE,
               CAL_STATUS,
               CREATION_USER,
               IS_AUTOED,
               CREATION_TIME)
              SELECT A.SORT_ID,
                     A.FACTORY_CODE,
                     A.MODEL_CODE,
                     A.ORDER_NO,
                     A.WEON_TIME,
                     A.AFOFF_TIME,
                     A.PHASE,
                     0,
                     'SYSTEM',
                     '1',
                     SYSDATE
                FROM MM_PUB_PRO_PLAN A
               WHERE A.AFOFF_TIME >=
                     (select trunc(cur_date + 14, 'iw') from dual)
                 AND A.AFOFF_TIME <=
                     (select trunc(cur_date + 14, 'iw') + (v_num - 2) * 7
                        from dual)
                 AND A.FACTORY_CODE = in_arr_factory
                 AND A.PHASE IN ('4', '5');
            --==========================================处理W+3周数据结束========================================
          ELSE
            RETURN;
          END IF;
        END IF;
      END IF;
    
      COMMIT;
    
    EXCEPTION
      WHEN OTHERS THEN
        BEGIN
        
          err_num := sqlcode;
          err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                             1,
                             200);
          --异常的时候记录异常日志
          INSERT INTO MM_PUB_PRO_ERROR
            (id, alert_type, error_name, error_desc, creation_date, key_name)
          VALUES
            (seq_pub_pro_error.nextval,
             'USP_MP_GET_PLAN_TEMP',
             err_num,
             err_msg,
             sysdate,
             '获取生产计划到临时表');
          COMMIT;
          ROLLBACK;
        END;
    END USP_MP_GET_PLAN_TEMP;
    --***************************************************************************
  */
  --***************************************************************************
  --存储过程名：USP_MP_GET_PLAN
  --功能描述：获取计划到临时表
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/09/19

  PROCEDURE USP_MP_GET_PLAN(in_arr_factory IN VARCHAR2,
                            out_code       OUT NUMBER) AS
  
    err_num  number;
    err_msg  varchar2(200);
    cur_date date;
    --获取几周的计划用于计算
    v_day_num number;
  
    v_max_version number;
  BEGIN
    cur_date := sysdate;
  
    --MODIFY wangyu 2019-06-05
    /*--==========================================处理W+1 W+2数据开始========================================
    --删除该工厂临时计划数据
    DELETE FROM MM_MP_DIFF_NUM_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
    COMMIT;
    
    --根据工厂删除临时表的W+1和W+2数据
    DELETE FROM MM_MP_PRO_PLAN_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
    COMMIT;
    
    --找到新W+1和W+2的数据写入到临时表
    INSERT INTO MM_MP_PRO_PLAN_TEMP
      (SORT_ID,
       FACTORY_CODE,
       CAR_TYPE,
       ORDER_NO,
       WEON_TIME,
       AFOFF_TIME,
       PRO_PHASE,
       CAL_STATUS,
       CREATION_USER,
       IS_AUTOED,
       CREATION_TIME)
      SELECT A.SORT_ID,
             A.FACTORY_CODE,
             A.MODEL_CODE,
             A.ORDER_NO,
             A.WEON_TIME,
             A.AFOFF_TIME,
             A.PHASE,
             0,
             'SYSTEM',
             '1',
             SYSDATE
        FROM MM_PUB_PRO_PLAN A
       WHERE A.AFOFF_TIME >= (select trunc(cur_date, 'iw') from dual)
         AND A.AFOFF_TIME <=
             (select trunc(cur_date + 7, 'iw') + 7 from dual)
         AND A.FACTORY_CODE = in_arr_factory
            --MODIFY  wangyu 2019-06-05
         AND A.PHASE IN (SELECT B.CODE_VALUE
                           FROM MM_PUB_SYS_PARAM A, MM_PUB_DATA_DICT B
                          WHERE A.FACTORY_CODE = B.FACTORY_CODE
                            AND A.PARAM_VAL = B.CODE_VALUE_NAME
                            AND A.PARAM_GROUP = 'MP_CAL_PHASE'
                            AND A.FACTORY_CODE = in_arr_factory);
    
    --计算计划调整产生的差异
    --***************************************************************************
    --修改说明：从MM_MP_PRO_PLAN_TEMP中取最高版本的W+1 和 W+2周计划写入差异表
    --修改人: wangyu
    --修改时间： 2019/01/26
    
    --先查询MM_MP_DIFF_NUM_TEMP中的最高版本
    BEGIN
      SELECT MAX(A.VERSION)
        INTO v_max_version
        FROM MM_MP_PRO_PLAN_TEMP A
       WHERE A.VERSION IS NOT NULL
         AND A.FACTORY_CODE = in_arr_factory;
    EXCEPTION
      WHEN OTHERS THEN
        v_max_version := 1;
    END;
    
    --找到旧W+1 和W+2的数据写入临时表
    INSERT INTO MM_MP_PRO_PLAN_TEMP
      (SORT_ID,
       FACTORY_CODE,
       CAR_TYPE,
       ORDER_NO,
       WEON_TIME,
       AFOFF_TIME,
       PRO_PHASE,
       CAL_STATUS,
       CREATION_USER,
       IS_AUTOED,
       CREATION_TIME,
       VERSION,
       WRITE_TIME)
      SELECT A.SORT_ID,
             A.FACTORY_CODE,
             A.CAR_TYPE,
             A.ORDER_NO,
             A.WEON_TIME,
             A.AFOFF_TIME,
             A.PRO_PHASE,
             0,
             'SYSTEM',
             '1',
             SYSDATE,
             A.VERSION,
             A.WRITE_TIME
        FROM MM_MP_PRO_PLAN_HIS A
       WHERE A.AFOFF_TIME >= (select trunc(cur_date, 'iw') from dual)
         AND A.AFOFF_TIME <=
             (select trunc(cur_date + 7, 'iw') + 7 from dual)
         AND A.FACTORY_CODE = in_arr_factory
         AND A.PRO_PHASE IN ('4', '5')
         AND A.VERSION = v_max_version;
    
    --==========================================处理W+1 W+2数据结束========================================*/
  
    DELETE FROM MM_MP_VEH_PLAN_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
  
    COMMIT;
    --获取本周需要获取几周的计划用于计算
    SELECT A.WEEK_NUM
      INTO v_day_num
      FROM MM_MP_WEEK_PLAN A
     WHERE A.FACTORY_CODE = in_arr_factory
       AND A.YEAR = TO_CHAR(cur_date, 'YYYY')
       AND A.WEEK = TO_NUMBER(TO_CHAR(cur_date, 'iw'));
  
    --将W+3的数据写入到车辆计划表
    INSERT INTO MM_MP_VEH_PLAN_TEMP
      (SORT_ID,
       FACTORY_CODE,
       CAR_TYPE,
       ORDER_NO,
       --MODIFY 2019-06-05 增加MES订单号
       MES_ORDER_NO,
       WEON_TIME,
       AFOFF_TIME,
       PRO_PHASE,
       CAL_STATUS,
       CREATION_USER,
       CREATION_TIME)
      SELECT A.SORT_ID,
             A.FACTORY_CODE,
             A.MODEL_CODE,
             A.ORDER_NO,
             --MODIFY 2019-06-05 增加MES订单号
             A.MES_ORDER_NO,
             A.WEON_TIME,
             A.AFOFF_TIME,
             A.PHASE,
             0,
             'SYSTEM',
             SYSDATE
        FROM MM_PUB_PRO_PLAN A
      --MODIFY wangyu 2019-06-05
      /*WHERE A.AFOFF_TIME >= (select trunc(cur_date + 14, 'iw') from dual)
      AND A.AFOFF_TIME <=
          (select trunc(cur_date + 14, 'iw') + (v_day_num - 2) * 7
             from dual)*/
       WHERE A.AFOFF_TIME >= (select trunc(cur_date, 'iw') from dual)
         AND A.AFOFF_TIME <=
             (select trunc(cur_date, 'iw') + (v_day_num) * 7 from dual)
         AND A.FACTORY_CODE = in_arr_factory
            --MODIFY  wangyu 2019-06-05
            /* AND A.PHASE IN ('4', '5');*/
         AND A.PHASE IN (SELECT B.CODE_VALUE
                           FROM MM_PUB_SYS_PARAM A, MM_PUB_DATA_DICT B
                          WHERE A.FACTORY_CODE = B.FACTORY_CODE
                            AND A.PARAM_VAL = B.CODE_VALUE_NAME
                            AND A.PARAM_GROUP = 'MP_CAL_PHASE'
                            AND A.FACTORY_CODE = in_arr_factory);
    COMMIT;
  
    --操作成功
    out_code := 0;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_GET_PLAN',
           err_num,
           err_msg,
           sysdate,
           '获取计划到临时表');
        COMMIT;
      
        ROLLBACK;
      END;
  END USP_MP_GET_PLAN;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_CONFRIM_PLAN
  --功能描述：临时车辆计划的确认导入按钮
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/12/09
  PROCEDURE USP_MP_CONFRIM_PLAN(in_arr_factory IN VARCHAR2,
                                out_code       OUT NUMBER) AS
  
    err_num     number;
    err_msg     varchar2(200);
    cur_date    date;
    max_sort_id number;
  BEGIN
    cur_date := sysdate;
    /*--根据工厂删除临时表的W+1和W+2数据
    DELETE FROM MM_MP_PRO_PLAN_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;*/
    --删除车辆计划里面为该工厂的状态为未订购的车辆计划
    DELETE FROM MM_MP_VEH_PLAN A
     WHERE NOT EXISTS (SELECT 1
              FROM MM_MP_VEH_PLAN B
              LEFT JOIN (SELECT *
                          FROM MM_MP_CAR_TYPE_QUEUE T
                         WHERE T.MULTI_CAR_TYPE = T.CAR_TYPE
                           AND T.CAR_TYPE IS NOT NULL) C
                ON B.SORT_ID = C.SORT_ID
              LEFT JOIN MM_MP_CAL_END CE
                ON CE.CAR_TYPE = C.MULTI_CAR_TYPE
             WHERE A.SORT_ID = B.SORT_ID
               AND C.CAR_TYPE_SORT_ID <= CE.CAL_POINT)
       AND A.FACTORY_CODE = in_arr_factory;
  
    /*--找到W+1和W+2的数据写入到临时表
    INSERT INTO MM_MP_PRO_PLAN_TEMP
      (FACTORY_CODE,
       ORDER_NO,
       ORDER_TYPE,
       WEON_TIME,
       AFOFF_TIME,
       SORT_ID,
       MODEL_CODE,
       PHASE,
       CREATION_TIME)
      SELECT FACTORY_CODE,
             ORDER_NO,
             ORDER_TYPE,
             WEON_TIME,
             AFOFF_TIME,
             SORT_ID,
             MODEL_CODE,
             PHASE,
             SYSDATE
        FROM MM_PUB_PRO_PLAN A
       WHERE A.AFOFF_TIME >= (select trunc(cur_date, 'iw') from dual)
         AND A.AFOFF_TIME <=
             (select trunc(cur_date + 7, 'iw') + 6 from dual)
         AND A.FACTORY_CODE = in_arr_factory
         AND A.PHASE = '5';*/
  
    --记录当前最大sort_id
    SELECT NVL(MAX(A.SORT_ID), 0)
      INTO max_sort_id
      FROM MM_MP_VEH_PLAN A
     WHERE A.FACTORY_CODE = in_arr_factory;
  
    --将W+3的数据写入到车辆计划表
    INSERT INTO MM_MP_VEH_PLAN
      (SORT_ID,
       MES_SORT_ID,
       FACTORY_CODE,
       CAR_TYPE,
       ORDER_NO,
       --MODIFY 2019-06-05 增加MES订单号
       MES_ORDER_NO,
       WEON_TIME,
       AFOFF_TIME,
       PRO_PHASE,
       CAL_STATUS,
       CREATION_USER,
       CREATION_TIME)
      SELECT max_sort_id + ROW_NUMBER() OVER(ORDER BY C.SORT_ID),
             C.SORT_ID,
             C.FACTORY_CODE,
             C.CAR_TYPE,
             C.ORDER_NO,
             --MODIFY 2019-06-05 增加MES订单号
             C.MES_ORDER_NO,
             C.WEON_TIME,
             C.AFOFF_TIME,
             C.PRO_PHASE,
             0,
             'SYSTEM',
             SYSDATE
        FROM (SELECT A.SORT_ID,
                     A.FACTORY_CODE,
                     A.CAR_TYPE,
                     A.ORDER_NO,
                     --MODIFY 2019-06-05 增加MES订单号
                     A.MES_ORDER_NO,
                     A.WEON_TIME,
                     A.AFOFF_TIME,
                     A.PRO_PHASE
                FROM MM_MP_VEH_PLAN_TEMP A
               WHERE A.FACTORY_CODE = in_arr_factory
                 AND A.PRO_PHASE IN
                     (SELECT B.CODE_VALUE
                        FROM MM_PUB_SYS_PARAM A, MM_PUB_DATA_DICT B
                       WHERE A.FACTORY_CODE = B.FACTORY_CODE
                         AND A.PARAM_VAL = B.CODE_VALUE_NAME
                         AND A.PARAM_GROUP = 'MP_CAL_PHASE'
                         AND A.FACTORY_CODE = in_arr_factory)
              --MODIFY wangyu 2019-06-05
              /* UNION ALL
              SELECT B.SORT_ID,
                     B.FACTORY_CODE,
                     B.CAR_TYPE,
                     B.ORDER_NO,
                     B.WEON_TIME,
                     B.AFOFF_TIME,
                     B.PRO_PHASE
                FROM MM_MP_PRO_PLAN_TEMP B
               WHERE B.FACTORY_CODE = in_arr_factory
                 AND B.VERSION IS NULL
                 AND B.PRO_PHASE IN ('4', '5')*/
              ) C
       WHERE NOT EXISTS (SELECT 1
                FROM MM_MP_VEH_PLAN D
               WHERE
              --MODIFY 2019-06-05 增加MES订单号
              /*C.ORDER_NO = D.ORDER_NO*/
               C.MES_ORDER_NO = D.MES_ORDER_NO
            AND D.FACTORY_CODE = in_arr_factory
            AND D.FACTORY_CODE = C.FACTORY_CODE);
  
    --删除临时表的数据
    DELETE FROM MM_MP_VEH_PLAN_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
    COMMIT;
  
    --操作成功
    out_code := 0;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_CONFRIM_PLAN',
           err_num,
           err_msg,
           sysdate,
           '临时车辆计划的确认导入');
        COMMIT;
        ROLLBACK;
      
      END;
  END USP_MP_CONFRIM_PLAN;
  --***************************************************************************

  /*--***************************************************************************
  --存储过程名：USP_MP_AUTO_CONFRIM_PLAN
  --功能描述：将临时表车辆计划自动写入车辆计划表
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/12/09
  PROCEDURE USP_MP_AUTO_CONFRIM_PLAN(in_arr_factory IN VARCHAR2,
                                     out_code       OUT NUMBER) AS
  
    err_num     number;
    err_msg     varchar2(200);
    cur_date    date;
    max_sort_id number;
    --自动写入的数量
    v_autoed_num number;
    v_count      number;
  BEGIN
    out_code := 0;
    cur_date := sysdate;
  
    --查询自动写入的数量
    SELECT COUNT(1)
      INTO v_autoed_num
      FROM MM_MP_VEH_PLAN_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory
       AND A.PRO_PHASE IN ('4', '5')
       AND A.IS_AUTOED = 1;
  
    --查询是否存在数据
    SELECT COUNT(1)
      INTO v_count
      FROM MM_MP_VEH_PLAN_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory
       AND A.PRO_PHASE IN ('4', '5');
  
    IF v_count <= 0 THEN
      RETURN;
    END IF;
  
    IF v_autoed_num < v_count THEN
      --表明已经有写入的数据
      RETURN;
    ELSE
      --表明全都是自动写入的数据
      \*--根据工厂删除临时表的W+1和W+2数据
      DELETE FROM MM_MP_PRO_PLAN_TEMP A
       WHERE A.FACTORY_CODE = in_arr_factory;*\
    
      --删除车辆计划里面为该工厂的状态为未订购的车辆计划
      DELETE FROM MM_MP_VEH_PLAN A
       WHERE NOT EXISTS (SELECT 1
                FROM MM_MP_VEH_PLAN B
                LEFT JOIN (SELECT *
                            FROM MM_MP_CAR_TYPE_QUEUE T
                           WHERE T.MULTI_CAR_TYPE = T.CAR_TYPE
                             AND T.CAR_TYPE IS NOT NULL) C
                  ON B.SORT_ID = C.SORT_ID
                LEFT JOIN MM_MP_CAL_END CE
                  ON CE.CAR_TYPE = C.MULTI_CAR_TYPE
               WHERE A.SORT_ID = B.SORT_ID
                 AND C.CAR_TYPE_SORT_ID <= CE.CAL_POINT)
         AND A.FACTORY_CODE = in_arr_factory;
    
      \*--找到W+1和W+2的数据写入到临时表
      INSERT INTO MM_MP_PRO_PLAN_TEMP
        (FACTORY_CODE,
         ORDER_NO,
         ORDER_TYPE,
         WEON_TIME,
         AFOFF_TIME,
         SORT_ID,
         MODEL_CODE,
         PHASE,
         CREATION_TIME)
        SELECT FACTORY_CODE,
               ORDER_NO,
               ORDER_TYPE,
               WEON_TIME,
               AFOFF_TIME,
               SORT_ID,
               MODEL_CODE,
               PHASE,
               SYSDATE
          FROM MM_PUB_PRO_PLAN A
         WHERE A.AFOFF_TIME >= (select trunc(cur_date, 'iw') from dual)
           AND A.AFOFF_TIME <=
               (select trunc(cur_date + 7, 'iw') + 6 from dual)
           AND A.FACTORY_CODE = in_arr_factory
           AND A.PHASE = '5';*\
    
      --记录当前最大sort_id
      SELECT NVL(MAX(A.SORT_ID), 0)
        INTO max_sort_id
        FROM MM_MP_VEH_PLAN A
       WHERE A.FACTORY_CODE = in_arr_factory;
    
      --将W+3的数据写入到车辆计划表
      INSERT INTO MM_MP_VEH_PLAN
        (SORT_ID,
         MES_SORT_ID,
         FACTORY_CODE,
         CAR_TYPE,
         ORDER_NO,
         WEON_TIME,
         AFOFF_TIME,
         PRO_PHASE,
         CAL_STATUS,
         CREATION_USER,
         CREATION_TIME)
        SELECT max_sort_id + ROW_NUMBER() OVER(ORDER BY A.SORT_ID),
               A.SORT_ID,
               A.FACTORY_CODE,
               A.CAR_TYPE,
               A.ORDER_NO,
               A.WEON_TIME,
               A.AFOFF_TIME,
               A.PRO_PHASE,
               0,
               'SYSTEM',
               SYSDATE
          FROM MM_MP_VEH_PLAN_TEMP A
         WHERE A.FACTORY_CODE = in_arr_factory
           AND A.PRO_PHASE IN ('4', '5')
           AND NOT EXISTS
         (SELECT 1 FROM MM_MP_VEH_PLAN B WHERE A.ORDER_NO = B.ORDER_NO);
    
      --删除临时表的数据
      DELETE FROM MM_MP_VEH_PLAN_TEMP A
       WHERE A.FACTORY_CODE = in_arr_factory;
    
      out_code := 1;
    END IF;
  
    COMMIT;
  
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_AUTO_CONFRIM_PLAN',
           err_num,
           err_msg,
           sysdate,
           '临时车辆计划的确认导入');
        COMMIT;
      
        ROLLBACK;
      END;
  END USP_MP_AUTO_CONFRIM_PLAN;
  --****************************************************************************/

  --***************************************************************************
  --存储过程名：USP_MP_DEMAND_FORECAST_GEN
  --功能描述：需求预测
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --version  版本
  --foreType 预测类型
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2019/04/18
  PROCEDURE USP_MP_DEMAND_FORECAST_GEN(in_arr_factory in VARCHAR2,
                                       in_account     in VARCHAR2,
                                       in_version     in VARCHAR2,
                                       in_foreType    in VARCHAR2,
                                       out_code       out VARCHAR2) AS
  
    err_num       number;
    err_msg       varchar2(200);
    V_NUM         NUMBER(5);
    V_UNLOAD_PORT VARCHAR2(100);
    V_MM_MODEL    VARCHAR2(100);
    --ERROR_TAG          NUMBER(10);
    --ERROR_MESSAGE      VARCHAR2(1000);
    V_AREA             VARCHAR2(20); --区域
    V_OUT_TIME         NUMBER(10); --生产节拍
    V_ADVANCE_TIME     NUMBER(10); --提前取货时间
    V_TRANS_TIME       NUMBER(10); --运输时长
    v_loc_num          number(10); --落点车体流动数
    v_use_location_num VARCHAR2(30);
    v_location         VARCHAR2(20);
    V_TIME             DATE; --厂内装配时间
    V_TIME1            NUMBER(10); --厂内提前时间
    V_WORKCENTER       VARCHAR2(30); --车间
    v_af_max_loc       NUMBER;
    v_pa_max_loc       NUMBER;
    v_we_max_loc       NUMBER;
    v_wbs_max_loc      NUMBER;
    v_pbs_max_loc      NUMBER;
    V_VERSION_EXIST    NUMBER(10); --判断版本是否存在
  BEGIN
    --判断该版本是否已经发布
    SELECT COUNT(1)
      INTO V_NUM
      FROM MM_SW_DEMAND_FORECAST A
     WHERE A.P_SUPPLIER IS NOT NULL
       AND A.FORE_TYPE = in_foreType
       AND A.VERSION = in_version
       AND A.FACTORY_CODE = in_arr_factory;
    v_num := 0;
    IF v_num > 0 THEN
      --表明已经发布过该版本
      out_code := 2;
    else
      --处理之前先删除之前的数据
      DELETE FROM MM_SW_DEMAND_FORECAST_SUPPORT A
       WHERE A.FORE_TYPE = in_foreType
         AND A.FACTORY_CODE = in_arr_factory
         AND A.VERSION = in_version;
    
      FOR SUB_FORECAST IN (SELECT *
                             FROM (SELECT BOM.FACTORY_CODE FACTORY_CODE,
                                          CONNECT_BY_ROOT(BOM.VERSION) VERSION_NO,
                                          CONNECT_BY_ROOT(BOM.PLAN_DELIVERY) REC_DATE,
                                          CONNECT_BY_ROOT(BOM.PHASE) PHASE,
                                          BOM.SUPPLIER_NO SUPPLIER_NO,
                                          BOM.PART_NO,
                                          CONNECT_BY_ROOT(BOM.PART_NO) PARTF_ID,
                                          CONNECT_BY_ROOT(BOM.ORDER_QTY) PARTF_ORDER_QTY,
                                          CONNECT_BY_ROOT(BOM.FORE_TYPE) FORE_TYPE,
                                          CONNECT_BY_ROOT(BOM.END_DATE) END_DATE,
                                          MY_EVAL_NUMBER(1 ||
                                                         SYS_CONNECT_BY_PATH(BOM.ORDER_QTY,
                                                                             '*')) ORDER_NUM,
                                          CONNECT_BY_ROOT(BOM.START_DATE) START_DATE,
                                          CONNECT_BY_ROOT(BOM.MODEL_CODE) MODEL_CODE,
                                          BOM.PART_UNIT,
                                          CONNECT_BY_ROOT(BOM.PUBLISH_MONTH) PUBLISH_MONTH,
                                          CONNECT_BY_ROOT(BOM.PUBLISH_WEEK) PUBLISH_WEEK,
                                          CONNECT_BY_ROOT(BOM.OBJ_MONTH) OBJ_MONTH,
                                          CONNECT_BY_ROOT(BOM.OBJ_WEEK) OBJ_WEEK,
                                          CONNECT_BY_ROOT(BOM.SEQ) SEQ,
                                          BOM.WORKCENTER,
                                          BOM.NEXT_PLACEMENT
                                     FROM (SELECT F.FACTORY_CODE,
                                                  F.VERSION,
                                                  F.PLAN_DELIVERY,
                                                  F.PHASE,
                                                  F.SUPPLIER_NO,
                                                  F.PART_NO,
                                                  F.FORE_TYPE,
                                                  F.END_DATE,
                                                  F.ORDER_QTY,
                                                  F.START_DATE,
                                                  F.MODEL_CODE,
                                                  F.PART_UNIT,
                                                  F.PUBLISH_MONTH,
                                                  F.PUBLISH_WEEK,
                                                  F.OBJ_MONTH,
                                                  F.OBJ_WEEK,
                                                  NULL            PARTF_ID,
                                                  F.WORKCENTER,
                                                  NULL            NEXT_PLACEMENT,
                                                  F.SEQ
                                             FROM MM_SW_DEMAND_FORECAST F
                                            WHERE F.FACTORY_CODE =
                                                  in_arr_factory
                                              AND F.FORE_TYPE = in_foreType
                                              AND F.VERSION = in_version
                                                 --存在于支给件里面的数据需要递归处理
                                              AND EXISTS
                                            (SELECT 1
                                                     FROM MM_PUB_SUPPORTING_PART B
                                                    WHERE F.FACTORY_CODE =
                                                          B.FACTORY_CODE
                                                      AND B.FACTORY_CODE =
                                                          F.FACTORY_CODE
                                                      AND F.PART_NO =
                                                          B.PARTF_ID)
                                           UNION ALL
                                           SELECT PSP.FACTORY_CODE,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  PPS.SUPPLIER_NO,
                                                  PSP.PART_NO,
                                                  NULL,
                                                  NULL,
                                                  PSP.NUM,
                                                  NULL,
                                                  NULL,
                                                  PSP.USE_AGE_AMOUNT_UNIT,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  PSP.PARTF_ID,
                                                  NULL WORKCENTER,
                                                  PSP.NEXT_PLACEMENT,
                                                  NULL
                                             FROM MM_PUB_SUPPORTING_PART PSP
                                           --关联零件供应商关系，只算零件供应商关系存在的数据
                                             LEFT JOIN MM_PUB_PART_SUPPLIER PPS
                                               ON PSP.PART_NO = PPS.PART_NO
                                              AND PSP.FACTORY_CODE =
                                                  PPS.FACTORY_CODE
                                            WHERE PPS.SUPPLIER_NO IS NOT NULL
                                              AND EXISTS
                                            (SELECT 1
                                                     FROM MM_SW_DEMAND_FORECAST SDF
                                                    WHERE SDF.FACTORY_CODE =
                                                          in_arr_factory
                                                      AND SDF.FORE_TYPE =
                                                          in_foreType
                                                      AND SDF.VERSION =
                                                          in_version
                                                      AND SDF.PART_NO =
                                                          PSP.PARTF_ID)) BOM
                                    START WITH BOM.PARTF_ID IS NULL
                                   CONNECT BY NOCYCLE
                                    PRIOR BOM.PART_NO = BOM.PARTF_ID) D
                            WHERE D.NEXT_PLACEMENT IS NOT NULL
                            ORDER BY D.VERSION_NO ASC) LOOP
      
        --计算提前取货时间
        IF SUB_FORECAST.FORE_TYPE = '2' THEN
          FOR CUR_ADVAN IN (
                            
                            SELECT ACC.WORKCENTER,
                                    ACC.ARRIVE_NUM,
                                    ACC.DISTRIBUTION_NUM
                              FROM (SELECT C.ARRIVE_NUM,
                                            C.DISTRIBUTION_NUM,
                                            C.PART_NO,
                                            C.WORKCENTER
                                       FROM MM_MP_PART C
                                     UNION
                                     SELECT D.ARRIVE_NUM,
                                            D.DISTRIBUTION_NUM,
                                            D.PART_NO,
                                            CD.WORKCENTER
                                       FROM MM_JIT_PART D
                                       LEFT JOIN MM_PUB_PLAN_CODE CD
                                         ON D.PLAN_CODE = CD.PLAN_CODE
                                     UNION
                                     SELECT PP.ARRIVE_NUM,
                                            PP.DISTRIBUTION_NUM,
                                            JI.PART_NO,
                                            CDD.WORKCENTER
                                       FROM MM_JISO_PARTGROUP PP
                                       LEFT JOIN MM_JISO_PART JI
                                         ON PP.ID = JI.PARTGROUP_ID
                                       LEFT JOIN MM_PUB_PLAN_CODE CDD
                                         ON PP.PLAN_CODE = CDD.PLAN_CODE) ACC
                             WHERE ACC.PART_NO = SUB_FORECAST.PART_NO) LOOP
          
            ----最大工深获取方式修改为如下------------------------------------------------------------------- 
            BEGIN
              --判断如果是总装
              SELECT NVL(A.PARAM_VAL, 0)
                INTO v_af_max_loc
                FROM MM_PUB_SYS_PARAM A
               WHERE A.PARAM_GROUP = 'MAX_LOC'
                 AND A.FACTORY_CODE = SUB_FORECAST.FACTORY_CODE
                 AND A.PARAM_CODE = 'AF_TOTAL_PRO_NUM';
            END;
          
            v_loc_num := v_af_max_loc;
          
            --台套数对应时间
            --如果车间不是总装焊装涂装，使用总装计算
            V_OUT_TIME := PKG_PUB.USF_GET_PRODUCE_TIME(SUB_FORECAST.FACTORY_CODE,
                                                       'A1',
                                                       NULL) *
                          (v_loc_num + CUR_ADVAN.ARRIVE_NUM +
                           CUR_ADVAN.DISTRIBUTION_NUM);
          
            --厂内装配时间
            --如果车间不是总装焊装涂装，使用总装计算
            V_TIME := PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.FACTORY_CODE,
                                                   'A1',
                                                   SUB_FORECAST.REC_DATE,
                                                   -V_OUT_TIME);
          
            --DBMS_OUTPUT.put_line(TO_CHAR(V_TIME, 'YYYY-MM-DD HH24:mi:ss'));
            V_TIME1 := V_TIME - SUB_FORECAST.REC_DATE;
          
            SELECT MAX(A.AREA), MAX(A.TRANS_TIME)
              INTO V_AREA, V_TRANS_TIME
              FROM MM_PUP_ROUTE A
             WHERE A.FACTORY_CODE = SUB_FORECAST.FACTORY_CODE
               AND A.SUPPLIER_NO = SUB_FORECAST.SUPPLIER_NO
               AND A.SUP_FACTORY =
                   (SELECT UDA.SUP_FACTORY
                      FROM MM_PUB_PART_UDA UDA
                     WHERE UDA.PART_NO = SUB_FORECAST.PART_NO)
               AND A.CAR_TYPE = SUB_FORECAST.MODEL_CODE;
          
            V_ADVANCE_TIME := 0;
          
            IF V_AREA IS NOT NULL AND V_TRANS_TIME IS NOT NULL THEN
              IF V_TRANS_TIME = 0 THEN
                V_TRANS_TIME := 1;
              END IF;
              IF V_AREA = '省内' THEN
                --V_ADVANCE_TIME := CEIL(V_ENDTIME - V_TRANS_TIME/24);
              
                V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                  PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.FACTORY_CODE,
                                                               'A1',
                                                               V_TIME,
                                                               -V_TRANS_TIME);
              END IF;
              --SELECT ceil(V_OUT_TIME + V_TRANS_TIME) INTO V_ADVANCE_TIME FROM DUAL;
              IF V_AREA = '省外' THEN
                --SELECT ceil(V_OUT_TIME + V_TRANS_TIME) / 24 INTO V_ADVANCE_TIME FROM DUAL;
                --V_ADVANCE_TIME := CEIL(V_ENDTIME + V_TRANS_TIME/24);
              
                V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                  TO_DATE(USF_MM_MP_FORBAKWORKDATE(TO_CHAR(V_TIME,
                                                                           'YYYY-MM-DD'),
                                                                   CEIL(NVL(V_TRANS_TIME,
                                                                            0) / 24),
                                                                   'A1',
                                                                   SUB_FORECAST.FACTORY_CODE,
                                                                   0) ||
                                          TO_CHAR(V_TIME, 'HH24:MI:SS'),
                                          'YYYY-MM-DD HH24:MI:SS');
              END IF;
            END IF;
          
          END LOOP;
        END IF;
      
        BEGIN
          SELECT WM_CONCAT(UNLOAD_PORT)
            INTO V_UNLOAD_PORT
            FROM (SELECT *
                    FROM MM_PUB_PART_UNLOAD OAD
                   WHERE OAD.PART_NO = SUB_FORECAST.PART_NO
                     AND OAD.WORKCENTER = SUB_FORECAST.PART_NO);
        
        EXCEPTION
          WHEN OTHERS THEN
            V_UNLOAD_PORT := '';
        END;
      
        BEGIN
          SELECT Max(OAD.LOGISTICS_MODEL)
            INTO V_MM_MODEL --获取物流模式
            FROM MM_PUB_PART_UNLOAD OAD
           WHERE OAD.PART_NO = SUB_FORECAST.PART_NO;
        
        EXCEPTION
          WHEN OTHERS THEN
            V_MM_MODEL := '';
        END;
      
        INSERT INTO MM_SW_DEMAND_FORECAST_SUPPORT
          (ID,
           FACTORY_CODE,
           FORE_TYPE,
           VERSION,
           PLAN_DELIVERY,
           START_DATE,
           END_DATE,
           PHASE,
           UNLOAD_PORT,
           PART_NO,
           PART_UNIT,
           ORDER_QTY,
           SUPPLIER_NO,
           MODEL_CODE,
           LOGISTICS_MODE,
           CREATION_USER,
           CREATION_TIME,
           PUBLISH_MONTH,
           OBJ_MONTH,
           PUBLISH_WEEK,
           OBJ_WEEK,
           P_SUPPLIER,
           PARTF_ID,
           PARTF_ORDER_QTY,
           SEQ,
           ADVANCE_TIME)
        VALUES
          (SEQ_MM_SW_DEMAND_FORETEMP.NEXTVAL,
           SUB_FORECAST.FACTORY_CODE,
           SUB_FORECAST.FORE_TYPE,
           SUB_FORECAST.VERSION_NO,
           SUB_FORECAST.REC_DATE,
           SUB_FORECAST.START_DATE,
           SUB_FORECAST.END_DATE,
           SUB_FORECAST.PHASE,
           V_UNLOAD_PORT,
           SUB_FORECAST.PART_NO,
           SUB_FORECAST.PART_UNIT,
           SUB_FORECAST.ORDER_NUM,
           SUB_FORECAST.SUPPLIER_NO,
           SUB_FORECAST.MODEL_CODE,
           V_MM_MODEL,
           in_account,
           SYSDATE,
           SUB_FORECAST.PUBLISH_MONTH,
           SUB_FORECAST.OBJ_MONTH,
           SUB_FORECAST.PUBLISH_WEEK,
           SUB_FORECAST.OBJ_WEEK,
           SUB_FORECAST.NEXT_PLACEMENT,
           SUB_FORECAST.PARTF_ID,
           SUB_FORECAST.PARTF_ORDER_QTY,
           SUB_FORECAST.SEQ,
           V_ADVANCE_TIME);
      END LOOP;
      COMMIT;
      out_code := 0;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_DEMAND_FORECAST_GEN',
           err_num,
           err_msg,
           sysdate,
           '需求预测计算');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_DEMAND_FORECAST_GEN;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_DEMAND_FORECAST_RELEASE
  --功能描述：需求预测发布
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --version  版本
  --foreType 预测类型
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2019/04/18
  PROCEDURE USP_MP_DEMAND_FORECAST_RELEASE(in_arr_factory in VARCHAR2,
                                           in_account     in VARCHAR2,
                                           in_version     in VARCHAR2,
                                           in_foreType    in VARCHAR2,
                                           out_code       out VARCHAR2) AS
  
    err_num number;
    err_msg varchar2(200);
    V_NUM   NUMBER;
  BEGIN
    --判断这个版本是否已经发布
    SELECT COUNT(1) V_NUM
      INTO V_NUM
      FROM MM_SW_DEMAND_FORECAST A
     WHERE A.VERSION = in_version
       AND A.P_SUPPLIER IS NOT NULL
       AND A.FORE_TYPE = in_foreType
       AND A.FACTORY_CODE = in_arr_factory;
  
    --如果大于0，表示已经发布了不能重复发布
    IF V_NUM > 0 THEN
      out_code := 2;
    ELSE
      --发布数据
      INSERT INTO MM_SW_DEMAND_FORECAST
        (ID,
         FACTORY_CODE,
         FORE_TYPE,
         VERSION,
         PLAN_DELIVERY,
         START_DATE,
         MODEL_CODE,
         END_DATE,
         PHASE,
         UNLOAD_PORT,
         PART_NO,
         PART_UNIT,
         ORDER_QTY,
         SUPPLIER_NO,
         LOGISTICS_MODE,
         DOWNLOAD_STATUS,
         CREATION_TIME,
         RELEASE_STATUS,
         FEEDBACK_STATUS,
         PUBLISH_MONTH,
         OBJ_MONTH,
         OBJ_WEEK,
         PUBLISH_WEEK,
         ADVANCE_TIME,
         P_SUPPLIER,
         DO_FLAG,
         SEQ)
        SELECT SEQ_MM_SW_DEMAND_FORE.NEXTVAL,
               A.FACTORY_CODE,
               A.FORE_TYPE,
               A.VERSION,
               A.PLAN_DELIVERY,
               A.START_DATE,
               A.MODEL_CODE,
               A.END_DATE,
               A.PHASE,
               A.UNLOAD_PORT,
               A.PART_NO,
               A.PART_UNIT,
               A.ORDER_QTY,
               A.SUPPLIER_NO,
               A.LOGISTICS_MODE,
               0,
               SYSDATE,
               1,
               0,
               A.PUBLISH_MONTH,
               A.OBJ_MONTH,
               A.OBJ_WEEK,
               A.OBJ_MONTH,
               A.ADVANCE_TIME,
               A.P_SUPPLIER,
               'I',
               A.SEQ
          FROM MM_SW_DEMAND_FORECAST_SUPPORT A
         WHERE A.FORE_TYPE = in_foreType
           AND A.VERSION = in_version
           AND A.FACTORY_CODE = in_arr_factory;
    
      COMMIT;
    
      --更新发布状态
      UPDATE MM_SW_DEMAND_FORECAST_SUPPORT A
         SET A.RELEASE_STATUS = 1
       WHERE A.FORE_TYPE = in_foreType
         AND A.VERSION = in_version
         AND A.FACTORY_CODE = in_arr_factory;
    
      COMMIT;
    
      out_code := 0;
    END IF;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_DEMAND_FORECAST_RELEASE',
           err_num,
           err_msg,
           sysdate,
           '发布需求预测');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_DEMAND_FORECAST_RELEASE;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_MP_DEMAND_PARTIF_GEN
  --功能描述：一级件零件需求预测计算
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --foreType 预测类型
  --out_code 返回代码
  --创建人员: luoxianqin
  --创建时间： 2019/04/28
  /*PROCEDURE USP_MP_DEMAND_PARTIF_GEN(in_arr_factory in VARCHAR2,
                                     in_account     in VARCHAR2,
                                     in_foreType    in VARCHAR2,
                                     out_code       out VARCHAR2) AS
  
    err_num       number;
    err_msg       varchar2(200);
    V_NUM         NUMBER(5);
    V_UNLOAD_PORT VARCHAR2(100);
    V_MM_MODEL    VARCHAR2(100);
    --ERROR_TAG          NUMBER(10);
    --ERROR_MESSAGE      VARCHAR2(1000);
    V_AREA             VARCHAR2(20); --区域
    V_OUT_TIME         NUMBER(10); --生产节拍
    V_ADVANCE_TIME     NUMBER(10); --提前取货时间
    V_TRANS_TIME       NUMBER(10); --运输时长
    v_loc_num          number(10); --落点车体流动数
    v_use_location_num VARCHAR2(30);
    v_location         VARCHAR2(20);
    V_TIME             DATE; --厂内装配时间
    V_TIME1            NUMBER(10); --厂内提前时间
    V_WORKCENTER       VARCHAR2(30); --车间
    v_af_max_loc       NUMBER;
    v_pa_max_loc       NUMBER;
    v_we_max_loc       NUMBER;
    v_wbs_max_loc      NUMBER;
    v_pbs_max_loc      NUMBER;
    V_VERSION_EXIST    NUMBER(10); --判断版本是否存在
  BEGIN
    delete from mm_sw_demand_forecast_imp;
    FOR SUB_FORECAST IN (SELECT P.FACTORY_CODE COMP,
                                --P.AFOFF_TIME REC_DATE,
                                P.MODEL_CODE MODEL_CODE,
                                P.PHASE      PHASE,
                                BOM.PART_NO  PART_NO,
                                --BOM.NUM ORDER_NUM,
                                BOM.PURCHASE_TYPE PURCHASE_TYPE,
                                PS.SUPPLIER_NO,
                                T.PART_UNIT,
                                to_char(SE.START_DATE, 'yyyy-mm-dd') START_DATE,
                                to_char(SE.END_DATE, 'yyyy-mm-dd') END_DATE,
                                to_char(SE.START_DATE, 'yyyy-mm-dd') OBJ_WEEK,
                                to_char(trunc(to_date(to_char(sysdate,
                                                              'yyyy-mm-dd'),
                                                      'yyyy-mm-dd'),
                                              'd') + 1,
                                        'yyyy-mm-dd') PUBLISH_WEEK,
                                --TS.REC_DATE,
                                --TS.ORDER_NUM,
                                SUM(BOM.NUM) ORDER_NUM,
                                to_date(SUBSTR(to_char(P.AFOFF_TIME,
                                                       'yyyy-mm-dd hh24:mi:ss'),
                                               0,
                                               10),
                                        'yyyy-mm-dd hh24:mi:ss') REC_DATE
                           FROM MM_PUB_PRO_PLAN P
                           LEFT JOIN MM_PUB_ORDER_BOM BOM
                             ON P.ORDER_NO = BOM.ORDER_NO
                           LEFT JOIN MM_PUB_PART_SUPPLIER PS
                             ON BOM.PART_NO = PS.PART_NO
                           LEFT JOIN MM_PUB_PART T
                             ON BOM.PART_NO = T.PART_NO
                           LEFT JOIN (SELECT MIN(A.AFOFF_TIME) START_DATE,
                                            MAX(A.AFOFF_TIME) END_DATE
                                       FROM MM_PUB_PRO_PLAN A
                                      WHERE A.AFOFF_TIME >=
                                            trunc(to_date(to_char(sysdate,
                                                                  'yyyy-mm-dd'),
                                                          'yyyy-mm-dd'),
                                                  'd') + 1
                                        AND A.AFOFF_TIME < =
                                            trunc(to_date(to_char(sysdate,
                                                                  'yyyy-mm-dd'),
                                                          'yyyy-mm-dd'),
                                                  'd') + 28) SE
                             ON 1 = 1
                         
                          WHERE P.AFOFF_TIME >=
                                trunc(to_date(to_char(sysdate, 'yyyy-mm-dd'),
                                              'yyyy-mm-dd'),
                                      'd') + 1
                            AND P.AFOFF_TIME < =
                                trunc(to_date(to_char(sysdate, 'yyyy-mm-dd'),
                                              'yyyy-mm-dd'),
                                      'd') + 28
                            AND P.FACTORY_CODE = 2000
                            AND (BOM.PURCHASE_TYPE = 'W'
                                --OR BOM.PURCHASE_TYPE = 'FW' 
                                OR BOM.PURCHASE_TYPE = 'AW')
                          GROUP BY to_date(SUBSTR(to_char(P.AFOFF_TIME,
                                                          'yyyy-mm-dd hh24:mi:ss'),
                                                  0,
                                                  10),
                                           'yyyy-mm-dd hh24:mi:ss'),
                                   BOM.PART_NO,
                                   P.FACTORY_CODE,
                                   P.MODEL_CODE,
                                   P.PHASE,
                                   BOM.PURCHASE_TYPE,
                                   PS.SUPPLIER_NO,
                                   T.PART_UNIT,
                                   to_char(SE.START_DATE, 'yyyy-mm-dd'),
                                   to_char(SE.END_DATE, 'yyyy-mm-dd'),
                                   to_char(SE.START_DATE, 'yyyy-mm-dd'),
                                   to_char(trunc(to_date(to_char(sysdate,
                                                                 'yyyy-mm-dd'),
                                                         'yyyy-mm-dd'),
                                                 'd') + 1,
                                           'yyyy-mm-dd')) LOOP
    
      --计算提前取货时间
      FOR CUR_ADVAN IN (
                        
                        SELECT ACC.WORKCENTER,
                                ACC.ARRIVE_NUM,
                                ACC.DISTRIBUTION_NUM
                          FROM (SELECT C.ARRIVE_NUM,
                                        C.DISTRIBUTION_NUM,
                                        C.PART_NO,
                                        C.WORKCENTER
                                   FROM MM_MP_PART C
                                 UNION
                                 SELECT D.ARRIVE_NUM,
                                        D.DISTRIBUTION_NUM,
                                        D.PART_NO,
                                        CD.WORKCENTER
                                   FROM MM_JIT_PART D
                                   LEFT JOIN MM_PUB_PLAN_CODE CD
                                     ON D.PLAN_CODE = CD.PLAN_CODE
                                 UNION
                                 SELECT PP.ARRIVE_NUM,
                                        PP.DISTRIBUTION_NUM,
                                        JI.PART_NO,
                                        CDD.WORKCENTER
                                   FROM MM_JISO_PARTGROUP PP
                                   LEFT JOIN MM_JISO_PART JI
                                     ON PP.ID = JI.PARTGROUP_ID
                                   LEFT JOIN MM_PUB_PLAN_CODE CDD
                                     ON PP.PLAN_CODE = CDD.PLAN_CODE) ACC
                         WHERE ACC.PART_NO = SUB_FORECAST.PART_NO) LOOP
      
        --获取属地信息
        v_location := null;
        v_loc_num  := 0;
        --v_distri_person := null;
        --1、根据零件获取属地信息中任一落点信息
        for cur_loc in (select a.location, a.location_num, a.distri_person
                          from mm_inv_part_location a
                         where a.factory_code = SUB_FORECAST.COMP
                           and a.workcenter = CUR_ADVAN.workcenter
                           and a.part_no = SUB_FORECAST.part_NO
                           and a.eff_start <= sysdate
                           and a.eff_end > sysdate
                         order by a.location_num desc) loop
          v_location := cur_loc.location;
          v_loc_num  := cur_loc.location_num;
          --v_distri_person := cur_loc.distri_person;
          v_use_location_num := 'LOC';
          exit;
        end loop;
        --2、获取属地信息中车间最大工深
        if v_location is null then
          select decode(max(a.location_num), null, 0, max(a.location_num))
            into v_loc_num
            from mm_inv_part_location a
           where a.factory_code = SUB_FORECAST.COMP
                --and a.workcenter = SUB_FORECAST.workcenter
             and a.eff_start <= sysdate
             and a.eff_end > sysdate;
          v_use_location_num := 'WC';
        end if;
        --3、获取系统参数中车间最大工深
        --if v_location is null then
        if CUR_ADVAN.WORKCENTER = 'A1' THEN
          V_WORKCENTER := 'AF';
        ELSIF CUR_ADVAN.WORKCENTER = 'W1' THEN
          V_WORKCENTER := 'WE';
        ELSIF CUR_ADVAN.WORKCENTER = 'T1' THEN
          V_WORKCENTER := 'PA';
        ELSE
          V_WORKCENTER := 'AF';
        END IF;
      
        ----最大工深获取方式修改为如下------------------------------------------------------------------- 
        BEGIN
          --判断如果是总装
          SELECT NVL(A.PARAM_VAL, 0)
            INTO v_af_max_loc
            FROM MM_PUB_SYS_PARAM A
           WHERE A.PARAM_GROUP = 'MAX_LOC'
             AND A.FACTORY_CODE = SUB_FORECAST.COMP
             AND A.PARAM_CODE = 'AF_TOTAL_PRO_NUM';
        
          --判断如果是焊装
          SELECT NVL(A.PARAM_VAL, 0)
            INTO v_we_max_loc
            FROM MM_PUB_SYS_PARAM A
           WHERE A.PARAM_GROUP = 'MAX_LOC'
             AND A.FACTORY_CODE = SUB_FORECAST.COMP
             AND A.PARAM_CODE = 'WE_TOTAL_PRO_NUM';
        
          --判断如果是涂装
          SELECT NVL(A.PARAM_VAL, 0)
            INTO v_pa_max_loc
            FROM MM_PUB_SYS_PARAM A
           WHERE A.PARAM_GROUP = 'MAX_LOC'
             AND A.FACTORY_CODE = SUB_FORECAST.COMP
             AND A.PARAM_CODE = 'PA_TOTAL_PRO_NUM';
          --判断如果是涂装
          SELECT NVL(A.PARAM_VAL, 0)
            INTO v_wbs_max_loc
            FROM MM_PUB_SYS_PARAM A
           WHERE A.PARAM_GROUP = 'MAX_LOC'
             AND A.FACTORY_CODE = SUB_FORECAST.COMP
             AND A.PARAM_CODE = 'WBS_TOTAL_PRO_NUM';
        
          --判断如果是涂装
          SELECT NVL(A.PARAM_VAL, 0)
            INTO v_pbs_max_loc
            FROM MM_PUB_SYS_PARAM A
           WHERE A.PARAM_GROUP = 'MAX_LOC'
             AND A.FACTORY_CODE = SUB_FORECAST.COMP
             AND A.PARAM_CODE = 'PBS_TOTAL_PRO_NUM';
        END;
      
        IF CUR_ADVAN.WORKCENTER = 'A1' AND NVL(v_loc_num, 0) = 0 THEN
          v_loc_num := v_af_max_loc;
        ELSIF CUR_ADVAN.WORKCENTER = 'A1' AND NVL(v_loc_num, 0) != 0 THEN
          v_loc_num := NVL(v_loc_num, 0);
        ELSIF CUR_ADVAN.WORKCENTER = 'T1' AND NVL(v_loc_num, 0) = 0 THEN
          v_loc_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc;
        ELSIF CUR_ADVAN.WORKCENTER = 'T1' AND NVL(v_loc_num, 0) != 0 THEN
          v_loc_num := v_af_max_loc + v_pbs_max_loc + NVL(v_loc_num, 0);
        ELSIF CUR_ADVAN.WORKCENTER = 'W1' AND NVL(v_loc_num, 0) = 0 THEN
          v_loc_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc +
                       v_wbs_max_loc + v_we_max_loc;
        ELSIF CUR_ADVAN.WORKCENTER = 'W1' AND NVL(v_loc_num, 0) != 0 THEN
          v_loc_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc +
                       v_wbs_max_loc + NVL(v_loc_num, 0);
        END IF;
      
        ------------------------------------------------------------------------     
      
        \*            v_loc_num          := to_number(PKG_PUB.USF_GET_SYS_PARAM(SUB_FORECAST.Comp,
        'MAX_LOC',
        V_WORKCENTER ||
        'TOTAL_PRO_NUM'));*\
        v_use_location_num := 'SYS';
      
        --end if;
      
        if v_loc_num is null then
          v_loc_num          := 0;
          v_use_location_num := null;
        end if;
        IF CUR_ADVAN.WORKCENTER IN ('W1', 'A1', 'T1') THEN
        
          --台套数对应时间
          V_OUT_TIME := PKG_PUB.USF_GET_PRODUCE_TIME(SUB_FORECAST.COMP,
                                                     CUR_ADVAN.WORKCENTER,
                                                     NULL) *
                        (nvl(v_loc_num, 0) + nvl(CUR_ADVAN.ARRIVE_NUM, 0) +
                         nvl(CUR_ADVAN.DISTRIBUTION_NUM, 0));
        
          --DBMS_OUTPUT.put_line(to_char(SUB_FORECAST.REC_DATE,'yyyy-mm-dd hh24:mi:ss'));
          --厂内装配时间
          V_TIME := PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                 CUR_ADVAN.WORKCENTER,
                                                 SUB_FORECAST.REC_DATE,
                                                 -V_OUT_TIME);
        
        ELSE
          --台套数对应时间
          --如果车间不是总装焊装涂装，使用总装计算
          V_OUT_TIME := PKG_PUB.USF_GET_PRODUCE_TIME(SUB_FORECAST.COMP,
                                                     'A1',
                                                     NULL) *
                        (v_loc_num + CUR_ADVAN.ARRIVE_NUM +
                         CUR_ADVAN.DISTRIBUTION_NUM);
        
          --厂内装配时间
          --如果车间不是总装焊装涂装，使用总装计算
          V_TIME := PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                 'A1',
                                                 SUB_FORECAST.REC_DATE,
                                                 -V_OUT_TIME);
        
        END IF;
      
        -- DBMS_OUTPUT.put_line(to_date(SUB_FORECAST.REC_DATE,'yyyy-mm-dd'));
        --DBMS_OUTPUT.put_line(TO_CHAR(V_TIME, 'YYYY-MM-DD HH24:mi:ss'));
        V_TIME1 := V_TIME - SUB_FORECAST.REC_DATE;
        \*    V_ENDTIME := 0;
        IF V_ENDTIME > V_TIME1 THEN 
          V_ENDTIME := V_TIME1;
          END IF;*\
        --从路线中获取省内省外和运输时长                                                         
        SELECT MAX(A.AREA), MAX(A.TRANS_TIME)
          INTO V_AREA, V_TRANS_TIME
          FROM MM_PUP_ROUTE A
         WHERE A.FACTORY_CODE = SUB_FORECAST.COMP
           AND A.SUPPLIER_NO = SUB_FORECAST.SUPPLIER_NO
           AND A.SUP_FACTORY =
               (SELECT UDA.SUP_FACTORY
                  FROM MM_PUB_PART_UDA UDA
                 WHERE UDA.PART_NO = SUB_FORECAST.PART_NO)
           AND A.CAR_TYPE = SUB_FORECAST.MODEL_CODE;
      
        V_ADVANCE_TIME := 0;
      
        IF V_AREA IS NOT NULL AND V_TRANS_TIME IS NOT NULL THEN
          IF V_TRANS_TIME = 0 THEN
            V_TRANS_TIME := 1;
          END IF;
          IF V_AREA = '省内' THEN
            --V_ADVANCE_TIME := CEIL(V_ENDTIME - V_TRANS_TIME/24);
            IF CUR_ADVAN.WORKCENTER IN ('A1', 'W1', 'T1') THEN
            
              V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                             CUR_ADVAN.WORKCENTER,
                                                             V_TIME,
                                                             -V_TRANS_TIME);
            ELSE
              V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                             'A1',
                                                             V_TIME,
                                                             -V_TRANS_TIME);
            END IF;
          END IF;
          --SELECT ceil(V_OUT_TIME + V_TRANS_TIME) INTO V_ADVANCE_TIME FROM DUAL;
          IF V_AREA = '省外' THEN
            --SELECT ceil(V_OUT_TIME + V_TRANS_TIME) / 24 INTO V_ADVANCE_TIME FROM DUAL;
            --V_ADVANCE_TIME := CEIL(V_ENDTIME + V_TRANS_TIME/24);
          
            IF CUR_ADVAN.WORKCENTER IN ('A1', 'W1', 'T1') THEN
            
              V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                TO_DATE(USF_MM_MP_FORBAKWORKDATE(TO_CHAR(V_TIME,
                                                                         'YYYY-MM-DD'),
                                                                 CEIL(NVL(V_TRANS_TIME,
                                                                          0) / 24),
                                                                 CUR_ADVAN.WORKCENTER,
                                                                 SUB_FORECAST.COMP,
                                                                 0) ||
                                        TO_CHAR(V_TIME, 'HH24:MI:SS'),
                                        'YYYY-MM-DD HH24:MI:SS');
            ELSE
              V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                TO_DATE(USF_MM_MP_FORBAKWORKDATE(TO_CHAR(V_TIME,
                                                                         'YYYY-MM-DD'),
                                                                 CEIL(NVL(V_TRANS_TIME,
                                                                          0) / 24),
                                                                 'A1',
                                                                 SUB_FORECAST.COMP,
                                                                 0) ||
                                        TO_CHAR(V_TIME, 'HH24:MI:SS'),
                                        'YYYY-MM-DD HH24:MI:SS');
            END IF;
          END IF;
        END IF;
      
      END LOOP;
    
      BEGIN
        SELECT MAX(UNLOAD_PORT) --获取卸货口
          INTO V_UNLOAD_PORT
          FROM (SELECT DISTINCT SD.UNLOAD_PORT
                  FROM MM_INV_PART_LOCATION SD
                 WHERE SD.PART_NO = SUB_FORECAST.PART_NO
                   AND SUB_FORECAST.COMP = SD.FACTORY_CODE
                   AND SD.EFF_START <= SYSDATE
                   AND SYSDATE <= SD.EFF_END);
      
      EXCEPTION
        WHEN OTHERS THEN
          V_UNLOAD_PORT := '';
      END;
    
      BEGIN
        SELECT Max(OAD.LOGISTICS_MODEL)
          INTO V_MM_MODEL --获取物流模式
          FROM MM_PUB_PART_UNLOAD OAD
         WHERE OAD.PART_NO = SUB_FORECAST.PART_NO;
      
      EXCEPTION
        WHEN OTHERS THEN
          V_MM_MODEL := '';
      END;
    
      INSERT INTO MM_SW_DEMAND_FORECAST_IMP
        (ID,
         FACTORY_CODE,
         FORE_TYPE,
         PLAN_DELIVERY,
         START_DATE,
         END_DATE,
         PHASE,
         UNLOAD_PORT,
         PART_NO,
         PART_UNIT,
         ORDER_QTY,
         SUPPLIER_NO,
         MODEL_CODE,
         LOGISTICS_MODE,
         CREATION_USER,
         CREATION_TIME,
         PUBLISH_WEEK,
         OBJ_WEEK,
         ADVANCE_TIME,
         RELEASE_STATUS,
         FEEDBACK_STATUS,
         DO_FLAG,
         DEAL_FLAG)
      VALUES
        (SEQ_SW_DEMAND_FORECAST_IMP.NEXTVAL,
         SUB_FORECAST.COMP,
         in_foreType,
         SUB_FORECAST.REC_DATE,
         to_date(SUB_FORECAST.START_DATE, 'yyyy-mm-dd'),
         to_date(SUB_FORECAST.END_DATE, 'yyyy-mm-dd'),
         decode(SUB_FORECAST.PHASE, '5', '1', '7', '1', '2'),
         V_UNLOAD_PORT,
         SUB_FORECAST.PART_NO,
         SUB_FORECAST.PART_UNIT,
         SUB_FORECAST.ORDER_NUM,
         SUB_FORECAST.SUPPLIER_NO,
         SUB_FORECAST.MODEL_CODE,
         V_MM_MODEL,
         in_account,
         SYSDATE,
         SUB_FORECAST.PUBLISH_WEEK,
         SUB_FORECAST.OBJ_WEEK,
         V_ADVANCE_TIME,
         '0',
         '0',
         'I',
         '0');
    END LOOP;
    COMMIT;
    out_code := 0;
    --END IF;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_DEMAND_PARTIF_GEN',
           err_num,
           err_msg,
           sysdate,
           '一级件零件预测计算');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_DEMAND_PARTIF_GEN;*/

  --***************************************************************************
  --存储过程名：USP_INV_STOCK_GEN
  --功能描述：支给W-1周库存计算
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: wangyu
  --创建时间： 2019/04/18
  /*PROCEDURE USP_INV_STOCK_GEN(in_arr_factory in VARCHAR2,
                              in_account     in VARCHAR2,
                              out_code       out VARCHAR2) AS
  
    err_num number;
    err_msg varchar2(200);
    V_NUM   NUMBER;
  BEGIN
    FOR STOCK_NUM IN (select ta.depot_no,
                             ta.part_no,
                             ta.factory_code,
                             sum(ta.qtyNum)
                        from (select b.depot_no,
                                     c.part_no,
                                     b.factory_code,
                                     nvl(c.order_qty, 0) -
                                     nvl(c.arrive_num, 0) qtyNum --c.arrive_num --支给件订单未到货数量
                                from mm_sw_order b
                                left join mm_sw_order_detail c
                                  on b.purchase_no = c.purchase_no
                               where b.order_type = '01'
                                 and b.zg_flag = '1'
                                 and trunc(sysdate, 'd') + 1 <=
                                     c.creation_time
                                 and sysdate <= trunc(sysdate, 'd') + 7
                              
                              UNION ALL
                              select e.depot_no,
                                     e.part_no,
                                     d.factory_code,
                                     nvl(e.order_qty, 0) -
                                     nvl(e.arrive_num, 0) qtyNum --支给件例外订单为未货数量
                                from mm_sw_order d
                                left join mm_sw_order_detail e
                                  on d.purchase_no = e.purchase_no
                               where d.order_type = '02'
                                 and trunc(sysdate, 'd') + 1 <=
                                     e.creation_time
                                 and sysdate <= trunc(sysdate, 'd') + 7
                                 and exists
                               (select 1
                                        from mm_pub_supporting_part p
                                       where e.part_no = p.part_no)
                              
                              UNION ALL
                              select iin.depot_no,
                                     ii.part_no,
                                     iin.factory_code,
                                     ii.rec_qty qtyNum
                              
                                from mm_inv_in_detail ii
                                left join mm_inv_in iin
                                  on ii.rec_no = iin.rec_no
                               where ii.rec_qty is not null
                                 and trunc(sysdate, 'd') + 1 <=
                                     ii.creation_time
                                 and sysdate <= trunc(sysdate, 'd') + 7
                              
                              UNION ALL
                              select ib.ware_code    depot_no,
                                     ib.part_no,
                                     ib.factory_code,
                                     ib.stock        qtyNum
                                from mm_inv_benchmark ib
                               where ib.flag = 1) ta
                       group by ta.depot_no, ta.part_no, ta.factory_code
                       order by ta.depot_no, ta.part_no) LOOP
      --发布数据
      INSERT INTO MM_SW_DEMAND_FORECAST
        (ID,
         FACTORY_CODE,
         FORE_TYPE,
         VERSION,
         PLAN_DELIVERY,
         START_DATE,
         MODEL_CODE,
         END_DATE,
         PHASE,
         UNLOAD_PORT,
         PART_NO,
         PART_UNIT,
         ORDER_QTY,
         SUPPLIER_NO,
         LOGISTICS_MODE,
         DOWNLOAD_STATUS,
         CREATION_TIME,
         RELEASE_STATUS,
         FEEDBACK_STATUS,
         PUBLISH_MONTH,
         OBJ_MONTH,
         OBJ_WEEK,
         PUBLISH_WEEK,
         ADVANCE_TIME,
         P_SUPPLIER,
         DO_FLAG,
         SEQ)
        SELECT SEQ_MM_SW_DEMAND_FORE.NEXTVAL,
               A.FACTORY_CODE,
               A.FORE_TYPE,
               A.VERSION,
               A.PLAN_DELIVERY,
               A.START_DATE,
               A.MODEL_CODE,
               A.END_DATE,
               A.PHASE,
               A.UNLOAD_PORT,
               A.PART_NO,
               A.PART_UNIT,
               A.ORDER_QTY,
               A.SUPPLIER_NO,
               A.LOGISTICS_MODE,
               0,
               SYSDATE,
               1,
               0,
               A.PUBLISH_MONTH,
               A.OBJ_MONTH,
               A.OBJ_WEEK,
               A.OBJ_MONTH,
               A.ADVANCE_TIME,
               A.P_SUPPLIER,
               'I',
               A.SEQ
          FROM MM_SW_DEMAND_FORECAST_SUPPORT A
         WHERE A.FORE_TYPE = in_foreType
           AND A.VERSION = in_version
           AND A.FACTORY_CODE = in_arr_factory;
    
      COMMIT;
    
      --更新发布状态
      UPDATE MM_SW_DEMAND_FORECAST_SUPPORT A
         SET A.RELEASE_STATUS = 1
       WHERE A.FORE_TYPE = in_foreType
         AND A.VERSION = in_version
         AND A.FACTORY_CODE = in_arr_factory;
    
      COMMIT;
    
      out_code := 0;
    END IF;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_DEMAND_FORECAST_RELEASE',
           err_num,
           err_msg,
           sysdate,
           '发布需求预测');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_INV_STOCK_GEN;*/

  --***************************************************************************
  --存储过程名：USP_MP_DEMAND_PARTIF_GEN
  --功能描述：一级件零件需求预测计算
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --foreType 预测类型
  --out_code 返回代码
  --创建人员: luoxianqin
  --创建时间： 2019/04/28
  PROCEDURE USP_MP_DEMAND_PARTIF_GEN(in_arr_factory in VARCHAR2,
                                     in_account     in VARCHAR2,
                                     in_foreType    in VARCHAR2,
                                     in_startDate   in VARCHAR2,
                                     in_endDate     in VARCHAR2,
                                     out_code       out VARCHAR2) AS
  
    err_num       number;
    err_msg       varchar2(200);
    V_NUM         NUMBER(5);
    V_UNLOAD_PORT VARCHAR2(100);
    V_MM_MODEL    VARCHAR2(100);
    --ERROR_TAG          NUMBER(10);
    --ERROR_MESSAGE      VARCHAR2(1000);
    V_AREA             VARCHAR2(20); --区域
    V_OUT_TIME         NUMBER(10); --生产节拍
    V_ADVANCE_TIME     NUMBER(10); --提前取货时间
    V_TRANS_TIME       NUMBER(10); --运输时长
    v_loc_num          number(10); --落点车体流动数
    v_use_location_num VARCHAR2(30);
    v_location         VARCHAR2(20);
    V_TIME             DATE; --厂内装配时间
    V_TIME1            NUMBER(10); --厂内提前时间
    V_WORKCENTER       VARCHAR2(30); --车间
    v_af_max_loc       NUMBER;
    v_pa_max_loc       NUMBER;
    v_we_max_loc       NUMBER;
    v_wbs_max_loc      NUMBER;
    v_pbs_max_loc      NUMBER;
    V_VERSION_EXIST    NUMBER(10); --判断版本是否存在
    v_dateNum          NUMBER(10); --判断用户输入的时间范围是否有对应的生成计划数据
  
  BEGIN
    select count(1)
      into v_dateNum
      from MM_PUB_PRO_PLAN P
      left join MM_PUB_ORDER_BOM BOM
        ON P.ORDER_NO = BOM.ORDER_NO
     WHERE substr(P.AFOFF_TIME, 0, 10) >=
           to_date(in_startDate, 'yyyy-mm-dd')
       AND substr(P.AFOFF_TIME, 0, 10) < =
           to_date(in_endDate, 'yyyy-mm-dd')
       AND P.FACTORY_CODE = in_arr_factory
       AND BOM.PURCHASE_TYPE in ('W', 'AW');
  
    if v_dateNum = 0 then
      out_code := 2;
    else
      delete from mm_sw_demand_forecast_imp;
      FOR SUB_FORECAST IN (SELECT P.FACTORY_CODE COMP,
                                  --P.AFOFF_TIME REC_DATE,
                                  P.MODEL_CODE MODEL_CODE,
                                  P.PHASE      PHASE,
                                  BOM.PART_NO  PART_NO,
                                  --BOM.NUM ORDER_NUM,
                                  BOM.PURCHASE_TYPE PURCHASE_TYPE,
                                  PS.SUPPLIER_NO,
                                  T.PART_UNIT,
                                  to_char(SE.START_DATE, 'yyyy-mm-dd') START_DATE,
                                  to_char(SE.END_DATE, 'yyyy-mm-dd') END_DATE,
                                  to_char(SE.START_DATE, 'yyyy-mm-dd') OBJ_WEEK,
                                  to_char(trunc(to_date(to_char(sysdate,
                                                                'yyyy-mm-dd'),
                                                        'yyyy-mm-dd'),
                                                'd') + 1,
                                          'yyyy-mm-dd') PUBLISH_WEEK,
                                  --TS.REC_DATE,
                                  --TS.ORDER_NUM,
                                  SUM(BOM.NUM) ORDER_NUM,
                                  to_date(SUBSTR(to_char(P.AFOFF_TIME,
                                                         'yyyy-mm-dd hh24:mi:ss'),
                                                 0,
                                                 10),
                                          'yyyy-mm-dd hh24:mi:ss') REC_DATE
                             FROM MM_PUB_PRO_PLAN P
                             LEFT JOIN MM_PUB_ORDER_BOM BOM
                               ON P.ORDER_NO = BOM.ORDER_NO
                             LEFT JOIN MM_PUB_PART_SUPPLIER PS
                               ON BOM.PART_NO = PS.PART_NO
                              AND BOM.FACTORY_CODE = PS.FACTORY_CODE
                             LEFT JOIN MM_PUB_PART T
                               ON BOM.PART_NO = T.PART_NO
                              AND BOM.FACTORY_CODE = T.FACTORY_CODE
                             LEFT JOIN (SELECT MIN(A.AFOFF_TIME) START_DATE,
                                              MAX(A.AFOFF_TIME) END_DATE
                                         FROM MM_PUB_PRO_PLAN A
                                       /*WHERE A.AFOFF_TIME >=
                                           trunc(to_date(to_char(sysdate, 'yyyy-mm-dd'),
                                                         'yyyy-mm-dd'),
                                                 'd') + 1
                                       AND A.AFOFF_TIME < =
                                           trunc(to_date(to_char(sysdate, 'yyyy-mm-dd'),
                                                         'yyyy-mm-dd'),
                                                 'd') + 28*/
                                        WHERE substr(A.AFOFF_TIME, 0, 10) >=
                                              to_date(in_startDate,
                                                      'yyyy-mm-dd')
                                          AND substr(A.AFOFF_TIME, 0, 10) < =
                                              to_date(in_endDate,
                                                      'yyyy-mm-dd')) SE
                               ON 1 = 1
                           
                           /* WHERE P.AFOFF_TIME >=
                               trunc(to_date(to_char(sysdate, 'yyyy-mm-dd'), 'yyyy-mm-dd'), 'd') + 1
                           AND P.AFOFF_TIME < =
                               trunc(to_date(to_char(sysdate, 'yyyy-mm-dd'), 'yyyy-mm-dd'), 'd') + 28*/
                            WHERE substr(P.AFOFF_TIME, 0, 10) >=
                                  to_date(in_startDate, 'yyyy-mm-dd')
                              AND substr(P.AFOFF_TIME, 0, 10) < =
                                  to_date(in_endDate, 'yyyy-mm-dd')
                              AND P.FACTORY_CODE = in_arr_factory
                              AND (BOM.PURCHASE_TYPE = 'W'
                                   -- OR BOM.PURCHASE_TYPE = 'FW' 
                                   OR BOM.PURCHASE_TYPE = 'AW')
                            GROUP BY to_date(SUBSTR(to_char(P.AFOFF_TIME,
                                                            'yyyy-mm-dd hh24:mi:ss'),
                                                    0,
                                                    10),
                                             'yyyy-mm-dd hh24:mi:ss'),
                                     BOM.PART_NO,
                                     P.FACTORY_CODE,
                                     P.MODEL_CODE,
                                     P.PHASE,
                                     BOM.PURCHASE_TYPE,
                                     PS.SUPPLIER_NO,
                                     T.PART_UNIT,
                                     to_char(SE.START_DATE, 'yyyy-mm-dd'),
                                     to_char(SE.END_DATE, 'yyyy-mm-dd'),
                                     to_char(SE.START_DATE, 'yyyy-mm-dd'),
                                     to_char(trunc(to_date(to_char(sysdate,
                                                                   'yyyy-mm-dd'),
                                                           'yyyy-mm-dd'),
                                                   'd') + 1,
                                             'yyyy-mm-dd')) LOOP
      
        --计算提前取货时间
        FOR CUR_ADVAN IN (
                          
                          SELECT ACC.WORKCENTER,
                                  ACC.ARRIVE_NUM,
                                  ACC.DISTRIBUTION_NUM
                            FROM (SELECT C.ARRIVE_NUM,
                                          C.DISTRIBUTION_NUM,
                                          C.PART_NO,
                                          C.WORKCENTER
                                     FROM MM_MP_PART C
                                   UNION
                                   SELECT D.ARRIVE_NUM,
                                          D.DISTRIBUTION_NUM,
                                          D.PART_NO,
                                          CD.WORKCENTER
                                     FROM MM_JIT_PART D
                                     LEFT JOIN MM_PUB_PLAN_CODE CD
                                       ON D.PLAN_CODE = CD.PLAN_CODE
                                   UNION
                                   SELECT PP.ARRIVE_NUM,
                                          PP.DISTRIBUTION_NUM,
                                          JI.PART_NO,
                                          CDD.WORKCENTER
                                     FROM MM_JISO_PARTGROUP PP
                                     LEFT JOIN MM_JISO_PART JI
                                       ON PP.ID = JI.PARTGROUP_ID
                                     LEFT JOIN MM_PUB_PLAN_CODE CDD
                                       ON PP.PLAN_CODE = CDD.PLAN_CODE) ACC
                           WHERE ACC.PART_NO = SUB_FORECAST.PART_NO) LOOP
        
          --获取属地信息
          v_location := null;
          v_loc_num  := 0;
          --v_distri_person := null;
          --1、根据零件获取属地信息中任一落点信息
          for cur_loc in (select a.location, a.location_num, a.distri_person
                            from mm_inv_part_location a
                           where a.factory_code = SUB_FORECAST.COMP
                             and a.workcenter = CUR_ADVAN.workcenter
                             and a.part_no = SUB_FORECAST.part_NO
                             and a.eff_start <= sysdate
                             and a.eff_end > sysdate
                           order by a.location_num desc) loop
            v_location := cur_loc.location;
            v_loc_num  := cur_loc.location_num;
            --v_distri_person := cur_loc.distri_person;
            v_use_location_num := 'LOC';
            exit;
          end loop;
          --2、获取属地信息中车间最大工深
          if v_location is null then
            select decode(max(a.location_num), null, 0, max(a.location_num))
              into v_loc_num
              from mm_inv_part_location a
             where a.factory_code = SUB_FORECAST.COMP
                  --and a.workcenter = SUB_FORECAST.workcenter
               and a.eff_start <= sysdate
               and a.eff_end > sysdate;
            v_use_location_num := 'WC';
          end if;
          --3、获取系统参数中车间最大工深
          --if v_location is null then
          if CUR_ADVAN.WORKCENTER = 'A1' THEN
            V_WORKCENTER := 'AF';
          ELSIF CUR_ADVAN.WORKCENTER = 'W1' THEN
            V_WORKCENTER := 'WE';
          ELSIF CUR_ADVAN.WORKCENTER = 'T1' THEN
            V_WORKCENTER := 'PA';
          ELSE
            V_WORKCENTER := 'AF';
          END IF;
        
          ----最大工深获取方式修改为如下------------------------------------------------------------------- 
          BEGIN
            --判断如果是总装
            SELECT NVL(A.PARAM_VAL, 0)
              INTO v_af_max_loc
              FROM MM_PUB_SYS_PARAM A
             WHERE A.PARAM_GROUP = 'MAX_LOC'
               AND A.FACTORY_CODE = SUB_FORECAST.COMP
               AND A.PARAM_CODE = 'AF_TOTAL_PRO_NUM';
          
            --判断如果是焊装
            SELECT NVL(A.PARAM_VAL, 0)
              INTO v_we_max_loc
              FROM MM_PUB_SYS_PARAM A
             WHERE A.PARAM_GROUP = 'MAX_LOC'
               AND A.FACTORY_CODE = SUB_FORECAST.COMP
               AND A.PARAM_CODE = 'WE_TOTAL_PRO_NUM';
          
            --判断如果是涂装
            SELECT NVL(A.PARAM_VAL, 0)
              INTO v_pa_max_loc
              FROM MM_PUB_SYS_PARAM A
             WHERE A.PARAM_GROUP = 'MAX_LOC'
               AND A.FACTORY_CODE = SUB_FORECAST.COMP
               AND A.PARAM_CODE = 'PA_TOTAL_PRO_NUM';
            --判断如果是涂装
            SELECT NVL(A.PARAM_VAL, 0)
              INTO v_wbs_max_loc
              FROM MM_PUB_SYS_PARAM A
             WHERE A.PARAM_GROUP = 'MAX_LOC'
               AND A.FACTORY_CODE = SUB_FORECAST.COMP
               AND A.PARAM_CODE = 'WBS_TOTAL_PRO_NUM';
          
            --判断如果是涂装
            SELECT NVL(A.PARAM_VAL, 0)
              INTO v_pbs_max_loc
              FROM MM_PUB_SYS_PARAM A
             WHERE A.PARAM_GROUP = 'MAX_LOC'
               AND A.FACTORY_CODE = SUB_FORECAST.COMP
               AND A.PARAM_CODE = 'PBS_TOTAL_PRO_NUM';
          END;
        
          IF CUR_ADVAN.WORKCENTER = 'A1' AND NVL(v_loc_num, 0) = 0 THEN
            v_loc_num := v_af_max_loc;
          ELSIF CUR_ADVAN.WORKCENTER = 'A1' AND NVL(v_loc_num, 0) != 0 THEN
            v_loc_num := NVL(v_loc_num, 0);
          ELSIF CUR_ADVAN.WORKCENTER = 'T1' AND NVL(v_loc_num, 0) = 0 THEN
            v_loc_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc;
          ELSIF CUR_ADVAN.WORKCENTER = 'T1' AND NVL(v_loc_num, 0) != 0 THEN
            v_loc_num := v_af_max_loc + v_pbs_max_loc + NVL(v_loc_num, 0);
          ELSIF CUR_ADVAN.WORKCENTER = 'W1' AND NVL(v_loc_num, 0) = 0 THEN
            v_loc_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc +
                         v_wbs_max_loc + v_we_max_loc;
          ELSIF CUR_ADVAN.WORKCENTER = 'W1' AND NVL(v_loc_num, 0) != 0 THEN
            v_loc_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc +
                         v_wbs_max_loc + NVL(v_loc_num, 0);
          END IF;
        
          ------------------------------------------------------------------------     
        
          /*            v_loc_num          := to_number(PKG_PUB.USF_GET_SYS_PARAM(SUB_FORECAST.Comp,
          'MAX_LOC',
          V_WORKCENTER ||
          'TOTAL_PRO_NUM'));*/
          v_use_location_num := 'SYS';
        
          --end if;
        
          if v_loc_num is null then
            v_loc_num          := 0;
            v_use_location_num := null;
          end if;
          IF CUR_ADVAN.WORKCENTER IN ('W1', 'A1', 'T1') THEN
          
            --台套数对应时间
            V_OUT_TIME := PKG_PUB.USF_GET_PRODUCE_TIME(SUB_FORECAST.COMP,
                                                       CUR_ADVAN.WORKCENTER,
                                                       NULL) *
                          (nvl(v_loc_num, 0) + nvl(CUR_ADVAN.ARRIVE_NUM, 0) +
                           nvl(CUR_ADVAN.DISTRIBUTION_NUM, 0));
          
            --DBMS_OUTPUT.put_line(to_char(SUB_FORECAST.REC_DATE,'yyyy-mm-dd hh24:mi:ss'));
            --厂内装配时间
            V_TIME := PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                   CUR_ADVAN.WORKCENTER,
                                                   SUB_FORECAST.REC_DATE,
                                                   -V_OUT_TIME);
          
          ELSE
            --台套数对应时间
            --如果车间不是总装焊装涂装，使用总装计算
            V_OUT_TIME := PKG_PUB.USF_GET_PRODUCE_TIME(SUB_FORECAST.COMP,
                                                       'A1',
                                                       NULL) *
                          (v_loc_num + CUR_ADVAN.ARRIVE_NUM +
                           CUR_ADVAN.DISTRIBUTION_NUM);
          
            --厂内装配时间
            --如果车间不是总装焊装涂装，使用总装计算
            V_TIME := PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                   'A1',
                                                   SUB_FORECAST.REC_DATE,
                                                   -V_OUT_TIME);
          
          END IF;
        
          -- DBMS_OUTPUT.put_line(to_date(SUB_FORECAST.REC_DATE,'yyyy-mm-dd'));
          --DBMS_OUTPUT.put_line(TO_CHAR(V_TIME, 'YYYY-MM-DD HH24:mi:ss'));
          V_TIME1 := V_TIME - SUB_FORECAST.REC_DATE;
          /*    V_ENDTIME := 0;
          IF V_ENDTIME > V_TIME1 THEN 
            V_ENDTIME := V_TIME1;
            END IF;*/
          --从路线中获取省内省外和运输时长                                                         
          SELECT MAX(A.AREA), MAX(A.TRANS_TIME)
            INTO V_AREA, V_TRANS_TIME
            FROM MM_PUP_ROUTE A
           WHERE A.FACTORY_CODE = SUB_FORECAST.COMP
             AND A.SUPPLIER_NO = SUB_FORECAST.SUPPLIER_NO
             AND A.SUP_FACTORY =
                 (SELECT UDA.SUP_FACTORY
                    FROM MM_PUB_PART_UDA UDA
                   WHERE UDA.PART_NO = SUB_FORECAST.PART_NO)
             AND A.CAR_TYPE = SUB_FORECAST.MODEL_CODE;
        
          V_ADVANCE_TIME := 0;
        
          IF V_AREA IS NOT NULL AND V_TRANS_TIME IS NOT NULL THEN
            IF V_TRANS_TIME = 0 THEN
              V_TRANS_TIME := 1;
            END IF;
            IF V_AREA = '省内' THEN
              --V_ADVANCE_TIME := CEIL(V_ENDTIME - V_TRANS_TIME/24);
              IF CUR_ADVAN.WORKCENTER IN ('A1', 'W1', 'T1') THEN
              
                V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                  PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                               CUR_ADVAN.WORKCENTER,
                                                               V_TIME,
                                                               -V_TRANS_TIME);
              ELSE
                V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                  PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                               'A1',
                                                               V_TIME,
                                                               -V_TRANS_TIME);
              END IF;
            END IF;
            --SELECT ceil(V_OUT_TIME + V_TRANS_TIME) INTO V_ADVANCE_TIME FROM DUAL;
            IF V_AREA = '省外' THEN
              --SELECT ceil(V_OUT_TIME + V_TRANS_TIME) / 24 INTO V_ADVANCE_TIME FROM DUAL;
              --V_ADVANCE_TIME := CEIL(V_ENDTIME + V_TRANS_TIME/24);
            
              IF CUR_ADVAN.WORKCENTER IN ('A1', 'W1', 'T1') THEN
              
                V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                  TO_DATE(USF_MM_MP_FORBAKWORKDATE(TO_CHAR(V_TIME,
                                                                           'YYYY-MM-DD'),
                                                                   CEIL(NVL(V_TRANS_TIME,
                                                                            0) / 24),
                                                                   CUR_ADVAN.WORKCENTER,
                                                                   SUB_FORECAST.COMP,
                                                                   0) ||
                                          TO_CHAR(V_TIME, 'HH24:MI:SS'),
                                          'YYYY-MM-DD HH24:MI:SS');
              ELSE
                V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                  TO_DATE(USF_MM_MP_FORBAKWORKDATE(TO_CHAR(V_TIME,
                                                                           'YYYY-MM-DD'),
                                                                   CEIL(NVL(V_TRANS_TIME,
                                                                            0) / 24),
                                                                   'A1',
                                                                   SUB_FORECAST.COMP,
                                                                   0) ||
                                          TO_CHAR(V_TIME, 'HH24:MI:SS'),
                                          'YYYY-MM-DD HH24:MI:SS');
              END IF;
            END IF;
          END IF;
        
        END LOOP;
      
        BEGIN
          SELECT MAX(UNLOAD_PORT) --获取卸货口
            INTO V_UNLOAD_PORT
            FROM (SELECT DISTINCT SD.UNLOAD_PORT
                    FROM MM_INV_PART_LOCATION SD
                   WHERE SD.PART_NO = SUB_FORECAST.PART_NO
                     AND SUB_FORECAST.COMP = SD.FACTORY_CODE
                     AND SD.EFF_START <= SYSDATE
                     AND SYSDATE <= SD.EFF_END);
        
        EXCEPTION
          WHEN OTHERS THEN
            V_UNLOAD_PORT := '';
        END;
      
        BEGIN
          SELECT Max(OAD.LOGISTICS_MODEL)
            INTO V_MM_MODEL --获取物流模式
            FROM MM_PUB_PART_UNLOAD OAD
           WHERE OAD.PART_NO = SUB_FORECAST.PART_NO;
        
        EXCEPTION
          WHEN OTHERS THEN
            V_MM_MODEL := '';
        END;
      
        INSERT INTO MM_SW_DEMAND_FORECAST_IMP
          (ID,
           FACTORY_CODE,
           FORE_TYPE,
           PLAN_DELIVERY,
           START_DATE,
           END_DATE,
           PHASE,
           UNLOAD_PORT,
           PART_NO,
           PART_UNIT,
           ORDER_QTY,
           SUPPLIER_NO,
           MODEL_CODE,
           LOGISTICS_MODE,
           CREATION_USER,
           CREATION_TIME,
           PUBLISH_WEEK,
           OBJ_WEEK,
           ADVANCE_TIME,
           RELEASE_STATUS,
           FEEDBACK_STATUS,
           DO_FLAG,
           DEAL_FLAG)
        VALUES
          (SEQ_SW_DEMAND_FORECAST_IMP.NEXTVAL,
           SUB_FORECAST.COMP,
           in_foreType,
           SUB_FORECAST.REC_DATE,
           to_date(SUB_FORECAST.START_DATE, 'yyyy-mm-dd'),
           to_date(SUB_FORECAST.END_DATE, 'yyyy-mm-dd'),
           decode(SUB_FORECAST.PHASE, '5', '1', '7', '1', '2'),
           V_UNLOAD_PORT,
           SUB_FORECAST.PART_NO,
           SUB_FORECAST.PART_UNIT,
           SUB_FORECAST.ORDER_NUM,
           SUB_FORECAST.SUPPLIER_NO,
           SUB_FORECAST.MODEL_CODE,
           V_MM_MODEL,
           in_account,
           SYSDATE,
           SUB_FORECAST.PUBLISH_WEEK,
           SUB_FORECAST.OBJ_WEEK,
           V_ADVANCE_TIME,
           '0',
           '0',
           'I',
           '0');
      END LOOP;
      COMMIT;
      out_code := 0;
    end if;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_DEMAND_PARTIF_GEN',
           err_num,
           err_msg,
           sysdate,
           '一级件零件预测计算');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_DEMAND_PARTIF_GEN;

  --***************************************************************************
  --存储过程名：USP_INV_STOCK_GEN
  --功能描述：支给W-1周库存计算
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: luoxq
  --创建时间： 2019/05/30
  PROCEDURE USP_INV_STOCK_GEN(in_arr_factory in VARCHAR2,
                              in_account     in VARCHAR2,
                              out_code       out VARCHAR2) AS
  
    err_num number;
    err_msg varchar2(200);
    V_NUM   NUMBER;
  BEGIN
    FOR STOCK_NUM IN (select ta.depot_no,
                             ta.part_no,
                             ta.factory_code,
                             sum(ta.qtyNum) qtyNum
                        from (select b.depot_no,
                                     c.part_no,
                                     b.factory_code,
                                     nvl(c.order_qty, 0) -
                                     nvl(c.arrive_num, 0) qtyNum --c.arrive_num --支给件订单未到货数量
                                from mm_sw_order b
                                left join mm_sw_order_detail c
                                  on b.purchase_no = c.purchase_no
                               where b.order_type = '01'
                                 and b.zg_flag = '1'
                                 and trunc(sysdate, 'd') + 1 <=
                                     c.creation_time
                                 and sysdate <= trunc(sysdate, 'd') + 7
                              
                              UNION ALL
                              select e.depot_no,
                                     e.part_no,
                                     d.factory_code,
                                     nvl(e.order_qty, 0) -
                                     nvl(e.arrive_num, 0) qtyNum --支给件例外订单为未货数量
                                from mm_sw_order d
                                left join mm_sw_order_detail e
                                  on d.purchase_no = e.purchase_no
                               where d.order_type = '02'
                                 and trunc(sysdate, 'd') + 1 <=
                                     e.creation_time
                                 and sysdate <= trunc(sysdate, 'd') + 7
                                 and exists
                               (select 1
                                        from mm_pub_supporting_part p
                                       where e.part_no = p.part_no)
                              
                              UNION ALL
                              select iin.depot_no,
                                     ii.part_no,
                                     iin.factory_code,
                                     ii.rec_qty qtyNum
                              
                                from mm_inv_in_detail ii
                                left join mm_inv_in iin
                                  on ii.rec_no = iin.rec_no
                               where ii.rec_qty is not null
                                 and trunc(sysdate, 'd') + 1 <=
                                     ii.creation_time
                                 and sysdate <= trunc(sysdate, 'd') + 7
                              
                              UNION ALL
                              select ib.ware_code    depot_no,
                                     ib.part_no,
                                     ib.factory_code,
                                     ib.stock        qtyNum
                                from mm_inv_benchmark ib
                               where ib.flag = 1) ta
                       group by ta.depot_no, ta.part_no, ta.factory_code
                       order by ta.depot_no, ta.part_no) LOOP
    
      SELECT COUNT(1)
        INTO V_NUM
        FROM MM_INV_BENCHMARK A
       WHERE --判断该零件（状态为生成）的库存是否存在 ，存在则修改该零件库存
       A.FACTORY_CODE = in_arr_factory
       AND A.WARE_CODE = STOCK_NUM.DEPOT_NO
       AND A.PART_NO = STOCK_NUM.PART_NO
       AND A.FLAG = 0;
    
      IF V_NUM > 0 THEN
        --修改库存
        UPDATE MM_INV_BENCHMARK A
           SET A.STOCK              = STOCK_NUM.qtyNum,
               A.LAST_MODIFIED_USER = in_account,
               A.LAST_MODIFIED_TIME = SYSDATE
         WHERE A.WARE_CODE = STOCK_NUM.DEPOT_NO
           AND A.PART_NO = STOCK_NUM.PART_NO
           AND A.FLAG = 1;
      
      ELSE
        --不存在的零件写入库存基准表
        INSERT INTO MM_INV_BENCHMARK
          (ID,
           FACTORY_CODE,
           WARE_CODE,
           PART_NO,
           STOCK,
           FLAG,
           CAL_USER,
           CAL_TIME,
           CREATION_USER,
           CREATION_TIME)
        VALUES
          (SEQ_MM_INV_BENCHMARK.NEXTVAL,
           in_arr_factory,
           STOCK_NUM.Depot_No,
           STOCK_NUM.PART_NO,
           STOCK_NUM.QTYNUM,
           '0',
           in_account,
           sysdate,
           in_account,
           sysdate);
      
      END IF;
    END LOOP;
    COMMIT;
    out_code := 0;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_INV_STOCK_GEN',
           err_num,
           err_msg,
           sysdate,
           '支给W-1周库存计算');
        COMMIT;
        ROLLBACK;
      
      END;
  END USP_INV_STOCK_GEN;

  --***************************************************************************
  --存储过程名：USP_INV_GET_DIFFERENCE
  --功能描述：支给获取库存差异
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: luoxq
  --创建时间： 2019/05/30
  PROCEDURE USP_INV_GET_DIFFERENCE(in_arr_factory in VARCHAR2,
                                   in_account     in VARCHAR2,
                                   out_code       out VARCHAR2) AS
  
    err_num   number;
    err_msg   varchar2(200);
    V_NUM     NUMBER;
    v_count   number;
    v_count_a number;
    v_count_b number;
  BEGIN
    delete from mm_inv_difference; --每次生成之前删除上次的数据
    v_count := 1;
    select nvl(max(a.cal_week), 0) into v_count_a from mm_inv_week_cal a;
  
    loop
      FOR DIFFE_NUM IN (SELECT bbm.part_no,
                               SP.next_placement ware_code,
                               sum(bbm.useNum) useNum,
                               bbm.AFDATE AFDATE,
                               W.CAL_WEEK calWeek
                          FROM (SELECT BOM.PART_NO,
                                       SUM(BOM.NUM) useNum,
                                       TO_CHAR(A.AFOFF_TIME, 'YYYY-MM-DD') AFDATE
                                
                                  FROM MM_PUB_PRO_PLAN A
                                  LEFT JOIN MM_PUB_ORDER_BOM BOM
                                    ON A.ORDER_NO = BOM.ORDER_NO
                                 WHERE EXISTS
                                 (SELECT 1
                                          FROM MM_PUB_SUPPORTING_PART B
                                         WHERE BOM.PART_NO = B.PART_NO)
                                 GROUP BY BOM.PART_NO,
                                          TO_CHAR(A.AFOFF_TIME, 'YYYY-MM-DD')
                                 ORDER BY BOM.PART_NO) bbm
                        
                          left join mm_inv_week_cal w
                            on bbm.part_no = w.part_no
                          left join mm_pub_supporting_part sp
                            on sp.partf_id = bbm.part_no
                         start with sp.part_no is not null
                        connect by sp.part_no = bbm.part_no
                         GROUP BY bbm.part_no,
                                  bbm.AFDATE,
                                  sp.next_placement,
                                  W.CAL_WEEK
                         order by bbm.part_No, bbm.AFDATE) LOOP
      
        select to_date(DIFFE_NUM.AFDATE, 'yyyy-mm-dd') -
               (TRUNC(SYSDATE, 'd') + 7)
          into v_count_b
          from dual;
      
        if v_count <= v_count_b then
        
          SELECT COUNT(1)
            INTO V_NUM
            FROM MM_INV_DIFFERENCE A
           WHERE A.FACTORY_CODE = in_arr_factory
             AND A.WARE_CODE = DIFFE_NUM.WARE_CODE
             AND A.PART_NO = DIFFE_NUM.PART_NO
             AND to_char(A.AF_DATE, 'yyyy-mm-dd') = DIFFE_NUM.AFDATE;
        
          IF V_NUM > 0 THEN
            --修改用量
            UPDATE MM_INV_DIFFERENCE A
               SET A.USE_NUM            = DIFFE_NUM.USENUM,
                   A.LAST_MODIFIED_USER = in_account,
                   A.LAST_MODIFIED_TIME = SYSDATE
             WHERE A.WARE_CODE = DIFFE_NUM.WARE_CODE
               AND A.PART_NO = DIFFE_NUM.PART_NO
               AND to_char(A.AF_DATE, 'yyyy-mm-dd') = DIFFE_NUM.AFDATE;
          
          ELSE
            --不存在的零件写入库存基准表
            INSERT INTO MM_INV_DIFFERENCE
              (ID,
               FACTORY_CODE,
               WARE_CODE,
               PART_NO,
               USE_NUM,
               AF_DATE,
               CREATION_USER,
               CREATION_TIME)
            VALUES
              (SEQ_MM_INV_DIFFERENCE.NEXTVAL,
               in_arr_factory,
               DIFFE_NUM.WARE_CODE,
               DIFFE_NUM.PART_NO,
               DIFFE_NUM.USENUM,
               to_date(DIFFE_NUM.AFDATE, 'yyyy-mm-dd'),
               in_account,
               sysdate);
          
          END IF;
        
        END IF;
      END LOOP;
      v_count := v_count + 1;
      exit when v_count > v_count_a;
    end loop;
    COMMIT;
    out_code := 0;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_INV_GET_DIFFERENCE',
           err_num,
           err_msg,
           sysdate,
           '支给库存获取差异查询');
        COMMIT;
        ROLLBACK;
      
      END;
  END USP_INV_GET_DIFFERENCE;

  --***************************************************************************
  --存储过程名：USP_MP_DEMAND_EFFECT
  --功能描述：在物流系统就是那的周预测数据生效使用并写到业务表中
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --foreType 预测类型
  --out_code 返回代码
  --创建人员: luoxianqin
  --创建时间： 2019/04/28
  PROCEDURE USP_MP_DEMAND_EFFECT(in_arr_factory in VARCHAR2,
                                 in_account     in VARCHAR2,
                                 in_foreType    in VARCHAR2,
                                 out_code       out VARCHAR2) AS
    V_NUM             NUMBER(5);
    v_exec_start_time date; --存储过程执行开始时间点
    err_num           number;
    err_msg           varchar2(200);
  BEGIN
    v_exec_start_time := sysdate;
    select count(1)
      into V_NUM
      from mm_sw_demand_forecast_imp a
     where a.factory_code = in_arr_factory
       and a.version is not null
        or a.version != '';
    if V_NUM = 0 THEN
      --如果要生效使用的数据没有版本号则不写入到业务表
      out_code := 2;
    else
      FOR CUR_ORDER_NO IN (SELECT T.*
                             FROM MM_SW_DEMAND_FORECAST_IMP T
                            WHERE T.DEAL_FLAG = 0
                            ORDER BY T.CREATION_TIME) LOOP
      
        insert into MM_SW_DEMAND_FORECAST
          (ID,
           FACTORY_CODE,
           FORE_TYPE,
           VERSION,
           PLAN_DELIVERY,
           START_DATE,
           END_DATE,
           PHASE,
           UNLOAD_PORT,
           PART_NO,
           PART_UNIT,
           ORDER_QTY,
           SUPPLIER_NO,
           SUPPLIER_NAME,
           SUP_FACTORY_ADDR,
           SUP_FACTORY,
           MODEL_CODE,
           LOGISTICS_MODE,
           DOWNLOAD_STATUS,
           DOWNLOAD_TIME,
           CREATION_USER,
           CREATION_TIME,
           
           RELEASE_STATUS,
           FEEDBACK_STATUS,
           FEEDBACK_REMARK,
           
           OBJ_WEEK,
           PUBLISH_WEEK,
           ADVANCE_TIME,
           DEAL_FLAG,
           DO_FLAG)
        values
          (SEQ_MM_SW_DEMAND_FORE.nextval,
           in_arr_factory,
           in_foreType,
           CUR_ORDER_NO.VERSION,
           CUR_ORDER_NO.PLAN_DELIVERY,
           CUR_ORDER_NO.START_DATE,
           CUR_ORDER_NO.END_DATE,
           CUR_ORDER_NO.PHASE,
           CUR_ORDER_NO.UNLOAD_PORT,
           CUR_ORDER_NO.PART_NO,
           CUR_ORDER_NO.PART_UNIT,
           CUR_ORDER_NO.ORDER_QTY,
           CUR_ORDER_NO.SUPPLIER_NO,
           CUR_ORDER_NO.SUPPLIER_NAME,
           CUR_ORDER_NO.SUP_FACTORY_ADDR,
           CUR_ORDER_NO.SUP_FACTORY,
           CUR_ORDER_NO.MODEL_CODE,
           CUR_ORDER_NO.LOGISTICS_MODE,
           CUR_ORDER_NO.DOWNLOAD_STATUS,
           CUR_ORDER_NO.DOWNLOAD_TIME,
           CUR_ORDER_NO.CREATION_USER,
           CUR_ORDER_NO.CREATION_TIME,
           
           '1',
           CUR_ORDER_NO.FEEDBACK_STATUS,
           CUR_ORDER_NO.FEEDBACK_REMARK,
           
           CUR_ORDER_NO.OBJ_WEEK,
           CUR_ORDER_NO.PUBLISH_WEEK,
           CUR_ORDER_NO.ADVANCE_TIME,
           '1',
           'I');
      
        --更新中间表处理标记位为已处理
        update MM_SW_DEMAND_FORECAST_IMP a
           set a.deal_flag = 1, a.deal_time = sysdate
         where a.id = CUR_ORDER_NO.id
           AND A.FACTORY_CODE = CUR_ORDER_NO.FACTORY_CODE;
        COMMIT;
        out_code := 0;
      END LOOP;
    
      --统计存储过程执行消耗时间
      insert into mm_pub_exec_time_log
        (exec_code, exec_desc, start_time, end_time)
      values
        ('USP_MP_DEMAND_EFFECT',
         '执行生效使用周预测数据',
         v_exec_start_time,
         sysdate);
    end if;
  
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      out_code := 1;
      err_num  := SQLCODE;
      err_msg  := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                         1,
                         200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_MP_DEMAND_EFFECT',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
    
  END USP_MP_DEMAND_EFFECT;

end PKG_MP_MAIN;
/

prompt
prompt Creating package body PKG_PR_ALERT
prompt ==================================
prompt
create or replace package body PKG_PR_ALERT as

  --****************************************************************************
  --过程名  : USP_PRINT_EXCEP_CHECK
  --功能描述: 自动打印异常检查
  --参数说明:
  --in_arr_factory 工厂
  --创建人员: chenjq
  --创建时间: 2016-09-13
  --****************************************************************************
  procedure USP_PRINT_EXCEP_CHECK(in_arr_factory IN VARCHAR2) as
    err_num        number(19); --错误代码
    err_msg        varchar2(300); --错误信息
    v_count        number(10); --记录数
    v_factory_name varchar2(30); --工厂名称
    v_alert_depot  varchar2(100); --需要报警的仓库代码
  begin
    SELECT count(T.INS_NO)
      into v_count
      FROM MM_SPS_INS t
      LEFT JOIN MM_SPS_MOULD a
        ON T.MOULD_ID = a.id
      left join mm_pr_printer b
        on b.id = a.printer_id
      left join mm_pr_job c
        on c.printer_name = c.printer_name
      left join mm_pr_job_business d
        on d.job_name = c.job_name
     where t.print_status = 0
       and t.creation_time < (sysdate - 8 / 1440)
       and a.is_auto_print = 1
       and t.is_load = '0'
       and b.printer_name not in
           (select distinct m.printer_name
              from mm_pr_transaction_log m
             where m.entry_time > (sysdate - 4 / 1440)
               and m.content like '%Printer is not accepting job%')
       and not exists (
           select 1 from mm_sps_test_print_imp i where i.ins_no = t.ins_no
       );
     if v_count > 0 then
          --写入异常提醒表
          insert into MM_PR_EXCEP_ALERT
            (FUNC_POINT, ERROR_MSG, CREATION_TIME, DEAL_FLAG)
          values
            (in_arr_factory || 'SPS', in_arr_factory||'SPS指示票未打印张数：'||v_count, sysdate, 0);
        end if;
        commit;
    exception
    when others then
      rollback;
      err_num := sqlcode;
      err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(), 1, 200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (seq_pub_pro_error.nextval, 'USP_PRINT_EXCEP_CHECK', err_num, err_msg, sysdate,'自动打印异常提醒处理异常');
      commit;
  end USP_PRINT_EXCEP_CHECK;

  --过程名  : USP_PRINT_EXCEP_ALERT
  --功能描述: 自动打印异常提醒
  --创建人员: dtp
  --创建时间: 2019-02-22
  --****************************************************************************
  procedure USP_PRINT_EXCEP_ALERT as
    err_num                 number(19);--错误代码
    err_msg                 varchar2(300);--错误信息
  begin

    USP_PRINT_EXCEP_CHECK('2000');
  exception
    when others then
      err_num := sqlcode;
      err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(), 1, 200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (seq_pub_pro_error.nextval, 'USP_PRINT_EXCEP_ALERT', err_num, err_msg, sysdate,'自动打印异常提醒处理异常');
      commit;
  end USP_PRINT_EXCEP_ALERT;

end PKG_PR_ALERT;
/

prompt
prompt Creating package body PKG_PUB
prompt =============================
prompt
create or replace package body PKG_PUB is

  --****************************************************************************
  --函数  : USF_GET_BATCH_CYCLE
  --功能描述: 获取批次循环基数
  --参数说明:
  -- in_plan_code  :信息点
  --返回值: 批次循环基数
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCH_CYCLE(in_plan_code in varchar2) RETURN NUMBER AS
    out_batch_cycle mm_mon_kb.batch_cycle_num%type;
  BEGIN
    for cur_kb in (select b.batch_cycle_num
                     from mm_pub_plan_code a, mm_mon_kb b
                    where a.kb_id = b.id
                      and a.plan_code = in_plan_code) loop
      out_batch_cycle := cur_kb.batch_cycle_num;
    end loop;
    return out_batch_cycle;
  END USF_GET_BATCH_CYCLE;

  --****************************************************************************
  --函数  : USF_GET_PROCESS_CYCLE
  --功能描述: 获取进度循环基数
  --参数说明:
  -- in_plan_code  :信息点
  --返回值: 进度循环基数
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_PROCESS_CYCLE(in_plan_code in varchar2) RETURN NUMBER AS
    out_process_cycle mm_mon_kb.process_cycle_num%type;
  BEGIN
    for cur_kb in (select b.process_cycle_num
                     from mm_pub_plan_code a, mm_mon_kb b
                    where a.kb_id = b.id
                      and a.plan_code = in_plan_code) loop
      out_process_cycle := cur_kb.process_cycle_num;
    end loop;
    return out_process_cycle;
  END USF_GET_PROCESS_CYCLE;

  --****************************************************************************
  --函数名  : USF_GET_BATCH_NO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 批次号
  --创建人员: wxl
  --创建时间: 2018-11-12
  --****************************************************************************
  FUNCTION USF_GET_BATCHNO_BY_PRODSEQNO(in_kb_id         in number,
                                        in_product_seqno in number)
    RETURN NUMBER AS
    out_batch_no    mm_mon_kb.curr_batch_no%type;
    v_batch_cycle   mm_mon_kb.batch_cycle_num%type; --批次循环基数
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取批次循环基数和进度循环基数
    for cur_kb in (select b.batch_cycle_num, b.process_cycle_num
                     from mm_mon_kb b
                    where b.id = in_kb_id) loop
      v_batch_cycle   := cur_kb.batch_cycle_num;
      v_process_cycle := cur_kb.process_cycle_num;
    end loop;
  
    --计算批次号
    if in_product_seqno < 1 then
      out_batch_no := mod(ceil((1 - in_product_seqno) / v_process_cycle),
                          v_batch_cycle);
      if out_batch_no = 0 then
        out_batch_no := v_batch_cycle;
      end if;
      out_batch_no := v_batch_cycle - out_batch_no + 1;
    else
      out_batch_no := mod(ceil(in_product_seqno / v_process_cycle),
                          v_batch_cycle);
      if out_batch_no = 0 then
        out_batch_no := v_batch_cycle;
      end if;
    end if;
    return out_batch_no;
  END USF_GET_BATCHNO_BY_PRODSEQNO;

  --****************************************************************************
  --函数名  : USF_GET_PROCESSNO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 进度号
  --创建人员: wxl
  --创建时间: 2018-11-12
  --****************************************************************************
  FUNCTION USF_GET_PROCESSNO_BY_PRODSEQNO(in_kb_id         in number,
                                          in_product_seqno in number)
    RETURN NUMBER AS
    out_process_no  mm_mon_kb.curr_process_no%type;
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取进度循环基数
    for cur_kb in (select b.process_cycle_num
                     from mm_mon_kb b
                    where b.id = in_kb_id) loop
      v_process_cycle := cur_kb.process_cycle_num;
    end loop;
  
    --计算进度号
    if in_product_seqno < 1 then
      out_process_no := v_process_cycle -
                        mod(1 - in_product_seqno, v_process_cycle) + 1;
    else
      out_process_no := v_process_cycle -
                        mod(in_product_seqno, v_process_cycle) + 1;
    end if;
    if out_process_no = v_process_cycle + 1 then
      out_process_no := 1;
    end if;
  
    return out_process_no;
  END USF_GET_PROCESSNO_BY_PRODSEQNO;

  --****************************************************************************
  --函数名  : USF_GET_BATCH_NO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCHNO_BY_PRODSEQNO(in_plan_code     in varchar2,
                                        in_product_seqno in number)
    RETURN NUMBER AS
    out_batch_no    mm_mon_kb.curr_batch_no%type;
    v_batch_cycle   mm_mon_kb.batch_cycle_num%type; --批次循环基数
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取批次循环基数和进度循环基数
    v_batch_cycle   := USF_GET_BATCH_CYCLE(in_plan_code);
    v_process_cycle := USF_GET_PROCESS_CYCLE(in_plan_code);
  
    --计算批次号
    if in_product_seqno < 1 then
      out_batch_no := mod(ceil((1 - in_product_seqno) / v_process_cycle),
                          v_batch_cycle);
      if out_batch_no = 0 then
        out_batch_no := v_batch_cycle;
      end if;
      out_batch_no := v_batch_cycle - out_batch_no + 1;
    else
      out_batch_no := mod(ceil(in_product_seqno / v_process_cycle),
                          v_batch_cycle);
      if out_batch_no = 0 then
        out_batch_no := v_batch_cycle;
      end if;
    end if;
    return out_batch_no;
  END USF_GET_BATCHNO_BY_PRODSEQNO;

  --****************************************************************************
  --函数名  : USF_GET_PROCESSNO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 进度号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_PROCESSNO_BY_PRODSEQNO(in_plan_code     in varchar2,
                                          in_product_seqno in number)
    RETURN NUMBER AS
    out_process_no  mm_mon_kb.curr_process_no%type;
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取进度循环基数
    v_process_cycle := USF_GET_PROCESS_CYCLE(in_plan_code);
  
    --计算进度号
    if in_product_seqno < 1 then
      out_process_no := v_process_cycle -
                        mod(1 - in_product_seqno, v_process_cycle) + 1;
    else
      out_process_no := v_process_cycle -
                        mod(in_product_seqno, v_process_cycle) + 1;
    end if;
    if out_process_no = v_process_cycle + 1 then
      out_process_no := 1;
    end if;
  
    return out_process_no;
  END USF_GET_PROCESSNO_BY_PRODSEQNO;

  --****************************************************************************
  --函数名  : USF_GET_PRODSEQNO_BY_BATCH
  --功能描述: 根据批次获取产品流水号
  --参数说明:
  -- in_plan_code  :信息点
  -- in_batch_no  :批次号
  -- in_process_no  :进度号
  --返回值  : 产品流水号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_PRODSEQNO_BY_BATCH(in_plan_code  in varchar2,
                                      in_batch_no   in number,
                                      in_process_no in number) RETURN NUMBER AS
    out_product_seqno  mm_mon_kb.curr_batch_seqno%type;
    v_batch_cycle      mm_mon_kb.batch_cycle_num%type; --批次循环基数
    v_process_cycle    mm_mon_kb.process_cycle_num%type; --进度循环基数
    v_kb_batch_no      mm_mon_kb.curr_batch_no%type; --看板批次号
    v_kb_process_no    mm_mon_kb.curr_process_no%type; --看板进度号
    v_kb_product_seqno mm_mon_kb.product_seqno%type; --看板产品流水号
  BEGIN
    --获取批次循环基数
    v_batch_cycle := USF_GET_BATCH_CYCLE(in_plan_code);
    --获取进度循环基数
    v_process_cycle := USF_GET_PROCESS_CYCLE(in_plan_code);
    if in_batch_no <= 0 or in_batch_no > v_batch_cycle or
       in_process_no <= 0 or in_process_no > v_process_cycle then
      return out_product_seqno;
    end if;
  
    --获取当前看板的相关信息
    for cur_kb in (select b.curr_batch_no,
                          b.curr_process_no,
                          b.product_seqno
                     from mm_pub_plan_code a, mm_mon_kb b
                    where a.kb_id = b.id
                      and a.plan_code = in_plan_code) loop
      v_kb_batch_no      := cur_kb.curr_batch_no;
      v_kb_process_no    := cur_kb.curr_process_no;
      v_kb_product_seqno := cur_kb.product_seqno;
      --计算当前批次循环，首台产品流水号
      out_product_seqno := v_kb_product_seqno -
                           v_kb_batch_no * v_process_cycle +
                           v_kb_process_no;
      --计算传入批次对应产品流水号
      out_product_seqno := out_product_seqno +
                           in_batch_no * v_process_cycle - in_process_no;
    end loop;
  
    return out_product_seqno;
  END USF_GET_PRODSEQNO_BY_BATCH;

  --****************************************************************************
  --函数名  : USF_GET_BATCHSEQ_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次流水号
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 批次流水号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCHSEQ_BY_PRODSEQNO(in_kb_id         in number,
                                         in_product_seqno in number)
    RETURN NUMBER AS
    out_batch_seqno mm_mon_kb.curr_batch_seqno%type;
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取进度循环基数
    --获取批次循环基数和进度循环基数
    for cur_kb in (select b.batch_cycle_num, b.process_cycle_num
                     from mm_mon_kb b
                    where b.id = in_kb_id) loop
      v_process_cycle := cur_kb.process_cycle_num;
    end loop;
  
    --计算批次流水流水号
    if v_process_cycle is not null then
      out_batch_seqno := ceil(in_product_seqno / v_process_cycle);
    end if;
  
    return out_batch_seqno;
  END USF_GET_BATCHSEQ_BY_PRODSEQNO;

  --****************************************************************************
  --函数名  : USF_GET_BATCHSEQ_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次流水号
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次流水号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCHSEQ_BY_PRODSEQNO(in_plan_code     in varchar2,
                                         in_product_seqno in number)
    RETURN NUMBER AS
    out_batch_seqno mm_mon_kb.curr_batch_seqno%type;
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取进度循环基数
    v_process_cycle := USF_GET_PROCESS_CYCLE(in_plan_code);
  
    --计算批次流水流水号
    if v_process_cycle is not null then
      out_batch_seqno := ceil(in_product_seqno / v_process_cycle);
    end if;
  
    return out_batch_seqno;
  END USF_GET_BATCHSEQ_BY_PRODSEQNO;

  --****************************************************************************
  --函数名  : USF_GET_BATCH_NO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次循环流水号
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 批次基数流水号
  --创建人员: wxl
  --创建时间: 2019-06-29
  --****************************************************************************
  FUNCTION USF_GET_BCYCLESEQ_BY_PRODSEQNO(in_kb_id         in number,
                                          in_product_seqno in number)
    RETURN NUMBER AS
    out_bcycle_seqno mm_mon_kb.curr_batch_seqno%type;
    v_batch_cycle   mm_mon_kb.batch_cycle_num%type; --批次循环基数
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取批次循环基数和进度循环基数
    for cur_kb in (select b.batch_cycle_num, b.process_cycle_num
                     from mm_mon_kb b
                    where b.id = in_kb_id) loop
      v_batch_cycle   := cur_kb.batch_cycle_num;
      v_process_cycle := cur_kb.process_cycle_num;
    end loop;

    --计算批次流水流水号
    if v_batch_cycle is not null and v_process_cycle is not null then
      out_bcycle_seqno := ceil(ceil(in_product_seqno / v_process_cycle)/v_batch_cycle);
    end if;

    return out_bcycle_seqno;
  END USF_GET_BCYCLESEQ_BY_PRODSEQNO;
  
  --****************************************************************************
  --函数名  : USF_GET_BATCH_NO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次循环流水号
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次基数流水号
  --创建人员: wxl
  --创建时间: 2019-06-29
  --****************************************************************************
  FUNCTION USF_GET_BCYCLESEQ_BY_PRODSEQNO(in_plan_code     in varchar2,
                                          in_product_seqno in number)
    RETURN NUMBER AS
    out_bcycle_seqno mm_mon_kb.curr_batch_seqno%type;
    v_batch_cycle   mm_mon_kb.batch_cycle_num%type; --批次循环基数
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取批次循环基数和进度循环基数
    for cur_kb in (select b.batch_cycle_num, b.process_cycle_num
                     from mm_pub_plan_code a, mm_mon_kb b
                    where a.kb_id = b.id
                      and a.plan_code = in_plan_code) loop
      v_batch_cycle   := cur_kb.batch_cycle_num;
      v_process_cycle := cur_kb.process_cycle_num;
    end loop;

    --计算批次流水流水号
    if v_batch_cycle is not null and v_process_cycle is not null then
      out_bcycle_seqno := ceil(ceil(in_product_seqno / v_process_cycle)/v_batch_cycle);
    end if;

    return out_bcycle_seqno;
  END USF_GET_BCYCLESEQ_BY_PRODSEQNO;
  
  --****************************************************************************
  --函数名  : USF_GET_WORK_DATE
  --功能描述: 根据输入的时间获取当前工作日期(不包含时分秒)
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_time  :输入时间
  --返回值  : 工作日期(不包含时分秒)
  --创建人员: wxl
  --创建时间: 2018-09-11
  --****************************************************************************
  FUNCTION USF_GET_WORK_DATE(in_factory_code in varchar2,
                             in_workcenter   in varchar2,
                             in_time         in date) RETURN DATE AS
    out_work_date date;
  BEGIN
    --根据生产工作日历表获取输入时间对应的工作日期
    for cur_work_date in (select a.work_date
                            from mm_pub_work_calendar a
                           where a.factory_code = in_factory_code
                             and a.workcenter = in_workcenter
                             and a.work_start_time <= in_time
                             and a.work_end_time >= in_time) loop
      out_work_date := cur_work_date.work_date;
      exit;
    end loop;
    --如果未维护工作日历，则获取输入时间的日期为工作日期
    if out_work_date is null then
      out_work_date := to_date(to_char(in_time, 'yyyy-mm-dd'), 'yyyy-mm-dd');
    end if;
  
    return out_work_date;
  END USF_GET_WORK_DATE;

  --****************************************************************************
  --函数名  : USF_GET_PRODUCE_TIME
  --功能描述: 获取生产节拍
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  FUNCTION USF_GET_PRODUCE_TIME(in_factory_code    in varchar2,
                                in_workcenter      in varchar2,
                                in_production_line in varchar2) RETURN NUMBER AS
    out_produce_time number(10, 3); --生产节拍
  BEGIN
    --获取生产节拍
    for cur_produce_time in (select produce_time
                               from (select a.produce_time,
                                            row_number() over(PARTITION BY a.factory_code, a.workcenter order by a.eff_date desc) sn
                                       from mm_pub_tact_time a
                                      where a.factory_code = in_factory_code
                                        and a.workcenter = in_workcenter
                                        and ((in_production_line is not null and
                                            a.production_line =
                                            in_production_line) or
                                            (in_production_line is null and
                                            a.production_line in
                                            ('WE_MAIN',
                                               'PA_MAIN',
                                               'AF_MAIN')))
                                        and a.eff_date > sysdate)
                              where sn = 1) loop
      out_produce_time := cur_produce_time.produce_time;
      exit;
    end loop;
    RETURN out_produce_time;
  END USF_GET_PRODUCE_TIME;

  --****************************************************************************
  --函数名  : USF_GET_CAL_WORKTIME
  --功能描述: 获取工厂车间某一时间点前几秒或后几秒的工作时间
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  -- in_time  :输入时间
  -- in_num_offset  :  偏移秒数(单位:秒)
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2019-01-20
  --****************************************************************************
  FUNCTION USF_GET_CAL_WORKTIME(in_factory_code in varchar2,
                                in_workcenter   in varchar2,
                                in_time         in date,
                                in_num_offset   in number) RETURN DATE AS
    out_time date; --计算后时间
  BEGIN
    if in_factory_code is null or in_workcenter is null or in_time is null THEN
      return null;
    end if;
    if in_num_offset > 0 then
      out_time := USF_GET_NEXT_WORKTIME(in_factory_code,
                                        in_workcenter,
                                        in_time,
                                        in_num_offset);
    elsif in_num_offset < 0 then
      out_time := USF_GET_PRE_WORKTIME(in_factory_code,
                                       in_workcenter,
                                       in_time,
                                       in_num_offset);
    else
      out_time := in_time;
    end if;
    return out_time;
  END USF_GET_CAL_WORKTIME;

  --****************************************************************************
  --函数名  : USF_GET_PRE_WORKTIME
  --功能描述: 获取工厂车间某一时间点前几秒的工作时间
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  -- in_time  :输入时间
  -- in_num_offset  :  偏移秒数(负数，单位:秒)
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  FUNCTION USF_GET_PRE_WORKTIME(in_factory_code in varchar2,
                                in_workcenter   in varchar2,
                                in_time         in date,
                                in_num_offset   in number) RETURN DATE AS
    v_num_offset  number; --偏移天数
    v_cal_time    date; --此次计算时间
    v_s_rest_time date; --开始休息时间
    v_e_rest_time date; --结束休息时间
    out_time      date; --计算后时间
  BEGIN
    if in_time is null OR in_num_offset >= 0 THEN
      return null;
    end if;
  
    --偏移秒数转化为天
    v_num_offset := in_num_offset / (24 * 3600);
    v_cal_time   := in_time;
    out_time     := v_cal_time + v_num_offset;
    --按工作日、班组顺序遍历工作日历
    for cur_work in (select a.id, a.work_start_time, a.work_end_time
                       from mm_pub_work_calendar a
                      where a.factory_code = in_factory_code
                        and a.workcenter = in_workcenter
                        and a.work_start_time < in_time
                      order by a.work_date desc, a.shift_code desc) loop
      --计算时间比结束工作时间大时,计算时间为结束工作时间
      if v_cal_time > cur_work.work_end_time then
        out_time   := cur_work.work_end_time + (out_time - v_cal_time);
        v_cal_time := cur_work.work_end_time;
      end if;
      --按休息时间先后遍历休息日历
      for cur_rest in (select start_time, end_time
                         from mm_pub_work_calendar_detail
                        where work_calendar_id = cur_work.id
                          and time_type = '1' --???类型
                          and start_time < v_cal_time
                        order by start_time desc) loop
        --如果开始休息时间比开始工作时间小,为开始工作时间
        if cur_rest.start_time < cur_work.work_start_time then
          v_s_rest_time := cur_work.work_start_time;
        else
          v_s_rest_time := cur_rest.start_time;
        end if;
        --如果结束休息时间比结束工作时间大，为结束工作时间
        if cur_rest.end_time > cur_work.work_end_time then
          v_e_rest_time := cur_work.work_end_time;
        else
          v_e_rest_time := cur_rest.end_time;
        end if;
        --如果计算时间位于休息时间内,计算时间为开始休息时间
        if v_cal_time >= v_s_rest_time and v_cal_time < v_e_rest_time then
          out_time   := v_s_rest_time + (out_time - v_cal_time);
          v_cal_time := v_s_rest_time;
        else
          --如果计算时间???
          if out_time < v_e_rest_time THEN
            v_cal_time := v_s_rest_time;
            out_time   := out_time + (v_s_rest_time - v_e_rest_time);
          else
            GOTO firstloop;
          end if;
        end if;
      end loop;
      --如果计算后时间位于当前的工作日内，退出
      if out_time > cur_work.work_start_time then
        exit;
      else
        v_cal_time := cur_work.work_start_time;
      end if;
    end loop;
    <<firstloop>>
    return out_time;
  END USF_GET_PRE_WORKTIME;

  --****************************************************************************
  --函数名  : USF_GET_NEXT_WORKTIME
  --功能描述: 获取工厂车间某一时间点后几秒的工作时间
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  -- in_time  :输入时间
  -- in_num_offset  :  偏移秒数(正数，单位:秒)
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  FUNCTION USF_GET_NEXT_WORKTIME(in_factory_code in varchar2,
                                 in_workcenter   in varchar2,
                                 in_time         in date,
                                 in_num_offset   in number) RETURN DATE AS
    v_num_offset  number; --偏移天数
    v_cal_time    date; --此次计算时间
    v_s_rest_time date; --开始休息时间
    v_e_rest_time date; --结束休息时间
    out_time      date; --计算后时间
  BEGIN
    if in_time is null OR in_num_offset < 0 THEN
      return null;
    end if;
    --偏移秒数转化为天
    v_num_offset := in_num_offset / (24 * 3600);
    v_cal_time   := in_time;
    out_time     := v_cal_time + v_num_offset;
    --按工作日、班组顺序遍历工作日历
    for cur_work in (select a.id, a.work_start_time, a.work_end_time
                       from mm_pub_work_calendar a
                      where a.factory_code = in_factory_code
                        and a.workcenter = in_workcenter
                        and a.work_end_time > in_time
                      order by a.work_date, a.shift_code) loop
      --计算时间比开始工作时间小时,计算时间为开始工作时间
      if v_cal_time < cur_work.work_start_time then
        out_time   := cur_work.work_start_time + (out_time - v_cal_time);
        v_cal_time := cur_work.work_start_time;
      end if;
      --按休息时间先后遍历休息日历
      for cur_rest in (select start_time, end_time
                         from mm_pub_work_calendar_detail
                        where work_calendar_id = cur_work.id
                          and time_type = '1' --???类型
                          and end_time > v_cal_time
                        order by start_time) loop
        --如果开始休息时间比开始工作时间小,为开始工作时间
        if cur_rest.start_time < cur_work.work_start_time then
          v_s_rest_time := cur_work.work_start_time;
        else
          v_s_rest_time := cur_rest.start_time;
        end if;
        --如果结束休息时间比结束工作时间大，为结束工作时间
        if cur_rest.end_time > cur_work.work_end_time then
          v_e_rest_time := cur_work.work_end_time;
        else
          v_e_rest_time := cur_rest.end_time;
        end if;
        --如果计算时间位于休息时间内,计算时间为结束休息时间
        if v_cal_time >= v_s_rest_time and v_cal_time < v_e_rest_time then
          out_time   := out_time + (v_e_rest_time - v_cal_time);
          v_cal_time := v_e_rest_time;
        else
          --如果计算时间???
          if out_time > v_s_rest_time THEN
            v_cal_time := v_e_rest_time;
            out_time   := out_time + (v_e_rest_time - v_s_rest_time);
          else
            GOTO firstloop;
          end if;
        end if;
      end loop;
      --如果计算后时间位于当前的工作日内，退出
      if out_time < cur_work.work_end_time then
        exit;
      else
        v_cal_time := cur_work.work_end_time;
      end if;
    end loop;
    <<firstloop>>
    return out_time;
  END USF_GET_NEXT_WORKTIME;

  --****************************************************************************
  --函数名  : USF_GET_SYS_PARAM
  --功能描述: 获取系统参数
  --参数说明:
  -- in_factory_code  :工厂
  -- in_param_group  :参数组
  -- in_param_code  :参数代码
  --返回值  : 参数值
  --创建人员: wxl
  --创建时间: 2018-09-11
  --****************************************************************************
  FUNCTION USF_GET_SYS_PARAM(in_factory_code in varchar2,
                             in_param_group  in varchar2,
                             in_param_code   in varchar2) RETURN VARCHAR2 AS
    out_param_val mm_pub_sys_param.param_val%type;
  BEGIN
    for cur_param in (select a.param_val
                        from mm_pub_sys_param a
                       where a.factory_code = in_factory_code
                         and a.param_group = in_param_group
                         and a.param_code = in_param_code) loop
      out_param_val := cur_param.param_val;
      exit;
    end loop;
  
    return out_param_val;
  END USF_GET_SYS_PARAM;

  --****************************************************************************
  --方法名 : USF_GET_DICT
  --功能描述: 拉动计算车辆报废重投处理
  --输入参数:
  -- in_factory_code  :工厂代码
  -- in_code_type  :数据字典类型
  -- in_code_value  :数据字典代码
  --输出参数 : 数据字典名称
  --创建人员: wxl
  --创建时间: 2018-12-04
  --****************************************************************************
  FUNCTION USF_GET_DICT(in_factory_code in varchar2,
                        in_code_type    in varchar2,
                        in_code_value   in varchar2) RETURN VARCHAR2 AS
    out_code_value_name mm_pub_data_dict.code_value_name%type;
  BEGIN
    for cur_dict in (select a.code_value_name
                       from mm_pub_data_dict a
                      where a.factory_code = in_factory_code
                        and a.code_type = in_code_type
                        and a.code_value = in_code_value) loop
      out_code_value_name := cur_dict.code_value_name;
      exit;
    end loop;
  
    return out_code_value_name;
  END USF_GET_DICT;

  --****************************************************************************
  --函数名  : USF_GET_ORDER_NO
  --功能描述: 获取物流订单号
  --参数说明:
  -- in_plan_code  :信息点
  --返回值  : 物流订单号
  --创建人员: wxl
  --创建时间: 2018-09-13
  --修改记录：
  --          调整单据前缀、单据流水表结构 mod by wxl 20190128
  --****************************************************************************
  FUNCTION USF_GET_ORDER_NO(in_plan_code in varchar2) RETURN VARCHAR2 AS
    v_curr_time      date; --当前时间
    v_bill_prefix_id mm_pub_bill_prefix.id%type; --单据前缀ID
    v_factory_str    varchar2(1); --工厂
    v_order_str      varchar2(1); --单据代码
    v_year_str       varchar2(2); --年
    v_month_str      varchar(2); --月
    v_day_str        varchar(2); --日
    v_order_pre      varchar(7); --订单前缀：工厂1||单据代码1||年2||月1||日1
    v_seq_pre        varchar(4); --流水前缀
    v_seq_no         number(4); --数字流水
    v_seq_length     number(3); --流水位数
    v_seq_str        varchar(4); --流水号
    v_str            varchar(1); --单字符
    v_i              number; --临时计数
    v_flag           number; --临时标识
    out_order_no     varchar2(10); --订单前缀||流水3
  BEGIN
    v_curr_time := to_date(to_char(sysdate, 'yyyy-mm-dd'), 'yyyy-mm-dd');
  
    --获取工厂、订单前缀
    for cur_config in (select a.id,
                              a.factory_code_str,
                              a.bill_group_type_str
                         from mm_pub_bill_prefix a, mm_pub_plan_code b
                        where a.bill_group = 'ORDER'
                          and a.plan_code = b.plan_code
                          and a.plan_code = in_plan_code) loop
      v_bill_prefix_id := cur_config.id;
      v_factory_str    := cur_config.factory_code_str;
      v_order_str      := cur_config.bill_group_type_str;
    end loop;
    if v_bill_prefix_id is null then
      return out_order_no;
    end if;
  
    v_year_str  := to_char(v_curr_time, 'yy');
    v_month_str := to_number(to_char(v_curr_time, 'mm'));
    if v_month_str = 10 then
      v_month_str := 'X';
    elsif v_month_str = 11 then
      v_month_str := 'Y';
    elsif v_month_str = 12 then
      v_month_str := 'Z';
    end if;
    v_day_str   := to_char(v_curr_time, 'dd');
    v_order_pre := v_factory_str || v_order_str || v_year_str ||
                   v_month_str || v_day_str;
  
    --获取订单流水号
    select count(*)
      into v_flag
      from mm_pub_bill_sn a
     where a.bill_prefix_id = v_bill_prefix_id
       and a.bill_pre_str = v_order_pre
       and a.use_date = v_curr_time;
    if v_flag = 0 then
      v_seq_no  := 1;
      v_seq_str := lpad(1, 3, '0');
      --新增订单流水记录
      insert into mm_pub_bill_sn
        (bill_prefix_id, bill_pre_str, use_date, seq_pre_str, seq_no)
      values
        (v_bill_prefix_id, v_order_pre, v_curr_time, v_seq_pre, v_seq_no);
    else
      select a.seq_pre_str, a.seq_no + 1
        into v_seq_pre, v_seq_no
        from mm_pub_bill_sn a
       where a.bill_prefix_id = v_bill_prefix_id
         and a.bill_pre_str = v_order_pre
         and a.use_date = v_curr_time;
      if (v_seq_pre is null) then
        v_seq_length := 3;
      else
        --获取数字流水位数
        v_seq_length := 3 - length(v_seq_pre);
      end if;
      --判断数字流水是否超出
      if length(v_seq_no) <= v_seq_length then
        v_seq_str := v_seq_pre || lpad(v_seq_no, v_seq_length, '0');
      else
        v_i := length(v_seq_pre);
        if v_i is null then
          v_i := 1;
        end if;
        while v_i >= 1 loop
          --获取流水前缀最后一位字符
          v_str := substr(v_seq_pre, v_i, 1);
          if v_str is null or v_str = 'Z' then
            if v_i = 1 then
              --已有前缀位已用完
              if length(v_seq_pre) is null then
                v_seq_pre := lpad('A', 1, 'A');
              else
                v_seq_pre := lpad('A', length(v_seq_pre) + 1, 'A');
              end if;
            else
              v_seq_pre := substr(v_seq_pre, 0, length(v_seq_pre) - 1) || 'A';
            end if;
            v_i := v_i - 1;
          else
            v_seq_pre := substr(v_seq_pre, 0, v_i - 1) ||
                         chr(ascii(v_str) + 1) ||
                         substr(v_seq_pre, v_i + 1, length(v_seq_pre));
            exit;
          end if;
        end loop;
        v_seq_length := 3 - length(v_seq_pre);
        v_seq_no     := 1;
        v_seq_str    := v_seq_pre || lpad(v_seq_no, v_seq_length, '0');
      end if;
      if length(v_seq_str) > 3 then
        return null;
      end if;
      --更新订单流水记录
      update mm_pub_bill_sn a
         set a.seq_pre_str = v_seq_pre, a.seq_no = v_seq_no
       where a.bill_prefix_id = v_bill_prefix_id
         and a.bill_pre_str = v_order_pre
         and a.use_date = v_curr_time;
    end if;
    --生成订单号
    out_order_no := v_order_pre || v_seq_str;
  
    return out_order_no;
  END USF_GET_ORDER_NO;

  --****************************************************************************
  --函数名  : USF_GET_ORDER_NO_BY_DATE
  --功能描述: 获取物流订单号
  --参数说明:
  -- in_factory_code  :工厂
  -- in_order_type  :订单类型：
  --SW 取货订单    M
  --EXC 例外订单    E
  --TRIAL 新车型订单 N
  --JISO同步订单    C
  --JIT 拉动订单   D-H
  -- in_arrive_date: 到货时间
  --返回值  : 物流订单号
  --创建人员: wy
  --创建时间: 2018-09-17
  FUNCTION USF_GET_ORDER_NO_BY_DATE(in_factory_code in varchar2,
                                    in_order_type   in varchar2,
                                    in_arrive_date  in date) RETURN VARCHAR2 AS
    v_curr_time      date; --当前时间
    v_bill_prefix_id mm_pub_bill_prefix.id%type; --单据前缀ID
    v_factory_str    varchar2(1); --工厂
    v_order_str      varchar2(1); --订单
    v_year_str       varchar2(2); --年
    v_month_str      varchar2(2); --月
    v_day_str        varchar(2); --日
    v_order_pre      varchar(7); --订单前缀
    v_seq_pre        varchar(4); --流水前缀
    v_seq_no         number(4); --数字流水
    v_seq_length     number(3); --流水位数
    v_seq_str        varchar(4); --流水号
    v_str            varchar(1); --单字符
    v_i              number;
    v_flag           number; --临时标识
    out_order_no     varchar2(10);
  BEGIN
    v_curr_time := to_date(to_char(in_arrive_date, 'yyyy-mm-dd'),
                           'yyyy-mm-dd');
  
    --获取工厂、订单前缀
    for cur_config in (select a.id,
                              a.factory_code_str,
                              a.bill_group_type_str
                         from mm_pub_bill_prefix a
                        where a.bill_group = 'ORDER'
                          and a.factory_code = in_factory_code
                          and a.bill_group_type = in_order_type) loop
      v_bill_prefix_id := cur_config.id;
      v_factory_str    := cur_config.factory_code_str;
      v_order_str      := cur_config.bill_group_type_str;
    end loop;
    if v_factory_str is null or v_order_str is null then
      return out_order_no;
    end if;
  
    v_year_str := to_char(v_curr_time, 'yy');
  
    v_month_str := to_number(to_char(v_curr_time, 'mm'));
    if v_month_str = 10 then
      v_month_str := 'X';
    elsif v_month_str = 11 then
      v_month_str := 'Y';
    elsif v_month_str = 12 then
      v_month_str := 'Z';
    end if;
    v_day_str   := to_char(v_curr_time, 'dd');
    v_order_pre := v_factory_str || v_order_str || v_year_str ||
                   v_month_str || v_day_str;
  
    --获取订单流水号
    select count(*)
      into v_flag
      from mm_pub_bill_sn a
     where a.bill_prefix_id = v_bill_prefix_id
       and a.bill_pre_str = v_order_pre
       and a.use_date = v_curr_time;
    if v_flag = 0 then
      v_seq_no  := 1;
      v_seq_str := lpad(1, 3, '0');
      --新增订单流水记录
      insert into mm_pub_bill_sn
        (bill_prefix_id, bill_pre_str, use_date, seq_pre_str, seq_no)
      values
        (v_bill_prefix_id, v_order_pre, v_curr_time, v_seq_pre, v_seq_no);
    else
      select a.seq_pre_str, a.seq_no + 1
        into v_seq_pre, v_seq_no
        from mm_pub_bill_sn a
       where a.bill_prefix_id = v_bill_prefix_id
         and a.bill_pre_str = v_order_pre
         and a.use_date = v_curr_time;
      if (v_seq_pre is null) then
        v_seq_length := 3;
      else
        --获取数字流水位数
        v_seq_length := 3 - length(v_seq_pre);
      end if;
      --判断数字流水是否超出
      if length(v_seq_no) <= v_seq_length then
        v_seq_str := v_seq_pre || lpad(v_seq_no, v_seq_length, '0');
      else
        v_i := length(v_seq_pre);
        if v_i is null then
          v_i := 1;
        end if;
        while v_i >= 1 loop
          --获取流水前缀最后一位字符
          v_str := substr(v_seq_pre, v_i, 1);
          if v_str is null or v_str = 'Z' then
            if v_i = 1 then
              --已有前缀位已用完
              if length(v_seq_pre) is null then
                v_seq_pre := lpad('A', 1, 'A');
              else
                v_seq_pre := lpad('A', length(v_seq_pre) + 1, 'A');
              end if;
            else
              v_seq_pre := substr(v_seq_pre, 0, length(v_seq_pre) - 1) || 'A';
            end if;
            v_i := v_i - 1;
          else
            v_seq_pre := substr(v_seq_pre, 0, v_i - 1) ||
                         chr(ascii(v_str) + 1) ||
                         substr(v_seq_pre, v_i + 1, length(v_seq_pre));
            exit;
          end if;
        end loop;
        v_seq_length := 3 - length(v_seq_pre);
        v_seq_no     := 1;
        v_seq_str    := v_seq_pre || lpad(v_seq_no, v_seq_length, '0');
      end if;
      if length(v_seq_str) > 3 then
        return null;
      end if;
      --更新订单流水记录
      update mm_pub_bill_sn a
         set a.seq_pre_str = v_seq_pre, a.seq_no = v_seq_no
       where a.bill_prefix_id = v_bill_prefix_id
         and a.bill_pre_str = v_order_pre
         and a.use_date = v_curr_time;
    end if;
    --生成订单号
    out_order_no := v_order_pre || v_seq_str;
  
    return out_order_no;
  END USF_GET_ORDER_NO_BY_DATE;

  --****************************************************************************
  --函数  : USF_GET_WORKCENTER_PRE
  --功能描述: 获取车间头
  --参数说明:
  -- in_workcenter  :车间
  --返回值: 获取车间头
  --创建人员: wxl
  --创建时间: 2019-01-18
  --****************************************************************************
  FUNCTION USF_GET_WORKCENTER_PRE(in_workcenter in varchar2) RETURN VARCHAR2 AS
    out_worcenter_pre varchar2(1);
  BEGIN
    out_worcenter_pre := SUBSTR(in_workcenter, 1, 1);
    return out_worcenter_pre;
  END USF_GET_WORKCENTER_PRE;

  --****************************************************************************
  --函数名  : USF_GET_SEQUENCE
  --功能描述: 获取数据库序列值
  --参数说明:
  -- in_seq_name    :序列名字
  --返回值  : 下一个序列值
  --创建人员: chenjq
  --创建时间: 2016-11-15
  --****************************************************************************
  FUNCTION USF_GET_SEQUENCE(in_seq_name IN VARCHAR2) RETURN NUMBER AS
    v_seq_next_val number(19); --下一个序列值
  BEGIN
    --获取下一个序列值
    v_seq_next_val := null;
    execute immediate 'SELECT ' || in_seq_name || '.nextval FROM dual'
      INTO v_seq_next_val;
    RETURN v_seq_next_val;
  END USF_GET_SEQUENCE;
  --****************************************************************************
  --函数名  : USF_GET_BATCHPROC_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取 批次-进度
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次-进度
  --创建人员: dtp
  --创建时间: 2018-10-20
  --****************************************************************************
  FUNCTION USF_GET_BATCHPROC_BY_PRODSEQNO(in_plan_code     in varchar2,
                                          in_product_seqno in number)
    RETURN VARCHAR2 AS
    out_batch_process VARCHAR2(20);
    v_batch_no        mm_mon_kb.curr_batch_no%type; --批次
    v_process_no      mm_mon_kb.curr_process_no%type; --进度
  BEGIN
    IF in_product_seqno IS NULL THEN
      out_batch_process := NULL;
    ELSE
      v_batch_no        := PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(in_plan_code,
                                                                in_product_seqno);
      v_process_no      := PKG_PUB.USF_GET_PROCESSNO_BY_PRODSEQNO(in_plan_code,
                                                                  in_product_seqno);
      out_batch_process := v_batch_no || '-' || v_process_no;
    END IF;
    return out_batch_process;
  END USF_GET_BATCHPROC_BY_PRODSEQNO;

end PKG_PUB;
/

prompt
prompt Creating package body PKG_PUB_CHECK
prompt ===================================
prompt
create or replace package body PKG_PUB_CHECK is

  --***************************************************************************
  --存储过程名：USP_PUB_ORDER_PART_CHECK
  --功能描述：订购零件基础信息导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: wangyu
  --创建时间： 2018/11/04
  PROCEDURE USP_PUB_ORDER_PART_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                     IN_VAR_USERNAME   IN VARCHAR2,
                                     IN_VAR_OPEIP      IN VARCHAR2,
                                     OUT_ERROR_FLAG    OUT VARCHAR2,
                                     OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
  BEGIN
     --判断拉动同步的零件到货仓库是否存在
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '到货仓库不存在或者不是零件仓;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.ARR_DEPOT IS NOT NULL
       AND A.LOGISTICS_MODEL IN ('JIT', 'JISO')
       AND NOT EXISTS (SELECT 1
              FROM MM_INV_WAREHOUSE B
             WHERE A.ARR_DEPOT = B.WARE_CODE
               AND B.WARE_TYPE IN('1' , '0')
               AND A.FACTORY_CODE = B.FACTORY_CODE);

    --判断取货到货仓库是否存在
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '到货仓库不存在;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.ARR_DEPOT IS NOT NULL
       AND A.LOGISTICS_MODEL = 'SW'
       AND NOT EXISTS (SELECT 1
              FROM MM_INV_WAREHOUSE B
             WHERE A.ARR_DEPOT = B.WARE_CODE
               AND B.WARE_TYPE IN ('1', '3')
               AND A.FACTORY_CODE = B.FACTORY_CODE);

                /**
                                           20190323,何工导入正式订购零件基础信息修改
                                           */
       --校验零件供应商关系是否存在
       /*UPDATE MM_PUB_PART_IMP A
          SET A.CHECK_RESULT = 0,
              A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '零件与供应商关系不存在;'
        WHERE A.IMP_UUID = IN_VAR_UUID
          AND A.IMPORT_STATUS = 0
          AND A.PART_NO IS NOT NULL
          AND A.SUPPLIER_NO IS NOT NULL
          AND NOT EXISTS
        (SELECT 1
                 FROM MM_PUB_PART_SUPPLIER B
                WHERE A.PART_NO = B.PART_NO
                  AND A.SUPPLIER_NO = B.SUPPLIER_NO
                  AND A.FACTORY_CODE = B.FACTORY_CODE);*/

    --一个零件只能有一种物流模式
    /*UPDATE MM_PUB_PART_IMP E
      SET E.CHECK_RESULT = 0,
          E.CHECK_INFO   = NVL(E.CHECK_INFO, '') || '同一个零件,车间只能存在一种物流模式;'
    WHERE E.IMP_UUID = IN_VAR_UUID
      AND E.IMPORT_STATUS = 0
      AND (EXISTS
           (SELECT 1
              FROM (SELECT C.PART_NO, C.WORKCENTER, C.FACTORY_CODE
                      FROM (SELECT B.PART_NO,
                                   B.WORKCENTER,
                                   B.FACTORY_CODE,
                                   COUNT(1) TNUM
                              FROM (SELECT A.PART_NO,
                                           A.LOGISTICS_MODEL,
                                           A.WORKCENTER,
                                           A.FACTORY_CODE
                                      FROM MM_PUB_PART_IMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                       AND A.IMPORT_STATUS = 0
                                       AND A.EFF_START < SYSDATE
                                       AND A.EFF_END > SYSDATE
                                     GROUP BY A.PART_NO,
                                              A.LOGISTICS_MODEL,
                                              A.WORKCENTER,
                                              A.FACTORY_CODE) B
                             GROUP BY B.PART_NO, B.WORKCENTER, B.FACTORY_CODE) C
                     WHERE C.TNUM > 1) D
             WHERE E.PART_NO = D.PART_NO
               AND E.WORKCENTER = D.WORKCENTER
               AND E.FACTORY_CODE = D.FACTORY_CODE) OR EXIST
           (SELECT 1
              FROM (SELECT G.PART_NO, G.WORKCENTER, G.FACTORY_CODE
                      FROM MM_PUB_PART_IMP G
                     WHERE G.EFF_START < SYSDATE
                       AND G.EFF_END > SYSDATE
                       AND G.IMP_UUID = IN_VAR_UUID
                       AND G.IMPORT_STATUS = 0
                       AND EXISTS
                     (SELECT 1
                              FROM (SELECT C.PART_NO,
                                           'SW' LOGISTICS_MODEL,
                                           C.WORKCENTER,
                                           C.FACTORY_CODE
                                      FROM MM_MP_PART C
                                     WHERE C.EFF_START < SYSDATE
                                       AND C.EFF_END > SYSDATE
                                    UNION ALL
                                    SELECT D.PART_NO,
                                           'JIT' LOGISTICS_MODEL,
                                           H.WORKCENTER,
                                           H.FACTORY_CODE
                                      FROM MM_JIT_PART D
                                      LEFT JOIN MM_PUB_PLAN_CODE H
                                        ON D.PLAN_CODE = H.PLAN_CODE
                                     WHERE D.EFF_START < SYSDATE
                                       AND D.EFF_END > SYSDATE
                                    UNION ALL
                                    SELECT E.PART_NO,
                                           'JISO' LOGISTICS_MODEL,
                                           I.WORKCENTER,
                                           I.FACTORY_CODE
                                      FROM MM_JISO_PART E
                                      LEFT JOIN MM_JISO_PARTGROUP J
                                        ON E.PARTGROUP_ID = J.ID
                                      LEFT JOIN MM_PUB_PLAN_CODE I
                                        ON J.PLAN_CODE = I.PLAN_CODE
                                     WHERE E.EFF_START < SYSDATE
                                       AND E.EFF_END > SYSDATE) F
                             WHERE G.PART_NO = F.PART_NO
                               AND G.WORKCENTER = F.WORKCENTER
                               AND G.FACTORY_CODE = F.FACTORY_CODE
                               AND G.LOGISTICS_MODEL != F.LOGISTICS_MODEL)
                       AND NOT EXISTS
                     (SELECT 1
                              FROM MM_PUB_PART_IMP M
                             WHERE G.PART_NO = M.PART_NO
                               AND G.FACTORY_CODE = M.FACTORY_CODE
                               AND G.WORKCENTER = M.WORKCENTER
                               AND G.LOGISTICS_MODEL != M.LOGISTICS_MODEL
                               AND M.EFF_END < SYSDATE)) K
             WHERE E.PART_NO = K.PART_NO
               AND E.WORKCENTER = K.WORKCENTER
               AND E.FACTORY_CODE = K.FACTORY_CODE));*/

               --卸货口和物流模式的对应关系不存在
               UPDATE MM_PUB_PART_IMP A
                  SET A.CHECK_RESULT = 0,
                      A.CHECK_INFO   = NVL(A.CHECK_INFO, '') ||
                                       '卸货口和物流模式的对应关系不存在;'
                WHERE A.IMP_UUID = IN_VAR_UUID
                  AND A.IMPORT_STATUS = 0
                  AND NOT EXISTS
                (SELECT 1
                         FROM MM_INV_UNLOAD B
                        WHERE A.LOGISTICS_MODEL = B.LOGISTICS_MODE
                          AND A.UNLOAD_PORT = B.UNLOAD_PORT
                          AND A.FACTORY_CODE = B.FACTORY_CODE);

    --一次导入的数据同一零件不能存在两种物流模式
    UPDATE MM_PUB_PART_IMP E
       SET E.CHECK_RESULT = 0,
           E.CHECK_INFO   = NVL(E.CHECK_INFO, '') || '同一个零件,车间只能存在一种物流模式;'
     WHERE E.IMP_UUID = IN_VAR_UUID
       AND E.IMPORT_STATUS = 0
       AND (EXISTS
            (SELECT 1
               FROM (SELECT C.PART_NO, C.WORKCENTER, C.FACTORY_CODE
                       FROM (SELECT B.PART_NO,
                                    B.WORKCENTER,
                                    B.FACTORY_CODE,
                                    COUNT(1) TNUM
                               FROM (SELECT A.PART_NO,
                                            A.WORKCENTER,
                                            A.LOGISTICS_MODEL,
                                            A.FACTORY_CODE
                                       FROM MM_PUB_PART_IMP A
                                      WHERE A.IMP_UUID = IN_VAR_UUID
                                        AND A.IMPORT_STATUS = 0
                                        AND A.EFF_START < SYSDATE
                                        AND A.EFF_END > SYSDATE
                                      GROUP BY A.PART_NO,
                                               A.WORKCENTER,
                                               A.LOGISTICS_MODEL,
                                               A.FACTORY_CODE) B
                              GROUP BY B.PART_NO, B.WORKCENTER, B.FACTORY_CODE) C
                      WHERE C.TNUM > 1) D
              WHERE E.PART_NO = D.PART_NO
                AND E.WORKCENTER = D.WORKCENTER
                AND E.FACTORY_CODE = D.FACTORY_CODE));

    --校验同一零件号、物流模式、车间只能对应一个卸货口
    UPDATE MM_PUB_PART_IMP E
       SET E.CHECK_RESULT = 0,
           E.CHECK_INFO   = NVL(E.CHECK_INFO, '') ||
                            '同一个零件、物流模式、车间只能对应一个卸货口;'
     WHERE E.IMP_UUID = IN_VAR_UUID
       AND E.IMPORT_STATUS = 0
       AND E.PART_NO IS NOT NULL
       AND E.LOGISTICS_MODEL IS NOT NULL
       AND E.WORKCENTER IS NOT NULL
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.PART_NO,
                           C.LOGISTICS_MODEL,
                           C.WORKCENTER,
                           C.FACTORY_CODE
                      FROM (SELECT B.PART_NO,
                                   B.LOGISTICS_MODEL,
                                   B.WORKCENTER,
                                   B.FACTORY_CODE,
                                   COUNT(1) TNUM
                              FROM (SELECT A.PART_NO,
                                           A.LOGISTICS_MODEL,
                                           A.WORKCENTER,
                                           A.UNLOAD_PORT,
                                           A.FACTORY_CODE
                                      FROM MM_PUB_PART_IMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                       AND A.IMPORT_STATUS = 0
                                     GROUP BY A.PART_NO,
                                              A.LOGISTICS_MODEL,
                                              A.WORKCENTER,
                                              A.FACTORY_CODE,
                                              A.UNLOAD_PORT) B
                             GROUP BY B.PART_NO,
                                      B.LOGISTICS_MODEL,
                                      B.WORKCENTER,
                                      B.FACTORY_CODE) C
                     WHERE C.TNUM > 1) D
             WHERE E.PART_NO = D.PART_NO
               AND E.FACTORY_CODE = D.FACTORY_CODE
               AND E.WORKCENTER = D.WORKCENTER
               AND E.LOGISTICS_MODEL = D.LOGISTICS_MODEL);

    --厂外拉动和循环取货校验同一零件编号，对应的零件简号、零件名称数值相同
    UPDATE MM_PUB_PART_IMP E
       SET E.CHECK_RESULT = 0,
           E.CHECK_INFO   = NVL(E.CHECK_INFO, '') || '同一个零件存在不同的零件简号或零件名称;'
     WHERE E.IMP_UUID = IN_VAR_UUID
       AND E.IMPORT_STATUS = 0
       AND E.LOGISTICS_MODEL != 'JISO'
       AND E.PART_NO IS NOT NULL
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.PART_NO, C.FACTORY_CODE
                      FROM (SELECT B.PART_NO, B.FACTORY_CODE, COUNT(1) TNUM
                              FROM (SELECT A.PART_NO,
                                           A.PART_SHORT_NO,
                                           A.PART_NAME,
                                           A.FACTORY_CODE
                                      FROM MM_PUB_PART_IMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                       AND A.IMPORT_STATUS = 0
                                     GROUP BY A.PART_NO,
                                              A.PART_SHORT_NO,
                                              A.PART_NAME,
                                              A.FACTORY_CODE) B
                             GROUP BY B.PART_NO, B.FACTORY_CODE) C
                     WHERE C.TNUM > 1) D
             WHERE E.PART_NO = D.PART_NO
               AND E.FACTORY_CODE = D.FACTORY_CODE);

    --检验同一出货地代码，对应的供应商代码、供应商名称数值相同
    /*UPDATE MM_PUB_PART_IMP E
       SET E.CHECK_RESULT = 0,
           E.CHECK_INFO   = NVL(E.CHECK_INFO, '') ||
                            '同一出货地存在不同的供应商代码或供应商名称;'
     WHERE E.IMP_UUID = IN_VAR_UUID
       AND E.IMPORT_STATUS = 0
       AND E.SUP_FACTORY IS NOT NULL
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.SUP_FACTORY
                      FROM (SELECT B.SUP_FACTORY, COUNT(1) TNUM
                              FROM (SELECT A.SUP_FACTORY,
                                           A.SUPPLIER_NO,
                                           A.SUPPLIER_NAME
                                      FROM MM_PUB_PART_IMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                       AND A.IMPORT_STATUS = 0
                                     GROUP BY A.SUP_FACTORY,
                                              A.SUPPLIER_NO,
                                              A.SUPPLIER_NAME) B
                             GROUP BY B.SUP_FACTORY) C
                     WHERE C.TNUM > 1) D
             WHERE E.SUP_FACTORY = D.SUP_FACTORY);*/

    --检验同一车间、零件编号，对应卸货口相同
    UPDATE MM_PUB_PART_IMP D
       SET D.CHECK_RESULT = 0,
           D.CHECK_INFO   = NVL(D.CHECK_INFO, '') || '同一车间、零件号存在不同的卸货口;'
     WHERE D.IMP_UUID = IN_VAR_UUID
       AND D.IMPORT_STATUS = 0
       AND D.WORKCENTER IS NOT NULL
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.WORKCENTER, C.PART_NO
                      FROM (SELECT B.WORKCENTER, B.PART_NO, COUNT(1) TNUM
                              FROM (SELECT A.WORKCENTER,
                                           A.PART_NO,
                                           A.UNLOAD_PORT
                                      FROM MM_PUB_PART_IMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                       AND A.IMPORT_STATUS = 0
                                     GROUP BY A.WORKCENTER,
                                              A.PART_NO,
                                              A.UNLOAD_PORT) B
                             GROUP BY B.WORKCENTER, B.PART_NO) C
                     WHERE C.TNUM > 1) E
             WHERE D.WORKCENTER = E.WORKCENTER
               AND D.PART_NO = E.PART_NO);

                   --MODIFY  20190401 只校验同步和拉动的零件
    --卸货口和该车间，到货仓库的对应关系不存在
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '卸货口和车间,到货仓库的对应关系不存在;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL IN('JISO', 'JIT')
       AND EXISTS (SELECT 1
              FROM MM_INV_UNLOAD B
             WHERE B.UNLOAD_PORT = A.UNLOAD_PORT
               AND B.FACTORY_CODE = A.FACTORY_CODE
               AND (A.WORKCENTER != B.WORK_CENTER OR
                   A.ARR_DEPOT != B.WARE_CODE));

    --一个零件只能对应一个供应商和对应的出货地
    UPDATE MM_PUB_PART_IMP D
       SET D.CHECK_RESULT = 0,
           D.CHECK_INFO   = NVL(D.CHECK_INFO, '') || '一个零件只能对应一个供应商和出货地'
     WHERE D.IMP_UUID = IN_VAR_UUID
       AND D.IMPORT_STATUS = 0
       AND D.PART_NO IS NOT NULL
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.PART_NO, C.FACTORY_CODE
                      FROM (SELECT B.PART_NO, B.FACTORY_CODE, COUNT(1) TNUM
                              FROM (SELECT A.PART_NO,
                                           A.SUPPLIER_NO,
                                           A.SUP_FACTORY,
                                           A.FACTORY_CODE
                                      FROM MM_PUB_PART_IMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                       AND A.IMPORT_STATUS = 0
                                     GROUP BY A.PART_NO,
                                              A.SUPPLIER_NO,
                                              A.SUP_FACTORY,
                                              A.FACTORY_CODE) B
                             GROUP BY B.PART_NO, B.FACTORY_CODE) C
                     WHERE C.TNUM > 1) E
             WHERE D.PART_NO = E.PART_NO
               AND D.FACTORY_CODE = E.FACTORY_CODE);

    --转换拉动信息点
    UPDATE MM_PUB_PART_IMP A
       SET A.PLAN_CODE =
           (SELECT B.PLAN_CODE
              FROM MM_PUB_PLAN_CODE B
             WHERE A.PLAN_CODE = B.PLAN_CODE_DESC
               AND B.PLAN_CODE_TYPE = 'JITO')
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'JIT';

    --转换同步信息点
    UPDATE MM_PUB_PART_IMP A
       SET A.PLAN_CODE =
           (SELECT B.PLAN_CODE
              FROM MM_PUB_PLAN_CODE B
             WHERE A.PLAN_CODE = B.PLAN_CODE_DESC
               AND B.PLAN_CODE_TYPE = 'JISO')
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'JISO';

    --校验转换过后信息点为空的数据
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '同步拉动信息点不能为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.PLAN_CODE IS NULL
       AND A.LOGISTICS_MODEL IN ('JIT', 'JISO');

    --=============================================取货处理开始=============================================

    --校验SW的EXCEL数据重复
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') ||
                            '循环取货主键冲突,零件号、供应商、出货地、计算队列、工厂必须唯一;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'SW'
       AND EXISTS (SELECT 1
              FROM (SELECT B.PART_NO,
                           B.SUPPLIER_NO,
                           B.SUP_FACTORY,
                           B.MP_UNLOAD_PORT,
                           B.FACTORY_CODE
                      FROM MM_PUB_PART_IMP B
                     WHERE B.IMP_UUID = IN_VAR_UUID
                       AND B.IMPORT_STATUS = 0
                       AND B.LOGISTICS_MODEL = 'SW'
                     GROUP BY B.PART_NO,
                              B.SUPPLIER_NO,
                              B.SUP_FACTORY,
                              B.MP_UNLOAD_PORT,
                              B.FACTORY_CODE
                    HAVING COUNT(1) > 1) C
             WHERE A.PART_NO = C.PART_NO
               AND A.SUPPLIER_NO = C.SUPPLIER_NO
               AND A.SUP_FACTORY = C.SUP_FACTORY
               AND A.MP_UNLOAD_PORT = C.MP_UNLOAD_PORT
               AND A.FACTORY_CODE = C.FACTORY_CODE);

    --同一路线,组单台套数需要一致
    UPDATE MM_PUB_PART_IMP D
       SET D.CHECK_RESULT = 0,
           D.CHECK_INFO   = NVL(D.CHECK_INFO, '') ||
                            '同一路线,组单台套数,车型,发货提前台套数需要一致;'
     WHERE D.IMP_UUID = IN_VAR_UUID
       AND D.IMPORT_STATUS = 0
       AND D.LOGISTICS_MODEL = 'SW'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.SUPPLIER_NO,
                           C.SUP_FACTORY,
                           C.MP_UNLOAD_PORT,
                           C.FACTORY_CODE
                      FROM (SELECT B.FACTORY_CODE,
                                   B.SUPPLIER_NO,
                                   B.SUP_FACTORY,
                                   B.MP_UNLOAD_PORT,
                                   COUNT(1) TNUM
                              FROM (SELECT A.FACTORY_CODE,
                                           A.SUPPLIER_NO,
                                           A.SUP_FACTORY,
                                           A.MP_UNLOAD_PORT,
                                           A.ORDER_PRODUCT_NUM,
                                           A.DELIVERY_NUM,
                                           A.MODEL_CODE
                                      FROM MM_PUB_PART_IMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                       AND A.IMPORT_STATUS = 0
                                       AND A.LOGISTICS_MODEL = 'SW'
                                     GROUP BY A.FACTORY_CODE,
                                              A.SUPPLIER_NO,
                                              A.SUP_FACTORY,
                                              A.MP_UNLOAD_PORT,
                                              A.ORDER_PRODUCT_NUM,
                                              A.DELIVERY_NUM,
                                              A.MODEL_CODE) B
                             GROUP BY B.FACTORY_CODE,
                                      B.SUPPLIER_NO,
                                      B.SUP_FACTORY,
                                      B.MP_UNLOAD_PORT) C
                     WHERE C.TNUM > 1) E
             WHERE D.MP_UNLOAD_PORT = E.MP_UNLOAD_PORT
               AND D.SUPPLIER_NO = E.SUPPLIER_NO
               AND D.SUP_FACTORY = E.SUP_FACTORY
               AND D.FACTORY_CODE = E.FACTORY_CODE);

    /*    --校验是否存在
      UPDATE MM_PUB_PART_IMP A
         SET (A.ID, A.OPE_TYPE, A.CHECK_INFO) =
             (SELECT B.ID, 'U', NVL(A.CHECK_INFO, '') || '数据已存在;'
                FROM MM_MP_PART B
               WHERE A.PART_NO = B.PART_NO
                 AND A.SUPPLIER_NO = B.SUPPLIER_NO
                 AND A.SUP_FACTORY = B.SUP_FACTORY
                 AND A.MP_UNLOAD_PORT = B.UNLOAD_PORT
                 AND A.FACTORY_CODE = B.FACTORY_CODE)
       WHERE A.IMP_UUID = IN_VAR_UUID
         AND A.IMPORT_STATUS = 0
         AND A.CHECK_RESULT = 1
         AND A.LOGISTICS_MODEL = 'SW';
    */
    --一个计算队列只能对应一个到货仓库和车间
    UPDATE MM_PUB_PART_IMP D
       SET D.CHECK_RESULT = 0,
           D.CHECK_INFO   = NVL(D.CHECK_INFO, '') || '一个计算队列只能对应一个到货仓库和车间;'
     WHERE D.IMP_UUID = IN_VAR_UUID
       AND D.IMPORT_STATUS = 0
       AND D.LOGISTICS_MODEL = 'SW'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.MP_UNLOAD_PORT
                      FROM (SELECT B.MP_UNLOAD_PORT, COUNT(1) TNUM
                              FROM (SELECT A.MP_UNLOAD_PORT,
                                           A.WORKCENTER,
                                           A.ARR_DEPOT
                                      FROM MM_PUB_PART_IMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                       AND A.IMPORT_STATUS = 0
                                       AND A.LOGISTICS_MODEL = 'SW'
                                     GROUP BY A.MP_UNLOAD_PORT,
                                              A.WORKCENTER,
                                              A.ARR_DEPOT) B
                             GROUP BY B.MP_UNLOAD_PORT) C
                     WHERE C.TNUM > 1) E
             WHERE D.MP_UNLOAD_PORT = E.MP_UNLOAD_PORT);

    --系统校验同一路线对应的车型需要一致
    UPDATE MM_PUB_PART_IMP D
       SET D.CHECK_RESULT = 0,
           D.CHECK_INFO   = NVL(D.CHECK_INFO, '') || '同一路线对应的车型需要一致;'
     WHERE D.IMP_UUID = IN_VAR_UUID
       AND D.LOGISTICS_MODEL = 'SW'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.SUPPLIER_NO, C.SUP_FACTORY, C.MP_UNLOAD_PORT
                      FROM (SELECT B.SUPPLIER_NO,
                                   B.SUP_FACTORY,
                                   B.MP_UNLOAD_PORT,
                                   COUNT(1) TNUM
                              FROM (SELECT A.SUPPLIER_NO,
                                           A.SUP_FACTORY,
                                           A.MP_UNLOAD_PORT,
                                           A.MODEL_CODE
                                      FROM MM_PUB_PART_IMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                       AND A.IMPORT_STATUS = 0
                                       AND A.LOGISTICS_MODEL = 'SW'
                                     GROUP BY A.SUPPLIER_NO,
                                              A.SUP_FACTORY,
                                              A.MP_UNLOAD_PORT,
                                              A.MODEL_CODE) B
                             GROUP BY B.SUPPLIER_NO,
                                      B.SUP_FACTORY,
                                      B.MP_UNLOAD_PORT) C
                     WHERE C.TNUM > 1) E
             WHERE D.SUPPLIER_NO = E.SUPPLIER_NO
               AND D.SUP_FACTORY = E.SUP_FACTORY
               AND D.MP_UNLOAD_PORT = E.MP_UNLOAD_PORT);

     --取货到货仓库目前必须是厂内仓库
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '取货到货仓库必须是厂内仓库;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'SW'
       AND NOT EXISTS (SELECT 1
              FROM MM_INV_WAREHOUSE B
             WHERE A.ARR_DEPOT = B.WARE_CODE
               AND A.FACTORY_CODE = B.FACTORY_CODE
               AND B.WARE_TYPE IN ('0', '1', '2', '3'));

    --=============================================取货处理结束=============================================

    --=============================================拉动处理开始=============================================

    --校验JIT的EXCEL数据重复
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') ||
                            '厂外拉动主键冲突,零件号、信息点、车型、工厂必须唯一;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'SW'
       AND EXISTS (SELECT 1
              FROM (SELECT B.PART_NO,
                           B.PLAN_CODE,
                           B.MODEL_CODE,
                           B.FACTORY_CODE
                      FROM MM_PUB_PART_IMP B
                     WHERE B.IMP_UUID = IN_VAR_UUID
                       AND B.IMPORT_STATUS = 0
                       AND B.LOGISTICS_MODEL = 'JIT'
                     GROUP BY B.PART_NO,
                              B.PLAN_CODE,
                              B.MODEL_CODE,
                              B.FACTORY_CODE
                    HAVING COUNT(1) > 1) C
             WHERE A.PART_NO = C.PART_NO
               AND A.PLAN_CODE = C.PLAN_CODE
               AND A.MODEL_CODE = C.MODEL_CODE
               AND A.FACTORY_CODE = C.FACTORY_CODE);

    --拉动检验出货仓库类别为供应商仓库，对应的出货地代码数值相同
    /*UPDATE MM_PUB_PART_IMP A
      SET A.CHECK_RESULT = 0,
          A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '出货地代码和出货仓库不一致;'
    WHERE A.IMP_UUID = IN_VAR_UUID
      AND A.IMPORT_STATUS = 0
      AND A.LOGISTICS_MODEL = 'JIT'
      AND A.SHIP_DEPOT_TYPE = 'SUP'
      AND A.SHIP_DEPOT != A.SUP_FACTORY;*/

    --校验拉动零件业务主键唯一性，零件编号、信息点字段在系统必须唯一
    /*    UPDATE MM_PUB_PART_IMP A
      SET A.CHECK_RESULT = 0,
          A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '拉动主键冲突,信息点和零件号必须唯一;'
    WHERE A.IMP_UUID = IN_VAR_UUID
      AND A.IMPORT_STATUS = 0
      AND A.LOGISTICS_MODEL = 'JIT'
      AND EXISTS
    (SELECT 1
             FROM (SELECT B.PART_NO, B.PLAN_CODE, B.MODEL_CODE
                     FROM MM_PUB_PART_IMP B
                    WHERE B.IMP_UUID = IN_VAR_UUID
                      AND B.IMPORT_STATUS = 0
                      AND B.LOGISTICS_MODEL = 'JIT'
                    GROUP BY B.PART_NO, B.PLAN_CODE, B.MODEL_CODE
                   HAVING COUNT(1) > 1) C
            WHERE A.PART_NO = C.PART_NO
              AND A.PLAN_CODE = C.PLAN_CODE
              AND A.MODEL_CODE = C.MODEL_CODE);*/

    --校验拉动车间、信息点关系是否存在，数据表，表名：MM_PUB_PLAN_CODE。
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '车间、信息点关系不存在;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'JIT'
       AND A.PLAN_CODE IS NOT NULL
       AND NOT EXISTS (SELECT 1
              FROM MM_PUB_PLAN_CODE B
             WHERE B.PLAN_CODE = A.PLAN_CODE
               AND B.WORKCENTER = A.WORKCENTER);

    --检验同一出货仓库，对应出货仓库类别数值相同
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '同一出货仓库,对应出货仓库类别不同;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'JIT'
       AND A.SHIP_DEPOT IS NOT NULL
       AND EXISTS
     (SELECT 1
              FROM (SELECT D.SHIP_DEPOT
                      FROM (SELECT C.SHIP_DEPOT, COUNT(1) TNUM
                              FROM (SELECT B.SHIP_DEPOT, B.SHIP_DEPOT_TYPE
                                      FROM MM_PUB_PART_IMP B
                                     WHERE B.IMP_UUID = IN_VAR_UUID
                                       AND B.IMPORT_STATUS = 0
                                       AND B.LOGISTICS_MODEL = 'JIT'
                                     GROUP BY B.SHIP_DEPOT, B.SHIP_DEPOT_TYPE) C
                             GROUP BY C.SHIP_DEPOT) D
                     WHERE D.TNUM > 1) E
             WHERE A.SHIP_DEPOT = E.SHIP_DEPOT);

    --拉动到货仓库必须是厂内仓库
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '拉动到货仓库必须是厂内仓库;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.ARR_DEPOT IS NOT NULL
       AND A.LOGISTICS_MODEL = 'JIT'
       AND NOT EXISTS (SELECT 1
              FROM MM_INV_WAREHOUSE B
             WHERE A.ARR_DEPOT = B.WARE_CODE
               AND A.FACTORY_CODE = B.FACTORY_CODE
               AND B.WARE_TYPE IN ('0', '1', '2'));

    --校验JIT零件的EXCEL数据重复
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') ||
                            '拉动主键冲突,零件号、信息点、车型必须唯一;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'JIT'
       AND EXISTS
     (SELECT 1
              FROM (SELECT B.PART_NO, B.PLAN_CODE, B.MODEL_CODE
                      FROM MM_PUB_PART_IMP B
                     WHERE B.IMP_UUID = IN_VAR_UUID
                       AND B.IMPORT_STATUS = 0
                       AND B.LOGISTICS_MODEL = 'JIT'
                     GROUP BY B.PART_NO, B.PLAN_CODE, B.MODEL_CODE
                    HAVING COUNT(1) > 1) C
             WHERE A.PART_NO = C.PART_NO
               AND A.PLAN_CODE = C.PLAN_CODE
               AND A.MODEL_CODE = C.MODEL_CODE);

    --校验拉动信息点是否存在
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') ||
                            '拉动信息点不存在或者维护的车间信息点关系不存在;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'JIT'
       AND (NOT EXISTS
            (SELECT 1
               FROM MM_PUB_PLAN_CODE B
              WHERE A.PLAN_CODE = B.PLAN_CODE
                AND (B.PLAN_CODE_TYPE = 'JITO' OR B.PLAN_CODE_TYPE = 'JIT')) OR
            EXISTS (SELECT 1
                      FROM MM_PUB_PLAN_CODE C
                     WHERE A.PLAN_CODE = C.PLAN_CODE
                       AND A.WORKCENTER != C.WORKCENTER));

    --校验拉动同一零件编号、信息点，对应的出货仓库、到货仓库、规格包装数、订购包装数、配送提前台套数、
    --到货提前台套数、发货提前台套数、发车提前台套数、备件提前台套数值相同
    UPDATE MM_PUB_PART_IMP D
       SET D.CHECK_RESULT = 0,
           D.CHECK_INFO   = NVL(D.CHECK_INFO, '') ||
                            '拉动同一零件号,信息点对应基础数据存在不一致;'
     WHERE D.IMP_UUID = IN_VAR_UUID
       AND D.IMPORT_STATUS = 0
       AND D.LOGISTICS_MODEL = 'JIT'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.PART_NO, C.PLAN_CODE
                      FROM (SELECT B.PART_NO, B.PLAN_CODE, COUNT(1) TNUM
                              FROM (SELECT A.PART_NO,
                                           A.PLAN_CODE,
                                           A.SHIP_DEPOT,
                                           A.ARR_DEPOT,
                                           A.STANDARD_PACKAGE,
                                           A.ORDER_PACKAGE,
                                           A.DISTRIBUTION_NUM,
                                           A.ARRIVE_NUM,
                                           A.DELIVERY_NUM,
                                           A.DISPATCH_NUM,
                                           A.PREPARE_NUM
                                      FROM MM_PUB_PART_IMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                       AND A.IMPORT_STATUS = 0
                                       AND A.LOGISTICS_MODEL = 'JIT'
                                     GROUP BY A.PART_NO,
                                              A.PLAN_CODE,
                                              A.SHIP_DEPOT,
                                              A.ARR_DEPOT,
                                              A.STANDARD_PACKAGE,
                                              A.ORDER_PACKAGE,
                                              A.DISTRIBUTION_NUM,
                                              A.ARRIVE_NUM,
                                              A.DELIVERY_NUM,
                                              A.DISPATCH_NUM,
                                              A.PREPARE_NUM) B
                             GROUP BY B.PART_NO, B.PLAN_CODE) C
                     WHERE C.TNUM > 1) E
             WHERE D.PLAN_CODE = E.PLAN_CODE
               AND D.PART_NO = E.PART_NO);

    --校验JIT组单的EXCEL数据重复
    /*    UPDATE MM_PUB_PART_IMP A
      SET A.CHECK_RESULT = 0,
          A.CHECK_INFO   = NVL(A.CHECK_INFO, '') ||
                           '校验拉动组单业务主键唯一性，信息点、出货仓库、到货仓库字段在系统必须唯一;'
    WHERE A.IMP_UUID = IN_VAR_UUID
      AND A.IMPORT_STATUS = 0
      AND A.LOGISTICS_MODEL = 'JIT'
      AND EXISTS
    (SELECT 1
             FROM (SELECT B.PLAN_CODE, B.SHIP_DEPOT, B.ARR_DEPOT
                     FROM MM_PUB_PART_IMP B
                    WHERE B.IMP_UUID = IN_VAR_UUID
                      AND B.IMPORT_STATUS = 0
                      AND B.LOGISTICS_MODEL = 'JIT'
                    GROUP BY B.PLAN_CODE, B.SHIP_DEPOT, B.ARR_DEPOT
                   HAVING COUNT(1) > 1) C
            WHERE A.PLAN_CODE = C.PLAN_CODE
              AND A.SHIP_DEPOT = C.SHIP_DEPOT
              AND A.ARR_DEPOT = C.ARR_DEPOT);*/

    --校验拉动同一信息点、出货仓库、到货仓库，对应的出货地代码、供应商代码、供应商名称、组单台套数、组单提前台套数相同
    UPDATE MM_PUB_PART_IMP D
       SET D.CHECK_RESULT = 0,
           D.CHECK_INFO   = NVL(D.CHECK_INFO, '') ||
                            '拉动信息点, 出货仓库, 到货仓库对应基础数据存在不一致;'
     WHERE D.IMP_UUID = IN_VAR_UUID
       AND D.IMPORT_STATUS = 0
       AND D.LOGISTICS_MODEL = 'JIT'
       AND D.SHIP_DEPOT_TYPE = 'SUP'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.PLAN_CODE, C.SHIP_DEPOT, C.ARR_DEPOT
                      FROM (SELECT B.PLAN_CODE,
                                   B.SHIP_DEPOT,
                                   B.ARR_DEPOT,
                                   COUNT(1) TNUM
                              FROM (SELECT A.PLAN_CODE,
                                           A.SHIP_DEPOT,
                                           A.ARR_DEPOT,
                                           A.SUP_FACTORY,
                                           A.SUPPLIER_NO,
                                           A.SUPPLIER_NAME,
                                           A.ORDER_PRODUCT_NUM,
                                           A.AHEAD_PRODUCT_NUM
                                      FROM MM_PUB_PART_IMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                       AND A.IMPORT_STATUS = 0
                                       AND A.LOGISTICS_MODEL = 'JIT'
                                       AND A.SHIP_DEPOT_TYPE = 'SUP'
                                     GROUP BY A.PLAN_CODE,
                                              A.SHIP_DEPOT,
                                              A.ARR_DEPOT,
                                              A.SUP_FACTORY,
                                              A.SUPPLIER_NO,
                                              A.SUPPLIER_NAME,
                                              A.ORDER_PRODUCT_NUM,
                                              A.AHEAD_PRODUCT_NUM) B
                             GROUP BY B.PLAN_CODE, B.SHIP_DEPOT, B.ARR_DEPOT) C
                     WHERE C.TNUM > 1) E
             WHERE D.PLAN_CODE = E.PLAN_CODE
               AND D.SHIP_DEPOT = E.SHIP_DEPOT
               AND D.ARR_DEPOT = E.ARR_DEPOT);

    --校验拉动同一信息点、出货仓库、到货仓库，对应的出货地代码、供应商代码、供应商名称、组单台套数、组单提前台套数相同
    UPDATE MM_PUB_PART_IMP D
       SET D.CHECK_RESULT = 0,
           D.CHECK_INFO   = NVL(D.CHECK_INFO, '') ||
                            '拉动信息点, 出货仓库, 到货仓库对应基础数据存在不一致;'
     WHERE D.IMP_UUID = IN_VAR_UUID
       AND D.IMPORT_STATUS = 0
       AND D.LOGISTICS_MODEL = 'JIT'
       AND D.SHIP_DEPOT_TYPE = 'WX'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.PLAN_CODE, C.SHIP_DEPOT, C.ARR_DEPOT
                      FROM (SELECT B.PLAN_CODE,
                                   B.SHIP_DEPOT,
                                   B.ARR_DEPOT,
                                   COUNT(1) TNUM
                              FROM (SELECT A.PLAN_CODE,
                                           A.SHIP_DEPOT,
                                           A.ARR_DEPOT,
                                           A.ORDER_PRODUCT_NUM,
                                           A.AHEAD_PRODUCT_NUM
                                      FROM MM_PUB_PART_IMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                       AND A.IMPORT_STATUS = 0
                                       AND A.LOGISTICS_MODEL = 'JIT'
                                       AND A.SHIP_DEPOT_TYPE = 'WX'
                                     GROUP BY A.PLAN_CODE,
                                              A.SHIP_DEPOT,
                                              A.ARR_DEPOT,
                                              A.ORDER_PRODUCT_NUM,
                                              A.AHEAD_PRODUCT_NUM) B
                             GROUP BY B.PLAN_CODE, B.SHIP_DEPOT, B.ARR_DEPOT) C
                     WHERE C.TNUM > 1) E
             WHERE D.PLAN_CODE = E.PLAN_CODE
               AND D.SHIP_DEPOT = E.SHIP_DEPOT
               AND D.ARR_DEPOT = E.ARR_DEPOT);

    --=============================================拉动处理结束=============================================

    --=============================================同步处理开始=============================================

    --厂外同步校验同一零件编号，对应的零件简号、零件名称和零件记号数值相同
    UPDATE MM_PUB_PART_IMP E
       SET E.CHECK_RESULT = 0,
           E.CHECK_INFO   = NVL(E.CHECK_INFO, '') ||
                            '同一个零件存在不同的零件记号、零件简号或零件名称;'
     WHERE E.IMP_UUID = IN_VAR_UUID
       AND E.IMPORT_STATUS = 0
       AND E.LOGISTICS_MODEL = 'JISO'
       AND E.PART_NO IS NOT NULL
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.PART_NO, C.FACTORY_CODE
                      FROM (SELECT B.PART_NO, B.FACTORY_CODE, COUNT(1) TNUM
                              FROM (SELECT A.PART_NO,
                                           A.PART_SHORT_NO,
                                           A.PART_NAME,
                                           A.PART_MARK,
                                           A.FACTORY_CODE
                                      FROM MM_PUB_PART_IMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                       AND A.IMPORT_STATUS = 0
                                     GROUP BY A.PART_NO,
                                              A.PART_SHORT_NO,
                                              A.PART_NAME,
                                              A.PART_MARK,
                                              A.FACTORY_CODE) B
                             GROUP BY B.PART_NO, B.FACTORY_CODE) C
                     WHERE C.TNUM > 1) D
             WHERE E.PART_NO = D.PART_NO
               AND E.FACTORY_CODE = D.FACTORY_CODE);

    --检验同一出货仓库，对应出货仓库类别数值相同
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '同一出货仓库，对应出货仓库类别不同;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'JISO'
       AND EXISTS
     (SELECT 1
              FROM (SELECT D.SHIP_DEPOT
                      FROM (SELECT C.SHIP_DEPOT, COUNT(1) TNUM
                              FROM (SELECT B.SHIP_DEPOT, B.SHIP_DEPOT_TYPE
                                      FROM MM_PUB_PART_IMP B
                                     WHERE B.IMP_UUID = IN_VAR_UUID
                                       AND B.IMPORT_STATUS = 0
                                       AND B.LOGISTICS_MODEL = 'JISO'
                                     GROUP BY B.SHIP_DEPOT, B.SHIP_DEPOT_TYPE) C
                             GROUP BY C.SHIP_DEPOT) D
                     WHERE D.TNUM > 1) E
             WHERE A.SHIP_DEPOT = E.SHIP_DEPOT);

    --同步到货仓库必须是厂内仓库
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '同步到货仓库必须是厂内仓库;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'JISO'
       AND NOT EXISTS (SELECT 1
              FROM MM_INV_WAREHOUSE B
             WHERE A.ARR_DEPOT = B.WARE_CODE
               AND A.FACTORY_CODE = B.FACTORY_CODE
               AND B.WARE_TYPE IN ('0', '1', '2'));

    --检验同步信息点是否存在
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '信息点不存在;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'JISO'
       AND NOT EXISTS (SELECT 1
              FROM MM_PUB_PLAN_CODE B
             WHERE A.PLAN_CODE = B.PLAN_CODE
               AND B.PLAN_CODE_TYPE = 'JISO');

    --校验同步同一信息点、零件组代码，对应的零件组名称、到货仓库、组票台套数、组单指示票数、配送提前台套数、
    --到货提前台套数、发货提前台套数、发车提前台套数、备件提前台套、是否考虑出货地切换、是否生成订单数值相同
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') ||
                            '同一信息点,零件组代码,对应基础数据存在不同;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'JISO'
       AND EXISTS
     (SELECT 1
              FROM (SELECT D.PLAN_CODE, D.PARTGROUP_NO
                      FROM (SELECT C.PLAN_CODE, C.PARTGROUP_NO, COUNT(1) TNUM
                              FROM (SELECT B.PLAN_CODE,
                                           B.PARTGROUP_NO,
                                           B.PARTGROUP_NAME,
                                           B.ARR_DEPOT,
                                           B.INS_PRODUCT_NUM,
                                           B.ORDER_INS_NUM,
                                           B.DISTRIBUTION_NUM,
                                           B.ARRIVE_NUM,
                                           B.DELIVERY_NUM,
                                           B.DISPATCH_NUM,
                                           B.PREPARE_NUM,
                                           B.GEN_INS_WAY,
                                           B.ORDER_FLG
                                      FROM MM_PUB_PART_IMP B
                                     WHERE B.IMP_UUID = IN_VAR_UUID
                                       AND B.IMPORT_STATUS = 0
                                       AND B.LOGISTICS_MODEL = 'JISO'
                                     GROUP BY B.PLAN_CODE,
                                              B.PARTGROUP_NO,
                                              B.PARTGROUP_NAME,
                                              B.ARR_DEPOT,
                                              B.INS_PRODUCT_NUM,
                                              B.ORDER_INS_NUM,
                                              B.DISTRIBUTION_NUM,
                                              B.ARRIVE_NUM,
                                              B.DELIVERY_NUM,
                                              B.DISPATCH_NUM,
                                              B.PREPARE_NUM,
                                              B.GEN_INS_WAY,
                                              B.ORDER_FLG) C
                             GROUP BY C.PLAN_CODE, C.PARTGROUP_NO) D
                     WHERE D.TNUM > 1) E
             WHERE A.PLAN_CODE = E.PLAN_CODE
               AND A.PARTGROUP_NO = E.PARTGROUP_NO);

    --检验同步同一零件组代码、出货地代码，对应的供应商代码、装车代码、装车代码描述数值相同
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') ||
                            '同一零件组代码,出货地,对应基础数据存在不同;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'JISO'
       AND EXISTS
     (SELECT 1
              FROM (SELECT D.PARTGROUP_NO, D.SUP_FACTORY
                      FROM (SELECT C.PARTGROUP_NO,
                                   C.SUP_FACTORY,
                                   COUNT(1) TNUM
                              FROM (SELECT B.PARTGROUP_NO,
                                           B.SUP_FACTORY,
                                           B.SUPPLIER_NO,
                                           B.ROUTE_CODE,
                                           B.ROUTE_DESC
                                      FROM MM_PUB_PART_IMP B
                                     WHERE B.IMP_UUID = IN_VAR_UUID
                                       AND B.IMPORT_STATUS = 0
                                       AND B.LOGISTICS_MODEL = 'JISO'
                                     GROUP BY B.PARTGROUP_NO,
                                              B.SUP_FACTORY,
                                              B.SUPPLIER_NO,
                                              B.ROUTE_CODE,
                                              B.ROUTE_DESC) C
                             GROUP BY C.PARTGROUP_NO, C.SUP_FACTORY) D
                     WHERE D.TNUM > 1) E
             WHERE A.PARTGROUP_NO = E.PARTGROUP_NO
               AND A.SUP_FACTORY = E.SUP_FACTORY);

    --检验同步同一信息点、零件组代码、零件编号，对应记号数值相同
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') ||
                            '同一零件组代码,信息点,零件号,对应基础数据存在不同;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'JISO'
       AND EXISTS
     (SELECT 1
              FROM (SELECT D.PARTGROUP_NO, D.PLAN_CODE, D.PART_NO
                      FROM (SELECT C.PLAN_CODE,
                                   C.PARTGROUP_NO,
                                   C.PART_NO,
                                   COUNT(1) TNUM
                              FROM (SELECT B.PLAN_CODE,
                                           B.PARTGROUP_NO,
                                           B.PART_NO,
                                           B.PART_MARK
                                      FROM MM_PUB_PART_IMP B
                                     WHERE B.IMP_UUID = IN_VAR_UUID
                                       AND B.IMPORT_STATUS = 0
                                       AND B.LOGISTICS_MODEL = 'JISO'
                                     GROUP BY B.PLAN_CODE,
                                              B.PARTGROUP_NO,
                                              B.PART_NO,
                                              B.PART_MARK) C
                             GROUP BY C.PLAN_CODE, C.PARTGROUP_NO, C.PART_NO) D
                     WHERE D.TNUM > 1) E
             WHERE A.PLAN_CODE = E.PLAN_CODE
               AND A.PART_NO = E.PART_NO
               AND A.PARTGROUP_NO = E.PARTGROUP_NO);

    --=============================================同步处理结束=============================================

--一个零件简号只能对应一个零件号
UPDATE MM_PUB_PART_IMP A
   SET A.CHECK_RESULT = 0,
       A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '一个零件简号只能对应一个零件号;'
 WHERE A.IMP_UUID = IN_VAR_UUID
   AND A.IMPORT_STATUS = 0
   AND A.PART_NO IS NOT NULL
   AND A.PART_SHORT_NO IS NOT NULL
   AND EXISTS (SELECT 1
          FROM (SELECT D.PART_SHORT_NO
                  FROM (SELECT B.PART_NO, B.PART_SHORT_NO
                          FROM MM_PUB_PART_IMP B
                         WHERE B.IMP_UUID = IN_VAR_UUID
                           AND B.IMPORT_STATUS = 0
                           AND B.PART_NO IS NOT NULL
                           AND B.PART_SHORT_NO IS NOT NULL
                        UNION
                        SELECT C.PART_NO, C.PART_SHORT_NO
                          FROM MM_PUB_PART_UDA C
                         WHERE C.PART_SHORT_NO IS NOT NULL) D
                 GROUP BY D.PART_SHORT_NO
                HAVING COUNT(1) > 1) E
         WHERE A.PART_SHORT_NO = E.PART_SHORT_NO);

    --检验取货零件基础数据是否已存在
    MERGE INTO MM_PUB_PART_IMP A
    USING (SELECT C.PK_ID, B.ID
             FROM MM_MP_PART B, MM_PUB_PART_IMP C
            WHERE C.CHECK_RESULT = 1
              AND C.IMP_UUID = IN_VAR_UUID
              AND C.IMPORT_STATUS = 0
              AND C.LOGISTICS_MODEL = 'SW'
              AND C.FACTORY_CODE = B.FACTORY_CODE
              AND C.SUPPLIER_NO = B.SUPPLIER_NO
              AND C.SUP_FACTORY = B.SUP_FACTORY
              AND C.MP_UNLOAD_PORT = B.UNLOAD_PORT
              AND C.PART_NO = B.PART_NO) D
    ON (A.PK_ID = D.PK_ID AND A.IMP_UUID = IN_VAR_UUID)
    WHEN MATCHED THEN
      UPDATE
         SET A.ID         = D.ID,
             A.OPE_TYPE   = 'U',
             A.CHECK_INFO = A.CHECK_INFO || '取货零件数据已存在;';

    --循环取货的数据导入的计算队列存在而对应的到货仓库或者车间不同的数据需要更新为当前导入的车间和到货仓库
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_INFO = NVL(A.CHECK_INFO, '') || '将会更新该计算队列的车间和到货仓库;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.CHECK_RESULT = 1
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL = 'SW'
       AND EXISTS (SELECT 1
              FROM MM_MP_PART B
             WHERE A.FACTORY_CODE = B.FACTORY_CODE
               AND A.MP_UNLOAD_PORT = B.UNLOAD_PORT
               AND (A.WORKCENTER != B.WORKCENTER OR
                   A.ARR_DEPOT != B.ORDER_DEPOT));

    --检验拉动零件基础数据是否已存在
    MERGE INTO MM_PUB_PART_IMP A
    USING (SELECT C.PK_ID, B.ID
             FROM MM_JIT_PART B, MM_PUB_PART_IMP C
            WHERE C.CHECK_RESULT = 1
              AND C.IMP_UUID = IN_VAR_UUID
              AND C.IMPORT_STATUS = 0
              AND C.LOGISTICS_MODEL = 'JIT'
              AND C.PLAN_CODE = B.PLAN_CODE
              AND C.PART_NO = B.PART_NO
              AND C.MODEL_CODE = B.MODEL_CODE) D
    ON (A.PK_ID = D.PK_ID AND A.IMP_UUID = IN_VAR_UUID)
    WHEN MATCHED THEN
      UPDATE
         SET A.ID         = D.ID,
             A.OPE_TYPE   = 'U',
             A.CHECK_INFO = A.CHECK_INFO || '拉动零件数据已存在;';

    --检验拉动组单基础数据是否已存在
    MERGE INTO MM_PUB_PART_IMP A
    USING (SELECT DISTINCT C.PK_ID
             FROM MM_JIT_ORDER B, MM_PUB_PART_IMP C
            WHERE C.CHECK_RESULT = 1
              AND C.IMP_UUID = IN_VAR_UUID
              AND C.IMPORT_STATUS = 0
              AND C.LOGISTICS_MODEL = 'JIT'
              AND C.PLAN_CODE = B.PLAN_CODE
              AND C.SHIP_DEPOT = B.SHIP_DEPOT
              AND C.ARR_DEPOT = B.ARR_DEPOT) D
    ON (A.PK_ID = D.PK_ID AND A.IMP_UUID = IN_VAR_UUID)
    WHEN MATCHED THEN
      UPDATE
         SET A.OPE_TYPE   = 'U',
             A.CHECK_INFO = A.CHECK_INFO || '拉动组单数据已存在;';

    --检验同步零件基础数据是否已存在
    MERGE INTO MM_PUB_PART_IMP A
    USING (SELECT C.PK_ID, B.ID
             FROM MM_JISO_PART B, MM_PUB_PART_IMP C
             LEFT JOIN MM_JISO_PARTGROUP E
               ON E.PLAN_CODE = C.PLAN_CODE
              AND E.PARTGROUP_NO = C.PARTGROUP_NO
            WHERE C.CHECK_RESULT = 1
              AND C.IMP_UUID = IN_VAR_UUID
              AND C.IMPORT_STATUS = 0
              AND C.LOGISTICS_MODEL = 'JISO'
              AND C.PART_NO = B.PART_NO
              AND E.ID = B.PARTGROUP_ID
              AND C.MODEL_CODE = B.MODEL_CODE) D
    ON (A.PK_ID = D.PK_ID AND A.IMP_UUID = IN_VAR_UUID)
    WHEN MATCHED THEN
      UPDATE
         SET A.ID         = D.ID,
             A.OPE_TYPE   = 'U',
             A.CHECK_INFO = A.CHECK_INFO || '同步零件数据已存在;';

    --检验同步零件组基础数据是否已存在
    MERGE INTO MM_PUB_PART_IMP A
    USING (SELECT DISTINCT C.PK_ID
             FROM MM_JISO_PARTGROUP B, MM_PUB_PART_IMP C
            WHERE C.CHECK_RESULT = 1
              AND C.IMP_UUID = IN_VAR_UUID
              AND C.IMPORT_STATUS = 0
              AND C.LOGISTICS_MODEL = 'JISO'
              AND C.PLAN_CODE = B.PLAN_CODE
              AND C.PARTGROUP_NO = B.PARTGROUP_NO) D
    ON (A.PK_ID = D.PK_ID AND A.IMP_UUID = IN_VAR_UUID)
    WHEN MATCHED THEN
      UPDATE
         SET A.OPE_TYPE   = 'U',
             A.CHECK_INFO = A.CHECK_INFO || '同步零件组数据已存在;';

    --检验同步零件组路线基础数据是否已存在
    MERGE INTO MM_PUB_PART_IMP A
    USING (SELECT DISTINCT C.PK_ID
             FROM MM_JISO_PARTGROUP_ROUTE B, MM_PUB_PART_IMP C
             LEFT JOIN MM_JISO_PARTGROUP E
               ON E.PLAN_CODE = C.PLAN_CODE
              AND E.PARTGROUP_NO = C.PARTGROUP_NO
            WHERE C.CHECK_RESULT = 1
              AND C.IMP_UUID = IN_VAR_UUID
              AND C.IMPORT_STATUS = 0
              AND C.LOGISTICS_MODEL = 'JISO'
              AND C.SUP_FACTORY = B.SUP_FACTORY
              AND E.ID = B.PARTGROUP_ID) D
    ON (A.PK_ID = D.PK_ID AND A.IMP_UUID = IN_VAR_UUID)
    WHEN MATCHED THEN
      UPDATE
         SET A.OPE_TYPE   = 'U',
             A.CHECK_INFO = A.CHECK_INFO || '同步零件组路线数据已存在;';

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

    /*--校验通过，判断非同步的零件是否存在于同步零件中
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_INFO = '同步物流模式更新;', A.OPE_TYPE = 'M'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.CHECK_RESULT = 1
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL != 'JISO'
       AND EXISTS (SELECT 1
              FROM MM_JISO_PART B
              LEFT JOIN MM_JISO_PARTGROUP C
                ON B.PARTGROUP_ID = C.ID
              LEFT JOIN MM_PUB_PLAN_CODE D
                ON C.PLAN_CODE = D.PLAN_CODE
             WHERE A.PART_NO = B.PART_NO
               AND A.WORKCENTER = D.WORKCENTER
               AND A.FACTORY_CODE = D.FACTORY_CODE);

    --校验通过，判断非拉动的零件是否存在于拉动零件中
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_INFO = '拉动物流模式更新;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.CHECK_RESULT = 1
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL != 'JIT'
       AND EXISTS (SELECT 1
              FROM MM_JIT_PART B
              LEFT JOIN MM_PUB_PLAN_CODE C
                ON B.PLAN_CODE = C.PLAN_CODE
             WHERE A.PART_NO = B.PART_NO
               AND A.WORKCENTER = C.WORKCENTER
               AND A.FACTORY_CODE = C.FACTORY_CODE);

    --校验通过，判断非取货的零件是否存在于取货零件中
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_INFO = '取货物流模式更新;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.CHECK_RESULT = 1
       AND A.IMPORT_STATUS = 0
       AND A.LOGISTICS_MODEL != 'SW'
       AND EXISTS (SELECT 1
              FROM MM_MP_PART B
             WHERE A.PART_NO = B.PART_NO
               AND A.WORKCENTER = B.WORKCENTER
               AND A.FACTORY_CODE = D.FACTORY_CODE);*/

    --根据MM_PUB_PART_UNLOAD判断零件物流模式是否变更
    UPDATE MM_PUB_PART_IMP A
       SET A.CHECK_INFO = A.CHECK_INFO || '物流模式更新;', A.OPE_TYPE = 'M'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.CHECK_RESULT = 1
       AND A.IMPORT_STATUS = 0
       AND EXISTS (SELECT 1
              FROM MM_PUB_PART_UNLOAD B
             WHERE A.PART_NO = B.PART_NO
               AND A.WORKCENTER = B.WORKCENTER
               AND A.LOGISTICS_MODEL != B.LOGISTICS_MODEL
               AND A.FACTORY_CODE = B.FACTORY_CODE);
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_PUB_ORDER_PART_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_PUB_ORDER_PART_CHECK;
  --***************************************************************************
  --存储过程名：USP_SPSCONFIG_IMPORT_CHECK
  --功能描述：SPS配置项明细导入校验
  --参数说明：
  --IN_VAR_UUID
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: zmj
  --创建时间： 2018/11/09
  PROCEDURE USP_SPSCONFIG_IMPORT_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                       OUT_ERROR_FLAG    OUT VARCHAR2,
                                       OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
  BEGIN
    --校验配置项代码是否存在
    UPDATE MM_SPS_CONFIG_DETAIL_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '配置项代码不存在;'
     WHERE NOT EXISTS (SELECT 1
              FROM MM_SPS_CONFIG B
             WHERE A.CONFIG_CODE = B.CONFIG_CODE
               AND A.FACTORY_CODE = B.FACTORY_CODE
               AND A.PRODUCTION_LINE = B.PRODUCTION_LINE)
       AND A.IMP_UUID = IN_VAR_UUID;

    --校验零件编号是否存在
   UPDATE MM_SPS_CONFIG_DETAIL_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '零件编号不存在;'
     WHERE NOT EXISTS
     --i-LMS2019053001 mod by dtp
     (SELECT 1 FROM MM_PUB_PART B WHERE A.PART_NO = B.PART_NO AND B.FACTORY_CODE = A.FACTORY_CODE)
       AND A.IMP_UUID = IN_VAR_UUID;

    --EXCEL是否重复
    update MM_SPS_CONFIG_DETAIL_IMP siglt
       set siglt.check_result = '0',
           siglt.check_info  =
           (nvl(siglt.check_info, '') || 'Excel数据重复;')
     where siglt.id in (select distinct T.id
                          from MM_SPS_CONFIG_DETAIL_IMP t,
                               (select CONFIG_CODE,
                                       STATION_CODE,
                                       PART_NO,
                                       MODEL_CODE,
                                       PART_MARK,
                                       SHELF_NO
                                  from (select count(*) count,
                                               siglt.CONFIG_CODE,
                                               siglt.STATION_CODE,
                                               siglt.PART_NO,
                                               siglt.MODEL_CODE,
                                               siglt.PART_MARK,
                                               siglt.SHELF_NO
                                          from MM_SPS_CONFIG_DETAIL_IMP siglt
                                         where siglt.imp_uuid = in_var_uuid
                                           and siglt.import_status = '0'
                                         group by siglt.CONFIG_CODE,
                                                  siglt.STATION_CODE,
                                                  siglt.PART_NO,
                                                  siglt.MODEL_CODE,
                                                  siglt.PART_MARK,
                                                  siglt.SHELF_NO)
                                 where count > 1) b
                         where t.CONFIG_CODE = b.CONFIG_CODE
                           and t.STATION_CODE = b.STATION_CODE
                           and t.PART_NO = b.PART_NO
                           and t.MODEL_CODE = b.MODEL_CODE
                           and t.SHELF_NO = b.SHELF_NO);

    --校验数据在详细表是否存在
    update MM_SPS_CONFIG_DETAIL_IMP t
       set t.check_result = '2'
           ,t.check_info  =
           (nvl(t.check_info, '') || '数据已存在;')
     where t.id in (select distinct siglt.id
                      from MM_SPS_CONFIG_DETAIL_IMP siglt
                     inner join MM_SPS_CONFIG_DETAIL sigld
                        on siglt.MODEL_CODE = sigld.MODEL_CODE
                       --and siglt.STATION_CODE = sigld.STATION_CODE
                       and siglt.PART_NO = sigld.PART_NO
                       and sigld.config_id = (select d.id
                           from mm_sps_config d where d.config_code = siglt.config_code )
                     where siglt.imp_uuid = IN_VAR_UUID
                       and siglt.import_status = '0'
                       and siglt.id is not null);

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_PUB_CHECK.USP_SPSCONFIG_IMPORT_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END USP_SPSCONFIG_IMPORT_CHECK;
  --***************************************************************************
  --存储过程名：USP_JIT_PART_REMAIN_CHECK
  --功能描述：零件余量批量导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: dtp
  --创建时间： 2018/10/12
  PROCEDURE USP_JIT_PART_REMAIN_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                      IN_VAR_USERNAME   IN VARCHAR2,
                                      IN_VAR_OPEIP      IN VARCHAR2,
                                      OUT_ERROR_FLAG    OUT VARCHAR2,
                                      OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
    v_row_num number(10);
  BEGIN
    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';
    --信息点不存在
    update mm_jit_part_remain_imp imp
       set imp.check_result = '0',
           imp.check_info   = nvl(imp.check_info, '') || '信息点不存在;'
     where not exists (select 1
              from mm_pub_plan_code c
             where c.plan_code = imp.plan_code)
       and imp.check_info not like '%信息点不存在%'
       and imp.imp_uuid = IN_VAR_UUID;
     --零件在系统不存在
    update mm_jit_part_remain_imp imp
       set imp.check_result = '0',
           imp.check_info   = nvl(imp.check_info, '') || '零件在系统不存在;'
     where not exists (select 1
              from mm_pub_part t
             where t.part_no = imp.part_no)
       and imp.imp_uuid = IN_VAR_UUID;
    --EXCEL是否重复
    update mm_jit_part_remain_imp siglt
       set siglt.check_result = '0',
           siglt.check_info  =
           (nvl(siglt.check_info, '') || 'Excel数据重复;')
     where siglt.id in (select distinct t.id
                          from mm_jit_part_remain_imp t,
                               (select plan_code, location, part_no
                                  from (select count(*) count,
                                               siglt.plan_code,
                                               siglt.location,
                                               siglt.part_no
                                          from mm_jit_part_remain_imp siglt
                                         where siglt.imp_uuid = IN_VAR_UUID
                                           and siglt.import_status = '0'
                                         group by siglt.plan_code,
                                                  siglt.location,
                                                  siglt.part_no)
                                 where count > 1) b
                         where t.plan_code = b.plan_code
                           and t.location = b.location
                           and t.part_no = b.part_no);
    --校验数据在主表是否存在
/*    update mm_jit_part_remain_imp t
       set t.check_result = '0',
           t.check_info  =
           (nvl(t.check_info, '') || '数据已存在;')
     where t.id in (select distinct siglt.id
                      from mm_jit_part_remain_imp siglt
                     inner join mm_jit_part_remain sigl
                        on sigl.plan_code = siglt.plan_code
                       and sigl.location = siglt.location
                       and sigl.part_no = siglt.part_no
                     where siglt.imp_uuid = IN_VAR_UUID
                       and siglt.import_status = '0'
                       and siglt.id is not null);*/
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_IMP_DEMO.USP_DEMO_TEST',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_JIT_PART_REMAIN_CHECK;
  --***************************************************************************
  --存储过程名：USP_SPS_CONFIG_ITEM_CHECK
  --功能描述：SPS配置项维护导入校验
  --参数说明：
  --IN_VAR_UUID
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: dtp
  --创建时间： 2018/12/17
  PROCEDURE USP_SPS_CONFIG_ITEM_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                      OUT_ERROR_FLAG    OUT VARCHAR2,
                                      OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
  BEGIN
    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';
    --EXCEL是否重复
    update mm_sps_config_imp siglt
       set siglt.check_result = '0',
           siglt.check_info  =
           (nvl(siglt.check_info, '') || 'EXCEL数据重复;')
     where siglt.id in (select distinct t.id
                          from mm_sps_config_imp t,
                               (select config_code, config_desc, config_type
                                  from (select count(*) count,
                                               tt.config_code,
                                               tt.config_desc,
                                               tt.config_type
                                          from mm_sps_config_imp tt
                                         where tt.imp_uuid = IN_VAR_UUID
                                           and tt.import_status = '0'
                                         group by tt.config_code,
                                                  tt.config_desc,
                                                  tt.config_type)
                                 where count > 1) b
                         where t.config_code = b.config_code
                           and t.config_desc = b.config_desc
                           and t.config_type = b.config_type);
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_IMP_DEMO.USP_DEMO_TEST',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_SPS_CONFIG_ITEM_CHECK;
  --***************************************************************************
  --存储过程名：USP_MM_SPS_MOULD_CONFIG_CHECK
  --功能描述：SPS票据模板配置导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: dtp
  --创建时间： 2018/10/12
  PROCEDURE USP_MM_SPS_MOULD_CONFIG_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                          IN_VAR_USERNAME   IN VARCHAR2,
                                          IN_VAR_OPEIP      IN VARCHAR2,
                                          OUT_ERROR_FLAG    OUT VARCHAR2,
                                          OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
    v_row_num number(10);
  BEGIN
    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';
    --EXCEL是否重复
    update mm_sps_mould_config_imp imp
       set imp.check_result = '0',
           imp.check_info   = （nvl(imp.check_info, '') || 'Excel数据重复;' ）
     where imp.id in (select distinct t.id
                        from mm_sps_mould_config t,
                             (select mould_place, config_code, config_show
                                from (select count(*) count,
                                             tt.mould_place,
                                             tt.config_code,
                                             tt.config_show
                                        from mm_sps_mould_config_imp tt
                                       where tt.imp_uuid = IN_VAR_UUID
                                         and tt.import_status = '0'
                                       group by tt.mould_place,
                                                tt.config_code,
                                                tt.config_show)
                               where count > 1) b
                       where b.mould_place = t.mould_place
                         and b.config_code = t.config_code
                         and b.config_show = t.config_show);
   --检查数据是否存在
   update mm_sps_mould_config_imp t
      set t.check_result = '0',
          t.check_info =
          (nvl(t.check_info, '') || '数据已存在;')
    where t.id in (select distinct imp.id
                     from mm_sps_mould_config_imp imp
                    inner join mm_sps_mould_config tt
                       on tt.config_code = imp.config_code
                      and tt.mould_place = imp.mould_place
                      and tt.mould_id = imp.mould_id
                    where imp.imp_uuid = IN_VAR_UUID
                      AND imp.import_status = '0'
                      AND imp.id is not null);
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_IMP_DEMO.USP_DEMO_TEST',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_MM_SPS_MOULD_CONFIG_CHECK;
  --***************************************************************************

  --存储过程名：USP_MM_SPS_SHELF_LABEL_CHECK
  --功能描述：SPS货架标签打印导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: dtp
  --创建时间： 2018/10/12
  PROCEDURE USP_MM_SPS_SHELF_LABEL_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                         IN_VAR_USERNAME   IN VARCHAR2,
                                         IN_VAR_OPEIP      IN VARCHAR2,
                                         OUT_ERROR_FLAG    OUT VARCHAR2,
                                         OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
  BEGIN
    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';
    --零件编号、货架号关系是否存在
    update mm_sps_shelf_lable_imp imp
      set imp.check_result = '0',
          imp.check_info  =
          (nvl(imp.check_info, '') || '零件与货架号关系在系统不存在;')
    where not exists (select 1
             from mm_inv_part_location t
            where t.part_no = imp.part_no
              and t.shelf_no = imp.shelf_no)
      and imp.imp_uuid = IN_VAR_UUID;

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_IMP_DEMO.USP_DEMO_TEST',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_MM_SPS_SHELF_LABEL_CHECK;
  --***************************************************************************
  --存储过程名：USP_MM_INV_PART_LOCATION_CHECK
  --功能描述：零件属地导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: dtp
  --创建时间： 2019/02/20
  PROCEDURE USP_MM_INV_PART_LOCATION_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                           IN_VAR_USERNAME   IN VARCHAR2,
                                           IN_VAR_OPEIP      IN VARCHAR2,
                                           OUT_ERROR_FLAG    OUT VARCHAR2,
                                           OUT_OUT_ERROR_MSG OUT VARCHAR2)  IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
  BEGIN
    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';
    --Excel数据重复
  UPDATE MM_INV_PART_LOCATION_TEMP IMP
   SET IMP.CHECK_RESULT = '0',
       IMP.CHECK_INFO  =
       (nvl(imp.check_info, '') || 'Excel数据重复;')
       WHERE IMP.ID IN (
                  SELECT DISTINCT TTTT.ID
                    FROM MM_INV_PART_LOCATION_TEMP TTTT,
                          (SELECT TT.OLD_PART_NO,
                                  TT.OLD_SUPPLIER_NO,
                                  TT.OLD_REPARE_PERSON,
                                  TT.OLD_CARPOOL,
                                  TT.OLD_STORAGE,
                                  TT.OLD_DISTRI_PERSON,
                                  TT.OLD_LOCATION,
                                  TT.OLD_STATION_CODE,
                                  TT.OLD_SHELF_NO,
                                  TT.OLD_LOCATION_NUM,
                                  TT.OLD_DEPT_NO,
                                  TT.NEW_UNLOAD_PORT,
                                  TT.NEW_SUPPLIER_NO,
                                  TT.NEW_PART_NO,
                                  TT.NEW_REPARE_PERSON,
                                  TT.NEW_CARPOOL,
                                  TT.NEW_STORAGE,
                                  TT.NEW_DISTRI_PERSON,
                                  TT.NEW_LOCATION,
                                  TT.NEW_STATION_CODE,
                                  TT.NEW_SHELF_NO,
                                  TT.NEW_LOCATION_NUM,
                                  TT.NEW_DEPT_NO,
                                  TT.MODEL_CODE
                             FROM (SELECT COUNT(*) COUNT,
                                          T.OLD_PART_NO,
                                          T.OLD_SUPPLIER_NO,
                                          T.OLD_REPARE_PERSON,
                                          T.OLD_CARPOOL,
                                          T.OLD_STORAGE,
                                          T.OLD_DISTRI_PERSON,
                                          T.OLD_LOCATION,
                                          T.OLD_STATION_CODE,
                                          T.OLD_SHELF_NO,
                                          T.OLD_LOCATION_NUM,
                                          T.OLD_DEPT_NO,
                                          T.NEW_UNLOAD_PORT,
                                          T.NEW_SUPPLIER_NO,
                                          T.NEW_PART_NO,
                                          T.NEW_REPARE_PERSON,
                                          T.NEW_CARPOOL,
                                          T.NEW_STORAGE,
                                          T.NEW_DISTRI_PERSON,
                                          T.NEW_LOCATION,
                                          T.NEW_STATION_CODE,
                                          T.NEW_SHELF_NO,
                                          T.NEW_LOCATION_NUM,
                                          T.NEW_DEPT_NO,
                                          T.MODEL_CODE
                                     FROM MM_INV_PART_LOCATION_TEMP T
                                    WHERE T.IMP_UUID = IN_VAR_UUID
                                      AND T.IMPORT_STATUS = '0'
                                    GROUP BY T.OLD_PART_NO,
                                             T.OLD_SUPPLIER_NO,
                                             T.OLD_PART_NO,
                                             T.OLD_REPARE_PERSON,
                                             T.OLD_CARPOOL,
                                             T.OLD_STORAGE,
                                             T.OLD_DISTRI_PERSON,
                                             T.OLD_LOCATION,
                                             T.OLD_STATION_CODE,
                                             T.OLD_SHELF_NO,
                                             T.OLD_LOCATION_NUM,
                                             T.OLD_DEPT_NO,
                                             T.NEW_UNLOAD_PORT,
                                             T.NEW_SUPPLIER_NO,
                                             T.NEW_PART_NO,
                                             T.NEW_REPARE_PERSON,
                                             T.NEW_CARPOOL,
                                             T.NEW_STORAGE,
                                             T.NEW_DISTRI_PERSON,
                                             T.NEW_LOCATION,
                                             T.NEW_STATION_CODE,
                                             T.NEW_SHELF_NO,
                                             T.NEW_LOCATION_NUM,
                                             T.NEW_DEPT_NO,
                                             T.MODEL_CODE) TT
                            WHERE COUNT > 1) TTT
                   WHERE TTT.OLD_PART_NO = TTTT.OLD_PART_NO
                   AND TTT.OLD_SUPPLIER_NO = TTTT.OLD_SUPPLIER_NO
                   AND TTT.OLD_REPARE_PERSON = TTTT.OLD_REPARE_PERSON
                   AND TTT.OLD_CARPOOL = TTTT.OLD_CARPOOL
                   AND TTT.OLD_STORAGE = TTTT.OLD_STORAGE
                   AND TTT.OLD_DISTRI_PERSON = TTTT.OLD_DISTRI_PERSON
                   AND TTT.OLD_LOCATION = TTTT.OLD_LOCATION
                   AND TTT.OLD_STATION_CODE = TTTT.OLD_STATION_CODE
                   AND TTT.OLD_SHELF_NO = TTTT.OLD_SHELF_NO
                   AND TTT.OLD_LOCATION_NUM = TTTT.OLD_LOCATION_NUM
                   AND TTT.OLD_DEPT_NO = TTTT.OLD_DEPT_NO
                   AND TTT.NEW_UNLOAD_PORT = TTTT.NEW_UNLOAD_PORT
                   AND TTT.NEW_SUPPLIER_NO = TTTT.NEW_SUPPLIER_NO
                   AND TTT.NEW_PART_NO = TTTT.NEW_PART_NO
                   AND TTT.NEW_REPARE_PERSON = TTTT.NEW_REPARE_PERSON
                   AND TTT.NEW_CARPOOL = TTTT.NEW_CARPOOL
                   AND TTT.NEW_STORAGE = TTTT.NEW_STORAGE
                   AND TTT.NEW_DISTRI_PERSON = TTTT.NEW_DISTRI_PERSON
                   AND TTT.NEW_LOCATION = TTTT.NEW_LOCATION
                   AND TTT.NEW_STATION_CODE = TTTT.NEW_STATION_CODE
                   AND TTT.NEW_SHELF_NO = TTTT.NEW_SHELF_NO
                   AND TTT.NEW_LOCATION_NUM = TTTT.NEW_LOCATION_NUM
                   AND TTT.NEW_DEPT_NO = TTTT.NEW_DEPT_NO
                   AND TTT.MODEL_CODE = TTTT.MODEL_CODE);
    --Excel变更后数据重复
UPDATE MM_INV_PART_LOCATION_TEMP IMP
   SET IMP.CHECK_RESULT = '0',
       IMP.CHECK_INFO  =
       (nvl(imp.check_info, '') || 'Excel变更后数据重复;')
       WHERE IMP.ID IN (
                  SELECT DISTINCT TTTT.ID
                    FROM MM_INV_PART_LOCATION_TEMP TTTT,
                          (SELECT
                                  TT.NEW_UNLOAD_PORT,
                                  TT.NEW_SUPPLIER_NO,
                                  TT.NEW_PART_NO,
                                  TT.NEW_REPARE_PERSON,
                                  TT.NEW_CARPOOL,
                                  TT.NEW_STORAGE,
                                  TT.NEW_DISTRI_PERSON,
                                  TT.NEW_LOCATION,
                                  TT.NEW_STATION_CODE,
                                  TT.NEW_SHELF_NO,
                                  TT.NEW_LOCATION_NUM,
                                  TT.NEW_DEPT_NO,
                                  TT.MODEL_CODE
                             FROM (SELECT COUNT(*) COUNT,
                                          T.NEW_UNLOAD_PORT,
                                          T.NEW_SUPPLIER_NO,
                                          T.NEW_PART_NO,
                                          T.NEW_REPARE_PERSON,
                                          T.NEW_CARPOOL,
                                          T.NEW_STORAGE,
                                          T.NEW_DISTRI_PERSON,
                                          T.NEW_LOCATION,
                                          T.NEW_STATION_CODE,
                                          T.NEW_SHELF_NO,
                                          T.NEW_LOCATION_NUM,
                                          T.NEW_DEPT_NO,
                                          T.MODEL_CODE
                                     FROM MM_INV_PART_LOCATION_TEMP T
                                    WHERE T.IMP_UUID = IN_VAR_UUID
                                      AND T.IMPORT_STATUS = '0'
                                    GROUP BY T.NEW_UNLOAD_PORT,
                                             T.NEW_SUPPLIER_NO,
                                             T.NEW_PART_NO,
                                             T.NEW_REPARE_PERSON,
                                             T.NEW_CARPOOL,
                                             T.NEW_STORAGE,
                                             T.NEW_DISTRI_PERSON,
                                             T.NEW_LOCATION,
                                             T.NEW_STATION_CODE,
                                             T.NEW_SHELF_NO,
                                             T.NEW_LOCATION_NUM,
                                             T.NEW_DEPT_NO,
                                             T.MODEL_CODE) TT
                            WHERE COUNT > 1) TTT
                   WHERE
                       TTT.NEW_UNLOAD_PORT = TTTT.NEW_UNLOAD_PORT
                   AND TTT.NEW_SUPPLIER_NO = TTTT.NEW_SUPPLIER_NO
                   AND TTT.NEW_PART_NO = TTTT.NEW_PART_NO
                   AND TTT.NEW_REPARE_PERSON = TTTT.NEW_REPARE_PERSON
                   AND TTT.NEW_CARPOOL = TTTT.NEW_CARPOOL
                   AND TTT.NEW_STORAGE = TTTT.NEW_STORAGE
                   AND TTT.NEW_DISTRI_PERSON = TTTT.NEW_DISTRI_PERSON
                   AND TTT.NEW_LOCATION = TTTT.NEW_LOCATION
                   AND TTT.NEW_STATION_CODE = TTTT.NEW_STATION_CODE
                   AND TTT.NEW_SHELF_NO = TTTT.NEW_SHELF_NO
                   AND TTT.NEW_LOCATION_NUM = TTTT.NEW_LOCATION_NUM
                   AND TTT.NEW_DEPT_NO = TTTT.NEW_DEPT_NO
                   AND TTT.MODEL_CODE = TTTT.MODEL_CODE);
    --零件与工位关系在系统不存在
     /*UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '零件与工位关系在系统不存在;')
     WHERE NOT EXISTS (SELECT 1
              FROM MM_PUB_SUPER_BOM T
             WHERE T.PART_NO = IMP.NEW_PART_NO
               AND T.PROCESS_TYPE = IMP.NEW_STATION_CODE
               AND T.PLAN_EFF_START < SYSDATE
               AND T.PLAN_EFF_END > SYSDATE
               )
       AND IMP.IMP_UUID = IN_VAR_UUID AND IMP.OPERATION_TYPE IN ('新增','移动'）;*/
    --同一零件号+仓库代码只有一个卸货编码
    --新增
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+仓库代码只有一个卸货编码;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '新增'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_WARE_CODE
                      FROM (SELECT B.NEW_PART_NO, B.NEW_WARE_CODE, COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_UNLOAD_PORT
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_UNLOAD_PORT
                                    UNION
                                    SELECT AA.PART_NO, AA.WARE_CODE, AA.UNLOAD_PORT
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO,
                                              AA.WARE_CODE,
                                              AA.UNLOAD_PORT) B
                             GROUP BY B.NEW_PART_NO, B.NEW_WARE_CODE) C
                     WHERE C.TNUM > 1) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_WARE_CODE = IMP.NEW_PART_NO);
    --移动
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+仓库代码只有一个卸货编码;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_WARE_CODE
                      FROM (SELECT B.NEW_PART_NO, B.NEW_WARE_CODE, COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_UNLOAD_PORT
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_UNLOAD_PORT
                                    UNION
                                    SELECT AA.PART_NO, AA.WARE_CODE, AA.UNLOAD_PORT
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO,
                                              AA.WARE_CODE,
                                              AA.UNLOAD_PORT) B
                             GROUP BY B.NEW_PART_NO, B.NEW_WARE_CODE) C
                     WHERE C.TNUM = 2) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_WARE_CODE = IMP.NEW_PART_NO
               --判断修改前与修改后数量
               AND ((SELECT COUNT(1) FROM MM_INV_PART_LOCATION_TEMP TE WHERE TE.NEW_PART_NO = D.NEW_PART_NO AND
                   TE.NEW_WARE_CODE = D.NEW_WARE_CODE ) <>
                   (SELECT COUNT(1) FROM MM_INV_PART_LOCATION LO WHERE LO.PART_NO = D.NEW_PART_NO AND
                   LO.WARE_CODE =  D.NEW_WARE_CODE )));

    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+仓库代码只有一个卸货编码;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_WARE_CODE
                      FROM (SELECT B.NEW_PART_NO, B.NEW_WARE_CODE, COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_UNLOAD_PORT
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_UNLOAD_PORT
                                    UNION
                                    SELECT AA.PART_NO, AA.WARE_CODE, AA.UNLOAD_PORT
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO,
                                              AA.WARE_CODE,
                                              AA.UNLOAD_PORT) B
                             GROUP BY B.NEW_PART_NO, B.NEW_WARE_CODE) C
                     WHERE C.TNUM > 2) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_WARE_CODE = IMP.NEW_PART_NO);
    --同一零件号+仓库代码只有一个备货工程
    --新增
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+仓库代码只有一个备货工程;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '新增'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_WARE_CODE
                      FROM (SELECT B.NEW_PART_NO, B.NEW_WARE_CODE, COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_REPARE_PERSON
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_REPARE_PERSON
                                    UNION
                                    SELECT AA.PART_NO,
                                           AA.WARE_CODE,
                                           AA.PREPARE_PERSON
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO,
                                              AA.WARE_CODE,
                                              AA.PREPARE_PERSON) B
                             GROUP BY B.NEW_PART_NO, B.NEW_WARE_CODE) C
                     WHERE C.TNUM > 1) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_WARE_CODE = IMP.NEW_WARE_CODE);
    --移动
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+仓库代码只有一个备货工程;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_WARE_CODE
                      FROM (SELECT B.NEW_PART_NO, B.NEW_WARE_CODE, COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_REPARE_PERSON
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_REPARE_PERSON
                                    UNION
                                    SELECT AA.PART_NO,
                                           AA.WARE_CODE,
                                           AA.PREPARE_PERSON
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO,
                                              AA.WARE_CODE,
                                              AA.PREPARE_PERSON) B
                             GROUP BY B.NEW_PART_NO, B.NEW_WARE_CODE) C
                     WHERE C.TNUM = 2) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_WARE_CODE = IMP.NEW_WARE_CODE
               --判断修改前与修改后数量
               AND （(SELECT COUNT(1) FROM MM_INV_PART_LOCATION_TEMP TE WHERE TE.NEW_PART_NO = D.NEW_PART_NO AND
                           TE.NEW_WARE_CODE = D.NEW_WARE_CODE AND TE.IMP_UUID = IN_VAR_UUID) <>
                    (SELECT COUNT(1) FROM MM_INV_PART_LOCATION LO WHERE LO.PART_NO = D.NEW_PART_NO AND
                            LO.WARE_CODE = D.NEW_WARE_CODE
                           )）
               );
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+仓库代码只有一个备货工程;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_WARE_CODE
                      FROM (SELECT B.NEW_PART_NO, B.NEW_WARE_CODE, COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_REPARE_PERSON
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_REPARE_PERSON
                                    UNION
                                    SELECT AA.PART_NO,
                                           AA.WARE_CODE,
                                           AA.PREPARE_PERSON
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO,
                                              AA.WARE_CODE,
                                              AA.PREPARE_PERSON) B
                             GROUP BY B.NEW_PART_NO, B.NEW_WARE_CODE) C
                     WHERE C.TNUM > 2) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_WARE_CODE = IMP.NEW_WARE_CODE);
    --同一零件号+仓库代码只有一个台车号
    --新增
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+仓库代码只有一个台车号;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '新增'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_WARE_CODE
                      FROM (SELECT B.NEW_PART_NO, B.NEW_WARE_CODE, COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_CARPOOL
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_CARPOOL
                                    UNION
                                    SELECT AA.PART_NO, AA.WARE_CODE, AA.CARPOOL
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO, AA.WARE_CODE, AA.CARPOOL) B
                             GROUP BY B.NEW_PART_NO, B.NEW_WARE_CODE) C
                     WHERE C.TNUM > 1) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_WARE_CODE = IMP.NEW_WARE_CODE);
    --移动
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+仓库代码只有一个台车号;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_WARE_CODE
                      FROM (SELECT B.NEW_PART_NO, B.NEW_WARE_CODE, COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_CARPOOL
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_CARPOOL
                                    UNION
                                    SELECT AA.PART_NO, AA.WARE_CODE, AA.CARPOOL
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO, AA.WARE_CODE, AA.CARPOOL) B
                             GROUP BY B.NEW_PART_NO, B.NEW_WARE_CODE) C
                     WHERE C.TNUM = 2) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_WARE_CODE = IMP.NEW_WARE_CODE
               --判断修改前与修改后数量
               AND ((SELECT COUNT(1) FROM MM_INV_PART_LOCATION_TEMP TE WHERE TE.NEW_PART_NO = D.NEW_PART_NO AND
                           TE.NEW_WARE_CODE = D.NEW_WARE_CODE AND TE.IMP_UUID = IN_VAR_UUID) <>
                    (SELECT COUNT(1) FROM MM_INV_PART_LOCATION LO WHERE LO.PART_NO = D.NEW_PART_NO AND
                            LO.WARE_CODE = D.NEW_WARE_CODE
                           )));

    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+仓库代码只有一个台车号;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_WARE_CODE
                      FROM (SELECT B.NEW_PART_NO, B.NEW_WARE_CODE, COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_CARPOOL
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_CARPOOL
                                    UNION
                                    SELECT AA.PART_NO, AA.WARE_CODE, AA.CARPOOL
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO, AA.WARE_CODE, AA.CARPOOL) B
                             GROUP BY B.NEW_PART_NO, B.NEW_WARE_CODE) C
                     WHERE C.TNUM > 2) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_WARE_CODE = IMP.NEW_WARE_CODE);
    --同一零件号+仓库代码只有一个物流库地址
    --新增
    /*UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+仓库代码只有一个物流库地址;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '新增'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_WARE_CODE
                      FROM (SELECT B.NEW_PART_NO, B.NEW_WARE_CODE, COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_STORAGE
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_STORAGE
                                    UNION
                                    SELECT AA.PART_NO, AA.WARE_CODE, AA.STORAGE
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO, AA.WARE_CODE, AA.STORAGE) B
                             GROUP BY B.NEW_PART_NO, B.NEW_WARE_CODE) C
                     WHERE C.TNUM > 1) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_WARE_CODE = IMP.NEW_WARE_CODE);
    --移动
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+仓库代码只有一个物流库地址;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_WARE_CODE
                      FROM (SELECT B.NEW_PART_NO, B.NEW_WARE_CODE, COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_STORAGE
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_STORAGE
                                    UNION
                                    SELECT AA.PART_NO, AA.WARE_CODE, AA.STORAGE
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO, AA.WARE_CODE, AA.STORAGE) B
                             GROUP BY B.NEW_PART_NO, B.NEW_WARE_CODE) C
                     WHERE C.TNUM > 2) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_WARE_CODE = IMP.NEW_WARE_CODE);*/
    --同一零件号+工位只有一个配送工程
    --新增
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+工位只有一个配送工程;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '新增'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_STATION_CODE
                      FROM (SELECT B.NEW_PART_NO,
                                   B.NEW_STATION_CODE,
                                   COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_STATION_CODE,
                                           A.NEW_DISTRI_PERSON
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_STATION_CODE,
                                              A.NEW_DISTRI_PERSON
                                    UNION
                                    SELECT AA.PART_NO,
                                           AA.STATION_CODE,
                                           AA.DISTRI_PERSON
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO,
                                              AA.STATION_CODE,
                                              AA.DISTRI_PERSON) B
                             GROUP BY B.NEW_PART_NO, B.NEW_STATION_CODE) C
                     WHERE C.TNUM > 1) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_STATION_CODE = IMP.NEW_STATION_CODE);
    --移动
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+工位只有一个配送工程;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_STATION_CODE
                      FROM (SELECT B.NEW_PART_NO,
                                   B.NEW_STATION_CODE,
                                   COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_STATION_CODE,
                                           A.NEW_DISTRI_PERSON
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_STATION_CODE,
                                              A.NEW_DISTRI_PERSON
                                    UNION
                                    SELECT AA.PART_NO,
                                           AA.STATION_CODE,
                                           AA.DISTRI_PERSON
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO,
                                              AA.STATION_CODE,
                                              AA.DISTRI_PERSON) B
                             GROUP BY B.NEW_PART_NO, B.NEW_STATION_CODE) C
                     WHERE C.TNUM = 2) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_STATION_CODE = IMP.NEW_STATION_CODE
               --判断修改前与修改后数量
               AND ((SELECT COUNT(1) FROM MM_INV_PART_LOCATION_TEMP TE WHERE TE.NEW_PART_NO = D.NEW_PART_NO AND
                           TE.NEW_STATION_CODE = D.NEW_STATION_CODE AND TE.IMP_UUID = IN_VAR_UUID) <>
                    (SELECT COUNT(1) FROM MM_INV_PART_LOCATION LO WHERE LO.PART_NO = D.NEW_PART_NO AND
                            LO.STATION_CODE = D.NEW_STATION_CODE
                           )));

    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+工位只有一个配送工程;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_STATION_CODE
                      FROM (SELECT B.NEW_PART_NO,
                                   B.NEW_STATION_CODE,
                                   COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_STATION_CODE,
                                           A.NEW_DISTRI_PERSON
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_STATION_CODE,
                                              A.NEW_DISTRI_PERSON
                                    UNION
                                    SELECT AA.PART_NO,
                                           AA.STATION_CODE,
                                           AA.DISTRI_PERSON
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO,
                                              AA.STATION_CODE,
                                              AA.DISTRI_PERSON) B
                             GROUP BY B.NEW_PART_NO, B.NEW_STATION_CODE) C
                     WHERE C.TNUM > 2) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_STATION_CODE = IMP.NEW_STATION_CODE);
    --同一工厂+车间+零件+工位只有一个配送地址
    --新增
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一工厂+车间+零件+工位只有一个配送地址;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '新增'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.FACTORY_CODE,
                           C.NEW_WORK_CENTER,
                           C.NEW_PART_NO,
                           C.NEW_STATION_CODE
                      FROM (SELECT B.FACTORY_CODE,
                                   B.NEW_WORK_CENTER,
                                   B.NEW_PART_NO,
                                   B.NEW_STATION_CODE,
                                   COUNT(1) TNUM
                              FROM (SELECT A.FACTORY_CODE,
                                           A.NEW_WORK_CENTER,
                                           A.NEW_PART_NO,
                                           A.NEW_STATION_CODE,
                                           A.NEW_LOCATION
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.FACTORY_CODE,
                                              A.NEW_WORK_CENTER,
                                              A.NEW_PART_NO,
                                              A.NEW_STATION_CODE,
                                              A.NEW_LOCATION
                                    UNION
                                    SELECT AA.FACTORY_CODE,
                                           AA.WORKCENTER,
                                           AA.PART_NO,
                                           AA.STATION_CODE,
                                           AA.LOCATION
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.FACTORY_CODE,
                                              AA.WORKCENTER,
                                              AA.PART_NO,
                                              AA.STATION_CODE,
                                              AA.LOCATION) B
                             GROUP BY B.FACTORY_CODE,
                                      B.NEW_WORK_CENTER,
                                      B.NEW_PART_NO,
                                      B.NEW_STATION_CODE) C
                     WHERE C.TNUM > 1) D
             WHERE D.FACTORY_CODE = IMP.FACTORY_CODE
               AND D.NEW_WORK_CENTER = IMP.NEW_WORK_CENTER
               AND D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_STATION_CODE = IMP.NEW_STATION_CODE);
    --移动
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一工厂+车间+零件+工位只有一个配送地址;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.FACTORY_CODE,
                           C.NEW_WORK_CENTER,
                           C.NEW_PART_NO,
                           C.NEW_STATION_CODE
                      FROM (SELECT B.FACTORY_CODE,
                                   B.NEW_WORK_CENTER,
                                   B.NEW_PART_NO,
                                   B.NEW_STATION_CODE,
                                   COUNT(1) TNUM
                              FROM (SELECT A.FACTORY_CODE,
                                           A.NEW_WORK_CENTER,
                                           A.NEW_PART_NO,
                                           A.NEW_STATION_CODE,
                                           A.NEW_LOCATION
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.FACTORY_CODE,
                                              A.NEW_WORK_CENTER,
                                              A.NEW_PART_NO,
                                              A.NEW_STATION_CODE,
                                              A.NEW_LOCATION
                                    UNION
                                    SELECT AA.FACTORY_CODE,
                                           AA.WORKCENTER,
                                           AA.PART_NO,
                                           AA.STATION_CODE,
                                           AA.LOCATION
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.FACTORY_CODE,
                                              AA.WORKCENTER,
                                              AA.PART_NO,
                                              AA.STATION_CODE,
                                              AA.LOCATION) B
                             GROUP BY B.FACTORY_CODE,
                                      B.NEW_WORK_CENTER,
                                      B.NEW_PART_NO,
                                      B.NEW_STATION_CODE) C
                     WHERE C.TNUM > 2) D
             WHERE D.FACTORY_CODE = IMP.FACTORY_CODE
               AND D.NEW_WORK_CENTER = IMP.NEW_WORK_CENTER
               AND D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_STATION_CODE = IMP.NEW_STATION_CODE
               --判断修改前与修改后数量
               AND ((SELECT COUNT(1) FROM MM_INV_PART_LOCATION_TEMP TE WHERE TE.FACTORY_CODE = D.FACTORY_CODE
                   AND TE.NEW_WORK_CENTER = D.NEW_WORK_CENTER AND TE.NEW_PART_NO = D.NEW_PART_NO
                   AND TE.NEW_STATION_CODE = D.NEW_STATION_CODE AND TE.IMP_UUID = IN_VAR_UUID) <>
                   (SELECT COUNT(1) FROM MM_INV_PART_LOCATION LO WHERE LO.FACTORY_CODE = D.FACTORY_CODE
                   AND LO.WORKCENTER = D.NEW_WORK_CENTER AND LO.PART_NO = D.NEW_PART_NO
                   AND LO.STATION_CODE = D.NEW_STATION_CODE)));

    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一工厂+车间+零件+工位只有一个配送地址;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.FACTORY_CODE,
                           C.NEW_WORK_CENTER,
                           C.NEW_PART_NO,
                           C.NEW_STATION_CODE
                      FROM (SELECT B.FACTORY_CODE,
                                   B.NEW_WORK_CENTER,
                                   B.NEW_PART_NO,
                                   B.NEW_STATION_CODE,
                                   COUNT(1) TNUM
                              FROM (SELECT A.FACTORY_CODE,
                                           A.NEW_WORK_CENTER,
                                           A.NEW_PART_NO,
                                           A.NEW_STATION_CODE,
                                           A.NEW_LOCATION
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.FACTORY_CODE,
                                              A.NEW_WORK_CENTER,
                                              A.NEW_PART_NO,
                                              A.NEW_STATION_CODE,
                                              A.NEW_LOCATION
                                    UNION
                                    SELECT AA.FACTORY_CODE,
                                           AA.WORKCENTER,
                                           AA.PART_NO,
                                           AA.STATION_CODE,
                                           AA.LOCATION
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.FACTORY_CODE,
                                              AA.WORKCENTER,
                                              AA.PART_NO,
                                              AA.STATION_CODE,
                                              AA.LOCATION) B
                             GROUP BY B.FACTORY_CODE,
                                      B.NEW_WORK_CENTER,
                                      B.NEW_PART_NO,
                                      B.NEW_STATION_CODE) C
                     WHERE C.TNUM > 2) D
             WHERE D.FACTORY_CODE = IMP.FACTORY_CODE
               AND D.NEW_WORK_CENTER = IMP.NEW_WORK_CENTER
               AND D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_STATION_CODE = IMP.NEW_STATION_CODE);
    --同一货架号只有一个配送地址地址
    --新增
     UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一货架号只有一个配送地址;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '新增'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_SHELF_NO
                      FROM (SELECT B.NEW_SHELF_NO, COUNT(1) TNUM
                              FROM (SELECT A.NEW_SHELF_NO, A.NEW_LOCATION
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                      WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_SHELF_NO, A.NEW_LOCATION
                                    UNION
                                    SELECT AA.SHELF_NO, AA.LOCATION
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.SHELF_NO, AA.LOCATION) B
                             GROUP BY B.NEW_SHELF_NO) C
                     WHERE C.TNUM > 1) D
             WHERE D.NEW_SHELF_NO = IMP.NEW_SHELF_NO);
    --移动
    /*UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一货架号只有一个配送地址;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_SHELF_NO
                      FROM (SELECT B.NEW_SHELF_NO, COUNT(1) TNUM
                              FROM (SELECT A.NEW_SHELF_NO, A.NEW_LOCATION
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                      WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_SHELF_NO, A.NEW_LOCATION
                                    UNION
                                    SELECT AA.SHELF_NO, AA.LOCATION
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.SHELF_NO, AA.LOCATION) B
                             GROUP BY B.NEW_SHELF_NO) C
                     WHERE C.TNUM = 2) D
             WHERE D.NEW_SHELF_NO = IMP.NEW_SHELF_NO
             AND ((SELECT COUNT(1) FROM MM_INV_PART_LOCATION_TEMP TE WHERE TE.NEW_SHELF_NO = D.NEW_SHELF_NO
                 AND TE.IMP_UUID = IN_VAR_UUID) <>
                 (SELECT COUNT(1) FROM MM_INV_PART_LOCATION LO WHERE LO.SHELF_NO = D.NEW_SHELF_NO)));*/

    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一货架号只有一个配送地址;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_SHELF_NO
                      FROM (SELECT B.NEW_SHELF_NO, COUNT(1) TNUM
                              FROM (SELECT A.NEW_SHELF_NO, A.NEW_LOCATION
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                      WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_SHELF_NO, A.NEW_LOCATION
                                    UNION
                                    SELECT AA.SHELF_NO, AA.LOCATION
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.SHELF_NO, AA.LOCATION) B
                             GROUP BY B.NEW_SHELF_NO) C
                     WHERE C.TNUM > 2) D
             WHERE D.NEW_SHELF_NO = IMP.NEW_SHELF_NO);
    --同一零件号+工位只有一个货架号
    --新增
  /*  UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+工位只有一个货架号;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '新增'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_STATION_CODE
                      FROM (SELECT B.NEW_PART_NO,
                                   B.NEW_STATION_CODE,
                                   COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_STATION_CODE,
                                           A.NEW_SHELF_NO
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_STATION_CODE,
                                              A.NEW_SHELF_NO
                                    UNION
                                    SELECT AA.PART_NO, AA.STATION_CODE, AA.SHELF_NO
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO,
                                              AA.STATION_CODE,
                                              AA.SHELF_NO) B
                             GROUP BY B.NEW_PART_NO, B.NEW_STATION_CODE) C
                     WHERE C.TNUM > 1) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_STATION_CODE = IMP.NEW_STATION_CODE);
    --移动
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一零件号+工位只有一个货架号;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.NEW_PART_NO, C.NEW_STATION_CODE
                      FROM (SELECT B.NEW_PART_NO,
                                   B.NEW_STATION_CODE,
                                   COUNT(1) TNUM
                              FROM (SELECT A.NEW_PART_NO,
                                           A.NEW_STATION_CODE,
                                           A.NEW_SHELF_NO
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.NEW_PART_NO,
                                              A.NEW_STATION_CODE,
                                              A.NEW_SHELF_NO
                                    UNION
                                    SELECT AA.PART_NO, AA.STATION_CODE, AA.SHELF_NO
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.PART_NO,
                                              AA.STATION_CODE,
                                              AA.SHELF_NO) B
                             GROUP BY B.NEW_PART_NO, B.NEW_STATION_CODE) C
                     WHERE C.TNUM > 2) D
             WHERE D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_STATION_CODE = IMP.NEW_STATION_CODE);*/
    --同一工厂+配送地址只有一个工程深度
    --新增
    /*UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一工厂+配送地址只有一个工程深度;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '新增'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.FACTORY_CODE, C.NEW_LOCATION
                      FROM (SELECT B.FACTORY_CODE, B.NEW_LOCATION, COUNT(1) TNUM
                              FROM (SELECT A.FACTORY_CODE,
                                           A.NEW_LOCATION,
                                           A.NEW_LOCATION_NUM
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.FACTORY_CODE,
                                              A.NEW_LOCATION,
                                              A.NEW_LOCATION_NUM
                                    UNION
                                    SELECT AA.FACTORY_CODE, AA.LOCATION, AA.LOCATION_NUM
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.FACTORY_CODE,
                                              AA.LOCATION,
                                              AA.LOCATION_NUM) B
                             GROUP BY B.FACTORY_CODE, B.NEW_LOCATION) C
                     WHERE C.TNUM > 1) D
             WHERE D.FACTORY_CODE = IMP.FACTORY_CODE
               AND D.NEW_LOCATION = IMP.NEW_LOCATION);
    --移动
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一工厂+配送地址只有一个工程深度;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.FACTORY_CODE, C.NEW_LOCATION
                      FROM (SELECT B.FACTORY_CODE, B.NEW_LOCATION, COUNT(1) TNUM
                              FROM (SELECT A.FACTORY_CODE,
                                           A.NEW_LOCATION,
                                           A.NEW_LOCATION_NUM
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.FACTORY_CODE,
                                              A.NEW_LOCATION,
                                              A.NEW_LOCATION_NUM
                                    UNION
                                    SELECT AA.FACTORY_CODE, AA.LOCATION, AA.LOCATION_NUM
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.FACTORY_CODE,
                                              AA.LOCATION,
                                              AA.LOCATION_NUM) B
                             GROUP BY B.FACTORY_CODE, B.NEW_LOCATION) C
                     WHERE C.TNUM > 2) D
             WHERE D.FACTORY_CODE = IMP.FACTORY_CODE
               AND D.NEW_LOCATION = IMP.NEW_LOCATION);*/
    --同一工厂+零件+供应商代码+仓库代码+工位只有一个责任班组
    --新增
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一工厂+零件+供应商代码+仓库代码+工位只有一个责任班组;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '新增'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.FACTORY_CODE,
                           C.NEW_PART_NO,
                           C.NEW_SUPPLIER_NO,
                           C.NEW_WARE_CODE,
                           C.NEW_STATION_CODE
                      FROM (SELECT B.FACTORY_CODE,
                                   B.NEW_PART_NO,
                                   B.NEW_SUPPLIER_NO,
                                   B.NEW_WARE_CODE,
                                   B.NEW_STATION_CODE,
                                   COUNT(1) TNUM
                              FROM (SELECT A.FACTORY_CODE,
                                           A.NEW_PART_NO,
                                           A.NEW_SUPPLIER_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_STATION_CODE,
                                           A.NEW_DEPT_NO
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.FACTORY_CODE,
                                              A.NEW_PART_NO,
                                              A.NEW_SUPPLIER_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_STATION_CODE,
                                              A.NEW_DEPT_NO
                                    UNION
                                    SELECT AA.FACTORY_CODE,
                                           AA.PART_NO,
                                           AA.SUPPLIER_NO,
                                           AA.WARE_CODE,
                                           AA.STATION_CODE,
                                           AA.DEP_NO
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.FACTORY_CODE,
                                              AA.PART_NO,
                                              AA.SUPPLIER_NO,
                                              AA.WARE_CODE,
                                              AA.STATION_CODE,
                                              AA.DEP_NO) B
                             GROUP BY B.FACTORY_CODE,
                                      B.NEW_PART_NO,
                                      B.NEW_SUPPLIER_NO,
                                      B.NEW_WARE_CODE,
                                      B.NEW_STATION_CODE) C
                     WHERE C.TNUM > 1) D
             WHERE D.FACTORY_CODE = IMP.FACTORY_CODE
               AND D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_SUPPLIER_NO = IMP.NEW_SUPPLIER_NO
               AND D.NEW_WARE_CODE = IMP.NEW_WARE_CODE
               AND D.NEW_STATION_CODE = IMP.NEW_STATION_CODE);
    --移动
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一工厂+零件+供应商代码+仓库代码+工位只有一个责任班组;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.FACTORY_CODE,
                           C.NEW_PART_NO,
                           C.NEW_SUPPLIER_NO,
                           C.NEW_WARE_CODE,
                           C.NEW_STATION_CODE
                      FROM (SELECT B.FACTORY_CODE,
                                   B.NEW_PART_NO,
                                   B.NEW_SUPPLIER_NO,
                                   B.NEW_WARE_CODE,
                                   B.NEW_STATION_CODE,
                                   COUNT(1) TNUM
                              FROM (SELECT A.FACTORY_CODE,
                                           A.NEW_PART_NO,
                                           A.NEW_SUPPLIER_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_STATION_CODE,
                                           A.NEW_DEPT_NO
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.FACTORY_CODE,
                                              A.NEW_PART_NO,
                                              A.NEW_SUPPLIER_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_STATION_CODE,
                                              A.NEW_DEPT_NO
                                    UNION
                                    SELECT AA.FACTORY_CODE,
                                           AA.PART_NO,
                                           AA.SUPPLIER_NO,
                                           AA.WARE_CODE,
                                           AA.STATION_CODE,
                                           AA.DEP_NO
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.FACTORY_CODE,
                                              AA.PART_NO,
                                              AA.SUPPLIER_NO,
                                              AA.WARE_CODE,
                                              AA.STATION_CODE,
                                              AA.DEP_NO) B
                             GROUP BY B.FACTORY_CODE,
                                      B.NEW_PART_NO,
                                      B.NEW_SUPPLIER_NO,
                                      B.NEW_WARE_CODE,
                                      B.NEW_STATION_CODE) C
                     WHERE C.TNUM = 2) D
             WHERE D.FACTORY_CODE = IMP.FACTORY_CODE
               AND D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_SUPPLIER_NO = IMP.NEW_SUPPLIER_NO
               AND D.NEW_WARE_CODE = IMP.NEW_WARE_CODE
               AND D.NEW_STATION_CODE = IMP.NEW_STATION_CODE
               --判断修改前与修改后数量
               AND ((SELECT COUNT(1) FROM MM_INV_PART_LOCATION_TEMP TE WHERE TE.FACTORY_CODE = D.FACTORY_CODE
                   AND TE.NEW_PART_NO = D.NEW_PART_NO AND TE.NEW_SUPPLIER_NO = D.NEW_SUPPLIER_NO
                   AND TE.NEW_WARE_CODE = D.NEW_WARE_CODE AND TE.NEW_STATION_CODE = D.NEW_STATION_CODE
                   AND TE.IMP_UUID = IN_VAR_UUID) <>
                   (SELECT COUNT(1) FROM MM_INV_PART_LOCATION LO WHERE LO.FACTORY_CODE = D.FACTORY_CODE
                   AND LO.PART_NO = D.NEW_PART_NO AND LO.SUPPLIER_NO = D.NEW_SUPPLIER_NO
                   AND LO.WARE_CODE = D.NEW_WARE_CODE AND LO.STATION_CODE = D.NEW_STATION_CODE)));

    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '同一工厂+零件+供应商代码+仓库代码+工位只有一个责任班组;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE = '移动'
       AND EXISTS
     (SELECT 1
              FROM (SELECT C.FACTORY_CODE,
                           C.NEW_PART_NO,
                           C.NEW_SUPPLIER_NO,
                           C.NEW_WARE_CODE,
                           C.NEW_STATION_CODE
                      FROM (SELECT B.FACTORY_CODE,
                                   B.NEW_PART_NO,
                                   B.NEW_SUPPLIER_NO,
                                   B.NEW_WARE_CODE,
                                   B.NEW_STATION_CODE,
                                   COUNT(1) TNUM
                              FROM (SELECT A.FACTORY_CODE,
                                           A.NEW_PART_NO,
                                           A.NEW_SUPPLIER_NO,
                                           A.NEW_WARE_CODE,
                                           A.NEW_STATION_CODE,
                                           A.NEW_DEPT_NO
                                      FROM MM_INV_PART_LOCATION_TEMP A
                                     WHERE A.IMP_UUID = IN_VAR_UUID
                                     GROUP BY A.FACTORY_CODE,
                                              A.NEW_PART_NO,
                                              A.NEW_SUPPLIER_NO,
                                              A.NEW_WARE_CODE,
                                              A.NEW_STATION_CODE,
                                              A.NEW_DEPT_NO
                                    UNION
                                    SELECT AA.FACTORY_CODE,
                                           AA.PART_NO,
                                           AA.SUPPLIER_NO,
                                           AA.WARE_CODE,
                                           AA.STATION_CODE,
                                           AA.DEP_NO
                                      FROM MM_INV_PART_LOCATION AA
                                     GROUP BY AA.FACTORY_CODE,
                                              AA.PART_NO,
                                              AA.SUPPLIER_NO,
                                              AA.WARE_CODE,
                                              AA.STATION_CODE,
                                              AA.DEP_NO) B
                             GROUP BY B.FACTORY_CODE,
                                      B.NEW_PART_NO,
                                      B.NEW_SUPPLIER_NO,
                                      B.NEW_WARE_CODE,
                                      B.NEW_STATION_CODE) C
                     WHERE C.TNUM > 2) D
             WHERE D.FACTORY_CODE = IMP.FACTORY_CODE
               AND D.NEW_PART_NO = IMP.NEW_PART_NO
               AND D.NEW_SUPPLIER_NO = IMP.NEW_SUPPLIER_NO
               AND D.NEW_WARE_CODE = IMP.NEW_WARE_CODE
               AND D.NEW_STATION_CODE = IMP.NEW_STATION_CODE);
   --数据不存在
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '变更前数据不存在;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE IN ('废止','移动'）
       AND IMP.ID NOT IN (SELECT DISTINCT T.ID
           FROM MM_INV_PART_LOCATION_TEMP T
              INNER JOIN  MM_INV_PART_LOCATION A
             ON A.UNLOAD_PORT = T.OLD_UNLOAD_PORT
               AND A.SUPPLIER_NO = T.OLD_SUPPLIER_NO
               AND A.PART_NO = T.OLD_PART_NO
               AND A.PREPARE_PERSON = T.OLD_REPARE_PERSON
               AND A.CARPOOL = T.OLD_CARPOOL
               AND A.STORAGE = T.OLD_STORAGE
               AND A.DISTRI_PERSON = T.OLD_DISTRI_PERSON
               AND A.LOCATION = T.OLD_LOCATION
               AND A.STATION_CODE = T.OLD_STATION_CODE
               AND A.SHELF_NO = T.OLD_SHELF_NO
               AND A.LOCATION_NUM = T.OLD_LOCATION_NUM
               AND A.DEP_NO = T.OLD_DEPT_NO
               AND A.MODEL_CODE = T.MODEL_CODE
               AND T.IMP_UUID = IN_VAR_UUID
               AND T.IMPORT_STATUS = 0
               AND T.ID IS NOT NULL);
    --变更后数据已存在
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '变更后数据已存在;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = '1'
       AND IMP.OPERATION_TYPE IN ('移动'）
       AND IMP.ID IN (SELECT DISTINCT T.ID
           FROM MM_INV_PART_LOCATION_TEMP T
              INNER JOIN  MM_INV_PART_LOCATION A
             ON A.UNLOAD_PORT = T.NEW_UNLOAD_PORT
               AND A.SUPPLIER_NO = T.NEW_SUPPLIER_NO
               AND A.PART_NO = T.NEW_PART_NO
               AND A.PREPARE_PERSON = T.NEW_REPARE_PERSON
               AND A.CARPOOL = T.NEW_CARPOOL
               AND A.STORAGE = T.NEW_STORAGE
               AND A.DISTRI_PERSON = T.NEW_DISTRI_PERSON
               AND A.LOCATION = T.NEW_LOCATION
               AND A.STATION_CODE = T.NEW_STATION_CODE
               AND A.SHELF_NO = T.NEW_SHELF_NO
               AND A.LOCATION_NUM = T.NEW_LOCATION_NUM
               AND A.DEP_NO = T.NEW_DEPT_NO
               AND A.MODEL_CODE = T.MODEL_CODE
               AND T.IMP_UUID = ''
               AND T.IMPORT_STATUS = 0
               AND T.ID IS NOT NULL);
     --数据已存在
    UPDATE MM_INV_PART_LOCATION_TEMP IMP
       SET IMP.CHECK_RESULT = '0',
           IMP.CHECK_INFO  =
           (nvl(imp.check_info, '') || '数据已存在;')
     WHERE IMP.IMPORT_STATUS = 0
       AND IMP.IMP_UUID = IN_VAR_UUID
       AND IMP.OPERATION_TYPE IN ('新增'）
       AND IMP.ID IN (SELECT DISTINCT T.ID
           FROM MM_INV_PART_LOCATION_TEMP T
              INNER JOIN  MM_INV_PART_LOCATION A
             ON A.UNLOAD_PORT = T.NEW_UNLOAD_PORT
               AND A.SUPPLIER_NO = T.NEW_SUPPLIER_NO
               AND A.PART_NO = T.NEW_PART_NO
               AND A.PREPARE_PERSON = T.NEW_REPARE_PERSON
               AND A.CARPOOL = T.NEW_CARPOOL
               AND A.STORAGE = T.NEW_STORAGE
               AND A.DISTRI_PERSON = T.NEW_DISTRI_PERSON
               AND A.LOCATION = T.NEW_LOCATION
               AND A.STATION_CODE = T.NEW_STATION_CODE
               AND A.SHELF_NO = T.NEW_SHELF_NO
               AND A.LOCATION_NUM = T.NEW_LOCATION_NUM
               AND A.DEP_NO = T.NEW_DEPT_NO
               AND A.MODEL_CODE = T.MODEL_CODE
               AND T.IMP_UUID = IN_VAR_UUID
               AND T.IMPORT_STATUS = 0
               AND T.ID IS NOT NULL);

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_PUB_CHECK.USP_MM_INV_PART_LOCATION_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_MM_INV_PART_LOCATION_CHECK;
  --*****************************************************************************

  --***************************************************************************
  --存储过程名：JISI_PART_GROUP_CHECK
  --功能描述：厂内同步零件组信息导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: luoxq
  --创建时间： 2018/09/17
 PROCEDURE JISI_PART_GROUP_CHECK(  IN_VAR_UUID       IN VARCHAR2,
                                  IN_VAR_USERNAME   IN VARCHAR2,
                                  IN_VAR_OPEIP      IN VARCHAR2,
                                  OUT_ERROR_FLAG    OUT VARCHAR2,
                                  OUT_OUT_ERROR_MSG OUT VARCHAR2) IS

    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

  BEGIN
    out_error_flag  := '0';
    out_out_error_msg   := '';

    /*update MM_JISI_PARTGROUP_IMP a
       set a.check_result = 0,
           a.ope_type = 'U',
           a.CHECK_INFO = a.CHECK_INFO || '主键重复;'
     where exists (select 1
              from (select b.Id
                      from MM_JISI_PARTGROUP_IMP b
                     where b.imp_uuid = in_var_uuid
                     group by b.id
                    having count(1) > 1) c
             where a.id = c.id)
       and a.imp_uuid = in_var_uuid;*/


    --EXCEL是否重复
    update MM_JISI_PARTGROUP_IMP siglt
       set siglt.check_result = 0,
           siglt.ope_type = 'U',
           siglt.check_info  =
           (nvl(siglt.check_info, '') || 'Excel数据重复;')
     where siglt.id in
           (select distinct T.id
              from MM_JISI_PARTGROUP_IMP t,
                   (select plan_code,
                           partgroup_no
                      from (select count(*) count,
                                   siglt.plan_code,
                                   siglt.partgroup_no
                              from MM_JISI_PARTGROUP_IMP siglt
                             where siglt.imp_uuid = in_var_uuid
                               and siglt.import_status = '0'
                             group by  siglt.plan_code,
                                       siglt.partgroup_no
                                       )
                     where count > 1) b
             where t.plan_code = b.plan_code
               and t.partgroup_no = B.partgroup_no
               );

    --主表中是否已存在该条记录
    /*MERGE INTO MM_JISI_PARTGROUP_IMP A
    USING (SELECT C.PARTGROUP_NO,C.PLAN_CODE
             FROM MM_JISI_PARTGROUP C, MM_JISI_PARTGROUP_IMP B
            WHERE B.check_result = 1
              AND B.imp_uuid = in_var_uuid
              AND B.plan_code = C.plan_code
              AND B.partgroup_no = C.partgroup_no
              ) D
    ON (A.plan_code = D.plan_code AND A.partgroup_no = D.partgroup_no AND A.IMP_UUID = in_var_uuid)
    WHEN MATCHED THEN
      UPDATE
         SET A.CHECK_RESULT = 0,
             A.OPE_TYPE   = 'U',
             A.CHECK_INFO = A.CHECK_INFO || '数据已存在;';

    OUT_ERROR_FLAG    := '0';
    out_OUT_ERROR_MSG := '';*/

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MM_PUP.PUP_FIX_TIME_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END JISI_PART_GROUP_CHECK;

--***************************************************************************
  --存储过程名：JISI_PART_CHECK
  --功能描述：厂内同步零件信息导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: luoxq
  --创建时间： 2018/09/17
 PROCEDURE JISI_PART_CHECK(    IN_VAR_UUID       IN VARCHAR2,
                                  IN_VAR_USERNAME   IN VARCHAR2,
                                  IN_VAR_OPEIP      IN VARCHAR2,
                                  OUT_ERROR_FLAG    OUT VARCHAR2,
                                  OUT_OUT_ERROR_MSG OUT VARCHAR2) IS

    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

  BEGIN
    out_error_flag  := '0';
    out_out_error_msg   := '';

    update MM_JISI_PARTGROUP_IMP a
       set a.check_result = 0,
           a.ope_type = 'U',
           a.CHECK_INFO = a.CHECK_INFO || '主键重复;'
     where exists (select 1
              from (select b.Id
                      from MM_JISI_PARTGROUP_IMP b
                     where b.imp_uuid = in_var_uuid
                     group by b.id
                    having count(1) > 1) c
             where a.id = c.id)
       and a.imp_uuid = in_var_uuid;

    --校验零件编号是否存在
    UPDATE MM_JISI_PART_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '零件编号不存在;'
     WHERE NOT EXISTS
     (SELECT 1 FROM MM_PUB_PART B WHERE A.PART_NO = B.PART_NO)
       AND A.IMP_UUID = IN_VAR_UUID;

    --校验零件组编码是否存在
    UPDATE MM_JISI_PART_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = NVL(A.CHECK_INFO, '') || '零件组代码不存在;'
     WHERE NOT EXISTS
     (SELECT 1 FROM MM_JISI_PARTGROUP B WHERE A.PARTGROUP_NO = B.PARTGROUP_NO)
       AND A.IMP_UUID = IN_VAR_UUID;

    --EXCEL是否重复
    update MM_JISI_PART_IMP siglt
       set siglt.check_result = 0,
           siglt.ope_type = 'U',
           siglt.check_info  =
           (nvl(siglt.check_info, '') || 'Excel数据重复;')
     where siglt.id in
           (select distinct T.id
              from MM_JISI_PART_IMP t,
                   (select part_no,
                           partgroup_no
                      from (select count(*) count,
                                   siglt.partgroup_no,
                                   siglt.part_no
                              from MM_JISI_PART_IMP siglt
                             where siglt.imp_uuid = in_var_uuid
                               and siglt.import_status = '0'
                             group by  siglt.partgroup_no,
                                       siglt.part_no
                                       )
                     where count > 1) b
             where t.part_no = b.part_no
               and t.partgroup_no = B.partgroup_no
               );

    --主表中是否已存在该条记录
    MERGE INTO MM_JISI_PART_IMP A
    USING (SELECT distinct C.PARTGROUP_ID,C.part_no,PG.PARTGROUP_NO
             FROM MM_JISI_PART C, MM_JISI_PART_IMP B,MM_JISI_PARTGROUP PG
            WHERE B.check_result = 1
              AND B.imp_uuid = in_var_uuid
              AND B.part_no = C.part_no
              AND PG.id = C.partGroup_id
              AND B.partgroup_no in (select distinct h.partgroup_no from mm_jisi_partgroup h where h.id = c.partgroup_id )
              ) D
    ON (A.part_no = D.part_no AND A.partgroup_no = D.PARTGROUP_NO AND A.IMP_UUID = in_var_uuid)
    WHEN MATCHED THEN
      UPDATE
         SET A.CHECK_RESULT = 0,
             A.OPE_TYPE   = 'U',
             A.CHECK_INFO = A.CHECK_INFO || '数据已存在;';

    OUT_ERROR_FLAG    := '0';
    out_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MM_PUP.PUP_FIX_TIME_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

 end JISI_PART_CHECK;
--***************************************************************************
--存储过程名：USP_MM_PART_IMPORT
    --功能描述：属地零件导入确认
    --参数说明：
    --OUT_ERROR_FLAG 返回错误标识
    --OUT_OUT_ERROR_MSG 返回错误信息
    --创建人员: lxh
    --创建时间： 2018/11/8
  PROCEDURE USP_MM_PART_IMPORT(OUT_ERROR_FLAG    OUT VARCHAR2,
                               OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
    v_row_num number(10);
  BEGIN
    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';
    FOR CUR IN (SELECT id,
                       new_part_no,
                       new_supplier_no,
                       new_unload_port,
                       new_repare_person,
                       new_carpool,
                       new_distri_person,
                       new_location,
                       new_station_code,
                       new_shelf_no,
                       new_location_num,
                       new_storage,
                       new_dept_no,
                       old_part_no,
                       old_supplier_no,
                       old_unload_port,
                       old_repare_person,
                       old_carpool,
                       old_distri_person,
                       old_location,
                       old_station_code,
                       old_shelf_no,
                       old_location_num,
                       old_storage,
                       old_dept_no,
                       model_code,
                       OPERATION_TYPE,
                       eff_start,
                       eff_end,
                       deal_flag,
                       check_flag,
                       FACTORY_CODE,
                       OLD_WORK_CENTER,
                       NEW_WORK_CENTER,
                       OLD_WARE_CODE,
                       NEW_WARE_CODE
                  FROM MM_INV_PART_LOCATION_TEMP
                 WHERE deal_flag = '0'
                   AND CHECK_FLAG = '1') LOOP
      --利用业务主键来做更新删除的条件
      --PART_NO, SUPPLIER_NO, WARE_CODE, STATION_CODE, FACTORY_CODE
      IF CUR.OPERATION_TYPE = '废止' THEN
        DELETE FROM MM_INV_PART_LOCATION
         WHERE part_no = CUR.OLD_PART_NO
           AND supplier_no = CUR.OLD_SUPPLIER_NO
           AND WARE_CODE = CUR.OLD_WARE_CODE
           AND station_code = CUR.OLD_STATION_CODE
           AND FACTORY_CODE = CUR.FACTORY_CODE;
      ELSIF CUR.OPERATION_TYPE = '移动' THEN
        UPDATE MM_INV_PART_LOCATION
           SET part_no        = CUR.NEW_PART_NO,
               supplier_no    = CUR.NEW_SUPPLIER_NO,
               station_code   = CUR.NEW_STATION_CODE,
               unload_port    = CUR.NEW_UNLOAD_PORT,
               prepare_person = CUR.NEW_REPARE_PERSON,
               carpool        = CUR.NEW_CARPOOL,
               distri_person  = CUR.NEW_DISTRI_PERSON,
               location       = CUR.NEW_LOCATION,
               shelf_no       = CUR.NEW_SHELF_NO,
               location_num   = CUR.NEW_LOCATION_NUM,
               dep_no         = cur.new_dept_no,
               model_code     = CUR.MODEL_CODE,
               storage        = CUR.OLD_STORAGE,
               FACTORY_CODE   = CUR.FACTORY_CODE,
               WORKCENTER     = CUR.NEW_WORK_CENTER,
               WARE_CODE      = CUR.NEW_WARE_CODE,
               eff_start      = CUR.EFF_START,
               EFF_END        = CUR.EFF_END
         WHERE part_no = CUR.OLD_PART_NO
           AND supplier_no = CUR.OLD_SUPPLIER_NO
           AND WARE_CODE = CUR.OLD_WARE_CODE
           AND station_code = CUR.OLD_STATION_CODE
           AND FACTORY_CODE = CUR.FACTORY_CODE;
      ELSIF CUR.OPERATION_TYPE = '新增' THEN
        INSERT INTO MM_INV_PART_LOCATION
          (ID,
           part_no,
           supplier_no,
           station_code,
           unload_port,
           prepare_person,
           carpool,
           distri_person,
           location,
           shelf_no,
           location_num,
           model_code,
           storage,
           eff_start,
           EFF_END,
           FACTORY_CODE,
           WORKCENTER,
           WARE_CODE,
           dep_no)
        VALUES
          (SEQ_MM_INV_PART_LOCATION.NEXTVAL,
           CUR.NEW_PART_NO,
           CUR.NEW_SUPPLIER_NO,
           CUR.NEW_STATION_CODE,
           CUR.NEW_UNLOAD_PORT,
           CUR.NEW_REPARE_PERSON,
           CUR.NEW_CARPOOL,
           CUR.NEW_DISTRI_PERSON,
           CUR.NEW_LOCATION,
           CUR.NEW_SHELF_NO,
           CUR.NEW_LOCATION_NUM,
           CUR.MODEL_CODE,
           CUR.NEW_STORAGE,
           CUR.EFF_START,
           CUR.EFF_END,
           CUR.FACTORY_CODE,
           CUR.NEW_WORK_CENTER,
           CUR.NEW_WARE_CODE,
           cur.new_dept_no);
      END IF;
      UPDATE MM_INV_PART_LOCATION_TEMP SET DEAL_FLAG = 1 WHERE ID = CUR.ID;
    END LOOP;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_SPS_CONFIG_IMPORT.USP_DEMO_TEST',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;

  END USP_MM_PART_IMPORT;
  --***************************************************************************
  --存储过程名：USP_MM_PUB_DELETE_IMP_TABLE
  --功能描述：清除导入临时表数据
  --参数说明：
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: dtp
  --创建时间： 2019/04/22
  --***************************************************************************
  PROCEDURE USP_MM_PUB_DELETE_IMP_TABLE(OUT_ERROR_FLAG    OUT VARCHAR2,
                               OUT_OUT_ERROR_MSG OUT VARCHAR2) IS
    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);
    v_delete_sql VARCHAR2(256);
  BEGIN
  --定时清除导入临时表
  for cur_tab in (
      select * from mm_pub_delete_imp_table t
             where t.is_delete = '1'
             order by t.id
    )
    loop
      v_delete_sql := 'DELETE FROM ' || cur_tab.Table_Name ||  ' WHERE CREATION_TIME < SYSDATE - 1;';
      execute immediate v_delete_sql;
      update mm_pub_delete_imp_table t set
             t.last_delete_time = sysdate
             where t.id = cur_tab.id;
    end loop;
  COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_SPS_CONFIG_IMPORT.USP_DEMO_TEST',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END USP_MM_PUB_DELETE_IMP_TABLE;
  --***************************************************************************

end PKG_PUB_CHECK;
/

prompt
prompt Creating package body PKG_PUB_DTP
prompt =================================
prompt
create or replace package body PKG_PUB_DTP is

  --****************************************************************************
  --函数  : USF_GET_BATCH_CYCLE
  --功能描述: 获取批次循环基数
  --参数说明:
  -- in_plan_code  :信息点
  --返回值: 批次循环基数
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCH_CYCLE(in_plan_code in varchar2) RETURN NUMBER AS
    out_batch_cycle mm_mon_kb.batch_cycle_num%type;
  BEGIN
    for cur_kb in (select b.batch_cycle_num
                     from mm_pub_plan_code a, mm_mon_kb b
                    where a.kb_id = b.id
                      and a.plan_code = in_plan_code) loop
      out_batch_cycle := cur_kb.batch_cycle_num;
    end loop;
    return out_batch_cycle;
  END USF_GET_BATCH_CYCLE;

  --****************************************************************************
  --函数  : USF_GET_PROCESS_CYCLE
  --功能描述: 获取进度循环基数
  --参数说明:
  -- in_plan_code  :信息点
  --返回值: 进度循环基数
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_PROCESS_CYCLE(in_plan_code in varchar2) RETURN NUMBER AS
    out_process_cycle mm_mon_kb.process_cycle_num%type;
  BEGIN
    for cur_kb in (select b.process_cycle_num
                     from mm_pub_plan_code a, mm_mon_kb b
                    where a.kb_id = b.id
                      and a.plan_code = in_plan_code) loop
      out_process_cycle := cur_kb.process_cycle_num;
    end loop;
    return out_process_cycle;
  END USF_GET_PROCESS_CYCLE;

  --****************************************************************************
  --函数名  : USF_GET_BATCH_NO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 批次号
  --创建人员: wxl
  --创建时间: 2018-11-12
  --****************************************************************************
  FUNCTION USF_GET_BATCHNO_BY_PRODSEQNO(in_kb_id         in number,
                                        in_product_seqno in number)
    RETURN NUMBER AS
    out_batch_no    mm_mon_kb.curr_batch_no%type;
    v_batch_cycle   mm_mon_kb.batch_cycle_num%type; --批次循环基数
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取批次循环基数和进度循环基数
    for cur_kb in (select b.batch_cycle_num, b.process_cycle_num
                     from mm_mon_kb b
                    where b.id = in_kb_id) loop
      v_batch_cycle   := cur_kb.batch_cycle_num;
      v_process_cycle := cur_kb.process_cycle_num;
    end loop;

    --计算批次号
    if in_product_seqno < 1 then
      out_batch_no := mod(ceil((1 - in_product_seqno) / v_process_cycle),
                          v_batch_cycle);
      if out_batch_no = 0 then
        out_batch_no := v_batch_cycle;
      end if;
      out_batch_no := v_batch_cycle - out_batch_no + 1;
    else
      out_batch_no := mod(ceil(in_product_seqno / v_process_cycle),
                          v_batch_cycle);
      if out_batch_no = 0 then
        out_batch_no := v_batch_cycle;
      end if;
    end if;
    return out_batch_no;
  END USF_GET_BATCHNO_BY_PRODSEQNO;

  --****************************************************************************
  --函数名  : USF_GET_PROCESSNO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 进度号
  --创建人员: wxl
  --创建时间: 2018-11-12
  --****************************************************************************
  FUNCTION USF_GET_PROCESSNO_BY_PRODSEQNO(in_kb_id         in number,
                                          in_product_seqno in number)
    RETURN NUMBER AS
    out_process_no  mm_mon_kb.curr_process_no%type;
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取进度循环基数
    for cur_kb in (select b.process_cycle_num
                     from mm_mon_kb b
                    where b.id = in_kb_id) loop
      v_process_cycle := cur_kb.process_cycle_num;
    end loop;

    --计算进度号
    if in_product_seqno < 1 then
      out_process_no := v_process_cycle -
                        mod(1 - in_product_seqno, v_process_cycle) + 1;
    else
      out_process_no := v_process_cycle -
                        mod(in_product_seqno, v_process_cycle) + 1;
    end if;
    if out_process_no = v_process_cycle + 1 then
      out_process_no := 1;
    end if;

    return out_process_no;
  END USF_GET_PROCESSNO_BY_PRODSEQNO;

  --****************************************************************************
  --函数名  : USF_GET_BATCH_NO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCHNO_BY_PRODSEQNO(in_plan_code     in varchar2,
                                        in_product_seqno in number)
    RETURN NUMBER AS
    out_batch_no    mm_mon_kb.curr_batch_no%type;
    v_batch_cycle   mm_mon_kb.batch_cycle_num%type; --批次循环基数
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取批次循环基数和进度循环基数
    v_batch_cycle   := USF_GET_BATCH_CYCLE(in_plan_code);
    v_process_cycle := USF_GET_PROCESS_CYCLE(in_plan_code);

    --计算批次号
    if in_product_seqno < 1 then
      out_batch_no := mod(ceil((1 - in_product_seqno) / v_process_cycle),
                          v_batch_cycle);
      if out_batch_no = 0 then
        out_batch_no := v_batch_cycle;
      end if;
      out_batch_no := v_batch_cycle - out_batch_no + 1;
    else
      out_batch_no := mod(ceil(in_product_seqno / v_process_cycle),
                          v_batch_cycle);
      if out_batch_no = 0 then
        out_batch_no := v_batch_cycle;
      end if;
    end if;
    return out_batch_no;
  END USF_GET_BATCHNO_BY_PRODSEQNO;

  --****************************************************************************
  --函数名  : USF_GET_PROCESSNO_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 进度号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_PROCESSNO_BY_PRODSEQNO(in_plan_code     in varchar2,
                                          in_product_seqno in number)
    RETURN NUMBER AS
    out_process_no  mm_mon_kb.curr_process_no%type;
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取进度循环基数
    v_process_cycle := USF_GET_PROCESS_CYCLE(in_plan_code);

    --计算进度号
    if in_product_seqno < 1 then
      out_process_no := v_process_cycle -
                        mod(1 - in_product_seqno, v_process_cycle) + 1;
    else
      out_process_no := v_process_cycle -
                        mod(in_product_seqno, v_process_cycle) + 1;
    end if;
    if out_process_no = v_process_cycle + 1 then
      out_process_no := 1;
    end if;

    return out_process_no;
  END USF_GET_PROCESSNO_BY_PRODSEQNO;

  --****************************************************************************
  --函数名  : USF_GET_PRODSEQNO_BY_BATCH
  --功能描述: 根据批次获取产品流水号
  --参数说明:
  -- in_plan_code  :信息点
  -- in_batch_no  :批次号
  -- in_process_no  :进度号
  --返回值  : 产品流水号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_PRODSEQNO_BY_BATCH(in_plan_code  in varchar2,
                                      in_batch_no   in number,
                                      in_process_no in number) RETURN NUMBER AS
    out_product_seqno  mm_mon_kb.curr_batch_seqno%type;
    v_batch_cycle      mm_mon_kb.batch_cycle_num%type; --批次循环基数
    v_process_cycle    mm_mon_kb.process_cycle_num%type; --进度循环基数
    v_kb_batch_no      mm_mon_kb.curr_batch_no%type; --看板批次号
    v_kb_process_no    mm_mon_kb.curr_process_no%type; --看板进度号
    v_kb_product_seqno mm_mon_kb.product_seqno%type; --看板产品流水号
  BEGIN
    --获取批次循环基数
    v_batch_cycle := USF_GET_BATCH_CYCLE(in_plan_code);
    --获取进度循环基数
    v_process_cycle := USF_GET_PROCESS_CYCLE(in_plan_code);
    if in_batch_no <= 0 or in_batch_no > v_batch_cycle or
       in_process_no <= 0 or in_process_no > v_process_cycle then
      return out_product_seqno;
    end if;

    --获取当前看板的相关信息
    for cur_kb in (select b.curr_batch_no,
                          b.curr_process_no,
                          b.product_seqno
                     from mm_pub_plan_code a, mm_mon_kb b
                    where a.kb_id = b.id
                      and a.plan_code = in_plan_code) loop
      v_kb_batch_no      := cur_kb.curr_batch_no;
      v_kb_process_no    := cur_kb.curr_process_no;
      v_kb_product_seqno := cur_kb.product_seqno;
      --计算当前批次循环，首台产品流水号
      out_product_seqno := v_kb_product_seqno -
                           v_kb_batch_no * v_process_cycle +
                           v_kb_process_no;
      --计算传入批次对应产品流水号
      out_product_seqno := out_product_seqno +
                           in_batch_no * v_process_cycle - in_process_no;
    end loop;

    return out_product_seqno;
  END USF_GET_PRODSEQNO_BY_BATCH;

  --****************************************************************************
  --函数名  : USF_GET_BATCHSEQ_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次流水号
  --参数说明:
  -- in_kb_id  :看板ID
  -- in_product_seqno  :产品流水号
  --返回值  : 批次流水号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCHSEQ_BY_PRODSEQNO(in_kb_id         in number,
                                         in_product_seqno in number)
    RETURN NUMBER AS
    out_batch_seqno mm_mon_kb.curr_batch_seqno%type;
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取进度循环基数
    --获取批次循环基数和进度循环基数
    for cur_kb in (select b.batch_cycle_num, b.process_cycle_num
                     from mm_mon_kb b
                    where b.id = in_kb_id) loop
      v_process_cycle := cur_kb.process_cycle_num;
    end loop;

    --计算批次流水流水号
    if v_process_cycle is not null then
      out_batch_seqno := ceil(in_product_seqno / v_process_cycle);
    end if;

    return out_batch_seqno;
  END USF_GET_BATCHSEQ_BY_PRODSEQNO;

  --****************************************************************************
  --函数名  : USF_GET_BATCHSEQ_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取批次流水号
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次流水号
  --创建人员: wxl
  --创建时间: 2018-09-10
  --****************************************************************************
  FUNCTION USF_GET_BATCHSEQ_BY_PRODSEQNO(in_plan_code     in varchar2,
                                         in_product_seqno in number)
    RETURN NUMBER AS
    out_batch_seqno mm_mon_kb.curr_batch_seqno%type;
    v_process_cycle mm_mon_kb.process_cycle_num%type; --进度循环基数
  BEGIN
    --获取进度循环基数
    v_process_cycle := USF_GET_PROCESS_CYCLE(in_plan_code);

    --计算批次流水流水号
    if v_process_cycle is not null then
      out_batch_seqno := ceil(in_product_seqno / v_process_cycle);
    end if;

    return out_batch_seqno;
  END USF_GET_BATCHSEQ_BY_PRODSEQNO;

  --****************************************************************************
  --函数名  : USF_GET_WORK_DATE
  --功能描述: 根据输入的时间获取当前工作日期(不包含时分秒)
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_time  :输入时间
  --返回值  : 工作日期(不包含时分秒)
  --创建人员: wxl
  --创建时间: 2018-09-11
  --****************************************************************************
  FUNCTION USF_GET_WORK_DATE(in_factory_code in varchar2,
                             in_workcenter   in varchar2,
                             in_time         in date) RETURN DATE AS
    out_work_date date;
  BEGIN
    --根据生产工作日历表获取输入时间对应的工作日期
    for cur_work_date in (select a.work_date
                            from mm_pub_work_calendar a
                           where a.factory_code = in_factory_code
                             and a.workcenter = in_workcenter
                             and a.work_start_time <= in_time
                             and a.work_end_time >= in_time) loop
      out_work_date := cur_work_date.work_date;
      exit;
    end loop;
    --如果未维护工作日历，则获取输入时间的日期为工作日期
    if out_work_date is null then
      out_work_date := to_date(to_char(in_time, 'yyyy-mm-dd'), 'yyyy-mm-dd');
    end if;

    return out_work_date;
  END USF_GET_WORK_DATE;

  --****************************************************************************
  --函数名  : USF_GET_PRODUCE_TIME
  --功能描述: 获取生产节拍
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  FUNCTION USF_GET_PRODUCE_TIME(in_factory_code    in varchar2,
                                in_workcenter      in varchar2,
                                in_production_line in varchar2) RETURN NUMBER AS
    out_produce_time number(10, 3); --生产节拍
  BEGIN
    --获取生产节拍
    for cur_produce_time in (select produce_time
                               from (select a.produce_time,
                                            row_number() over(PARTITION BY a.factory_code, a.workcenter order by a.eff_date desc) sn
                                       from mm_pub_tact_time a
                                      where a.factory_code = in_factory_code
                                        and a.workcenter = in_workcenter
                                        and ((in_production_line is not null and
                                            a.production_line =
                                            in_production_line) or
                                            (in_production_line is null and
                                            a.production_line in
                                            ('WE_MAIN',
                                               'PA_MAIN',
                                               'AF_MAIN')))
                                        and a.eff_date > sysdate)
                              where sn = 1) loop
      out_produce_time := cur_produce_time.produce_time;
      exit;
    end loop;
    RETURN out_produce_time;
  END USF_GET_PRODUCE_TIME;

  --****************************************************************************
  --函数名  : USF_GET_CAL_WORKTIME
  --功能描述: 获取工厂车间某一时间点前几秒或后几秒的工作时间
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  -- in_time  :输入时间
  -- in_num_offset  :  偏移秒数(单位:秒)
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2019-01-20
  --****************************************************************************
  FUNCTION USF_GET_CAL_WORKTIME(in_factory_code in varchar2,
                                in_workcenter   in varchar2,
                                in_time         in date,
                                in_num_offset   in number) RETURN DATE AS
    out_time date; --计算后时间
  BEGIN
    if in_factory_code is null or in_workcenter is null or in_time is null THEN
      return null;
    end if;
    if in_num_offset > 0 then
      out_time := USF_GET_NEXT_WORKTIME(in_factory_code,
                                        in_workcenter,
                                        in_time,
                                        in_num_offset);
    elsif in_num_offset < 0 then
      out_time := USF_GET_PRE_WORKTIME(in_factory_code,
                                       in_workcenter,
                                       in_time,
                                       in_num_offset);
    else
      out_time := in_time;
    end if;
    return out_time;
  END USF_GET_CAL_WORKTIME;

  --****************************************************************************
  --函数名  : USF_GET_PRE_WORKTIME
  --功能描述: 获取工厂车间某一时间点前几秒的工作时间
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  -- in_time  :输入时间
  -- in_num_offset  :  偏移秒数(负数，单位:秒)
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  FUNCTION USF_GET_PRE_WORKTIME(in_factory_code in varchar2,
                                in_workcenter   in varchar2,
                                in_time         in date,
                                in_num_offset   in number) RETURN DATE AS
    v_num_offset  number; --偏移天数
    v_cal_time    date; --此次计算时间
    v_s_rest_time date; --开始休息时间
    v_e_rest_time date; --结束休息时间
    out_time      date; --计算后时间
  BEGIN
    if in_time is null OR in_num_offset >= 0 THEN
      return null;
    end if;

    --偏移秒数转化为天
    v_num_offset := in_num_offset / (24 * 3600);
    v_cal_time   := in_time;
    out_time     := v_cal_time + v_num_offset;
    --按工作日、班组顺序遍历工作日历
    for cur_work in (select a.id, a.work_start_time, a.work_end_time
                       from mm_pub_work_calendar a
                      where a.factory_code = in_factory_code
                        and a.workcenter = in_workcenter
                        and a.work_start_time < in_time
                      order by a.work_date desc, a.shift_code desc) loop
      --计算时间比结束工作时间大时,计算时间为结束工作时间
      if v_cal_time > cur_work.work_end_time then
        out_time   := cur_work.work_end_time + (out_time - v_cal_time);
        v_cal_time := cur_work.work_end_time;
      end if;
      --按休息时间先后遍历休息日历
      for cur_rest in (select start_time, end_time
                         from mm_pub_work_calendar_detail
                        where work_calendar_id = cur_work.id
                          and time_type = '1' --???类型
                          and start_time < v_cal_time
                        order by start_time desc) loop
        --如果开始休息时间比开始工作时间小,为开始工作时间
        if cur_rest.start_time < cur_work.work_start_time then
          v_s_rest_time := cur_work.work_start_time;
        else
          v_s_rest_time := cur_rest.start_time;
        end if;
        --如果结束休息时间比结束工作时间大，为结束工作时间
        if cur_rest.end_time > cur_work.work_end_time then
          v_e_rest_time := cur_work.work_end_time;
        else
          v_e_rest_time := cur_rest.end_time;
        end if;
        --如果计算时间位于休息时间内,计算时间为开始休息时间
        if v_cal_time >= v_s_rest_time and v_cal_time < v_e_rest_time then
          out_time   := v_s_rest_time + (out_time - v_cal_time);
          v_cal_time := v_s_rest_time;
        else
          --如果计算时间???
          if out_time < v_e_rest_time THEN
            v_cal_time := v_s_rest_time;
            out_time   := out_time + (v_s_rest_time - v_e_rest_time);
          else
            GOTO firstloop;
          end if;
        end if;
      end loop;
      --如果计算后时间位于当前的工作日内，退出
      if out_time > cur_work.work_start_time then
        exit;
      else
        v_cal_time := cur_work.work_start_time;
      end if;
    end loop;
    <<firstloop>>
    return out_time;
  END USF_GET_PRE_WORKTIME;

  --****************************************************************************
  --函数名  : USF_GET_NEXT_WORKTIME
  --功能描述: 获取工厂车间某一时间点后几秒的工作时间
  --参数说明:
  -- in_factory_code  :工厂
  -- in_workcenter  :工作中心
  -- in_production_line  :生产线
  -- in_time  :输入时间
  -- in_num_offset  :  偏移秒数(正数，单位:秒)
  --返回值  : 生产节拍
  --创建人员: wxl
  --创建时间: 2018-09-12
  --****************************************************************************
  FUNCTION USF_GET_NEXT_WORKTIME(in_factory_code in varchar2,
                                 in_workcenter   in varchar2,
                                 in_time         in date,
                                 in_num_offset   in number) RETURN DATE AS
    v_num_offset  number; --偏移天数
    v_cal_time    date; --此次计算时间
    v_s_rest_time date; --开始休息时间
    v_e_rest_time date; --结束休息时间
    out_time      date; --计算后时间
  BEGIN
    if in_time is null OR in_num_offset < 0 THEN
      return null;
    end if;
    --偏移秒数转化为天
    v_num_offset := in_num_offset / (24 * 3600);
    v_cal_time   := in_time;
    out_time     := v_cal_time + v_num_offset;
    --按工作日、班组顺序遍历工作日历
    for cur_work in (select a.id, a.work_start_time, a.work_end_time
                       from mm_pub_work_calendar a
                      where a.factory_code = in_factory_code
                        and a.workcenter = in_workcenter
                        and a.work_end_time > in_time
                      order by a.work_date, a.shift_code) loop
      --计算时间比开始工作时间小时,计算时间为开始工作时间
      if v_cal_time < cur_work.work_start_time then
        out_time   := cur_work.work_start_time + (out_time - v_cal_time);
        v_cal_time := cur_work.work_start_time;
      end if;
      --按休息时间先后遍历休息日历
      for cur_rest in (select start_time, end_time
                         from mm_pub_work_calendar_detail
                        where work_calendar_id = cur_work.id
                          and time_type = '1' --???类型
                          and end_time > v_cal_time
                        order by start_time) loop
        --如果开始休息时间比开始工作时间小,为开始工作时间
        if cur_rest.start_time < cur_work.work_start_time then
          v_s_rest_time := cur_work.work_start_time;
        else
          v_s_rest_time := cur_rest.start_time;
        end if;
        --如果结束休息时间比结束工作时间大，为结束工作时间
        if cur_rest.end_time > cur_work.work_end_time then
          v_e_rest_time := cur_work.work_end_time;
        else
          v_e_rest_time := cur_rest.end_time;
        end if;
        --如果计算时间位于休息时间内,计算时间为结束休息时间
        if v_cal_time >= v_s_rest_time and v_cal_time < v_e_rest_time then
          out_time   := out_time + (v_e_rest_time - v_cal_time);
          v_cal_time := v_e_rest_time;
        else
          --如果计算时间???
          if out_time > v_s_rest_time THEN
            v_cal_time := v_e_rest_time;
            out_time   := out_time + (v_e_rest_time - v_s_rest_time);
          else
            GOTO firstloop;
          end if;
        end if;
      end loop;
      --如果计算后时间位于当前的工作日内，退出
      if out_time < cur_work.work_end_time then
        exit;
      else
        v_cal_time := cur_work.work_end_time;
      end if;
    end loop;
    <<firstloop>>
    return out_time;
  END USF_GET_NEXT_WORKTIME;

  --****************************************************************************
  --函数名  : USF_GET_SYS_PARAM
  --功能描述: 获取系统参数
  --参数说明:
  -- in_factory_code  :工厂
  -- in_param_group  :参数组
  -- in_param_code  :参数代码
  --返回值  : 参数值
  --创建人员: wxl
  --创建时间: 2018-09-11
  --****************************************************************************
  FUNCTION USF_GET_SYS_PARAM(in_factory_code in varchar2,
                             in_param_group  in varchar2,
                             in_param_code   in varchar2) RETURN VARCHAR2 AS
    out_param_val mm_pub_sys_param.param_val%type;
  BEGIN
    for cur_param in (select a.param_val
                        from mm_pub_sys_param a
                       where a.factory_code = in_factory_code
                         and a.param_group = in_param_group
                         and a.param_code = in_param_code) loop
      out_param_val := cur_param.param_val;
      exit;
    end loop;

    return out_param_val;
  END USF_GET_SYS_PARAM;

  --****************************************************************************
  --方法名 : USF_GET_DICT
  --功能描述: 拉动计算车辆报废重投处理
  --输入参数:
  -- in_factory_code  :工厂代码
  -- in_code_type  :数据字典类型
  -- in_code_value  :数据字典代码
  --输出参数 : 数据字典名称
  --创建人员: wxl
  --创建时间: 2018-12-04
  --****************************************************************************
  FUNCTION USF_GET_DICT(in_factory_code in varchar2,
                        in_code_type    in varchar2,
                        in_code_value   in varchar2) RETURN VARCHAR2 AS
    out_code_value_name mm_pub_data_dict.code_value_name%type;
  BEGIN
    for cur_dict in (select a.code_value_name
                       from mm_pub_data_dict a
                      where a.factory_code = in_factory_code
                        and a.code_type = in_code_type
                        and a.code_value = in_code_value) loop
      out_code_value_name := cur_dict.code_value_name;
      exit;
    end loop;

    return out_code_value_name;
  END USF_GET_DICT;

  --****************************************************************************
  --函数名  : USF_GET_ORDER_NO
  --功能描述: 获取物流订单号
  --参数说明:
  -- in_plan_code  :信息点
  --返回值  : 物流订单号
  --创建人员: wxl
  --创建时间: 2018-09-13
  --修改记录：
  --          调整单据前缀、单据流水表结构 mod by wxl 20190128
  --****************************************************************************
  FUNCTION USF_GET_ORDER_NO(in_plan_code in varchar2) RETURN VARCHAR2 AS
    v_curr_time      date; --当前时间
    v_bill_prefix_id mm_pub_bill_prefix.id%type; --单据前缀ID
    v_factory_str    varchar2(1); --工厂
    v_order_str      varchar2(1); --单据代码
    v_year_str       varchar2(2); --年
    v_month_str      varchar(2); --月
    v_day_str        varchar(2); --日
    v_order_pre      varchar(7); --订单前缀：工厂1||单据代码1||年2||月1||日1
    v_seq_pre        varchar(4); --流水前缀
    v_seq_no         number(4); --数字流水
    v_seq_length     number(3); --流水位数
    v_seq_str        varchar(4); --流水号
    v_str            varchar(1); --单字符
    v_i              number; --临时计数
    v_flag           number; --临时标识
    out_order_no     varchar2(10); --订单前缀||流水3
  BEGIN
    v_curr_time := to_date(to_char(sysdate, 'yyyy-mm-dd'), 'yyyy-mm-dd');

    --获取工厂、订单前缀
    for cur_config in (select a.id,
                              a.factory_code_str,
                              a.bill_group_type_str
                         from mm_pub_bill_prefix a, mm_pub_plan_code b
                        where a.bill_group = 'ORDER'
                          and a.plan_code = b.plan_code
                          and a.plan_code = in_plan_code) loop
      v_bill_prefix_id := cur_config.id;
      v_factory_str    := cur_config.factory_code_str;
      v_order_str      := cur_config.bill_group_type_str;
    end loop;
    if v_bill_prefix_id is null then
      return out_order_no;
    end if;

    v_year_str  := to_char(v_curr_time, 'yy');
    v_month_str := to_number(to_char(v_curr_time, 'mm'));
    if v_month_str = 10 then
      v_month_str := 'X';
    elsif v_month_str = 11 then
      v_month_str := 'Y';
    elsif v_month_str = 12 then
      v_month_str := 'Z';
    end if;
    v_day_str   := to_char(v_curr_time, 'dd');
    v_order_pre := v_factory_str || v_order_str || v_year_str ||
                   v_month_str || v_day_str;

    --获取订单流水号
    select count(*)
      into v_flag
      from mm_pub_bill_sn a
     where a.bill_prefix_id = v_bill_prefix_id
       and a.bill_pre_str = v_order_pre
       and a.use_date = v_curr_time;
    if v_flag = 0 then
      v_seq_no  := 1;
      v_seq_str := lpad(1, 3, '0');
      --新增订单流水记录
      insert into mm_pub_bill_sn
        (bill_prefix_id, bill_pre_str, use_date, seq_pre_str, seq_no)
      values
        (v_bill_prefix_id, v_order_pre, v_curr_time, v_seq_pre, v_seq_no);
    else
      select a.seq_pre_str, a.seq_no + 1
        into v_seq_pre, v_seq_no
        from mm_pub_bill_sn a
       where a.bill_prefix_id = v_bill_prefix_id
         and a.bill_pre_str = v_order_pre
         and a.use_date = v_curr_time;
      if (v_seq_pre is null) then
        v_seq_length := 3;
      else
        --获取数字流水位数
        v_seq_length := 3 - length(v_seq_pre);
      end if;
      --判断数字流水是否超出
      if length(v_seq_no) <= v_seq_length then
        v_seq_str := v_seq_pre || lpad(v_seq_no, v_seq_length, '0');
      else
        v_i := length(v_seq_pre);
        if v_i is null then
          v_i := 1;
        end if;
        while v_i >= 1 loop
          --获取流水前缀最后一位字符
          v_str := substr(v_seq_pre, v_i, 1);
          if v_str is null or v_str = 'Z' then
            if v_i = 1 then
              --已有前缀位已用完
              if length(v_seq_pre) is null then
                v_seq_pre := lpad('A', 1, 'A');
              else
                v_seq_pre := lpad('A', length(v_seq_pre) + 1, 'A');
              end if;
            else
              v_seq_pre := substr(v_seq_pre, 0, length(v_seq_pre) - 1) || 'A';
            end if;
            v_i := v_i - 1;
          else
            v_seq_pre := substr(v_seq_pre, 0, v_i - 1) ||
                         chr(ascii(v_str) + 1) ||
                         substr(v_seq_pre, v_i + 1, length(v_seq_pre));
            exit;
          end if;
        end loop;
        v_seq_length := 3 - length(v_seq_pre);
        v_seq_no     := 1;
        v_seq_str    := v_seq_pre || lpad(v_seq_no, v_seq_length, '0');
      end if;
      if length(v_seq_str) > 3 then
        return null;
      end if;
      --更新订单流水记录
      update mm_pub_bill_sn a
         set a.seq_pre_str = v_seq_pre, a.seq_no = v_seq_no
       where a.bill_prefix_id = v_bill_prefix_id
         and a.bill_pre_str = v_order_pre
         and a.use_date = v_curr_time;
    end if;
    --生成订单号
    out_order_no := v_order_pre || v_seq_str;

    return out_order_no;
  END USF_GET_ORDER_NO;

  --****************************************************************************
  --函数名  : USF_GET_ORDER_NO_BY_DATE
  --功能描述: 获取物流订单号
  --参数说明:
  -- in_factory_code  :工厂
  -- in_order_type  :订单类型：
  --SW 取货订单    M
  --EXC 例外订单    E
  --TRIAL 新车型订单 N
  --JISO同步订单    C
  --JIT 拉动订单   D-H
  -- in_arrive_date: 到货时间
  --返回值  : 物流订单号
  --创建人员: wy
  --创建时间: 2018-09-17
  FUNCTION USF_GET_ORDER_NO_BY_DATE(in_factory_code in varchar2,
                                    in_order_type   in varchar2,
                                    in_arrive_date  in date) RETURN VARCHAR2 AS
    v_curr_time      date; --当前时间
    v_bill_prefix_id mm_pub_bill_prefix.id%type; --单据前缀ID
    v_factory_str    varchar2(1); --工厂
    v_order_str      varchar2(1); --订单
    v_year_str       varchar2(2); --年
    v_month_str      varchar2(2); --月
    v_day_str        varchar(2); --日
    v_order_pre      varchar(7); --订单前缀
    v_seq_pre        varchar(4); --流水前缀
    v_seq_no         number(4); --数字流水
    v_seq_length     number(3); --流水位数
    v_seq_str        varchar(4); --流水号
    v_str            varchar(1); --单字符
    v_i              number;
    v_flag           number; --临时标识
    out_order_no     varchar2(10);
  BEGIN
    v_curr_time := to_date(to_char(in_arrive_date, 'yyyy-mm-dd'),
                           'yyyy-mm-dd');

    --获取工厂、订单前缀
    for cur_config in (select a.id,
                              a.factory_code_str,
                              a.bill_group_type_str
                         from mm_pub_bill_prefix a
                        where a.bill_group = 'ORDER'
                          and a.factory_code = in_factory_code
                          and a.bill_group_type = in_order_type) loop
      v_bill_prefix_id := cur_config.id;
      v_factory_str    := cur_config.factory_code_str;
      v_order_str      := cur_config.bill_group_type_str;
    end loop;
    if v_factory_str is null or v_order_str is null then
      return out_order_no;
    end if;

    v_year_str := to_char(v_curr_time, 'yy');

    v_month_str := to_number(to_char(v_curr_time, 'mm'));
    if v_month_str = 10 then
      v_month_str := 'X';
    elsif v_month_str = 11 then
      v_month_str := 'Y';
    elsif v_month_str = 12 then
      v_month_str := 'Z';
    end if;
    v_day_str   := to_char(v_curr_time, 'dd');
    v_order_pre := v_factory_str || v_order_str || v_year_str ||
                   v_month_str || v_day_str;

    --获取订单流水号
    select count(*)
      into v_flag
      from mm_pub_bill_sn a
     where a.bill_prefix_id = v_bill_prefix_id
       and a.bill_pre_str = v_order_pre
       and a.use_date = v_curr_time;
    if v_flag = 0 then
      v_seq_no  := 1;
      v_seq_str := lpad(1, 3, '0');
      --新增订单流水记录
      insert into mm_pub_bill_sn
        (bill_prefix_id, bill_pre_str, use_date, seq_pre_str, seq_no)
      values
        (v_bill_prefix_id, v_order_pre, v_curr_time, v_seq_pre, v_seq_no);
    else
      select a.seq_pre_str, a.seq_no + 1
        into v_seq_pre, v_seq_no
        from mm_pub_bill_sn a
       where a.bill_prefix_id = v_bill_prefix_id
         and a.bill_pre_str = v_order_pre
         and a.use_date = v_curr_time;
      if (v_seq_pre is null) then
        v_seq_length := 3;
      else
        --获取数字流水位数
        v_seq_length := 3 - length(v_seq_pre);
      end if;
      --判断数字流水是否超出
      if length(v_seq_no) <= v_seq_length then
        v_seq_str := v_seq_pre || lpad(v_seq_no, v_seq_length, '0');
      else
        v_i := length(v_seq_pre);
        if v_i is null then
          v_i := 1;
        end if;
        while v_i >= 1 loop
          --获取流水前缀最后一位字符
          v_str := substr(v_seq_pre, v_i, 1);
          if v_str is null or v_str = 'Z' then
            if v_i = 1 then
              --已有前缀位已用完
              if length(v_seq_pre) is null then
                v_seq_pre := lpad('A', 1, 'A');
              else
                v_seq_pre := lpad('A', length(v_seq_pre) + 1, 'A');
              end if;
            else
              v_seq_pre := substr(v_seq_pre, 0, length(v_seq_pre) - 1) || 'A';
            end if;
            v_i := v_i - 1;
          else
            v_seq_pre := substr(v_seq_pre, 0, v_i - 1) ||
                         chr(ascii(v_str) + 1) ||
                         substr(v_seq_pre, v_i + 1, length(v_seq_pre));
            exit;
          end if;
        end loop;
        v_seq_length := 3 - length(v_seq_pre);
        v_seq_no     := 1;
        v_seq_str    := v_seq_pre || lpad(v_seq_no, v_seq_length, '0');
      end if;
      if length(v_seq_str) > 3 then
        return null;
      end if;
      --更新订单流水记录
      update mm_pub_bill_sn a
         set a.seq_pre_str = v_seq_pre, a.seq_no = v_seq_no
       where a.bill_prefix_id = v_bill_prefix_id
         and a.bill_pre_str = v_order_pre
         and a.use_date = v_curr_time;
    end if;
    --生成订单号
    out_order_no := v_order_pre || v_seq_str;

    return out_order_no;
  END USF_GET_ORDER_NO_BY_DATE;

  --****************************************************************************
  --函数  : USF_GET_WORKCENTER_PRE
  --功能描述: 获取车间头
  --参数说明:
  -- in_workcenter  :车间
  --返回值: 获取车间头
  --创建人员: wxl
  --创建时间: 2019-01-18
  --****************************************************************************
  FUNCTION USF_GET_WORKCENTER_PRE(in_workcenter in varchar2) RETURN VARCHAR2 AS
    out_worcenter_pre varchar2(1);
  BEGIN
    out_worcenter_pre := SUBSTR(in_workcenter, 1, 1);
    return out_worcenter_pre;
  END USF_GET_WORKCENTER_PRE;

  --****************************************************************************
  --函数名  : USF_GET_SEQUENCE
  --功能描述: 获取数据库序列值
  --参数说明:
  -- in_seq_name    :序列名字
  --返回值  : 下一个序列值
  --创建人员: chenjq
  --创建时间: 2016-11-15
  --****************************************************************************
  FUNCTION USF_GET_SEQUENCE(in_seq_name IN VARCHAR2) RETURN NUMBER AS
    v_seq_next_val number(19); --下一个序列值
  BEGIN
    --获取下一个序列值
    v_seq_next_val := null;
    execute immediate 'SELECT ' || in_seq_name || '.nextval FROM dual'
      INTO v_seq_next_val;
    RETURN v_seq_next_val;
  END USF_GET_SEQUENCE;
  --****************************************************************************
  --函数名  : USF_GET_BATCHPROC_BY_PRODSEQNO
  --功能描述: 根据产品流水号获取 批次-进度
  --参数说明:
  -- in_plan_code  :信息点
  -- in_product_seqno  :产品流水号
  --返回值  : 批次-进度
  --创建人员: dtp
  --创建时间: 2018-10-20
  --****************************************************************************
  FUNCTION USF_GET_BATCHPROC_BY_PRODSEQNO(in_plan_code     in varchar2,
                                          in_product_seqno in number)
    RETURN VARCHAR2 AS
    out_batch_process VARCHAR2(20);
    v_batch_no        mm_mon_kb.curr_batch_no%type; --批次
    v_process_no      mm_mon_kb.curr_process_no%type; --进度
  BEGIN
    IF in_product_seqno IS NULL THEN
      out_batch_process := NULL;
    ELSE
      v_batch_no        := PKG_PUB.USF_GET_BATCHNO_BY_PRODSEQNO(in_plan_code,
                                                                in_product_seqno);
      v_process_no      := PKG_PUB.USF_GET_PROCESSNO_BY_PRODSEQNO(in_plan_code,
                                                                  in_product_seqno);
      out_batch_process := v_batch_no || '-' || v_process_no;
    END IF;
    return out_batch_process;
  END USF_GET_BATCHPROC_BY_PRODSEQNO;

end PKG_PUB_DTP;
/

prompt
prompt Creating package body PKG_PUP_CHECK
prompt ===================================
prompt
create or replace package body PKG_PUP_CHECK is

  --***************************************************************************
  --存储过程名：PUP_PRO_PLAN_CHECK
  --功能描述：生产计划导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: zmj
  --创建时间： 2018/09/17
  PROCEDURE PUP_PRO_PLAN_CHECK(IN_VAR_UUID       IN VARCHAR2,
                               IN_VAR_USERNAME   IN VARCHAR2,
                               IN_VAR_OPEIP      IN VARCHAR2,
                               OUT_ERROR_FLAG    OUT VARCHAR2,
                               OUT_OUT_ERROR_MSG OUT VARCHAR2) IS

    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

  BEGIN
    out_error_flag    := '0';
    out_out_error_msg := '';

    --校验生产订单顺序号是否重复
    update MM_PUP_PRO_PLAN_IMP a
       set a.check_result = 0,
           a.ope_type     = 'U',
           a.CHECK_INFO   = a.CHECK_INFO || '生产订单顺序号重复;'
     where exists (select 1
              from (select b.sort_id
                      from MM_PUP_PRO_PLAN_IMP b
                     where b.imp_uuid = in_var_uuid
                     group by b.sort_id
                    having count(1) > 1) c
             where a.sort_id = c.sort_id)
       and a.imp_uuid = in_var_uuid;

    --校验订单号是否重复
    update MM_PUP_PRO_PLAN_IMP a
       set a.check_result = 0,
           a.ope_type     = 'U',
           a.CHECK_INFO   = a.CHECK_INFO || '整车物料号重复;'
     where exists (select 1
              from (select b.order_no
                      from MM_PUP_PRO_PLAN_IMP b
                     where b.imp_uuid = in_var_uuid
                     group by b.order_no
                    having count(1) > 1) c
             where a.order_no = c.order_no)
       and a.imp_uuid = in_var_uuid;

    --校验分车型排序号是否重复
    update MM_PUP_PRO_PLAN_IMP a
       set a.check_result = 0,
           a.ope_type     = 'U',
           a.CHECK_INFO   = a.CHECK_INFO || '分车型排序号重复;'
     where exists (select 1
              from (select b.single_sort_id
                      from MM_PUP_PRO_PLAN_IMP b
                     where b.imp_uuid = in_var_uuid
                     group by b.single_sort_id
                    having count(1) > 1) c
             where a.single_sort_id = c.single_sort_id)
       and a.imp_uuid = in_var_uuid;

    --EXCEL是否重复
    update MM_PUP_PRO_PLAN_IMP siglt
       set siglt.check_result = 0,
           siglt.ope_type     = 'U',
           siglt.check_info  =
           (nvl(siglt.check_info, '') || 'Excel数据重复;')
     where siglt.id in (select distinct T.id
                          from MM_PUP_PRO_PLAN_IMP t,
                               (select CAR_TYPE,
                                       MARK,
                                       MIX_SORT_ID,
                                       SINGLE_SORT_ID,
                                       AFOFF_TIME
                                  from (select count(*) count,
                                               siglt.CAR_TYPE,
                                               siglt.MARK,
                                               siglt.MIX_SORT_ID,
                                               siglt.SINGLE_SORT_ID,
                                               siglt.AFOFF_TIME
                                          from MM_PUP_PRO_PLAN_IMP siglt
                                         where siglt.imp_uuid = in_var_uuid
                                           and siglt.import_status = '0'
                                         group by siglt.CAR_TYPE,
                                                  siglt.MARK,
                                                  siglt.MIX_SORT_ID,
                                                  siglt.SINGLE_SORT_ID,
                                                  siglt.AFOFF_TIME)
                                 where count > 1) b
                         where t.CAR_TYPE = b.CAR_TYPE
                           and t.MARK = B.MARK
                           and t.MIX_SORT_ID = b.MIX_SORT_ID
                           and t.SINGLE_SORT_ID = b.SINGLE_SORT_ID
                           and t.AFOFF_TIME = b.AFOFF_TIME);

    OUT_ERROR_FLAG    := '0';
    out_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MM_PUP.PUP_FIX_TIME_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END PUP_PRO_PLAN_CHECK;

  --***************************************************************************
  --存储过程名：PUP_FIX_TIME_CHECK
  --功能描述：固定取货导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: zmj
  --创建时间： 2018/09/17
  PROCEDURE PUP_FIX_TIME_CHECK(IN_VAR_UUID       IN VARCHAR2,
                               IN_VAR_USERNAME   IN VARCHAR2,
                               IN_VAR_OPEIP      IN VARCHAR2,
                               OUT_ERROR_FLAG    OUT VARCHAR2,
                               OUT_OUT_ERROR_MSG OUT VARCHAR2) IS

    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

  BEGIN
    out_error_flag    := '0';
    out_out_error_msg := '';

    --校验主键(路线代码，当日车次)是否重复
    update mm_pup_fix_pickup_time_imp a
       set a.check_result = 0,
           a.ope_type     = 'U',
           a.CHECK_INFO   = a.CHECK_INFO || '主键重复;'
     where exists (select 1
              from (select b.route_code, b.today_no
                      from mm_pup_fix_pickup_time_imp b
                     where b.imp_uuid = in_var_uuid
                     group by b.route_code, b.today_no
                    having count(1) > 1) c
             where a.route_code = c.route_code
               and a.today_no = c.today_no)
       and a.imp_uuid = in_var_uuid;

    --EXCEL是否重复
    update mm_pup_fix_pickup_time_imp siglt
       set siglt.check_result = '0',
           siglt.ope_type     = 'U',
           siglt.check_info  =
           (nvl(siglt.check_info, '') || 'Excel数据重复;')
     where siglt.id in (select distinct T.id
                          from mm_pup_fix_pickup_time_imp t,
                               (select factory_code, route_code, today_no
                                  from (select count(*) count,
                                               siglt.factory_code,
                                               siglt.route_code,
                                               siglt.today_no
                                          from mm_pup_fix_pickup_time_imp siglt
                                         where siglt.imp_uuid = in_var_uuid
                                           and siglt.import_status = '0'
                                         group by siglt.factory_code,
                                                  siglt.route_code,
                                                  siglt.today_no)
                                 where count > 1) b
                         where t.factory_code = b.factory_code
                           and t.route_code = b.route_code
                           and t.today_no = b.today_no);

    --主表中是否已存在该条记录
    MERGE INTO mm_pup_fix_pickup_time_imp A
    USING (SELECT B.ID, C.ID PID
             FROM mm_pup_fix_pickup_time C, mm_pup_fix_pickup_time_imp B
            WHERE B.check_result = 1
              AND B.imp_uuid = in_var_uuid
              AND B.route_code = C.route_code
              AND B.today_no = C.today_no
              AND B.factory_code = C.factory_code) D
    ON (D.ID = A.ID AND A.IMP_UUID = in_var_uuid)
    WHEN MATCHED THEN
      UPDATE
         SET A.BUSI_ID    = D.PID,
             A.OPE_TYPE   = 'U',
             A.CHECK_INFO = A.CHECK_INFO || '数据已存在;';

    OUT_ERROR_FLAG    := '0';
    out_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MM_PUP.PUP_FIX_TIME_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END PUP_FIX_TIME_CHECK;

  --***************************************************************************
  --存储过程名：PUP_FIX_TIME_CHECK
  --功能描述： 手工调整订单导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: zmj
  --创建时间： 2018/09/20
  PROCEDURE PUP_MANUAL_ORDER_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                   IN_VAR_USERNAME   IN VARCHAR2,
                                   IN_VAR_OPEIP      IN VARCHAR2,
                                   OUT_ERROR_FLAG    OUT VARCHAR2,
                                   OUT_OUT_ERROR_MSG OUT VARCHAR2) IS

    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

  BEGIN
    out_error_flag    := '0';
    out_out_error_msg := '';

    update MM_PUP_MANU_ORDER_IMP a
       set a.check_result = 0,
           a.CHECK_INFO   = a.CHECK_INFO || '主键(采购单号)重复;'
     where exists (select 1
              from (select b.PURCHASE_NO
                      from MM_PUP_MANU_ORDER_IMP b
                     where b.imp_uuid = in_var_uuid
                     group by b.PURCHASE_NO
                    having count(1) > 1) c
             where a.PURCHASE_NO = c.PURCHASE_NO)
       and a.imp_uuid = in_var_uuid;

    --EXCEL是否重复
    update MM_PUP_MANU_ORDER_IMP siglt
       set siglt.check_result = '0',
           siglt.ope_type     = 'U',
           siglt.check_info  =
           (nvl(siglt.check_info, '') || 'Excel数据重复;')
     where siglt.id in (select distinct T.id
                          from MM_PUP_MANU_ORDER_IMP t,
                               (select ORDER_NO,
                                       PURCHASE_NO,
                                       PICKUP_FLAG,
                                       AREA,
                                       SUP_FACTORY,
                                       CAR_TYPE,
                                       WORKDAY,
                                       PICK_DATE,
                                       ARRIVE_DATE,
                                       ORDER_DATE
                                  from (select count(*) count,
                                               siglt.ORDER_NO,
                                               siglt.PURCHASE_NO,
                                               siglt.PICKUP_FLAG,
                                               siglt.AREA,
                                               siglt.SUP_FACTORY,
                                               siglt.CAR_TYPE,
                                               siglt.WORKDAY,
                                               siglt.PICK_DATE,
                                               SIGLT.ARRIVE_DATE,
                                               siglt.ORDER_DATE
                                          from MM_PUP_MANU_ORDER_IMP siglt
                                         where siglt.imp_uuid = in_var_uuid
                                           and siglt.import_status = '0'
                                         group by siglt.ORDER_NO,
                                                  siglt.PURCHASE_NO,
                                                  siglt.PICKUP_FLAG,
                                                  siglt.AREA,
                                                  siglt.SUP_FACTORY,
                                                  siglt.CAR_TYPE,
                                                  siglt.WORKDAY,
                                                  siglt.PICK_DATE,
                                                  siglt.ARRIVE_DATE,
                                                  siglt.ORDER_DATE)
                                 where count > 1) b
                         where t.ORDER_NO = b.ORDER_NO
                           and t.PURCHASE_NO = b.PURCHASE_NO
                           and t.PICKUP_FLAG = b.PICKUP_FLAG
                           and t.AREA = b.AREA
                           and t.SUP_FACTORY = b.SUP_FACTORY
                           and t.CAR_TYPE = b.CAR_TYPE
                           and t.WORKDAY = b.WORKDAY
                           and t.PICK_DATE = B.PICK_DATE
                           and t.ORDER_DATE = b.ORDER_DATE);

    --主表中是否已存在该条记录
    MERGE INTO MM_PUP_MANU_ORDER_IMP A
    USING (SELECT C.PURCHASE_NO, C.ORDER_NO
             FROM MM_PUP_MANU_ORDER C, MM_PUP_MANU_ORDER_IMP B
            WHERE B.check_result = 1
              AND B.imp_uuid = in_var_uuid
              AND B.PURCHASE_NO = C.PURCHASE_NO) D
    ON (A.PURCHASE_NO = D.PURCHASE_NO AND A.IMP_UUID = in_var_uuid)
    WHEN MATCHED THEN
      UPDATE
         SET A.CHECK_RESULT = '1',
             A.OPE_TYPE     = 'U',
             A.CHECK_INFO   = A.CHECK_INFO || '数据已存在;';

    OUT_ERROR_FLAG    := '0';
    out_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MM_PUP.PUP_MANUAL_ORDER_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END PUP_MANUAL_ORDER_CHECK;

  --***************************************************************************
  --存储过程名：PUP_ROUTE_MESSAGE_CHECK
  --功能描述： 路线信息维护导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip 地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: zmj
  --创建时间： 2018/09/20
  PROCEDURE PUP_ROUTE_MESSAGE_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                    IN_VAR_USERNAME   IN VARCHAR2,
                                    IN_VAR_OPEIP      IN VARCHAR2,
                                    OUT_ERROR_FLAG    OUT VARCHAR2,
                                    OUT_OUT_ERROR_MSG OUT VARCHAR2) IS

    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

  BEGIN
    out_error_flag    := '0';
    out_out_error_msg := '';

    update MM_PUP_ROUTE_IMP a
       set a.check_result = 0,
           a.ope_type     = 'U',
           a.CHECK_INFO   = a.CHECK_INFO || 'Excel数据重复;'
     where exists (select 1
              from (select b.SUP_FACTORY,
                           b.UNLOAD_PORT,
                           b.CAR_TYPE,
                           B.SUPPLIER_NO,
                           b.FACTORY_CODE
                      from MM_PUP_ROUTE_IMP b
                     where b.imp_uuid = in_var_uuid
                     group by b.SUP_FACTORY,
                              b.UNLOAD_PORT,
                              b.CAR_TYPE,
                              B.SUPPLIER_NO,
                              b.FACTORY_CODE
                    having count(1) > 1) c
             where a.SUP_FACTORY = c.SUP_FACTORY
               and a.UNLOAD_PORT = c.UNLOAD_PORT
               and a.CAR_TYPE = c.CAR_TYPE
               AND A.SUPPLIER_NO = C.SUPPLIER_NO
               and a.FACTORY_CODE = c.FACTORY_CODE)
       and a.imp_uuid = in_var_uuid;

    --校验同一路线的合并基准值是否相同
    UPDATE MM_PUP_ROUTE_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = A.CHECK_INFO || '同一路线合并基准值或返空站台不一致;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.ROUTE_CODE IS NOT NULL
       AND EXISTS
     (SELECT 1
              FROM (SELECT D.ROUTE_CODE, D.FACTORY_CODE
                      FROM (SELECT C.ROUTE_CODE, COUNT(1) TNUM, C.FACTORY_CODE
                              FROM (SELECT B.ROUTE_CODE,
                                           B.MERGE_NUM,
                                           B.RET_EMPTY_PLATFORM,
                                           B.FACTORY_CODE
                                      FROM MM_PUP_ROUTE_IMP B
                                     WHERE B.IMP_UUID = IN_VAR_UUID
                                       AND B.IMPORT_STATUS = 0
                                     GROUP BY B.ROUTE_CODE,
                                              B.MERGE_NUM,
                                              B.RET_EMPTY_PLATFORM,
                                              B.FACTORY_CODE) C
                             GROUP BY C.ROUTE_CODE, C.FACTORY_CODE) D
                     WHERE D.TNUM > 1) E
             WHERE A.ROUTE_CODE = E.ROUTE_CODE
               AND A.FACTORY_CODE = E.FACTORY_CODE);

    --EXCEL是否重复
    /*update MM_PUP_ROUTE_IMP siglt
      set siglt.check_result = 0,
          siglt.ope_type     = 'U',
          siglt.check_info  =
          (nvl(siglt.check_info, '') || 'Excel数据重复;')
    where siglt.id in
          (select distinct T.id
             from MM_PUP_ROUTE_IMP t,
                  (select AREA,
                          ROUTE_DIST,
                          SUPPLIER_NO,
                          SUP_CAL_NUM,
                          START_SORT_ID,
                          WARE_CODE,
                          ROUTE_CODE,
                          PICKUP_TYPE,
                          SUP_FACTORY,
                          UNLOAD_PORT,
                          CAR_TYPE,
                          LOC_DEPTH,
                          ADVANCE_ARR_NUM,
                          FIRST_ARRIVE_TIME
                     from (select count(*) count,
                                  siglt.AREA,
                                  siglt.SUPPLIER_NO,
                                  siglt.ROUTE_DIST,
                                  siglt.SUP_CAL_NUM,
                                  siglt.START_SORT_ID,
                                  siglt.WARE_CODE,
                                  siglt.ROUTE_CODE,
                                  siglt.PICKUP_TYPE,
                                  siglt.SUP_FACTORY,
                                  siglt.UNLOAD_PORT,
                                  siglt.CAR_TYPE,
                                  siglt.LOC_DEPTH,
                                  siglt.ADVANCE_ARR_NUM,
                                  siglt.FIRST_ARRIVE_TIME
                             from MM_PUP_ROUTE_IMP siglt
                            where siglt.imp_uuid = in_var_uuid
                              and siglt.import_status = '0'
                            group by siglt.AREA,
                                     siglt.SUPPLIER_NO,
                                     siglt.ROUTE_DIST,
                                     siglt.SUP_CAL_NUM,
                                     siglt.START_SORT_ID,
                                     siglt.WARE_CODE,
                                     siglt.ROUTE_CODE,
                                     siglt.PICKUP_TYPE,
                                     siglt.SUP_FACTORY,
                                     siglt.UNLOAD_PORT,
                                     siglt.CAR_TYPE,
                                     siglt.LOC_DEPTH,
                                     siglt.ADVANCE_ARR_NUM,
                                     siglt.FIRST_ARRIVE_TIME)
                    where count > 1) b
            where t.AREA = b.AREA
              and t.SUPPLIER_NO = b.SUPPLIER_NO
              and t.ROUTE_DIST = b.ROUTE_DIST
              and t.SUP_CAL_NUM = b.SUP_CAL_NUM
              and t.START_SORT_ID = b.START_SORT_ID
              and t.WARE_CODE = b.WARE_CODE
              and t.ROUTE_CODE = b.ROUTE_CODE
              and t.PICKUP_TYPE = b.PICKUP_TYPE
              and t.SUP_FACTORY = b.SUP_FACTORY
              and t.UNLOAD_PORT = b.UNLOAD_PORT
              and t.CAR_TYPE = b.CAR_TYPE
              and t.LOC_DEPTH = b.LOC_DEPTH
              and t.ADVANCE_ARR_NUM = b.ADVANCE_ARR_NUM
              and t.FIRST_ARRIVE_TIME = b.FIRST_ARRIVE_TIME);*/

    OUT_ERROR_FLAG    := '0';
    out_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MM_PUP.PUP_ROUTE_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END PUP_ROUTE_MESSAGE_CHECK;

  --***************************************************************************
  --存储过程名：PUP_PICKUP_PLAN_CHECK
  --功能描述： 取货计划查询Excel导入检查校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip 地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: zmj
  --创建时间： 2018/09/30
  PROCEDURE PUP_PICKUP_PLAN_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                  IN_VAR_USERNAME   IN VARCHAR2,
                                  IN_VAR_OPEIP      IN VARCHAR2,
                                  OUT_ERROR_FLAG    OUT VARCHAR2,
                                  OUT_OUT_ERROR_MSG OUT VARCHAR2) IS

    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

  BEGIN
    out_error_flag    := '0';
    out_out_error_msg := '';

    --判断Excel数据是否重复
    UPDATE MM_SW_PICKUP_PLAN_IMP SPI
       SET SPI.CHECK_RESULT = '0',
           SPI.CHECK_INFO   = NVL(SPI.CHECK_INFO, '') || 'Excel数据重复;'
     WHERE SPI.ID IN (SELECT ID
                        FROM MM_SW_PICKUP_PLAN_IMP
                       WHERE ORDER_NO IN (SELECT SPI.ORDER_NO
                                            FROM MM_SW_PICKUP_PLAN_IMP SPI
                                           WHERE SPI.IMP_UUID = IN_VAR_UUID
                                             AND SPI.CHECK_RESULT = '1'
                                             AND SPI.IMPORT_STATUS = '0'
                                           GROUP BY SPI.ORDER_NO
                                          HAVING COUNT(*) > 1));

    --判断订单号是否存在
    UPDATE MM_SW_PICKUP_PLAN_IMP MSI
       SET MSI.check_result = 0,
           MSI.check_info  =
           (nvl(MSI.check_info, '') || '订单号在系统不存在;')
     where not exists (select 1
              from MM_SW_ORDER MSO
             where MSO.PURCHASE_NO = MSI.PURCHASE_NO
               and MSO.ORDER_NO = MSI.ORDER_NO)
       and MSI.IMP_UUID = IN_VAR_UUID;

    --订单已存在且已分配时不可修改
    /*UPDATE MM_SW_PICKUP_PLAN_IMP SPI
      SET SPI.OPE_TYPE     = 'U',
          SPI.CHECK_RESULT = '1',
          SPI.CHECK_INFO   = NVL(SPI.CHECK_INFO, '') || '订单数据已存在;'
    WHERE SPI.ID IN (SELECT ID
                       FROM MM_SW_PICKUP_PLAN_IMP SPI
                       LEFT OUTER JOIN MM_SW_PICKUP_PLAN SPP
                         ON SPI.ORDER_NO = SPP.ORDER_NO
                        AND SPI.PURCHASE_NO = SPP.PURCHASE_NO
                      WHERE SPI.IMP_UUID = IN_VAR_UUID
                        AND SPI.CHECK_RESULT = '1'
                        AND SPI.IMPORT_STATUS = '0');*/

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MM_PUP.PUP_PICKUP_PLAN_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END PUP_PICKUP_PLAN_CHECK;

  --****************************************************************************
  --过程名  : PUP_PICKUP_PLAN_IMPORT
  --功能描述: 取货计划数据确定导入
  --参数说明:
  --输入：
  --in_var_uuid                  导入的UUID
  --in_var_username              用户名
  --in_var_opeip                 操作IP
  --输出：
  --out_error_flag              返回结果 1：成功，其他：失败
  --out_error_msg               错误信息
  --创建人员: zmj
  --创建时间: 2018-09-30
  --****************************************************************************
  PROCEDURE PUP_PICKUP_PLAN_IMPORT(in_var_uuid     IN VARCHAR2,
                                   in_var_username IN VARCHAR2,
                                   in_var_opeip    IN VARCHAR2,
                                   out_error_flag  OUT VARCHAR2,
                                   out_error_msg   OUT VARCHAR2) AS
    --中间变量
    v_temp_count NUMBER(15);
  BEGIN
    out_error_flag := '1';
    out_error_msg  := '';
    FOR CUR_P IN (SELECT *
                    FROM MM_SW_PICKUP_PLAN_IMP SPI
                   WHERE SPI.IMP_UUID = IN_VAR_UUID
                     AND SPI.CHECK_RESULT = '1'
                     AND SPI.IMPORT_STATUS = '0') LOOP
      --判断主表中是否存在订单号、采购单号与导入数据相同的订单
      SELECT COUNT(*)
        INTO v_temp_count
        FROM MM_SW_PICKUP_PLAN
       WHERE ORDER_NO = CUR_P.ORDER_NO
         AND PURCHASE_NO = CUR_P.PURCHASE_NO;
      --不存在则新增
      IF 0 = v_temp_count THEN
        INSERT INTO MM_SW_PICKUP_PLAN
          (ORDER_NO,
           PURCHASE_NO,
           CONFIRM_DAYS,
           INTER_LOGIS_MANAGER,
           ORDER_USE,
           PLAN_ASSEMBLE_TIME,
           PLAN_ARR_TIME,
           PLAN_PICKUP_TIME,
           TODAY_CAR_BATCH,
           FEEDBACK_STATUS,
           LOGISTICS_MODE,
           AREA,
           CAR_TYPE,
           ROUTE_CODE,
           TOTAL_BATCHS,
           MERGE_BATCHS,
           SUP_FACTORY,
           SUPPLIER_NO,
           WORK_DATE,
           FACTORY_CODE,
           ORDER_DESC,
           PICKUP_TYPE,
           ORDER_ARR_DATE,
           DOWNLOAD_STATUS,
           DOWNLOAD_TIME,
           CREATION_USER,
           CREATION_TIME,
           LAST_MODIFIED_USER,
           LAST_MODIFIED_TIME,
           DIFF_FLAG,
           UNLOAD_PORT)
        VALUES
          (CUR_P.ORDER_NO,
           CUR_P.PURCHASE_NO,
           CUR_P.CONFIRM_DAYS,
           CUR_P.INTER_LOGIS_MANAGER,
           CUR_P.ORDER_USE,
           CUR_P.PLAN_ASSEMBLE_TIME,
           CUR_P.PLAN_ARR_TIME,
           CUR_P.PLAN_PICKUP_TIME,
           CUR_P.TODAY_CAR_BATCH,
           0,
           null,
           CUR_P.AREA,
           CUR_P.CAR_TYPE,
           CUR_P.ROUTE_CODE,
           CUR_P.TOTAL_BATCHS,
           CUR_P.MERGE_BATCHS,
           CUR_P.SUP_FACTORY,
           CUR_P.SUPPLIER_NO,
           CUR_P.WORK_DATE,
           CUR_P.FACTORY_CODE,
           null,
           CUR_P.PICKUP_TYPE,
           null,
           0,
           null,
           CUR_P.CREATION_USER,
           sysdate,
           null,
           null,
           2,
           CUR_P.UNLOAD_PORT);
        --存在则更新
      ELSIF 1 = v_temp_count THEN
        --记录修改日志
        INSERT INTO MM_PUB_OPE_LOG
          (ID,
           TRX_TIME,
           USER_ID,
           TABLE_NAME,
           FORM_NAME,
           TRX_TYPE,
           LOCAL_IP,
           RECORD_KEY,
           ID_COLUMN,
           TABLE_TYPE,
           OLD_VALUE)
          (SELECT SEQ_MM_PUB_OPE_LOG_ID.NEXTVAL,
                  sysdate,
                  in_var_username,
                  'MM_SW_PICKUP_PLAN',
                  '订单发布更新',
                  'U',
                  in_var_opeip,
                  '',
                  'ORDER_NO',
                  '',
                  '{' || 'ORDER_NO=' || A.ORDER_NO || ',' || 'PURCHASE_NO=' ||
                  A.PURCHASE_NO || ',' || 'CONFIRM_DAYS=' || A.CONFIRM_DAYS || ',' ||
                  'INTER_LOGIS_MANAGER=' || A.INTER_LOGIS_MANAGER || ',' ||
                  'ORDER_USE=' || A.ORDER_USE || ',' ||
                  'PLAN_ASSEMBLE_TIME=' || A.PLAN_ASSEMBLE_TIME || ',' ||
                  'PLAN_ARR_TIME=' || A.PLAN_ARR_TIME || ',' ||
                  'PLAN_PICKUP_TIME=' || A.PLAN_PICKUP_TIME || ',' ||
                  'TODAY_CAR_BATCH=' || A.TODAY_CAR_BATCH || ',' ||
                  'FEEDBACK_STATUS=' || A.FEEDBACK_STATUS || ',' ||
                  'LOGISTICS_MODE=' || A.LOGISTICS_MODE || ',' || 'AREA=' ||
                  A.AREA || ',' || 'CAR_TYPE=' || A.CAR_TYPE || ',' ||
                  'ROUTE_CODE=' || A.ROUTE_CODE || ',' || 'TOTAL_BATCHS=' ||
                  A.TOTAL_BATCHS || ',' || 'MERGE_BATCHS=' ||
                  A.MERGE_BATCHS || ',' || 'SUP_FACTORY=' || A.SUP_FACTORY || ',' ||
                  'SUPPLIER_NO=' || A.SUPPLIER_NO || ',' || 'WORK_DATE=' ||
                  A.WORK_DATE || ',' || 'FACTORY_CODE=' || A.FACTORY_CODE || ',' ||
                  'ORDER_DESC=' || A.ORDER_DESC || ',' || 'PICKUP_TYPE=' ||
                  A.PICKUP_TYPE || ',' || 'UNLOAD_PORT=' || A.UNLOAD_PORT || ',' ||
                  'ORDER_ARR_DATE=' || A.ORDER_ARR_DATE || ',' ||
                  'UNLOAD_PORT=' || A.UNLOAD_PORT || ',' ||
                  'DOWNLOAD_STATUS=' || A.DOWNLOAD_STATUS || ',' ||
                  'DOWNLOAD_TIME=' || A.DOWNLOAD_TIME || ',' ||
                  'CREATION_USER=' || A.CREATION_USER || ',' ||
                  'CREATION_TIME=' || A.CREATION_TIME || ',' ||
                  'LAST_MODIFIED_USER=' || A.LAST_MODIFIED_USER || ',' ||
                  'LAST_MODIFIED_TIME=' || A.LAST_MODIFIED_TIME || '}'
             FROM MM_SW_PICKUP_PLAN A
            WHERE A.ORDER_NO = CUR_P.ORDER_NO);

        SELECT COUNT(1)
          INTO v_temp_count
          FROM MM_SW_PICKUP_PLAN MSP
          LEFT JOIN MM_SW_PICKUP_PLAN_IMP MSI
            ON MSP.PURCHASE_NO = MSI.PURCHASE_NO
         WHERE MSP.ORDER_NO = CUR_P.ORDER_NO
           AND NVL(MSP.CONFIRM_DAYS, 1) = NVL(CUR_P.CONFIRM_DAYS, 1)
           AND NVL(MSP.INTER_LOGIS_MANAGER, 1) =
               NVL(CUR_P.INTER_LOGIS_MANAGER, 1)
           AND NVL(MSP.ORDER_USE, 1) = NVL(CUR_P.ORDER_USE, 1)
           AND NVL(MSP.PLAN_ASSEMBLE_TIME, SYSDATE) =
               NVL(CUR_P.PLAN_ASSEMBLE_TIME, SYSDATE)
           AND NVL(MSP.PLAN_ARR_TIME, SYSDATE) =
               NVL(CUR_P.PLAN_ARR_TIME, SYSDATE)
           AND NVL(MSP.PLAN_PICKUP_TIME, SYSDATE) =
               NVL(CUR_P.PLAN_PICKUP_TIME, SYSDATE)
           AND NVL(MSP.TODAY_CAR_BATCH, 1) = NVL(CUR_P.TODAY_CAR_BATCH, 1)
           AND NVL(MSP.AREA, 1) = NVL(CUR_P.AREA, 1)
           AND NVL(MSP.CAR_TYPE, 1) = NVL(CUR_P.CAR_TYPE, 1)
           AND NVL(MSP.ROUTE_CODE, 1) = NVL(CUR_P.ROUTE_CODE, 1)
           AND NVL(MSP.TOTAL_BATCHS, 1) = NVL(CUR_P.TOTAL_BATCHS, 1)
           AND NVL(MSP.SUP_FACTORY, 1) = NVL(CUR_P.SUP_FACTORY, 1)
           AND NVL(MSP.SUPPLIER_NO, 1) = NVL(CUR_P.SUPPLIER_NO, 1)
           AND NVL(MSP.WORK_DATE, SYSDATE) = NVL(CUR_P.WORK_DATE, SYSDATE)
           AND NVL(MSP.FACTORY_CODE, 1) = NVL(CUR_P.FACTORY_CODE, 1)
           AND NVL(MSP.PICKUP_TYPE, 1) = NVL(CUR_P.PICKUP_TYPE, 1)
           AND NVL(MSP.UNLOAD_PORT, 1) = NVL(CUR_P.UNLOAD_PORT, 1);

        IF 1 = v_temp_count THEN
          UPDATE MM_SW_PICKUP_PLAN
             SET DIFF_FLAG = 0
           WHERE ORDER_NO = CUR_P.ORDER_NO
             AND PURCHASE_NO = CUR_P.PURCHASE_NO;

        ELSIF 0 = v_temp_count THEN
          UPDATE MM_SW_PICKUP_PLAN
             SET CONFIRM_DAYS        = CUR_P.CONFIRM_DAYS,
                 INTER_LOGIS_MANAGER = CUR_P.INTER_LOGIS_MANAGER,
                 ORDER_USE           = CUR_P.ORDER_USE,
                 PLAN_ASSEMBLE_TIME  = CUR_P.PLAN_ASSEMBLE_TIME,
                 PLAN_ARR_TIME       = CUR_P.PLAN_ARR_TIME,
                 PLAN_PICKUP_TIME    = CUR_P.PLAN_PICKUP_TIME,
                 TODAY_CAR_BATCH     = CUR_P.TODAY_CAR_BATCH,
                 AREA                = CUR_P.AREA,
                 CAR_TYPE            = CUR_P.CAR_TYPE,
                 ROUTE_CODE          = CUR_P.ROUTE_CODE,
                 TOTAL_BATCHS        = CUR_P.TOTAL_BATCHS,
                 SUP_FACTORY         = CUR_P.SUP_FACTORY,
                 SUPPLIER_NO         = CUR_P.SUPPLIER_NO,
                 WORK_DATE           = CUR_P.WORK_DATE,
                 FACTORY_CODE        = CUR_P.FACTORY_CODE,
                 PICKUP_TYPE         = CUR_P.PICKUP_TYPE,
                 UNLOAD_PORT         = CUR_P.UNLOAD_PORT,
                 LAST_MODIFIED_USER  = in_var_username,
                 LAST_MODIFIED_TIME  = sysdate,
                 DIFF_FLAG           = 1
           WHERE ORDER_NO = CUR_P.ORDER_NO
             AND PURCHASE_NO = CUR_P.PURCHASE_NO;
        END IF;
      END IF;
    END LOOP;

    --更新临时数据导入状态
    UPDATE MM_SW_PICKUP_PLAN_IMP
       SET IMPORT_STATUS = '1'
     WHERE IMP_UUID = IN_VAR_UUID
       AND IMPORT_STATUS = '0'
       AND CHECK_RESULT = '1';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      out_error_flag := sqlcode;
      out_error_msg  := substr(sqlerrm ||
                               dbms_utility.format_error_backtrace(),
                               1,
                               200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MM_PUP.PUP_PICKUP_PLAN_IMPORT',
         out_error_flag,
         out_error_msg,
         SYSDATE,
         '');
      COMMIT;

      out_error_flag := '1';
      out_error_msg  := out_error_flag;
  END PUP_PICKUP_PLAN_IMPORT;

  --***************************************************************************
  --存储过程名：INV_DEV_BASE_CEHCK
  --功能描述： 库存推移EXCEL数据导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip 地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: zmj
  --创建时间： 2018/10/16
  PROCEDURE INV_DEV_BASE_CEHCK(IN_VAR_UUID       IN VARCHAR2,
                               IN_VAR_USERNAME   IN VARCHAR2,
                               IN_VAR_OPEIP      IN VARCHAR2,
                               OUT_ERROR_FLAG    OUT VARCHAR2,
                               OUT_OUT_ERROR_MSG OUT VARCHAR2) IS

    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

  BEGIN
    out_error_flag    := '0';
    out_out_error_msg := '';

    update MM_INV_DEV_BASE_IMP a
       set a.check_result = 0, a.CHECK_INFO = a.CHECK_INFO || '主键重复;'
     where exists (select 1
              from (select b.WORK_CENTER, b.PART_NO
                      from MM_INV_DEV_BASE_IMP b
                     where b.imp_uuid = in_var_uuid
                     group by b.WORK_CENTER, b.PART_NO
                    having count(1) > 1) c
             where a.WORK_CENTER = c.WORK_CENTER
               and a.PART_NO = c.PART_NO)
       and a.imp_uuid = in_var_uuid;

    --判断零件号是否存在
    update MM_INV_DEV_BASE_IMP mis
       set mis.check_result = 0,
           mis.check_info  =
           (nvl(mis.check_info, '') || '零件号不存在;')
     where not exists
     (select 1 from mm_pub_part mpp where mpp.part_no = mis.part_no)
       and mis.imp_uuid = in_var_uuid;

    --EXCEL是否重复
    update MM_INV_DEV_BASE_IMP siglt
       set siglt.check_result = 0,
           siglt.check_info  =
           (nvl(siglt.check_info, '') || 'Excel数据重复;')
     where (siglt.WORK_CENTER, siglt.WARE_CODE, siglt.PART_NO) in
           (select distinct T.WORK_CENTER, T.WARE_CODE, T.PART_NO
              from MM_INV_DEV_BASE_IMP t,
                   (select WORK_CENTER, WARE_CODE, PART_NO, STOCK
                      from (select count(*) count,
                                   siglt.WORK_CENTER,
                                   siglt.WARE_CODE,
                                   siglt.PART_NO,
                                   siglt.STOCK
                              from MM_INV_DEV_BASE_IMP siglt
                             where siglt.imp_uuid = in_var_uuid
                               and siglt.import_status = '0'
                             group by siglt.WORK_CENTER,
                                      siglt.WARE_CODE,
                                      siglt.PART_NO,
                                      siglt.STOCK)
                     where count > 1) b
             where t.WORK_CENTER = b.WORK_CENTER
               and t.WARE_CODE = B.WARE_CODE
               and t.PART_NO = b.PART_NO
               and t.STOCK = b.STOCK);

    --主表中是否已存在该条记录
    MERGE INTO MM_INV_DEV_BASE_IMP A
    USING (SELECT C.WORK_CENTER, C.PART_NO
             FROM MM_INV_DEV_BASE C, MM_INV_DEV_BASE_IMP B
            WHERE B.check_result = 1
              AND B.imp_uuid = in_var_uuid
              AND B.WORK_CENTER = C.WORK_CENTER
              AND B.PART_NO = C.PART_NO) D
    ON (A.IMP_UUID = in_var_uuid)
    WHEN MATCHED THEN
      UPDATE
         SET A.CHECK_RESULT = '0',
             A.CHECK_INFO   = A.CHECK_INFO || '数据已存在;';

    OUT_ERROR_FLAG    := '0';
    out_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'PKG_MM_PUP.INV_DEV_BASE_CEHCK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END INV_DEV_BASE_CEHCK;

  --***************************************************************************
  --存储过程名：USP_PUP_DCS_SEAL_CHECK
  --功能描述：DCS封条号导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: wangyu
  --创建时间： 2019/01/07
  PROCEDURE USP_PUP_DCS_SEAL_CHECK(IN_VAR_UUID       IN VARCHAR2,
                                   IN_VAR_USERNAME   IN VARCHAR2,
                                   IN_VAR_OPEIP      IN VARCHAR2,
                                   OUT_ERROR_FLAG    OUT VARCHAR2,
                                   OUT_OUT_ERROR_MSG OUT VARCHAR2) IS

    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

  BEGIN

    --判断封条号是不是已经存在于已使用封条号中
    UPDATE MM_PUP_DCS_SEAL_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || '该封条号已使用;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND EXISTS (SELECT 1
              FROM (SELECT B.FACTORY_CODE, B.SEAL_NO
                      FROM MM_PUP_DCS_SEAL B
                     WHERE B.DEAL_FLAG = 1) C
             WHERE A.FACTORY_CODE = C.FACTORY_CODE
               AND A.SEAL_NO = C.SEAL_NO);

    --EXCEL重复校验
    UPDATE MM_PUP_DCS_SEAL_IMP A
       SET A.CHECK_RESULT = '0',
           A.CHECK_INFO   = A.CHECK_INFO || 'EXCEL数据重复;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND EXISTS (SELECT 1
              FROM (SELECT B.SEAL_NO, B.FACTORY_CODE
                      FROM MM_PUP_DCS_SEAL_IMP B
                     WHERE B.IMP_UUID = IN_VAR_UUID
                       AND B.IMPORT_STATUS = 0
                     GROUP BY B.SEAL_NO, B.FACTORY_CODE
                    HAVING COUNT(1) > 1) C
             WHERE A.SEAL_NO = C.SEAL_NO
               AND A.FACTORY_CODE = C.FACTORY_CODE);

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN

      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_PUP_DCS_SEAL_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         '');
      COMMIT;

      ROLLBACK;
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END USP_PUP_DCS_SEAL_CHECK;

  --***************************************************************************
  --存储过程名：USP_PUP_DCS_CHECK
  --功能描述：DCS导入校验
  --参数说明：
  --IN_VAR_UUID
  --IN_VAR_USERNAME 操作人
  --IN_VAR_OPEIP ip地址
  --OUT_ERROR_FLAG 返回错误标识
  --OUT_OUT_ERROR_MSG 返回错误信息
  --创建人员: wangyu
  --创建时间： 2019/01/07
  PROCEDURE USP_PUP_DCS_CHECK(IN_VAR_UUID       IN VARCHAR2,
                              IN_FACTORY_CODE   IN VARCHAR2,
                              IN_VAR_USERNAME   IN VARCHAR2,
                              IN_VAR_OPEIP      IN VARCHAR2,
                              OUT_ERROR_FLAG    OUT VARCHAR2,
                              OUT_OUT_ERROR_MSG OUT VARCHAR2) IS

    v_err_num VARCHAR2(16);
    v_err_msg VARCHAR2(256);

  BEGIN

    --物流订单号为空
    UPDATE MM_PUP_DCS_DATA_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = A.CHECK_INFO || '物流订单号为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.ORDER_NO IS NULL;

    --物流订单重复
    UPDATE MM_PUP_DCS_DATA_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = A.CHECK_INFO || '物流订单重复;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND EXISTS (SELECT 1
              FROM (SELECT B.ORDER_NO
                      FROM MM_PUP_DCS_DATA_IMP B
                     WHERE B.IMP_UUID = IN_VAR_UUID
                       AND B.IMPORT_STATUS = 0
                     GROUP BY B.ORDER_NO
                    HAVING COUNT(1) > 1) C
             WHERE A.ORDER_NO = C.ORDER_NO);

    --校验该张订单是否属于该工厂
    UPDATE MM_PUP_DCS_DATA_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = A.CHECK_INFO || '订单不在' || IN_FACTORY_CODE ||
                            '工厂;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND NOT EXISTS (SELECT 1
              FROM MM_SW_ORDER B
             WHERE A.ORDER_NO = B.ORDER_NO
               AND A.FACTORY_CODE = B.FACTORY_CODE);

    --订单已下发任务不能调整
    UPDATE MM_PUP_DCS_DATA_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = A.CHECK_INFO || '订单已下发任务不能调整;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND EXISTS (SELECT 1
              FROM MM_PUP_DCS_PICK_PLAN C
              LEFT JOIN MM_PUP_DCS_PICK_PLAN_DETAIL B
                ON C.PLAN_SHEET_NO = B.PLAN_SHEET_NO
             WHERE A.ORDER_NO = B.ORDER_NO
               AND A.FACTORY_CODE = C.FACTORY_CODE
               AND C.FACTORY_CODE = IN_FACTORY_CODE
                  --状态为已执行的数据
               AND C.STATUS = 1);

    --无意义的订单物流模式
    UPDATE MM_PUP_DCS_DATA_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = A.CHECK_INFO || '无意义的订单物流模式;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.PICKUP_TYPE != '取货';

    --无意义的区域
    UPDATE MM_PUP_DCS_DATA_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = A.CHECK_INFO || '无意义的区域;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND A.AREA != '省内';

    --导入的取货或者到货时间为空
    UPDATE MM_PUP_DCS_DATA_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = A.CHECK_INFO || '取货或者到货时间为空;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND (A.PICK_DATE IS NULL OR A.ARRIVE_DATE IS NULL);

    --路线信息取货车辆维护异常
    UPDATE MM_PUP_DCS_DATA_IMP A
       SET A.CHECK_RESULT = 0,
           A.CHECK_INFO   = A.CHECK_INFO || '路线信息取货车辆维护异常;'
     WHERE A.IMP_UUID = IN_VAR_UUID
       AND A.IMPORT_STATUS = 0
       AND EXISTS (SELECT 1
              FROM (SELECT B.SUP_FACTORY,
                           B.SUPPLIER_NO,
                           B.ROUTE_CODE,
                           B.CAR_TYPE,
                           B.FACTORY_CODE
                      FROM MM_PUP_ROUTE B
                     WHERE B.PICKUP_CAR IS NULL
                       AND B.FACTORY_CODE = IN_FACTORY_CODE) C
             WHERE A.SUP_FACTORY = C.SUP_FACTORY
               AND A.ROUTE_CODE = C.ROUTE_CODE
               AND A.CAR_TYPE = C.CAR_TYPE
               AND A.FACTORY_CODE = C.FACTORY_CODE
               AND A.SUPPLIER_NO = C.SUPPLIER_NO);

    OUT_ERROR_FLAG    := '0';
    OUT_OUT_ERROR_MSG := '';

  EXCEPTION
    WHEN OTHERS THEN

      v_err_num := sqlcode;
      v_err_msg := substr(sqlerrm || dbms_utility.format_error_backtrace(),
                          1,
                          200);
      INSERT INTO MM_PUB_PRO_ERROR
        (ID, ALERT_TYPE, ERROR_NAME, ERROR_DESC, CREATION_DATE, KEY_NAME)
      VALUES
        (SEQ_PUB_PRO_ERROR.NEXTVAL,
         'USP_PUP_DCS_CHECK',
         v_err_num,
         v_err_msg,
         SYSDATE,
         'DCS异常调整');
      COMMIT;

      ROLLBACK;
      OUT_ERROR_FLAG    := '1';
      OUT_OUT_ERROR_MSG := v_err_msg;
  END USP_PUP_DCS_CHECK;

end PKG_PUP_CHECK;
/

prompt
prompt Creating package body PKG_PUP_MAIN
prompt ==================================
prompt
create or replace package body PKG_PUP_MAIN is

  --****************************************************************************
  --过程名  : USP_CHECK_WORKDAY
  --功能描述: 判断两个时间排除非工作日后相差天数
  --参数说明：
  --创建人员: wangyu
  --创建时间: 2018/10/10
  FUNCTION USP_PUP_CHECK_WORKDAY(date1 IN DATE, date2 IN DATE) RETURN NUMBER IS
    status NUMBER := 0;
    v_num  NUMBER := 0;
  BEGIN
    IF (date1 IS NULL) THEN
      RETURN 1;
    END IF;
    IF (FLOOR(date2 - date1) >= 2) THEN
      SELECT COUNT(*)
        INTO v_num
        FROM MM_PUB_WORK_CALENDAR A
       WHERE A.WORK_DATE >= date1
         AND A.WORK_DATE <= date2
         AND A.WORKCENTER = 'A1'
         AND A.SHIFT_CODE = 0;
      IF (v_num >= 2) then
        status := 1;
      END IF;
    END IF;
    RETURN status;
  END USP_PUP_CHECK_WORKDAY;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_PUP_GET_PLAN
  --功能描述：获取生产计划
  --参数说明：
  --in_afoff_time_start 开始时间
  --in_afoff_time_end 结束时间
  --in_week 周次
  --in_arr_factory 工厂代码
  --in_opeid 操作人
  --创建人员: wangyu
  --创建时间： 2018/10/09
  PROCEDURE USP_PUP_GET_PLAN(in_afoff_time_start IN VARCHAR2,
                             in_afoff_time_end   IN VARCHAR2,
                             in_week             IN VARCHAR2,
                             in_arr_factory      IN VARCHAR2,
                             in_opeid            IN VARCHAR2) AS
    err_num number;
    err_msg varchar2(200);
    --多少周的开始日期
    var_start_date varchar2(10);
    --多少周的结束日期
    var_end_date varchar2(10);
  BEGIN
    --删除生产计划数据
    DELETE FROM MM_PUP_PRO_PLAN A WHERE A.FACTORY_CODE = in_arr_factory;

    var_start_date := in_afoff_time_start;
    var_end_date   := in_afoff_time_end;
    --如果周次不为空，按周次获取计划，否则按照起始时间获取
    IF in_week IS NOT NULL THEN
      WITH PARAMS AS
       (SELECT TO_NUMBER(in_week) AS ZS, TO_CHAR(SYSDATE, 'YYYY') NF
          FROM DUAL)
      SELECT TO_CHAR((TRUNC(TO_DATE((SELECT NF FROM PARAMS) || '-01-01',
                                    'YYYY-MM-DD'),
                            'YYYY') - 7) +
                     (7 - TO_CHAR(TRUNC(TO_DATE((SELECT NF FROM PARAMS) ||
                                                '-01-01',
                                                'YYYY-MM-DD'),
                                        'YYYY'),
                                  'D') + 1) +
                     ((SELECT ZS FROM PARAMS) - 1) * 7 + 1,
                     'YYYY-MM-DD') FIRST_DAY,
             TO_CHAR((TRUNC(TO_DATE((SELECT NF FROM PARAMS) || '-01-01',
                                    'YYYY-MM-DD'),
                            'YYYY') - 7) +
                     (7 - TO_CHAR(TRUNC(TO_DATE((SELECT NF FROM PARAMS) ||
                                                '-01-01',
                                                'YYYY-MM-DD'),
                                        'YYYY'),
                                  'D') + 1) +
                     ((SELECT ZS FROM PARAMS) - 1) * 7 + 7,
                     'YYYY-MM-DD') LAST_DAY
        INTO var_start_date, var_end_date
        FROM DUAL;
    END IF;

    --将计划写入生产计划表
    INSERT INTO MM_PUP_PRO_PLAN
      (FACTORY_CODE,
       SORT_ID,
       ORDER_NO,
       CAR_TYPE,
       MARK,
       MIX_SORT_ID,
       SINGLE_SORT_ID,
       AFOFF_TIME,
       CREATION_USER,
       CREATION_TIME)
      SELECT A.FACTORY_CODE,
             A.SORT_ID,
             A.ORDER_NO,
             A.CAR_TYPE,
             NULL,
             --将各个分车型和对应的分车型号写入分车型号
             MY_CONCAT(USF_DELIMITER(DECODE(E.CAR_TYPE_SORT_ID,
                                            '',
                                            NULL,
                                            NULL,
                                            NULL,
                                            E.MULTI_CAR_TYPE || ':' ||
                                            E.CAR_TYPE_SORT_ID),
                                     ';')),
             B.CAR_TYPE_SORT_ID,
             A.AFOFF_TIME,
             in_opeid,
             SYSDATE
        FROM MM_MP_VEH_PLAN A
        LEFT JOIN MM_MP_CAR_TYPE_QUEUE B
          ON A.CAR_TYPE = B.MULTI_CAR_TYPE
         AND A.SORT_ID = B.SORT_ID
      --找到混合车型各个分车型排序号
        LEFT JOIN MM_MP_CAR_TYPE_QUEUE E
          ON A.SORT_ID = E.SORT_ID
         AND INSTR(E.MULTI_CAR_TYPE, ',') > 0
         AND INSTR(E.MULTI_CAR_TYPE, A.CAR_TYPE) > 0
        LEFT JOIN (SELECT C.ORDER_NO, MIN(C.AFOFF_TIME) AFOFF_TIME
                     FROM MM_PUB_PRO_PLAN C
                    GROUP BY C.ORDER_NO) D
          ON A.ORDER_NO = D.ORDER_NO
       WHERE EXISTS
       (SELECT 1
                FROM MM_MP_VEH_PLAN B
                LEFT JOIN (SELECT *
                            FROM MM_MP_CAR_TYPE_QUEUE T
                           WHERE T.MULTI_CAR_TYPE = T.CAR_TYPE
                             AND T.CAR_TYPE IS NOT NULL) C
                  ON B.SORT_ID = C.SORT_ID
                LEFT JOIN MM_MP_CAL_END CE
                  ON CE.CAR_TYPE = C.MULTI_CAR_TYPE
               WHERE A.SORT_ID = B.SORT_ID
                 AND C.CAR_TYPE_SORT_ID <= CE.CAL_POINT)
         AND A.FACTORY_CODE = in_arr_factory
         AND A.AFOFF_TIME >= TO_DATE(var_start_date, 'YYYY-MM-DD')
         AND A.AFOFF_TIME <= TO_DATE(var_end_date, 'YYYY-MM-DD')
       GROUP BY A.FACTORY_CODE,
                A.SORT_ID,
                A.ORDER_NO,
                A.CAR_TYPE,
                B.CAR_TYPE_SORT_ID,
                A.AFOFF_TIME;

    COMMIT;

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUP_GET_PLAN',
           err_num,
           err_msg,
           sysdate,
           '获取生产计划');
        COMMIT;

      END;
  END USP_PUP_GET_PLAN;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_PUP_GEN
  --功能描述：物流计划生成
  --参数说明：
  --in_arr_factory 工厂代码
  --out_code 返回值
  --创建人员: wangyu
  --创建时间： 2018/09/29
  PROCEDURE USP_PUP_GEN(in_arr_factory IN VARCHAR2, out_code OUT INT) AS
    err_num         NUMBER;
    err_msg         VARCHAR2(200);
    v_firstcar_time DATE;
    v_beat          NUMBER;
    v_num           NUMBER;
    v_temp          NUMBER;
    v_af_max_loc    NUMBER;
    v_we_max_loc    NUMBER;
    v_pa_max_loc    NUMBER;
    v_wbs_max_loc   NUMBER;
    v_pbs_max_loc   NUMBER;
    v_car_type      VARCHAR2(200);
    v_mix_sort_id   NUMBER;
  BEGIN
    DELETE FROM MM_PUP_ROUTE_CAL A WHERE A.FACTORY_CODE = in_arr_factory;
    DELETE FROM MM_PUP_ORDER_RECORD A
     WHERE A.FACTORY_CODE = in_arr_factory;
    DELETE FROM MM_PUP_DR A WHERE A.FACTORY_CODE = in_arr_factory;
    DELETE FROM MM_PUP_ROUTE_CAL_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
    DELETE FROM MM_PUP_PRO_PLAN_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;
     COMMIT;

    --获取订单数据
    --写入单车型订单
    INSERT INTO MM_PUP_ORDER_RECORD
      (PLAN_ORDER_ID,
       SUPPLIER_NO,
       SUP_FACTORY,
       UNLOAD_PORT,
       PART_NO,
       LOGISTIC_FLAG,
       GROUP_ID,
       LOGISTICS_ORDER,
       DR_SORT_ID_START,
       DR_SORT_ID_END,
       LR_SORT_ID_START,
       LR_SORT_ID_END,
       ORDER_NUM,
       TOTAL_ORDER_NUM,
       ISSUE_DATE,
       ARRIVE_TIME,
       ORDER_STATUS,
       FACTORY_CODE,
       ORDER_TYPE,
       CAR_TYPE_DIST,
       CREATION_TIME)
      SELECT B.PLAN_ORDER_ID,
             B.SUPPLIER_NO,
             B.SUP_FACTORY,
             B.UNLOAD_PORT,
             B.PART_NO,
             B.LOGISTICS_FLAG,
             B.GROUP_ID,
             B.LOGISTICS_ORDER,
             B.DR_SORT_ID_START,
             B.DR_SORT_ID_END,
             B.LR_SORT_ID_START,
             B.LR_SORT_ID_END,
             B.ORDER_NUM,
             B.TOTAL_ORDER_NUM,
             B.ORDER_ISSUE_DATE,
             B.ARRIVE_TIME,
             B.ORDER_STATUS,
             B.FACTORY_CODE,
             0,
             C.CAR_TYPE,
             SYSDATE
        FROM (SELECT *
                FROM MM_MP_ORDER_RECORD_HIS
               WHERE CREATION_TIME > SYSDATE - 60) B,
             (SELECT A.SUP_FACTORY,
                     A.UNLOAD_PORT,
                     MIN(A.CAR_TYPE) CAR_TYPE,
                     A.SUPPLIER_NO,
                     A.FACTORY_CODE
                FROM MM_PUP_ROUTE A
               WHERE A.FACTORY_CODE = in_arr_factory
               GROUP BY A.FACTORY_CODE,
                        A.SUPPLIER_NO,
                        A.SUP_FACTORY,
                        A.UNLOAD_PORT,
                        A.CAR_TYPE) C
       WHERE B.SUP_FACTORY = C.SUP_FACTORY
         AND B.UNLOAD_PORT = C.UNLOAD_PORT
         AND B.SUPPLIER_NO = C.SUPPLIER_NO
         AND B.FACTORY_CODE = C.FACTORY_CODE
         AND B.FACTORY_CODE = in_arr_factory
         AND EXISTS
       (SELECT 1
                FROM MM_PUP_PRO_PLAN D
               WHERE D.CAR_TYPE = C.CAR_TYPE
                 AND D.SINGLE_SORT_ID <= B.DR_SORT_ID_END
                 AND D.SINGLE_SORT_ID > = B.DR_SORT_ID_START);

    COMMIT;

    --循环混合车型不为空的数据
    FOR mix_order IN (SELECT *
                        FROM MM_PUP_PRO_PLAN A
                       WHERE A.MIX_SORT_ID IS NOT NULL
                         AND A.FACTORY_CODE = in_arr_factory) LOOP
      --拆解混合车型排序，弄成每个分车型排序
      FOR mix_order_detail IN (SELECT *
                                 FROM TABLE (SELECT USF_PROPLAN_SPLIT(B.MIX_SORT_ID,
                                                                      B.AFOFF_TIME,
                                                                      ';')
                                               FROM MM_PUP_PRO_PLAN B
                                              WHERE B.SORT_ID =
                                                    mix_order.SORT_ID
                                                AND B.FACTORY_CODE =
                                                    in_arr_factory)) LOOP
        /*--拿到车型
        SELECT SUBSTR(mix_order_detail.column_value,
                      0,
                      INSTR(mix_order_detail., ':') - 1)
          INTO v_car_type
          FROM DUAL;
        --拿到车型排序
        SELECT SUBSTR(mix_order_detail.column_value,
                      INSTR(mix_order_detail.column_value, ':') + 1)
          INTO v_mix_sort_id
          FROM DUAL;*/
        --按照分车型写入订单表
        INSERT INTO MM_PUP_ORDER_RECORD
          (PLAN_ORDER_ID,
           SUPPLIER_NO,
           SUP_FACTORY,
           UNLOAD_PORT,
           PART_NO,
           LOGISTIC_FLAG,
           GROUP_ID,
           LOGISTICS_ORDER,
           DR_SORT_ID_START,
           DR_SORT_ID_END,
           LR_SORT_ID_START,
           LR_SORT_ID_END,
           ORDER_NUM,
           TOTAL_ORDER_NUM,
           ISSUE_DATE,
           ARRIVE_TIME,
           ORDER_STATUS,
           FACTORY_CODE,
           ORDER_TYPE,
           CAR_TYPE_DIST,
           CREATION_TIME)
          SELECT B.PLAN_ORDER_ID,
                 B.SUPPLIER_NO,
                 B.SUP_FACTORY,
                 B.UNLOAD_PORT,
                 B.PART_NO,
                 B.LOGISTICS_FLAG,
                 B.GROUP_ID,
                 B.LOGISTICS_ORDER,
                 B.DR_SORT_ID_START,
                 B.DR_SORT_ID_END,
                 B.LR_SORT_ID_START,
                 B.LR_SORT_ID_END,
                 B.ORDER_NUM,
                 B.TOTAL_ORDER_NUM,
                 B.ORDER_ISSUE_DATE,
                 B.ARRIVE_TIME,
                 B.ORDER_STATUS,
                 B.FACTORY_CODE,
                 1,
                 C.CAR_TYPE,
                 SYSDATE
            FROM (SELECT *
                    FROM MM_MP_ORDER_RECORD_HIS
                   WHERE CREATION_TIME > SYSDATE - 60) B,
                 (SELECT A.SUP_FACTORY,
                         A.UNLOAD_PORT,
                         A.CAR_TYPE,
                         A.SUPPLIER_NO,
                         A.FACTORY_CODE
                    FROM MM_PUP_ROUTE A
                   WHERE A.FACTORY_CODE = in_arr_factory
                   GROUP BY A.FACTORY_CODE,
                            A.SUPPLIER_NO,
                            A.SUP_FACTORY,
                            A.UNLOAD_PORT,
                            A.CAR_TYPE) C
           WHERE B.SUP_FACTORY = C.SUP_FACTORY
             AND B.UNLOAD_PORT = C.UNLOAD_PORT
             AND B.SUPPLIER_NO = C.SUPPLIER_NO
             AND B.FACTORY_CODE = C.FACTORY_CODE
             AND B.FACTORY_CODE = in_arr_factory
             AND EXISTS
           (SELECT 1
                    FROM DUAL D
                   WHERE C.CAR_TYPE = mix_order_detail.car_type
                     AND mix_order_detail.mix_sort_id <= B.DR_SORT_ID_END
                     AND mix_order_detail.mix_sort_id > = B.DR_SORT_ID_START)
             AND NOT EXISTS
           (SELECT 1
                    FROM MM_PUP_ORDER_RECORD PO
                   WHERE PO.PLAN_ORDER_ID = B.PLAN_ORDER_ID);

        --写入分车型计划临时表
        INSERT INTO MM_PUP_PRO_PLAN_TEMP
          (FACTORY_CODE, CAR_TYPE, MIX_SORT_ID, AFOFF_TIME, CREATION_TIME)
        VALUES
          (mix_order.FACTORY_CODE,
           mix_order_detail.car_type,
           mix_order_detail.mix_sort_id,
           mix_order_detail.Af_Off_Time,
           SYSDATE);
      END LOOP;
    END LOOP;

    COMMIT;
    --获取供应商分组数据
    INSERT INTO MM_PUP_DR
      (SUPPLIER_NO,
       SUP_FACTORY,
       SUPPLIER_NAME,
       FACTORY_CODE,
       UNLOAD_PORT,
       TOTAL_NO,
       DR_SORT_ID_START,
       DR_SORT_ID_END,
       FINAL_UNDERLINE_TIME_START,
       FINAL_UNDERLINE_TIME_END)
      SELECT A.SUPPLIER_NO,
             A.SUP_FACTORY,
             NULL,
             A.FACTORY_CODE,
             A.UNLOAD_PORT,
             A.GROUP_ID,
             A.DR_SORT_ID_START,
             A.DR_SORT_ID_END,
             A.FINAL_UNDERLINE_TIME_START,
             A.FINAL_UNDERLINE_TIME_END
        FROM MM_MP_SUPPLIER_SORT A
       WHERE (A.FINAL_UNDERLINE_TIME_START > SYSDATE - 60 OR
             A.FINAL_UNDERLINE_TIME_START IS NULL)
         AND A.FACTORY_CODE = in_arr_factory;

    --删除已取货完成的数据
    --MODIFY: 2019-05-27
    --陈显钊要求需要计算已经收货的数据
    --MODIFY:2019-06-03
    DELETE FROM MM_PUP_ORDER_RECORD T1
     WHERE EXISTS (SELECT 1
              FROM (SELECT B.SUP_FACTORY,
                           B.SUPPLIER_NO,
                           B.FACTORY_CODE,
                           C.UNLOAD_PORT,
                           C.LOGISTICS_ORDER,
                           B.ORDER_NO
                      FROM MM_MP_PUR_ORDER B, MM_MP_PUR_ORDER_DETAIL C
                     WHERE B.ORDER_NO = C.ORDER_NO
                       AND B.FACTORY_CODE = in_arr_factory) T2
             WHERE T1.LOGISTICS_ORDER = T2.LOGISTICS_ORDER
               AND T1.FACTORY_CODE = T2.FACTORY_CODE
               AND T1.SUP_FACTORY = T2.SUP_FACTORY
               AND T1.SUPPLIER_NO = T2.SUPPLIER_NO
               AND T1.UNLOAD_PORT = T2.UNLOAD_PORT
               AND EXISTS (SELECT 1
                      FROM MM_SW_ORDER SO
                     WHERE SO.ORDER_NO = T2.ORDER_NO
                       AND SO.RECEIVE_STATUS = 2)
                  --MODIFY wangyu 2019-06-05
                  --何锋提出已发车的也不计算取货计划
               AND EXISTS
             (SELECT DPPD.ORDER_NO
                      FROM MM_PUP_DCS_PICK_PLAN DPP
                      LEFT JOIN MM_PUP_DCS_PICK_PLAN_DETAIL DPPD
                        ON DPP.PLAN_SHEET_NO = DPPD.PLAN_SHEET_NO
                     WHERE DPP.EXCUTE_STATUS = 1
                       AND DPP.FACTORY_CODE = in_arr_factory));

    --生产计划第一台车下线时间
    SELECT MIN(A.AFOFF_TIME) INTO v_firstcar_time FROM MM_PUP_PRO_PLAN A;

    --获取节拍
    /*SELECT BEAT
     INTO v_beat
     FROM (SELECT T1 * 24 * 3600 BEAT, COUNT(1)
             FROM (SELECT LEAD(A.AFOFF_TIME, 1) OVER(ORDER BY A.AFOFF_TIME) - A.AFOFF_TIME T1
                     FROM MM_PUP_PRO_PLAN A
                    WHERE A.FACTORY_CODE = in_arr_factory
                    ORDER BY A.AFOFF_TIME) T
            GROUP BY T1
            ORDER BY COUNT(1) DESC)
    WHERE ROWNUM = 1;*/

    --节拍标识
    SELECT PRODUCE_TIME
      INTO v_beat
      FROM (SELECT A.PRODUCE_TIME, COUNT(1) NUM
              FROM MM_PUB_TACT_TIME A
             WHERE A.WORKCENTER = 'A1'
               AND A.PRODUCTION_LINE = 'AF_MAIN'
             GROUP BY A.PRODUCE_TIME
             ORDER BY NUM DESC)
     WHERE ROWNUM = 1;

    --获取总装最大工深
    BEGIN
      SELECT NVL(A.PARAM_VAL, 0)
        INTO v_af_max_loc
        FROM MM_PUB_SYS_PARAM A
       WHERE A.PARAM_GROUP = 'MAX_LOC'
         AND A.PARAM_CODE = 'AF_TOTAL_PRO_NUM'
         AND A.FACTORY_CODE = in_arr_factory;
    EXCEPTION
      WHEN OTHERS THEN
        v_af_max_loc := 0;
    END;

    --获取焊装最大工深
    BEGIN
      SELECT NVL(A.PARAM_VAL, 0)
        INTO v_we_max_loc
        FROM MM_PUB_SYS_PARAM A
       WHERE A.PARAM_GROUP = 'MAX_LOC'
         AND A.PARAM_CODE = 'WE_TOTAL_PRO_NUM'
         AND A.FACTORY_CODE = in_arr_factory;
    EXCEPTION
      WHEN OTHERS THEN
        v_we_max_loc := 0;
    END;

    --获取涂装最大工深
    BEGIN
      SELECT NVL(A.PARAM_VAL, 0)
        INTO v_pa_max_loc
        FROM MM_PUB_SYS_PARAM A
       WHERE A.PARAM_GROUP = 'MAX_LOC'
         AND A.PARAM_CODE = 'PA_TOTAL_PRO_NUM'
         AND A.FACTORY_CODE = in_arr_factory;
    EXCEPTION
      WHEN OTHERS THEN
        v_pa_max_loc := 0;
    END;

    --获取WBS最大工深
    BEGIN
      SELECT NVL(A.PARAM_VAL, 0)
        INTO v_wbs_max_loc
        FROM MM_PUB_SYS_PARAM A
       WHERE A.PARAM_GROUP = 'MAX_LOC'
         AND A.PARAM_CODE = 'WBS_TOTAL_PRO_NUM'
         AND A.FACTORY_CODE = in_arr_factory;
    EXCEPTION
      WHEN OTHERS THEN
        v_wbs_max_loc := 0;
    END;

    --获取PBS最大工深
    BEGIN
      SELECT NVL(A.PARAM_VAL, 0)
        INTO v_pbs_max_loc
        FROM MM_PUB_SYS_PARAM A
       WHERE A.PARAM_GROUP = 'MAX_LOC'
         AND A.PARAM_CODE = 'PBS_TOTAL_PRO_NUM'
         AND A.FACTORY_CODE = in_arr_factory;
    EXCEPTION
      WHEN OTHERS THEN
        v_pbs_max_loc := 0;
    END;

    --分车型订单并且不是差异订单的订单装配时间，到货时间处理
    INSERT INTO MM_PUP_ROUTE_CAL_TEMP
      (ID,
       AREA,
       SUP_FACTORY,
       SUPPLIER_NO,
       UNLOAD_PORT,
       UNLOAD_PLACE,
       PICKUP_TYPE,
       CAR_TYPE,
       ROUTE_CODE,
       TOTAL_NO,
       START_SORT_ID,
       END_SORT_ID,
       ASSEMBLE_TIME,
       ARRIVE_TIME,
       PICK_TIME,
       MERGE_NUM,
       TRANS_TIME,
       ADVANCE_ARR_NUM,
       FLAG,
       ASSEMBLEID,
       FACTORY_CODE,
       FIRST_ARRIVE_TIME,
       SUP_DELIV_TIME,
       PICK_CYCLE,
       SPE_ARR_TIME,
       DEPART_TIME_POINT,
       RET_EMPTY_PLATFORM)
      SELECT SEQ_MM_PUP_ROUTE_CAL.NEXTVAL,
             T2.AREA,
             T2.SUP_FACTORY,
             T2.SUPPLIER_NO,
             T2.UNLOAD_PORT,
             T2.UNLOAD_PLACE,
             T2.PICKUP_TYPE,
             T2.CAR_TYPE,
             T2.ROUTE_CODE,
             T2.GROUPID,
             T2.DR_SORT_ID_START,
             T2.DR_SORT_ID_END,
             T2.ASSEMBLE_TIME,
             --计算到货时间
             PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                          'A1',
                                          T2.ASSEMBLE_TIME,
                                          -DECODE(NVL(T2.ADVANCE_ARR_NUM, 0) *
                                                  v_beat,
                                                  0,
                                                  1,
                                                  NVL(T2.ADVANCE_ARR_NUM, 0) *
                                                  v_beat)),
             --取货时间
             NULL,
             T2.MERGE_NUM,
             T2.TRANS_TIME,
             T2.ADVANCE_ARR_NUM,
             T2.FLAG,
             --装配SORT_ID
             NULL,
             T2.FACTORY_CODE,
             T2.FIRST_ARRIVE_TIME,
             T2.SUP_OUT_TIME,
             T2.PICK_CYCLE,
             TO_CHAR(T2.SPE_ARRIVE_TIME, 'HH24:MI:SS'),
             T2.DEPART_TIME_POINT,
             T2.RET_EMPTY_PLATFORM
        FROM (SELECT E.AREA,
                     D.SUP_FACTORY,
                     D.SUPPLIER_NO,
                     E.FACTORY_CODE,
                     D.UNLOAD_PORT,
                     E.UNLOAD_PLACE,
                     E.PICKUP_TYPE,
                     E.CAR_TYPE,
                     E.ROUTE_CODE,
                     D.GROUPID,
                     D.DR_SORT_ID_START,
                     D.DR_SORT_ID_END,
                     E.SUP_CAL_NUM,
                     NVL(E.MERGE_NUM, 0) MERGE_NUM,
                     NVL(E.LOC_DEPTH, 0) LOC_DEPTH,
                     D.L_START_SORT_ID,
                     D.FLAG,
                     E.TRANS_TIME,
                     E.ADVANCE_ARR_NUM,
                     CASE
                       WHEN D.WORKCENTER = 'W1' THEN
                       --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     D.AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             (v_af_max_loc +
                                                             v_pa_max_loc +
                                                             v_pbs_max_loc +
                                                             v_we_max_loc +
                                                             v_wbs_max_loc) *
                                                             v_beat,
                                                             (v_af_max_loc +
                                                             v_pbs_max_loc +
                                                             v_pa_max_loc +
                                                             v_wbs_max_loc +
                                                             NVL(F.LOC_DEPTH,
                                                                  0)) * v_beat))
                       WHEN D.WORKCENTER = 'T1' THEN
                       --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     D.AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             (v_af_max_loc +
                                                             v_pa_max_loc +
                                                             v_pbs_max_loc) *
                                                             v_beat,
                                                             (v_af_max_loc +
                                                             v_pbs_max_loc +
                                                             NVL(F.LOC_DEPTH,
                                                                  0)) * v_beat))
                       ELSE
                         --总装和支给件的数据
                       --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     D.AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             v_af_max_loc *
                                                             v_beat,
                                                             NVL(F.LOC_DEPTH, 0) *
                                                             v_beat))
                     END ASSEMBLE_TIME,
                     E.FIRST_ARRIVE_TIME,
                     E.SUP_OUT_TIME,
                     E.PICK_CYCLE,
                     E.SPE_ARRIVE_TIME,
                     0 FLAGX,
                     E.DEPART_TIME_POINT,
                     E.RET_EMPTY_PLATFORM
                FROM (SELECT A.SUP_FACTORY,
                             A.SUPPLIER_NO,
                             A.UNLOAD_PORT,
                             A.GROUPID,
                             MIN(A.DR_SORT_ID_START) DR_SORT_ID_START,
                             MIN(A.DR_SORT_ID_END) DR_SORT_ID_END,
                             MIN(C.AFOFF_TIME) AFOFF_TIME,
                             NULL L_START_SORT_ID,
                             0 FLAG,
                             MIN(A.WORKCENTER) WORKCENTER
                        FROM (SELECT PD.SUP_FACTORY,
                                     PD.SUPPLIER_NO,
                                     PD.UNLOAD_PORT,
                                     TO_CHAR(PD.TOTAL_NO) GROUPID,
                                     PD.DR_SORT_ID_START,
                                     PD.DR_SORT_ID_END,
                                     MP1.WORKCENTER
                                FROM MM_PUP_DR PD
                                LEFT JOIN (SELECT MP.UNLOAD_PORT,
                                                 MIN(MP.WORKCENTER) WORKCENTER,
                                                 MP.FACTORY_CODE
                                            FROM MM_MP_PART MP
                                           GROUP BY MP.UNLOAD_PORT,
                                                    MP.FACTORY_CODE) MP1
                                  ON PD.FACTORY_CODE = MP1.FACTORY_CODE
                                 AND PD.UNLOAD_PORT = MP1.UNLOAD_PORT
                               WHERE EXISTS
                               (SELECT 1
                                        FROM MM_PUP_ORDER_RECORD T
                                       WHERE INSTR(T.LOGISTICS_ORDER, '-') < 1
                                         AND T.TOTAL_ORDER_NUM > 0
                                         AND T.FACTORY_CODE = in_arr_factory
                                         AND T.SUP_FACTORY = PD.SUP_FACTORY
                                         AND T.UNLOAD_PORT = PD.UNLOAD_PORT
                                         AND T.SUPPLIER_NO = PD.SUPPLIER_NO
                                         AND T.ORDER_TYPE = 0
                                         AND T.GROUP_ID = PD.TOTAL_NO)
                                 AND PD.FACTORY_CODE = in_arr_factory) A
                        LEFT JOIN MM_PUP_ROUTE B
                          ON A.SUP_FACTORY = B.SUP_FACTORY
                         AND A.SUPPLIER_NO = B.SUPPLIER_NO
                         AND A.UNLOAD_PORT = B.UNLOAD_PORT
                         AND B.FACTORY_CODE = in_arr_factory
                        LEFT JOIN MM_PUP_PRO_PLAN C
                          ON A.DR_SORT_ID_START <= C.SINGLE_SORT_ID
                         AND A.DR_SORT_ID_END >= C.SINGLE_SORT_ID
                         AND B.FACTORY_CODE = C.FACTORY_CODE
                         AND B.CAR_TYPE = C.CAR_TYPE
                       GROUP BY A.SUPPLIER_NO,
                                A.SUP_FACTORY,
                                A.UNLOAD_PORT,
                                A.GROUPID) D
                LEFT JOIN MM_PUP_ROUTE E
                  ON D.SUP_FACTORY = E.SUP_FACTORY
                 AND D.SUPPLIER_NO = E.SUPPLIER_NO
                 AND D.UNLOAD_PORT = E.UNLOAD_PORT
                 AND E.FACTORY_CODE = in_arr_factory
                LEFT JOIN (SELECT IPL.SUPPLIER_NO,
                                 IPL.WORKCENTER,
                                 MAX(IPL.LOCATION_NUM) LOC_DEPTH
                            FROM MM_INV_PART_LOCATION IPL
                           WHERE IPL.FACTORY_CODE = in_arr_factory
                             AND IPL.EFF_START <= SYSDATE
                             AND IPL.EFF_END > SYSDATE
                           GROUP BY IPL.SUPPLIER_NO, IPL.WORKCENTER) F
                  ON D.SUPPLIER_NO = F.SUPPLIER_NO
                 AND D.WORKCENTER = F.WORKCENTER) T2;

    --分车型订单是差异订单的订单装配时间，到货时间处理
    INSERT INTO MM_PUP_ROUTE_CAL_TEMP
      (ID,
       AREA,
       SUP_FACTORY,
       SUPPLIER_NO,
       UNLOAD_PORT,
       UNLOAD_PLACE,
       PICKUP_TYPE,
       CAR_TYPE,
       ROUTE_CODE,
       TOTAL_NO,
       START_SORT_ID,
       END_SORT_ID,
       ASSEMBLE_TIME,
       ARRIVE_TIME,
       PICK_TIME,
       MERGE_NUM,
       TRANS_TIME,
       ADVANCE_ARR_NUM,
       FLAG,
       ASSEMBLEID,
       FACTORY_CODE,
       FIRST_ARRIVE_TIME,
       SUP_DELIV_TIME,
       PICK_CYCLE,
       SPE_ARR_TIME,
       DEPART_TIME_POINT,
       RET_EMPTY_PLATFORM)
      SELECT SEQ_MM_PUP_ROUTE_CAL.NEXTVAL,
             T2.AREA,
             T2.SUP_FACTORY,
             T2.SUPPLIER_NO,
             T2.UNLOAD_PORT,
             T2.UNLOAD_PLACE,
             T2.PICKUP_TYPE,
             T2.CAR_TYPE,
             T2.ROUTE_CODE,
             DECODE(T2.FLAGX,
                    1,
                    T2.GROUPID,
                    SUBSTR(T2.GROUPID, 1, INSTR(T2.GROUPID, '-') - 1)),
             DECODE(T2.FLAGX, 1, T2.L_START_SORT_ID, T2.DR_SORT_ID_START),
             T2.DR_SORT_ID_END,
             CASE
               WHEN T2.FLAGX = 1 AND T2.L_ASSEMBLE_TIME IS NOT NULL THEN
                T2.L_ASSEMBLE_TIME
               WHEN T2.FLAGX = 0 AND T2.D_ASSEMBLE_TIME IS NOT NULL THEN
                T2.D_ASSEMBLE_TIME
               ELSE
                v_firstcar_time
             END,
             CASE
               WHEN T2.FLAGX = 1 AND T2.L_ASSEMBLE_TIME IS NOT NULL THEN
               --计算到货时间
                PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                             'A1',
                                             T2.L_ASSEMBLE_TIME,
                                             -DECODE(NVL(T2.ADVANCE_ARR_NUM,
                                                         0) * v_beat,
                                                     0,
                                                     1,
                                                     NVL(T2.ADVANCE_ARR_NUM, 0) *
                                                     v_beat))
               WHEN T2.FLAGX = 0 AND T2.D_ASSEMBLE_TIME IS NOT NULL THEN
               --计算到货时间
                PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                             'A1',
                                             T2.D_ASSEMBLE_TIME,
                                             -DECODE(NVL(T2.ADVANCE_ARR_NUM,
                                                         0) * v_beat,
                                                     0,
                                                     1,
                                                     NVL(T2.ADVANCE_ARR_NUM, 0) *
                                                     v_beat))
               ELSE
                v_firstcar_time
             END,
             --取货时间
             NULL,
             T2.MERGE_NUM,
             T2.TRANS_TIME,
             T2.ADVANCE_ARR_NUM,
             T2.FLAGX,
             --装配SORT_ID
             NULL,
             T2.FACTORY_CODE,
             T2.FIRST_ARRIVE_TIME,
             T2.SUP_OUT_TIME,
             T2.PICK_CYCLE,
             TO_CHAR(T2.SPE_ARRIVE_TIME, 'HH24:MI:SS'),
             T2.DEPART_TIME_POINT,
             T2.RET_EMPTY_PLATFORM
        FROM (SELECT E.AREA,
                     T1.SUPPLIER_NO,
                     T1.SUP_FACTORY,
                     E.FACTORY_CODE,
                     T1.UNLOAD_PORT,
                     E.UNLOAD_PLACE,
                     E.PICKUP_TYPE,
                     E.CAR_TYPE,
                     E.ROUTE_CODE,
                     T1.GROUPID,
                     T1.DR_SORT_ID_START,
                     T1.DR_SORT_ID_END,
                     E.SUP_CAL_NUM,
                     NVL(E.MERGE_NUM, 0) MERGE_NUM,
                     NVL(F.LOC_DEPTH, 0) LOC_DEPTH,
                     T1.L_START_SORT_ID,
                     T1.FLAG,
                     E.TRANS_TIME,
                     E.ADVANCE_ARR_NUM,
                     T1.D_AFOFF_TIME,
                     CASE
                       WHEN T1.WORKCENTER = 'W1' THEN
                         --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     T1.D_AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             (v_af_max_loc +
                                                             v_pa_max_loc +
                                                             v_pbs_max_loc +
                                                             v_we_max_loc +
                                                             v_wbs_max_loc) *
                                                             v_beat,
                                                             (v_af_max_loc +
                                                             v_pbs_max_loc +
                                                             v_pa_max_loc +
                                                             v_wbs_max_loc +
                                                             NVL(F.LOC_DEPTH,
                                                                  0)) * v_beat))

                       WHEN T1.WORKCENTER = 'T1' THEN
                       --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     T1.D_AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             (v_af_max_loc +
                                                             v_pa_max_loc +
                                                             v_pbs_max_loc) *
                                                             v_beat,
                                                             (v_af_max_loc +
                                                             v_pbs_max_loc +
                                                             NVL(F.LOC_DEPTH,
                                                                  0)) * v_beat))
                       ELSE
                         --总装和支给件的数据
                        --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     T1.D_AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             v_af_max_loc *
                                                             v_beat,
                                                             NVL(F.LOC_DEPTH, 0) *
                                                             v_beat))
                     END D_ASSEMBLE_TIME,
                     T1.L_AFOFF_TIME,
                     --计算装配时间
                     CASE
                       WHEN T1.WORKCENTER = 'W1' THEN
                         --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     T1.L_AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             (v_af_max_loc +
                                                             v_pa_max_loc +
                                                             v_pbs_max_loc +
                                                             v_we_max_loc +
                                                             v_wbs_max_loc) *
                                                             v_beat,
                                                             (v_af_max_loc +
                                                             v_pbs_max_loc +
                                                             v_pa_max_loc +
                                                             v_wbs_max_loc +
                                                             NVL(F.LOC_DEPTH,
                                                                  0)) * v_beat))

                       WHEN T1.WORKCENTER = 'T1' THEN
                       --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     T1.L_AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             (v_af_max_loc +
                                                             v_pa_max_loc +
                                                             v_pbs_max_loc) *
                                                             v_beat,
                                                             (v_af_max_loc +
                                                             v_pbs_max_loc +
                                                             NVL(F.LOC_DEPTH,
                                                                  0)) * v_beat))
                       ELSE
                         --总装和支给件数据
                       --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     T1.D_AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             v_af_max_loc *
                                                             v_beat,
                                                             NVL(F.LOC_DEPTH, 0) *
                                                             v_beat))
                     END L_ASSEMBLE_TIME,
                     DECODE(T1.CYFLAG,
                            1,
                            1,
                            0,
                            PKG_PUP_MAIN.USP_PUP_CHECK_WORKDAY(NVL(T1.D_AFOFF_TIME,
                                                                   v_firstcar_time),

                                                               NVL(T1.L_AFOFF_TIME,
                                                                   v_firstcar_time))) FLAGX,
                     E.FIRST_ARRIVE_TIME,
                     E.SUP_OUT_TIME,
                     E.PICK_CYCLE,
                     E.SPE_ARRIVE_TIME,
                     E.DEPART_TIME_POINT,
                     E.RET_EMPTY_PLATFORM
                FROM (SELECT A.SUP_FACTORY,
                             A.SUPPLIER_NO,
                             A.UNLOAD_PORT,
                             A.GROUPID,
                             MIN(A.DR_SORT_ID_START) DR_SORT_ID_START,
                             MIN(A.DR_SORT_ID_END) DR_SORT_ID_END,
                             MIN(C.AFOFF_TIME) D_AFOFF_TIME,
                             DECODE(MIN(C.AFOFF_TIME), NULL, 1, 0) CYFLAG,
                             MIN(D.AFOFF_TIME) L_AFOFF_TIME,
                             MIN(LR_SORT_ID_START) L_START_SORT_ID,
                             1 FLAG,
                             MIN(A.WORKCENTER) WORKCENTER
                        FROM (SELECT TT.SUP_FACTORY,
                                     TT.UNLOAD_PORT,
                                     TT.DIST_GROUP_ID GROUPID,
                                     TT.DR_SORT_ID_START,
                                     TT.LR_SORT_ID_START,
                                     PD.DR_SORT_ID_END,
                                     TT.SUPPLIER_NO,
                                     MP1.WORKCENTER
                                FROM MM_PUP_DR PD
                                LEFT JOIN (SELECT MP.UNLOAD_PORT,
                                                 MIN(MP.WORKCENTER) WORKCENTER,
                                                 MP.FACTORY_CODE
                                            FROM MM_MP_PART MP
                                           GROUP BY MP.UNLOAD_PORT,
                                                    MP.FACTORY_CODE) MP1
                                  ON PD.FACTORY_CODE = MP1.FACTORY_CODE
                                 AND PD.UNLOAD_PORT = MP1.UNLOAD_PORT
                                LEFT JOIN (SELECT DISTINCT T.SUP_FACTORY,
                                                          T.SUPPLIER_NO,
                                                          T.UNLOAD_PORT,
                                                          T.GROUP_ID,
                                                          T.GROUP_ID || '-' ||
                                                          SUBSTR(T.LOGISTICS_ORDER,
                                                                 INSTR(T.LOGISTICS_ORDER,
                                                                       '-') + 1) DIST_GROUP_ID,
                                                          T.DR_SORT_ID_START,
                                                          T.LR_SORT_ID_START
                                            FROM MM_PUP_ORDER_RECORD T
                                           WHERE INSTR(T.LOGISTICS_ORDER, '-') > 1
                                             AND T.TOTAL_ORDER_NUM > 0
                                             AND T.ORDER_TYPE = 0
                                             AND T.FACTORY_CODE =
                                                 in_arr_factory) TT
                                  ON TT.SUP_FACTORY = PD.SUP_FACTORY
                                 AND PD.SUPPLIER_NO = TT.SUPPLIER_NO
                                 AND PD.UNLOAD_PORT = TT.UNLOAD_PORT
                                 AND PD.TOTAL_NO = TT.GROUP_ID
                               WHERE TT.SUP_FACTORY IS NOT NULL
                                 AND PD.FACTORY_CODE = in_arr_factory) A
                        LEFT JOIN MM_PUP_ROUTE B
                          ON A.SUP_FACTORY = B.SUP_FACTORY
                         AND A.SUPPLIER_NO = B.SUPPLIER_NO
                         AND B.UNLOAD_PORT = A.UNLOAD_PORT
                         AND B.FACTORY_CODE = in_arr_factory
                        LEFT JOIN MM_PUP_PRO_PLAN C
                          ON B.FACTORY_CODE = C.FACTORY_CODE
                         AND B.CAR_TYPE = C.CAR_TYPE
                         AND A.DR_SORT_ID_START <= C.SINGLE_SORT_ID
                         AND A.DR_SORT_ID_END >= C.SINGLE_SORT_ID
                        LEFT JOIN MM_PUP_PRO_PLAN D
                          ON D.FACTORY_CODE = B.FACTORY_CODE
                         AND D.CAR_TYPE = B.CAR_TYPE
                         AND A.LR_SORT_ID_START <= D.SINGLE_SORT_ID
                         AND A.DR_SORT_ID_END >= D.SINGLE_SORT_ID
                       GROUP BY A.SUPPLIER_NO,
                                A.SUP_FACTORY,
                                A.UNLOAD_PORT,
                                A.GROUPID) T1
                LEFT JOIN MM_PUP_ROUTE E
                  ON T1.SUP_FACTORY = E.SUP_FACTORY
                 AND T1.SUPPLIER_NO = E.SUPPLIER_NO
                 AND T1.UNLOAD_PORT = E.UNLOAD_PORT
                 AND E.FACTORY_CODE = in_arr_factory
                LEFT JOIN (SELECT IPL.SUPPLIER_NO,
                                 IPL.WORKCENTER,
                                 MAX(IPL.LOCATION_NUM) LOC_DEPTH
                            FROM MM_INV_PART_LOCATION IPL
                           WHERE IPL.FACTORY_CODE = in_arr_factory
                             AND IPL.EFF_START <= SYSDATE
                             AND IPL.EFF_END > SYSDATE
                           GROUP BY IPL.SUPPLIER_NO, IPL.WORKCENTER) F
                  ON T1.SUPPLIER_NO = F.SUPPLIER_NO
                 AND T1.WORKCENTER = F.WORKCENTER) T2
       WHERE NOT EXISTS
       (SELECT 1
                FROM MM_PUP_ROUTE_CAL_TEMP T
               WHERE T.TOTAL_NO =
                     DECODE(T2.FLAGX,
                            1,
                            T2.GROUPID,
                            SUBSTR(T2.GROUPID, 1, INSTR(T2.GROUPID, '-') - 1))
                 AND T.SUP_FACTORY = T2.SUP_FACTORY
                 AND T.SUPPLIER_NO = T2.SUPPLIER_NO
                 AND T.UNLOAD_PORT = T2.UNLOAD_PORT
                 AND T.ROUTE_CODE = T2.ROUTE_CODE);

    COMMIT;

    --混合订单并且不是差异订单的订单装配时间，到货时间处理
    INSERT INTO MM_PUP_ROUTE_CAL_TEMP
      (ID,
       AREA,
       SUP_FACTORY,
       SUPPLIER_NO,
       UNLOAD_PORT,
       UNLOAD_PLACE,
       PICKUP_TYPE,
       CAR_TYPE,
       ROUTE_CODE,
       TOTAL_NO,
       START_SORT_ID,
       END_SORT_ID,
       ASSEMBLE_TIME,
       ARRIVE_TIME,
       PICK_TIME,
       MERGE_NUM,
       TRANS_TIME,
       ADVANCE_ARR_NUM,
       FLAG,
       ASSEMBLEID,
       FACTORY_CODE,
       FIRST_ARRIVE_TIME,
       SUP_DELIV_TIME,
       PICK_CYCLE,
       SPE_ARR_TIME,
       DEPART_TIME_POINT,
       RET_EMPTY_PLATFORM)
      SELECT SEQ_MM_PUP_ROTE.NEXTVAL,
             T2.AREA,
             T2.SUP_FACTORY,
             T2.SUPPLIER_NO,
             T2.UNLOAD_PORT,
             T2.UNLOAD_PLACE,
             T2.PICKUP_TYPE,
             T2.CAR_TYPE,
             T2.ROUTE_CODE,
             T2.GROUPID,
             T2.DR_SORT_ID_START,
             T2.DR_SORT_ID_END,
             T2.ASSEMBLE_TIME,
             --计算到货时间
             PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                          'A1',
                                          T2.ASSEMBLE_TIME,
                                          -DECODE(NVL(T2.ADVANCE_ARR_NUM, 0) *
                                                  v_beat,
                                                  0,
                                                  1,
                                                  NVL(T2.ADVANCE_ARR_NUM, 0) *
                                                  v_beat)),
             NULL,
             T2.MERGE_NUM,
             T2.TRANS_TIME,
             T2.ADVANCE_ARR_NUM,
             T2.FLAG,
             NULL,
             T2.FACTORY_CODE,
             T2.FIRST_ARRIVE_TIME,
             T2.SUP_OUT_TIME,
             T2.PICK_CYCLE,
             T2.SPE_ARRIVE_TIME,
             T2.DEPART_TIME_POINT,
             T2.RET_EMPTY_PLATFORM
        FROM (SELECT E.AREA,
                     D.SUP_FACTORY,
                     D.SUPPLIER_NO,
                     E.FACTORY_CODE,
                     D.UNLOAD_PORT,
                     E.UNLOAD_PLACE,
                     E.PICKUP_TYPE,
                     E.CAR_TYPE,
                     E.ROUTE_CODE,
                     D.GROUPID,
                     D.DR_SORT_ID_START,
                     D.DR_SORT_ID_END,
                     E.SUP_CAL_NUM,
                     NVL(E.MERGE_NUM, 0) MERGE_NUM,
                     NVL(F.LOC_DEPTH, 0) LOC_DEPTH,
                     D.L_START_SORT_ID,
                     D.FLAG,
                     E.TRANS_TIME,
                     E.ADVANCE_ARR_NUM,
                     CASE
                       WHEN D.WORKCENTER = 'W1' THEN
                         --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     D.AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             (v_af_max_loc +
                                                             v_pa_max_loc +
                                                             v_pbs_max_loc +
                                                             v_we_max_loc +
                                                             v_wbs_max_loc) *
                                                             v_beat,
                                                             (v_af_max_loc +
                                                             v_pbs_max_loc +
                                                             v_pa_max_loc +
                                                             v_wbs_max_loc +
                                                             NVL(F.LOC_DEPTH,
                                                                  0)) * v_beat))

                       WHEN D.WORKCENTER = 'T1' THEN
                       --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     D.AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             (v_af_max_loc +
                                                             v_pa_max_loc +
                                                             v_pbs_max_loc) *
                                                             v_beat,
                                                             (v_af_max_loc +
                                                             v_pbs_max_loc +
                                                             NVL(F.LOC_DEPTH,
                                                                  0)) * v_beat))
                       ELSE
                         --总装和支给件数据
                        --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     D.AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             v_af_max_loc *
                                                             v_beat,
                                                             NVL(F.LOC_DEPTH, 0) *
                                                             v_beat))
                     END ASSEMBLE_TIME,
                     E.FIRST_ARRIVE_TIME,
                     E.SUP_OUT_TIME,
                     E.PICK_CYCLE,
                     E.SPE_ARRIVE_TIME,
                     0 FLAGX,
                     E.DEPART_TIME_POINT,
                     E.RET_EMPTY_PLATFORM
                FROM (SELECT A.SUP_FACTORY,
                             A.SUPPLIER_NO,
                             A.UNLOAD_PORT,
                             A.GROUPID,
                             MIN(A.DR_SORT_ID_START) DR_SORT_ID_START,
                             MIN(A.DR_SORT_ID_END) DR_SORT_ID_END,
                             MIN(C.AFOFF_TIME) AFOFF_TIME,
                             NULL L_START_SORT_ID,
                             0 FLAG,
                             MIN(A.WORKCENTER) WORKCENTER
                        FROM (SELECT PD.SUP_FACTORY,
                                     PD.UNLOAD_PORT,
                                     TO_CHAR(PD.TOTAL_NO) GROUPID,
                                     PD.DR_SORT_ID_START,
                                     NULL L_START_SORT_ID,
                                     PD.DR_SORT_ID_END,
                                     0 FLAG,
                                     PD.SUPPLIER_NO,
                                     MP1.WORKCENTER
                                FROM MM_PUP_DR PD
                                LEFT JOIN (SELECT MP.UNLOAD_PORT,
                                                 MIN(MP.WORKCENTER) WORKCENTER,
                                                 MP.FACTORY_CODE
                                            FROM MM_MP_PART MP
                                           GROUP BY MP.UNLOAD_PORT,
                                                    MP.FACTORY_CODE) MP1
                                  ON PD.FACTORY_CODE = MP1.FACTORY_CODE
                                 AND PD.UNLOAD_PORT = MP1.UNLOAD_PORT
                               WHERE EXISTS
                               (SELECT 1
                                        FROM MM_PUP_ORDER_RECORD T
                                       WHERE INSTR(T.LOGISTICS_ORDER, '-') < 1
                                         AND T.TOTAL_ORDER_NUM > 0
                                         AND T.FACTORY_CODE = in_arr_factory
                                         AND T.SUP_FACTORY = PD.SUP_FACTORY
                                         AND T.SUPPLIER_NO = PD.SUPPLIER_NO
                                         AND T.UNLOAD_PORT = PD.UNLOAD_PORT
                                         AND T.ORDER_TYPE = 1
                                         AND T.GROUP_ID = PD.TOTAL_NO)
                                 AND PD.FACTORY_CODE = in_arr_factory) A
                        LEFT JOIN (SELECT *
                                    FROM MM_PUP_ROUTE
                                   WHERE INSTR(CAR_TYPE, ',') > 1) B
                          ON A.SUP_FACTORY = B.SUP_FACTORY
                         AND A.SUPPLIER_NO = B.SUPPLIER_NO
                         AND A.UNLOAD_PORT = B.UNLOAD_PORT
                         AND B.FACTORY_CODE = in_arr_factory
                        LEFT JOIN MM_PUP_PRO_PLAN_TEMP C
                          ON A.DR_SORT_ID_START <= C.MIX_SORT_ID
                         AND A.DR_SORT_ID_END >= C.MIX_SORT_ID
                         AND B.CAR_TYPE = C.CAR_TYPE
                         AND B.FACTORY_CODE = C.FACTORY_CODE
                       GROUP BY A.SUPPLIER_NO,
                                A.SUP_FACTORY,
                                A.UNLOAD_PORT,
                                A.GROUPID) D
                LEFT JOIN MM_PUP_ROUTE E
                  ON D.SUP_FACTORY = E.SUP_FACTORY
                 AND D.SUPPLIER_NO = E.SUPPLIER_NO
                 AND D.UNLOAD_PORT = E.UNLOAD_PORT
                 AND E.FACTORY_CODE = in_arr_factory
                LEFT JOIN (SELECT IPL.SUPPLIER_NO,
                                 IPL.WORKCENTER,
                                 MAX(IPL.LOCATION_NUM) LOC_DEPTH
                            FROM MM_INV_PART_LOCATION IPL
                           WHERE IPL.FACTORY_CODE = in_arr_factory
                             AND IPL.EFF_START <= SYSDATE
                             AND IPL.EFF_END > SYSDATE
                           GROUP BY IPL.SUPPLIER_NO, IPL.WORKCENTER) F
                  ON D.SUPPLIER_NO = F.SUPPLIER_NO
                 AND D.WORKCENTER = F.WORKCENTER) T2;

    --混合车型，并且是差异订单装配时间，到货时间处理
    INSERT INTO MM_PUP_ROUTE_CAL_TEMP
      (ID,
       AREA,
       SUP_FACTORY,
       SUPPLIER_NO,
       UNLOAD_PORT,
       UNLOAD_PLACE,
       PICKUP_TYPE,
       CAR_TYPE,
       ROUTE_CODE,
       TOTAL_NO,
       START_SORT_ID,
       END_SORT_ID,
       ASSEMBLE_TIME,
       ARRIVE_TIME,
       PICK_TIME,
       MERGE_NUM,
       TRANS_TIME,
       ADVANCE_ARR_NUM,
       FLAG,
       ASSEMBLEID,
       FACTORY_CODE,
       FIRST_ARRIVE_TIME,
       SUP_DELIV_TIME,
       PICK_CYCLE,
       SPE_ARR_TIME,
       DEPART_TIME_POINT,
       RET_EMPTY_PLATFORM)
      SELECT SEQ_MM_PUP_ROUTE_CAL.NEXTVAL,
             T2.AREA,
             T2.SUP_FACTORY,
             T2.SUPPLIER_NO,
             T2.UNLOAD_PORT,
             T2.UNLOAD_PLACE,
             T2.PICKUP_TYPE,
             T2.CAR_TYPE,
             T2.ROUTE_CODE,
             DECODE(T2.FLAGX,
                    1,
                    T2.GROUPID,
                    SUBSTR(T2.GROUPID, 1, INSTR(T2.GROUPID, '-') - 1)),
             DECODE(T2.FLAGX, 1, T2.L_START_SORT_ID, T2.DR_SORT_ID_START),
             T2.DR_SORT_ID_END,
             CASE
               WHEN T2.FLAGX = 1 AND T2.L_ASSEMBLE_TIME IS NOT NULL THEN
                T2.L_ASSEMBLE_TIME
               WHEN T2.FLAGX = 0 AND T2.D_ASSEMBLE_TIME IS NOT NULL THEN
                T2.D_ASSEMBLE_TIME
               ELSE
                v_firstcar_time
             END,
             CASE
               WHEN T2.FLAGX = 1 AND T2.L_ASSEMBLE_TIME IS NOT NULL THEN
               --计算到货时间
                PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                             'A1',
                                             T2.L_ASSEMBLE_TIME,
                                             -DECODE(NVL(T2.ADVANCE_ARR_NUM,
                                                         0) * v_beat,
                                                     0,
                                                     1,
                                                     NVL(T2.ADVANCE_ARR_NUM, 0) *
                                                     v_beat))
               WHEN T2.FLAGX = 0 AND T2.D_ASSEMBLE_TIME IS NOT NULL THEN
               --计算到货时间
                PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                             'A1',
                                             T2.D_ASSEMBLE_TIME,
                                             -DECODE(NVL(T2.ADVANCE_ARR_NUM,
                                                         0) * v_beat,
                                                     0,
                                                     1,
                                                     NVL(T2.ADVANCE_ARR_NUM, 0) *
                                                     v_beat))
               ELSE
                v_firstcar_time
             END,
             --取货时间
             NULL,
             T2.MERGE_NUM,
             T2.TRANS_TIME,
             T2.ADVANCE_ARR_NUM,
             T2.FLAGX,
             --装配SORT_ID
             NULL,
             T2.FACTORY_CODE,
             T2.FIRST_ARRIVE_TIME,
             T2.SUP_OUT_TIME,
             T2.PICK_CYCLE,
             TO_CHAR(T2.SPE_ARRIVE_TIME, 'HH24:MI:SS'),
             T2.DEPART_TIME_POINT,
             T2.RET_EMPTY_PLATFORM
        FROM (SELECT E.AREA,
                     T1.SUP_FACTORY,
                     T1.SUPPLIER_NO,
                     E.FACTORY_CODE,
                     T1.UNLOAD_PORT,
                     E.UNLOAD_PLACE,
                     E.PICKUP_TYPE,
                     E.CAR_TYPE,
                     E.ROUTE_CODE,
                     T1.GROUPID,
                     T1.DR_SORT_ID_START,
                     T1.DR_SORT_ID_END,
                     E.SUP_CAL_NUM,
                     NVL(E.MERGE_NUM, 0) MERGE_NUM,
                     NVL(F.LOC_DEPTH, 0) LOC_DEPTH,
                     T1.L_START_SORT_ID,
                     T1.FLAG,
                     E.TRANS_TIME,
                     E.ADVANCE_ARR_NUM,
                     T1.D_AFOFF_TIME,
                     --计算装配时间
                     CASE
                       WHEN T1.WORKCENTER = 'W1' THEN
                         --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     T1.D_AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             (v_af_max_loc +
                                                             v_pa_max_loc +
                                                             v_pbs_max_loc +
                                                             v_we_max_loc +
                                                             v_wbs_max_loc) *
                                                             v_beat,
                                                             (v_af_max_loc +
                                                             v_pbs_max_loc +
                                                             v_pa_max_loc +
                                                             v_wbs_max_loc +
                                                             NVL(F.LOC_DEPTH,
                                                                  0)) * v_beat))

                       WHEN T1.WORKCENTER = 'T1' THEN
                       --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     T1.D_AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             (v_af_max_loc +
                                                             v_pa_max_loc +
                                                             v_pbs_max_loc) *
                                                             v_beat,
                                                             (v_af_max_loc +
                                                             v_pbs_max_loc +
                                                             NVL(F.LOC_DEPTH,
                                                                  0)) * v_beat))
                       ELSE
                         --总装和支给件数据
                       --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     T1.D_AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             v_af_max_loc *
                                                             v_beat,
                                                             NVL(F.LOC_DEPTH, 0) *
                                                             v_beat))
                     END D_ASSEMBLE_TIME,
                     T1.L_AFOFF_TIME,
                     CASE
                       WHEN T1.WORKCENTER = 'W1' THEN
                      --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     T1.L_AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             (v_af_max_loc +
                                                             v_pa_max_loc +
                                                             v_pbs_max_loc +
                                                             v_we_max_loc +
                                                             v_wbs_max_loc) *
                                                             v_beat,
                                                             (v_af_max_loc +
                                                             v_pbs_max_loc +
                                                             v_pa_max_loc +
                                                             v_wbs_max_loc +
                                                             NVL(F.LOC_DEPTH,
                                                                  0)) * v_beat))
                       WHEN T1.WORKCENTER = 'T1' THEN
                       --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     T1.L_AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             (v_af_max_loc +
                                                             v_pa_max_loc +
                                                             v_pbs_max_loc) *
                                                             v_beat,
                                                             (v_af_max_loc +
                                                             v_pbs_max_loc +
                                                             NVL(F.LOC_DEPTH,
                                                                  0)) * v_beat))
                       ELSE
                         --总装和支给件数据
                          --计算装配时间
                        PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                     'A1',
                                                     T1.L_AFOFF_TIME,
                                                     -DECODE(NVL(F.LOC_DEPTH,
                                                                 0) * v_beat,
                                                             0,
                                                             v_af_max_loc *
                                                             v_beat,
                                                             NVL(F.LOC_DEPTH, 0) *
                                                             v_beat))

                     END L_ASSEMBLE_TIME,
                     DECODE(T1.CYFLAG,
                            1,
                            1,
                            0,
                            PKG_PUP_MAIN.USP_PUP_CHECK_WORKDAY(NVL(T1.D_AFOFF_TIME,
                                                                   v_firstcar_time),

                                                               NVL(T1.L_AFOFF_TIME,
                                                                   v_firstcar_time))) FLAGX,
                     E.FIRST_ARRIVE_TIME,
                     E.SUP_OUT_TIME,
                     E.PICK_CYCLE,
                     E.SPE_ARRIVE_TIME,
                     E.DEPART_TIME_POINT,
                     E.RET_EMPTY_PLATFORM
                FROM (SELECT A.SUP_FACTORY,
                             A.UNLOAD_PORT,
                             A.GROUPID,
                             MIN(A.DR_SORT_ID_START) DR_SORT_ID_START,
                             MIN(A.DR_SORT_ID_END) DR_SORT_ID_END,
                             MIN(C.AFOFF_TIME) D_AFOFF_TIME,
                             DECODE(MIN(C.AFOFF_TIME), NULL, 1, 0) CYFLAG,
                             MIN(D.AFOFF_TIME) L_AFOFF_TIME,
                             MIN(LR_SORT_ID_START) L_START_SORT_ID,
                             1 FLAG,
                             A.SUPPLIER_NO,
                             MIN(A.WORKCENTER) WORKCENTER
                        FROM (SELECT TT.SUP_FACTORY,
                                     TT.UNLOAD_PORT,
                                     TT.DIST_GROUP_ID    GROUPID,
                                     TT.DR_SORT_ID_START,
                                     TT.LR_SORT_ID_START,
                                     PD.DR_SORT_ID_END,
                                     1                   FLAG,
                                     TT.SUPPLIER_NO,
                                     MP1.WORKCENTER
                                FROM MM_PUP_DR PD
                                LEFT JOIN (SELECT MP.UNLOAD_PORT,
                                                 MIN(MP.WORKCENTER) WORKCENTER,
                                                 MP.FACTORY_CODE
                                            FROM MM_MP_PART MP
                                           GROUP BY MP.UNLOAD_PORT,
                                                    MP.FACTORY_CODE) MP1
                                  ON PD.FACTORY_CODE = MP1.FACTORY_CODE
                                 AND PD.UNLOAD_PORT = MP1.UNLOAD_PORT
                                LEFT JOIN (SELECT DISTINCT T.SUP_FACTORY,
                                                          T.SUPPLIER_NO,
                                                          T.UNLOAD_PORT,
                                                          T.GROUP_ID GROUPID,
                                                          T.GROUP_ID || '-' ||
                                                          SUBSTR(T.LOGISTICS_ORDER,
                                                                 INSTR(T.LOGISTICS_ORDER,
                                                                       '-') + 1) DIST_GROUP_ID,
                                                          T.DR_SORT_ID_START,
                                                          T.LR_SORT_ID_START
                                            FROM MM_PUP_ORDER_RECORD T
                                           WHERE INSTR(T.LOGISTICS_ORDER, '-') > 1
                                             AND T.TOTAL_ORDER_NUM > 0
                                             AND T.ORDER_TYPE = 1
                                             AND T.FACTORY_CODE =
                                                 in_arr_factory) TT
                                  ON TT.SUP_FACTORY = PD.SUP_FACTORY
                                 AND TT.SUPPLIER_NO = PD.SUPPLIER_NO
                                 AND TT.UNLOAD_PORT = PD.UNLOAD_PORT
                                 AND TT.GROUPID = PD.TOTAL_NO
                               WHERE TT.SUP_FACTORY IS NOT NULL
                                 AND PD.FACTORY_CODE = in_arr_factory) A
                        LEFT JOIN MM_PUP_ROUTE B
                          ON A.SUP_FACTORY = B.SUP_FACTORY
                         AND A.SUPPLIER_NO = B.SUPPLIER_NO
                         AND B.UNLOAD_PORT = A.UNLOAD_PORT
                         AND B.FACTORY_CODE = in_arr_factory
                        LEFT JOIN MM_PUP_PRO_PLAN_TEMP C
                          ON B.FACTORY_CODE = C.FACTORY_CODE
                         AND B.CAR_TYPE = C.CAR_TYPE
                         AND A.DR_SORT_ID_START <= C.MIX_SORT_ID
                         AND A.DR_SORT_ID_END >= C.MIX_SORT_ID
                        LEFT JOIN MM_PUP_PRO_PLAN_TEMP D
                          ON D.FACTORY_CODE = B.FACTORY_CODE
                         AND D.CAR_TYPE = B.CAR_TYPE
                         AND A.LR_SORT_ID_START <= D.MIX_SORT_ID
                         AND A.DR_SORT_ID_END >= D.MIX_SORT_ID
                       GROUP BY A.SUPPLIER_NO,
                                A.SUP_FACTORY,
                                A.UNLOAD_PORT,
                                A.GROUPID) T1
                LEFT JOIN MM_PUP_ROUTE E
                  ON T1.SUP_FACTORY = E.SUP_FACTORY
                 AND T1.SUPPLIER_NO = E.SUPPLIER_NO
                 AND T1.UNLOAD_PORT = E.UNLOAD_PORT
                 AND E.FACTORY_CODE = in_arr_factory
                LEFT JOIN (SELECT IPL.SUPPLIER_NO,
                                 IPL.WORKCENTER,
                                 MAX(IPL.LOCATION_NUM) LOC_DEPTH
                            FROM MM_INV_PART_LOCATION IPL
                           WHERE IPL.FACTORY_CODE = in_arr_factory
                             AND IPL.EFF_START <= SYSDATE
                             AND IPL.EFF_END > SYSDATE
                           GROUP BY IPL.SUPPLIER_NO, IPL.WORKCENTER) F
                  ON T1.SUPPLIER_NO = F.SUPPLIER_NO
                 AND T1.WORKCENTER = F.WORKCENTER) T2
       WHERE NOT EXISTS
       (SELECT 1
                FROM MM_PUP_ROUTE_CAL_TEMP T
               WHERE T.TOTAL_NO =
                     DECODE(T2.FLAGX,
                            1,
                            T2.GROUPID,
                            SUBSTR(T2.GROUPID, 1, INSTR(T2.GROUPID, '-') - 1))
                 AND T.SUP_FACTORY = T2.SUP_FACTORY
                 AND T.SUPPLIER_NO = T2.SUPPLIER_NO
                 AND T.UNLOAD_PORT = T2.UNLOAD_PORT
                 AND T.ROUTE_CODE = T2.ROUTE_CODE);
    COMMIT;

    --省外到货时间处理（将省外的路线，少于上班时间的凌晨时间全部提前一天，按23:30到货。）
    UPDATE MM_PUP_ROUTE_CAL_TEMP A
       SET A.ARRIVE_TIME = TO_DATE(TO_CHAR(A.ARRIVE_TIME - 1, 'YYYY-MM-DD') || '' ||
                                   '23:30:00',
                                   'YYYY-MM-DD HH24:MI:SS')
     WHERE A.AREA = '省外'
       AND A.FACTORY_CODE = in_arr_factory
       AND TO_CHAR(A.ARRIVE_TIME, 'HH24:MI:SS') >= '00:00:00'
       AND TO_CHAR(A.ARRIVE_TIME, 'HH24:MI:SS') <=
           (SELECT TO_CHAR(B.WORK_END_TIME, 'HH24:MI:SS')
              FROM MM_PUB_WORK_CALENDAR B
             WHERE B.SHIFT_CODE = 1
               AND B.WORK_DATE =
                   TO_DATE(TO_CHAR(A.ARRIVE_TIME - 1, 'YYYY-MM-DD'),
                           'YYYY-MM-DD')
               AND B.FACTORY_CODE = in_arr_factory
               AND B.WORKCENTER = 'A1');

    --若计算出来的到货时间大于固定时间，则按固定时间，若少于固定时间，则提前一天到货。
    UPDATE MM_PUP_ROUTE_CAL_TEMP A
       SET A.ARRIVE_TIME = CASE
                             WHEN TO_CHAR(A.ARRIVE_TIME, 'HH24:MI:SS') >
                                  A.SPE_ARR_TIME THEN
                              TO_DATE(TO_CHAR(A.ARRIVE_TIME, 'YYYY-MM-DD') || '' ||
                                      A.SPE_ARR_TIME,
                                      'YYYY-MM-DD HH24:MI:SS')
                             ELSE
                              TO_DATE(TO_CHAR(A.ARRIVE_TIME - 1, 'YYYY-MM-DD') || '' ||
                                      A.SPE_ARR_TIME,
                                      'YYYY-MM-DD HH24:MI:SS')
                           END
     WHERE A.SPE_ARR_TIME <> '00:00:00'
       AND A.SPE_ARR_TIME IS NOT NULL
       AND A.FACTORY_CODE = in_arr_factory;

    --根据工作日调整到货时间(特殊到货时间处理) 提前一天的情况，需要判断提前到的那一天是不是工作日
    UPDATE MM_PUP_ROUTE_CAL_TEMP A
       SET A.ARRIVE_TIME =
           (SELECT TO_DATE(TO_CHAR(B.WORK_DATE, 'YYYY-MM-DD') || '' ||
                           TO_CHAR(A.ARRIVE_TIME, 'HH24:MI:SS'),
                           'YYYY-MM-DD HH24:MI:SS')
              FROM MM_PUB_WORK_CALENDAR B
             WHERE B.FACTORY_CODE = in_arr_factory
               AND B.WORK_DATE =
                   (SELECT MAX(D.WORK_DATE)
                      FROM MM_PUB_WORK_CALENDAR D
                     WHERE D.WORK_DATE < TRUNC(TO_DATE(SYSDATE), 'DD')
                       AND B.WORKCENTER = 'A1'))
     WHERE NOT EXISTS (SELECT 1
              FROM MM_PUB_WORK_CALENDAR C
             WHERE TRUNC(A.ARRIVE_TIME) = C.WORK_DATE)
       AND A.PICK_CYCLE IS NULL
       AND A.SPE_ARR_TIME <> '00:00:00'
       AND A.SPE_ARR_TIME IS NOT NULL
       AND A.FACTORY_CODE = in_arr_factory;

    --？？？？？？？？？？？如果到货时间在第一个工作日的00:00-04:05区间则提前到货

    /**
    取货时间处理修改2019-01-03，分省内和省外处理
    */
    /*--取货时间处理
    UPDATE MM_PUP_ROUTE_CAL_TEMP B
       SET B.PICK_TIME =
           (SELECT C.PICK_TIME
              FROM (SELECT A.ID,
                           --计算取货时间
                           USF_MM_MP_FORHOUR(TO_CHAR(A.ARRIVE_TIME,
                                                     'YYYY-MM-DD HH24:MI'),
                                             CEIL(NVL(A.TRANS_TIME, 0) * 60),
                                             'A1',
                                             in_arr_factory) PICK_TIME,
                           A.FACTORY_CODE
                      FROM MM_PUP_ROUTE_CAL_TEMP A) C
             WHERE C.ID = B.ID
               AND C.FACTORY_CODE = B.FACTORY_CODE);*/

    --省内取货时间处理
    UPDATE MM_PUP_ROUTE_CAL_TEMP B
       SET B.PICK_TIME =
           (SELECT C.PICK_TIME
              FROM (SELECT A.ID,
                           PKG_PUB.USF_GET_CAL_WORKTIME(in_arr_factory,
                                                        'A1',
                                                        A.ARRIVE_TIME,
                                                        - (DECODE(NVL(A.TRANS_TIME,
                                                                     0) * 60 * 60,
                                                                 0,
                                                                 1,
                                                                 NVL(A.TRANS_TIME,
                                                                     0) * 60 * 60))) PICK_TIME,
                           A.FACTORY_CODE
                      FROM MM_PUP_ROUTE_CAL_TEMP A) C
             WHERE C.ID = B.ID
               AND C.FACTORY_CODE = B.FACTORY_CODE)
     WHERE B.AREA = '省内';

    --省外取货时间处理
    UPDATE MM_PUP_ROUTE_CAL_TEMP B
       SET B.PICK_TIME =
           (SELECT C.PICK_TIME
              FROM (SELECT A.ID,
                           TO_DATE(USF_MM_MP_FORBAKWORKDATE(TO_CHAR(A.ARRIVE_TIME,
                                                                    'YYYY-MM-DD'),
                                                            CEIL(NVL(A.TRANS_TIME,
                                                                     0) / 24),
                                                            'A1',
                                                            in_arr_factory,
                                                            0) ||
                                   TO_CHAR(A.ARRIVE_TIME, 'HH24:MI:SS'),
                                   'YYYY-MM-DD HH24:MI:SS') PICK_TIME,
                           A.FACTORY_CODE
                      FROM MM_PUP_ROUTE_CAL_TEMP A) C
             WHERE C.ID = B.ID
               AND C.FACTORY_CODE = B.FACTORY_CODE)
     WHERE B.AREA = '省外';

    FOR cur_data IN (SELECT A.*, TO_CHAR(A.PICK_TIME, 'D') - 1 PICKDAY
                       FROM MM_PUP_ROUTE_CAL_TEMP A
                      WHERE A.PICK_CYCLE IS NOT NULL
                        AND A.FACTORY_CODE = in_arr_factory) LOOP
      IF (INSTR(cur_data.PICK_CYCLE, TO_CHAR(cur_data.PICKDAY)) > 0) THEN
        IF (cur_data.PICK_CYCLE = '1, 3, 5' AND
           (TO_CHAR(cur_data.PICK_TIME, 'D') = 6)) THEN
          --取货周期为1,3,5且为周五的时候提前到周3货量均衡，因为周六的会提前到周五，如果不调整会导致周五货量太多
          UPDATE MM_PUP_ROUTE_CAL_TEMP A
             SET A.ADJ_PICKUP_TIME = A.PICK_TIME - 2
           WHERE A.ID = cur_data.ID;
        ELSE
          UPDATE MM_PUP_ROUTE_CAL_TEMP A
             SET A.ADJ_PICKUP_TIME = A.PICK_TIME
           WHERE A.ID = cur_data.ID;
        END IF;
      ELSE
        v_num  := 0;
        v_temp := 0;
        LOOP
          --判断取货时间减去几天会落到会存在于取货周期上，记录天数
          v_num  := v_num + 1;
          v_temp := INSTR(cur_data.PICK_CYCLE,
                          TO_CHAR(cur_data.PICK_TIME - v_num, 'D') - 1);
          EXIT WHEN v_temp > 0;
        END LOOP;
        --将调整取货时间更新到最近的取货周期上
        UPDATE MM_PUP_ROUTE_CAL_TEMP A
           SET A.ADJ_PICKUP_TIME = A.PICK_TIME - v_num
         WHERE A.ID = cur_data.ID;

      END IF;
    END LOOP;

    --更新调整取货时间为空的数据取货时间
    UPDATE MM_PUP_ROUTE_CAL_TEMP A
       SET A.ADJ_PICKUP_TIME = A.PICK_TIME
     WHERE A.ADJ_PICKUP_TIME IS NULL
       AND A.FACTORY_CODE = in_arr_factory;

    --固定周期不对日期调整
    UPDATE MM_PUP_ROUTE_CAL_TEMP A
       SET A.ADJ_PICKUP_TIME = TO_DATE(TO_CHAR(A.ADJ_PICKUP_TIME,
                                               'YYYY-MM-DD') || '' ||
                                       TO_CHAR(A.SUP_DELIV_TIME,
                                               'HH24:MI:SS'),
                                       'YYYY-MM-DD HH24:MI:SS')
     WHERE A.SUP_DELIV_TIME IS NOT NULL
       AND A.FACTORY_CODE = in_arr_factory
       AND TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') >
           TO_CHAR(A.SUP_DELIV_TIME, 'HH24:MI:SS')
       AND A.PICK_CYCLE IS NOT NULL;

    --因为调整成了供应商出货时间，所以需要判断这个时间是不是在0点到中班结束之间
    UPDATE MM_PUP_ROUTE_CAL_TEMP A
       SET A.ADJ_PICKUP_TIME = TO_DATE(TO_CHAR(A.ADJ_PICKUP_TIME,
                                               'YYYY-MM-DD') || ' ' ||
                                       '08:30:00',
                                       'YYYY-MM-DD HH24:MI:SS')
     WHERE A.SUP_DELIV_TIME IS NOT NULL
       AND A.FACTORY_CODE = in_arr_factory
       AND (TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') >= '00:00:00' AND
           TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') <= '04:05:00')
       AND A.PICK_CYCLE IS NOT NULL;

    --根据供应商出货时间调整取货时间(非固定周期)
    UPDATE MM_PUP_ROUTE_CAL_TEMP A
       SET A.ADJ_PICKUP_TIME = CASE
                                 WHEN TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') >=
                                      '00:00:00' AND
                                      TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') <=
                                      '04:05:00' THEN
                                  TO_DATE(TO_CHAR(A.ADJ_PICKUP_TIME - 1,
                                                  'YYYY-MM-DD') || '' ||
                                          TO_CHAR(A.SUP_DELIV_TIME,
                                                  'HH24:MI:SS'),
                                          'YYYY-MM-DD HH24:MI:SS')
                                 WHEN TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') >
                                      TO_CHAR(A.SUP_DELIV_TIME, 'HH24:MI:SS') THEN
                                  TO_DATE(TO_CHAR(A.ADJ_PICKUP_TIME,
                                                  'YYYY-MM-DD') || ' ' ||
                                          TO_CHAR(A.SUP_DELIV_TIME,
                                                  'HH24:MI:SS'),
                                          'YYYY-MM-DD HH24:MI:SS')
                               END
     WHERE A.SUP_DELIV_TIME IS NOT NULL
       AND A.FACTORY_CODE = in_arr_factory
       AND (TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') >
           TO_CHAR(A.SUP_DELIV_TIME, 'HH24:MI:SS') OR
           (TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') >= '00:00:00' AND
           TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') <= '04:05:00'))
       AND A.PICK_CYCLE IS NULL;

    --根据工作日调整取货时间(大于中班结束时间)
    UPDATE MM_PUP_ROUTE_CAL_TEMP A
       SET A.ADJ_PICKUP_TIME =
           (SELECT TO_DATE(TO_CHAR(B.WORK_DATE, 'YYYY-MM-DD') || ' ' ||
                           TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS'),
                           'YYYY-MM-DD HH24:MI:SS')
              FROM MM_PUB_WORK_CALENDAR B
             WHERE B.FACTORY_CODE = in_arr_factory
               AND B.WORK_DATE =
                   (SELECT MAX(D.WORK_DATE)
                      FROM MM_PUB_WORK_CALENDAR D
                     WHERE D.WORK_DATE < TRUNC(A.ADJ_PICKUP_TIME, 'DD')))
     WHERE NOT EXISTS
     (SELECT 1
              FROM MM_PUB_WORK_CALENDAR C
             WHERE TRUNC(A.ADJ_PICKUP_TIME) = C.WORK_DATE)
       AND A.PICK_CYCLE IS NULL
       AND TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') >
           (SELECT E.WORK_END_TIME
              FROM MM_PUB_WORK_CALENDAR E
             WHERE E.WORK_DATE = TRUNC(A.ADJ_PICKUP_TIME - 1, 'DD')
               AND E.SHIFT_CODE = 1);

    --根据工作日调整取货时间(中班结束时间内)
    UPDATE MM_PUP_ROUTE_CAL_TEMP A
       SET A.ADJ_PICKUP_TIME =
           (SELECT TO_DATE(TO_CHAR(B.WORK_DATE, 'YYYY-MM-DD') || ' ' ||
                           TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS'),
                           'YYYY-MM-DD HH24:MI:SS')
              FROM MM_PUB_WORK_CALENDAR B
             WHERE B.FACTORY_CODE = in_arr_factory
               AND B.WORK_DATE =
                   (SELECT MAX(D.WORK_DATE)
                      FROM MM_PUB_WORK_CALENDAR D
                     WHERE D.WORK_DATE < TRUNC(A.ADJ_PICKUP_TIME, 'DD')
                       AND D.FACTORY_CODE = in_arr_factory))
     WHERE NOT EXISTS (SELECT 1
              FROM MM_PUB_WORK_CALENDAR C
             WHERE TRUNC(A.ADJ_PICKUP_TIME) = C.WORK_DATE)
       AND NOT EXISTS
     (SELECT 1
              FROM MM_PUB_WORK_CALENDAR F
             WHERE TRUNC(A.ADJ_PICKUP_TIME - 1, 'DD') = F.WORK_DATE
               AND F.FACTORY_CODE = in_arr_factory)
       AND A.PICK_CYCLE IS NULL
       AND TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') >= '00:00:00'
       AND TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') <=
           (SELECT E.WORK_END_TIME
              FROM MM_PUB_WORK_CALENDAR E
             WHERE E.WORK_DATE = TRUNC(A.ADJ_PICKUP_TIME - 1, 'DD')
               AND E.SHIFT_CODE = 1);

    --??????????如果取货时间在第一个工作日的00:00-04:05区间则提前取货

    --生成路线时刻表
    INSERT INTO MM_PUP_ROUTE_CAL
      (ID,
       AREA,
       CAR_TYPE,
       ROUTE_CODE,
       PICKUP_TYPE,
       TOTAL_NO,
       MERGE_NO,
       TODAY_NO,
       PICK_TIME,
       ARRIVE_TIME,
       ASSEMBLE_TIME,
       CREATION_TIME,
       ADJ_PICKUP_TIME,
       UNLOAD_PLACE,
       UNLOAD_PORT,
       FACTORY_CODE,
       MERGE_NUM)
      SELECT SEQ_MM_PUP_ROUTE_CAL.NEXTVAL,
             T5.AREA,
             T5.CAR_TYPE,
             T5.ROUTE_CODE,
             T5.PICKUP_TYPE,
             T5.TOTAL_NO,
             CEIL((ROW_NUMBER()
                   OVER(PARTITION BY T5.ROUTE_CODE ORDER BY T5.PICKTIME ASC)) /
                  DECODE(T5.MERGE_NUM, 0, 1, T5.MERGE_NUM)) *
             DECODE(T5.MERGE_NUM, 0, 0, 1),
             CEIL((ROW_NUMBER() OVER(PARTITION BY T5.ROUTE_CODE,
                                     TO_CHAR(T5.PICKTIME, 'YYYY-MM-DD') ORDER BY
                                     T5.PICKTIME ASC)) /
                  DECODE(T5.MERGE_NUM, 0, 1, T5.MERGE_NUM)),
             T5.PICKTIME,
             T5.ARRIVETIME,
             T5.ASSEMBLETIME,
             SYSDATE,
             T5.PICKTIME,
             T5.UNLOAD_PLACE,
             T5.UNLOAD_PORT,
             T5.FACTORY_CODE,
             T5.MERGE_NUM
        FROM (SELECT T4.AREA,
                     T4.CAR_TYPE,
                     T4.ROUTE_CODE,
                     T4.UNLOAD_PLACE,
                     T4.UNLOAD_PORT,
                     T4.PICKUP_TYPE,
                     T4.TOTAL_NO,
                     COUNT(1) NUMS,
                     MAX(T4.MERGE_NUM) MERGE_NUM,
                     MIN(T4.ADJ_PICKUP_TIME) PICKTIME,
                     MIN(T4.ARRIVE_TIME) ARRIVETIME,
                     MIN(T4.ASSEMBLE_TIME) ASSEMBLETIME,
                     T4.FACTORY_CODE
                FROM MM_PUP_ROUTE_CAL_TEMP T4
               WHERE T4.FACTORY_CODE = in_arr_factory
                 AND NOT EXISTS
               (SELECT 1
                        FROM MM_PUP_LOCK_PLAN SH
                       WHERE SH.ROUTE_CODE = T4.ROUTE_CODE
                         AND SH.CAR_TYPE = T4.CAR_TYPE
                         AND T4.TOTAL_NO = SH.TOTAL_NO
                         AND NVL(SH.MERGE_NO, 0) <> 0)
               GROUP BY T4.AREA,
                        T4.PICKUP_TYPE,
                        T4.CAR_TYPE,
                        T4.ROUTE_CODE,
                        T4.UNLOAD_PLACE,
                        T4.UNLOAD_PORT,
                        T4.TOTAL_NO,
                        T4.FACTORY_CODE) T5;

    --调整合并车次时间
    UPDATE MM_PUP_ROUTE_CAL B
       SET (B.PICK_TIME, B.ADJ_PICKUP_TIME, B.ARRIVE_TIME) =
           (SELECT C.PICKTIME, C.PICKTIME, C.ARRIVETIME
              FROM (SELECT A.ROUTE_CODE,
                           A.MERGE_NO,
                           MIN(A.ADJ_PICKUP_TIME) PICKTIME,
                           MIN(A.ARRIVE_TIME) ARRIVETIME
                      FROM MM_PUP_ROUTE_CAL A
                     WHERE A.MERGE_NO > 0
                       AND A.FACTORY_CODE = in_arr_factory
                     GROUP BY A.ROUTE_CODE, A.MERGE_NO) C
             WHERE B.ROUTE_CODE = C.ROUTE_CODE
               AND B.MERGE_NO = C.MERGE_NO)
     WHERE B.MERGE_NO > 0
       AND B.FACTORY_CODE = in_arr_factory;
    COMMIT;

    --更新工作日
    UPDATE MM_PUP_ROUTE_CAL A
       SET A.WORKDAY = CASE
                         WHEN TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') >
                              '00:00:00' AND
                              TO_CHAR(A.ADJ_PICKUP_TIME, 'HH24:MI:SS') < =
                              '04:05:00' THEN
                          TO_CHAR(A.ADJ_PICKUP_TIME - 1, 'YYYY-MM-DD')
                         ELSE
                          TO_CHAR(A.ADJ_PICKUP_TIME, 'YYYY-MM-DD')
                       END
     WHERE A.FACTORY_CODE = in_arr_factory;

    --更新当日车次顺序
    MERGE INTO MM_PUP_ROUTE_CAL PS
    USING (SELECT A.ID,
                  A.FACTORY_CODE,
                  CEIL((ROW_NUMBER() OVER(PARTITION BY A.ROUTE_CODE,
                                          A.WORKDAY ORDER BY A.MERGE_NO ASC,
                                          A.ASSEMBLE_TIME ASC,
                                          A.TOTAL_NO ASC)) /
                       DECODE(A.MERGE_NUM, 0, 1, A.MERGE_NUM)) NUMS
             FROM MM_PUP_ROUTE_CAL A) B
    ON (PS.ID = B.ID AND PS.FACTORY_CODE = B.FACTORY_CODE)
    WHEN MATCHED THEN
      UPDATE SET PS.TODAY_NO = B.NUMS;

    --调整固定路线取货时间,到货日期与取货日期不一致调整为工作日
    MERGE INTO (SELECT *
                  FROM MM_PUP_ROUTE_CAL A
                 WHERE A.ADJ_PICKUP_TIME IS NOT NULL
                   AND A.WORKDAY IS NOT NULL) A
    USING MM_PUP_FIX_PICKUP_TIME B
    ON (A.ROUTE_CODE = B.ROUTE_CODE AND A.TODAY_NO = B.TODAY_NO AND A.FACTORY_CODE = B.FACTORY_CODE)
    WHEN MATCHED THEN
      UPDATE
         SET A.ADJ_PICKUP_TIME = CASE
                                   WHEN TO_CHAR(A.ADJ_PICKUP_TIME, 'YYYY-MM-DD') != A.WORKDAY OR
                                        TO_CHAR(A.ARRIVE_TIME, 'YYYY-MM-DD') != A.WORKDAY THEN
                                    TO_DATE(A.WORKDAY || ' ' || TO_CHAR(B.PICK_TIME, 'HH24:MI:SS'),
                                            'YYYY-MM-DD HH24:MI:SS')
                                   ELSE
                                    TO_DATE(TO_CHAR(A.ADJ_PICKUP_TIME, 'YYYY-MM-DD') || ' ' ||
                                            TO_CHAR(B.PICK_TIME, 'HH24:MI:SS'),
                                            'YYYY-MM-DD HH24:MI:SS')
                                 END,
             A.PICK_TIME       = CASE
                                   WHEN TO_CHAR(A.ADJ_PICKUP_TIME, 'YYYY-MM-DD') != A.WORKDAY OR
                                        TO_CHAR(A.ARRIVE_TIME, 'YYYY-MM-DD') != A.WORKDAY THEN
                                    TO_DATE(A.WORKDAY || ' ' || TO_CHAR(B.PICK_TIME, 'HH24:MI:SS'),
                                            'YYYY-MM-DD HH24:MI:SS')
                                   ELSE
                                    TO_DATE(TO_CHAR(A.PICK_TIME, 'YYYY-MM-DD') || ' ' ||
                                            TO_CHAR(B.PICK_TIME, 'HH24:MI:SS'),
                                            'YYYY-MM-DD HH24:MI:SS')
                                 END,
             A.ARRIVE_TIME     = CASE
                                   WHEN TO_CHAR(A.ADJ_PICKUP_TIME, 'YYYY-MM-DD') != A.WORKDAY OR
                                        TO_CHAR(A.ARRIVE_TIME, 'YYYY-MM-DD') != A.WORKDAY THEN
                                    TO_DATE(A.WORKDAY || ' ' || TO_CHAR(B.ARRIVE_TIME, 'HH24:MI:SS'),
                                            'YYYY-MM-DD HH24:MI:SS')
                                   ELSE
                                    TO_DATE(TO_CHAR(A.ARRIVE_TIME, 'YYYY-MM-DD') || ' ' ||
                                            TO_CHAR(B.ARRIVE_TIME, 'HH24:MI:SS'),
                                            'YYYY-MM-DD HH24:MI:SS')
                                 END;

    --历史路线替换
    MERGE INTO MM_PUP_ROUTE_CAL A
    USING (SELECT *
             FROM MM_PUP_LOCK_PLAN SH
            WHERE SUBSTR(SH.WORKDAY, 1, 10) >=
                  TO_CHAR(SYSDATE - 7, 'YYYY-MM-DD')
              AND SH.FACTORY_CODE = in_arr_factory) B
    ON (A.ROUTE_CODE = B.ROUTE_CODE AND A.CAR_TYPE = B.CAR_TYPE AND A.TOTAL_NO = B.TOTAL_NO AND A.FACTORY_CODE = B.FACTORY_CODE)
    WHEN MATCHED THEN
      UPDATE
         SET A.PICK_TIME       = TO_DATE(TO_CHAR(B.PICK_DATE,
                                                 'YYYY-MM-DD HH24:MI:SS'),
                                         'YYYY-MM-DD HH24:MI:SS'),
             A.ARRIVE_TIME     = TO_DATE(TO_CHAR(B.ARRIVE_DATE,
                                                 'YYYY-MM-DD HH24:MI:SS'),
                                         'YYYY-MM-DD HH24:MI:SS'),
             A.ASSEMBLE_TIME   = TO_DATE(TO_CHAR(B.ASSEMBLE_DATE,
                                                 'YYYY-MM-DD HH24:MI:SS'),
                                         'YYYY-MM-DD HH24:MI:SS'),
             A.ADJ_PICKUP_TIME = TO_DATE(TO_CHAR(B.PICK_DATE,
                                                 'YYYY-MM-DD HH24:MI:SS'),
                                         'YYYY-MM-DD HH24:MI:SS'),
             A.MERGE_NO        = NVL(B.MERGE_NO, 0),
             A.TODAY_NO        = B.TODAY_NO,
             A.WORKDAY         = SUBSTR(B.WORKDAY, 1, 10)
    WHEN NOT MATCHED THEN
      INSERT
        (ID,
         AREA,
         PICKUP_TYPE,
         CAR_TYPE,
         ROUTE_CODE,
         TOTAL_NO,
         MERGE_NO,
         TODAY_NO,
         PICK_TIME,
         ADJ_PICKUP_TIME,
         ARRIVE_TIME,
         ASSEMBLE_TIME,
         WORKDAY,
         FACTORY_CODE,
         UNLOAD_PLACE)
      VALUES
        (SEQ_MM_PUP_ROUTE_CAL.Nextval,
         B.AREA,
         B.PICKUP_TYPE,
         B.CAR_TYPE,
         B.ROUTE_CODE,
         B.TOTAL_NO,
         B.MERGE_NO,
         B.TODAY_NO,
         B.PICK_DATE,
         B.PICK_DATE,
         B.ARRIVE_DATE,
         B.ASSEMBLE_DATE,
         B.WORKDAY,
         B.FACTORY_CODE,
         B.UNLOAD_PLACE);

    --有批次标识的到货时间 = 工作日加上+取货时间+运输时间
    /*    MERGE INTO MM_PUP_ROUTE_CAL A
    USING (SELECT TO_DATE(SUBSTR(D.WORKDAY, 1, 10) || ' ' ||
                          TO_CHAR(D.PICK_TIME, 'HH24:MI:SS'),
                          'YYYY-MM-DD HH24:MI:SS') + NVL(C.TRANS_TIME, 0) ARRIVE_TIME,
                  D.ID
             FROM (SELECT DISTINCT B.ROUTE_CODE,
                                   B.CAR_TYPE,
                                   B.FACTORY_CODE,
                                   B.BATCH,
                                   B.TRANS_TIME
                     FROM MM_PUP_ROUTE B
                    WHERE B.BATCH = 1) C,
                  MM_PUP_ROUTE_CAL D
            WHERE C.ROUTE_CODE = D.ROUTE_CODE
              AND C.CAR_TYPE = D.CAR_TYPE
              AND C.FACTORY_CODE = D.FACTORY_CODE
              AND C.FACTORY_CODE = in_arr_factory) E
    ON (A.ID = E.ID)
    WHEN MATCHED THEN
      UPDATE SET A.ARRIVE_TIME = E.ARRIVE_TIME;*/

    --固定省外的取货时间 9:30，到货时间 10:30
    UPDATE MM_PUP_ROUTE_CAL A
       SET A.PICK_TIME       = TO_DATE(TO_CHAR(A.PICK_TIME, 'YYYY-MM-DD') || ' ' ||
                                       '09:30:00',
                                       'YYYY-MM-DD HH24:MI:SS'),
           A.ADJ_PICKUP_TIME = TO_DATE(TO_CHAR(A.ADJ_PICKUP_TIME,
                                               'YYYY-MM-DD') || ' ' ||
                                       '09:30:00',
                                       'YYYY-MM-DD HH24:MI:SS'),
           A.ARRIVE_TIME     = TO_DATE(TO_CHAR(A.ARRIVE_TIME, 'YYYY-MM-DD') || ' ' ||
                                       '10:30:00',
                                       'YYYY-MM-DD HH24:MI:SS')
     WHERE A.AREA = '省外'
       AND A.ADJ_PICKUP_TIME IS NOT NULL
       AND A.FACTORY_CODE = in_arr_factory;

    --调整计划
    USP_PUP_MOD(in_arr_factory);

    COMMIT;
    out_code := 1;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        out_code := 0;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUP_GEN',
           err_num,
           err_msg,
           sysdate,
           '物流计划生成');
        COMMIT;

      END;
  END USP_PUP_GEN;

  --***************************************************************************
  --存储过程名：USP_PUP_MOD
  --功能描述：调整计划
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/10/09
  PROCEDURE USP_PUP_MOD(in_arr_factory IN VARCHAR2) AS
    err_num number;
    err_msg varchar2(200);
  BEGIN
    --先删除上次计算的订单数据
    DELETE FROM MM_PUP_ORDER_CAL A WHERE A.FACTORY_CODE = in_arr_factory;

    --取货订单数据
    INSERT INTO MM_PUP_ORDER_CAL
      (PICKUP_TYPE,
       AREA,
       CAR_TYPE,
       ROUTE_CODE,
       TOTAL_NO,
       MERGE_NO,
       DR_SORT_ID_START,
       DR_SORT_ID_END,
       TODAY_NO,
       PICK_DATE,
       ARRIVE_DATE,
       ASSEMBLE_DATE,
       ORDER_NO,
       PURCHASE_NO,
       CREATION_TIME,
       SUP_FACTORY,
       FACTORY_CODE,
       WORKDAY,
       WWL_MANAGER,
       NWL_MANAGER,
       LOGISTIC_FLAG,
       SUPPLIER_NO,
       ORDER_TYPE,
       UNLOAD_PORT)
      SELECT DISTINCT T4.PICKUP_TYPE,
                      T4.AREA,
                      T3.CAR_TYPE,
                      T3.ROUTE_CODE,
                      T3.DIST_GROUP_ID,
                      T4.MERGE_NO,
                      T3.DR_SORT_ID_START,
                      T3.DR_SORT_ID_END,
                      T4.TODAY_NO,
                      NVL(T4.ADJ_PICKUP_TIME, T4.PICK_TIME),
                      T4.ARRIVE_TIME,
                      T4.ASSEMBLE_TIME,
                      T5.ORDER_NO,
                      T5.PURCHASE_NO,
                      SYSDATE,
                      T3.SUP_FACTORY,
                      T3.FACTORY_CODE,
                      T4.WORKDAY,
                      T3.WWL_MANAGER,
                      T3.NWL_MANAGER,
                      T3.LOGISTIC_FLAG,
                      T3.SUPPLIER_NO,
                      T6.ORDER_TYPE,
                      T3.UNLOAD_PORT
        from (SELECT A.*,
                     D.CAR_TYPE,
                     D.AREA,
                     D.PICKUP_TYPE,
                     D.ROUTE_CODE,
                     D.WWL_MANAGER,
                     D.NWL_MANAGER,
                     DECODE(SIGN(INSTR(A.LOGISTICS_ORDER, '-')),
                            1,
                            A.GROUP_ID || '-' ||
                            SUBSTR(A.LOGISTICS_ORDER,
                                   INSTR(A.LOGISTICS_ORDER, '-') + 1),
                            A.GROUP_ID) DIST_GROUP_ID
                FROM (SELECT *
                        FROM MM_PUP_ORDER_RECORD
                       WHERE TOTAL_ORDER_NUM > 0
                         AND FACTORY_CODE = in_arr_factory) A
                LEFT JOIN MM_PUP_ROUTE D
                  ON A.SUP_FACTORY = D.SUP_FACTORY
                 AND A.SUPPLIER_NO = D.SUPPLIER_NO
                 AND A.UNLOAD_PORT = D.UNLOAD_PORT
                 AND D.CAR_TYPE = A.CAR_TYPE_DIST) T3
        LEFT JOIN (SELECT DISTINCT B.SUP_FACTORY,
                                   B.SUPPLIER_NO,
                                   B.FACTORY_CODE,
                                   C.UNLOAD_PORT,
                                   C.LOGISTICS_ORDER,
                                   C.PART_NO,
                                   B.ORDER_NO,
                                   B.PURCHASE_NO
                     FROM MM_MP_PUR_ORDER B, MM_MP_PUR_ORDER_DETAIL C
                    WHERE B.ORDER_NO = C.ORDER_NO) T5
          ON T5.SUP_FACTORY = T3.SUP_FACTORY
         AND T5.UNLOAD_PORT = T3.UNLOAD_PORT
         AND T5.SUPPLIER_NO = T3.SUPPLIER_NO
         AND T5.PART_NO = T3.PART_NO
         AND T5.LOGISTICS_ORDER = T3.LOGISTICS_ORDER
         AND T5.FACTORY_CODE = in_arr_factory
         AND T3.LOGISTIC_FLAG = 'GAM'
        LEFT JOIN MM_SW_ORDER T6
          ON T5.ORDER_NO = T6.ORDER_NO
        LEFT JOIN MM_PUP_ROUTE_CAL T4
          ON T3.ROUTE_CODE = T4.ROUTE_CODE
         AND T3.CAR_TYPE = T4.CAR_TYPE
         AND T3.UNLOAD_PORT = T4.UNLOAD_PORT
         AND T3.DIST_GROUP_ID = T4.TOTAL_NO
         AND T3.FACTORY_CODE = T4.FACTORY_CODE;

    --调整差异数据
    UPDATE MM_PUP_ORDER_CAL A
       SET (A.PICKUP_TYPE,
            A.AREA,
            A.MERGE_NO,
            A.TODAY_NO,
            A.PICK_DATE,
            A.ARRIVE_DATE,
            A.ASSEMBLE_DATE,
            A.TOTAL_NO,
            A.WORKDAY) =
           (SELECT B.PICKUP_TYPE,
                   B.AREA,
                   B.MERGE_NO,
                   B.TODAY_NO,
                   B.PICK_TIME,
                   B.ARRIVE_TIME,
                   B.ASSEMBLE_TIME,
                   B.TOTAL_NO,
                   B.WORKDAY
              FROM MM_PUP_ROUTE_CAL B
             WHERE B.CAR_TYPE = A.CAR_TYPE
               AND B.FACTORY_CODE = in_arr_factory
               AND A.ROUTE_CODE = B.ROUTE_CODE
               AND SUBSTR(A.TOTAL_NO, 1, INSTR(A.TOTAL_NO, '-') - 1) =
                   B.TOTAL_NO
               AND A.TOTAL_NO <> B.TOTAL_NO
               AND A.PICK_DATE IS NULL
               AND A.UNLOAD_PORT = B.UNLOAD_PORT
               AND ROWNUM < 2)
     WHERE A.PICK_DATE IS NULL
       AND A.TOTAL_NO IS NOT NULL
       AND A.FACTORY_CODE = in_arr_factory;
    COMMIT;

    --插入手工调整订单
    MERGE INTO MM_PUP_ORDER_CAL A
    USING (SELECT B.PICKUP_TYPE,
                  B.AREA AREA,
                  B.CAR_TYPE,
                  B.ROUTE_CODE,
                  B.TOTAL_NO,
                  B.MERGE_NO MERGE_NO,
                  B.TODAY_NO TODAY_NO,
                  B.PICK_DATE PICK_DATE,
                  B.ARRIVE_DATE ARRIVE_DATE,
                  B.ORDER_NO,
                  B.PURCHASE_NO,
                  SYSDATE,
                  B.SUP_FACTORY,
                  B.SUPPLIER_NO,
                  NULL UNLOAD_PORT,
                  B.FACTORY_CODE,
                  PF.WWL_MANAGER,
                  PF.NWL_MANAGER,
                  B.PICKUP_FLAG,
                  TO_CHAR(B.WORKDAY, 'YYYY-MM-DD') WORKDAY,
                  C.ORDER_TYPE
             FROM MM_PUP_MANU_ORDER B
             LEFT JOIN (SELECT DISTINCT A.FACTORY_CODE,
                                       A.ROUTE_CODE,
                                       A.CAR_TYPE,
                                       A.SUP_FACTORY,
                                       A.SUPPLIER_NO,
                                       A.AREA,
                                       A.WWL_MANAGER,
                                       A.NWL_MANAGER
                         FROM MM_PUP_ROUTE A) PF
               ON B.FACTORY_CODE = PF.FACTORY_CODE
              AND B.ROUTE_CODE = PF.ROUTE_CODE
              AND B.CAR_TYPE = PF.CAR_TYPE
              AND B.SUPPLIER_NO = PF.SUPPLIER_NO
              AND B.SUP_FACTORY = PF.SUP_FACTORY
             LEFT JOIN MM_SW_ORDER C
               ON B.ORDER_NO = C.ORDER_NO
            WHERE B.WORKDAY > SYSDATE - 7
              AND B.PICKUP_FLAG = 1) D
    ON (A.ORDER_NO = D.ORDER_NO AND A.FACTORY_CODE = D.FACTORY_CODE)
    WHEN MATCHED THEN
      UPDATE
         SET A.PICKUP_TYPE   = D.PICKUP_TYPE,
             A.AREA          = D.AREA,
             A.CAR_TYPE      = D.CAR_TYPE,
             A.ROUTE_CODE    = D.ROUTE_CODE,
             A.TOTAL_NO      = D.TOTAL_NO,
             A.MERGE_NO      = D.MERGE_NO,
             A.TODAY_NO      = D.TODAY_NO,
             A.PICK_DATE     = D.PICK_DATE,
             A.ARRIVE_DATE   = D.ARRIVE_DATE,
             A.SUP_FACTORY   = D.SUP_FACTORY,
             A.UNLOAD_PORT   = D.UNLOAD_PORT,
             A.WORKDAY       = D.WORKDAY,
             A.WWL_MANAGER   = D.WWL_MANAGER,
             A.NWL_MANAGER   = D.NWL_MANAGER,
             A.LOGISTIC_FLAG = 'GAM'
    WHEN NOT MATCHED THEN
      INSERT
      VALUES
        (D.FACTORY_CODE,
         D.PICKUP_TYPE,
         D.AREA,
         D.CAR_TYPE,
         D.ROUTE_CODE,
         D.TOTAL_NO,
         D.MERGE_NO,
         NULL,
         NULL,
         D.TODAY_NO,
         D.PICK_DATE,
         D.ARRIVE_DATE,
         NULL,
         D.ORDER_NO,
         D.PURCHASE_NO,
         D.SUP_FACTORY,
         NULL,
         D.WORKDAY,
         D.WWL_MANAGER,
         D.NWL_MANAGER,
         NULL,
         'GAM',
         D.SUPPLIER_NO,
         D.ORDER_TYPE,
         SYSDATE);

    --删除不取货订单
    DELETE FROM MM_PUP_ORDER_CAL A
     WHERE EXISTS (SELECT 1
              FROM MM_PUP_MANU_ORDER B
             WHERE A.ORDER_NO = B.ORDER_NO
               AND B.PICKUP_FLAG = 0
               AND A.FACTORY_CODE = B.FACTORY_CODE);

    --更新收货日期
    UPDATE MM_PUP_ORDER_CAL A
       SET A.REC_DATE = NVL(CASE
                              WHEN TO_CHAR(A.ARRIVE_DATE, 'HH24:MI:SS') <
                                   '08:30:00' THEN
                               A.ARRIVE_DATE - 1
                              ELSE
                               A.ARRIVE_DATE
                            END,
                            NULL)
     WHERE A.ARRIVE_DATE IS NOT NULL
       AND A.AREA != '省外'
       AND A.FACTORY_CODE = in_arr_factory;

    UPDATE MM_PUP_ORDER_CAL A
       SET A.REC_DATE = A.ARRIVE_DATE
     WHERE A.ARRIVE_DATE IS NOT NULL
       AND A.AREA = '省外'
       AND A.FACTORY_CODE = in_arr_factory;

    --更新订单类型
    UPDATE MM_PUP_ORDER_CAL A
       SET A.ORDER_TYPE =
           (SELECT B.CODE_VALUE_NAME
              FROM MM_PUB_DATA_DICT B
             WHERE B.CODE_TYPE = 'SW_ORDER_TYPE'
               AND B.CODE_VALUE = A.ORDER_TYPE);

    UPDATE MM_PUP_ORDER_CAL A
       SET A.ORDER_TYPE = '例外订单'
     WHERE A.ORDER_TYPE != '量产订单';

    COMMIT;

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUP_MOD',
           err_num,
           err_msg,
           sysdate,
           '调整计划');
        COMMIT;

      END;
  END USP_PUP_MOD;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_DCS_PLAN_TO_TEMP
  --功能描述：获取DCS任务
  --参数说明：
  --in_arr_factory 工厂代码
  --in_opeId 操作人员
  --out_code 返回代码 0 标识成功， 1 表示失败
  --创建人员: wangyu
  --创建时间： 2018/10/29
  PROCEDURE USP_DCS_PLAN_TO_TEMP(in_opeId         IN VARCHAR2,
                                 in_arr_factory   in VARCHAR2,
                                 in_workday_start in VARCHAR2,
                                 in_workday_end   in VARCHAR2,
                                 out_code         out number) AS
    err_num number;
    err_msg varchar2(200);
  BEGIN

    --写入之前先清除DCS临时表数据
    DELETE FROM MM_PUP_DCS_PLAN_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;

    --将DCS任务写入DCS临时表
    INSERT INTO MM_PUP_DCS_PLAN_TEMP
      (PICKUP_TYPE,
       AREA,
       CAR_TYPE_DIST,
       SUPPLIER_NO,
       SUP_FACTORY,
       ROUTE_CODE,
       TOTAL_NO,
       MERGE_NO,
       SUPPLIER_NAME,
       PURCHASE_NO,
       ORDER_NO,
       WORKDAY,
       TODAY_NO,
       PICK_TIME,
       ARRIVE_TIME,
       ASSEMBLE_DATE,
       NWL_MANAGER,
       WWL_MANAGER,
       ORDER_USE,
       CREATION_USER,
       CREATION_TIME,
       ORDER_DEPOT,
       ORDER_DESC,
       SPE_ARRIVE_TIME,
       DEPART_TIME_POINT,
       PICKUP_CAR,
       PLAN_SHEET_NO,
       ROUTE_NAME,
       PLAN_BEGIN_TIME,
       PLAN_END_TIME,
       FACTORY_CODE,
       UNLOAD_PORT)
    --查询当前计算出来的DCS数据
      SELECT C.PICKUP_TYPE,
             C.AREA,
             C.CAR_TYPE,
             C.SUPPLIER_NO,
             C.SUP_FACTORY,
             C.ROUTE_CODE,
             C.TOTAL_NO,
             C.MERGE_NO,
             C.SUPPLIER_NAME,
             C.PURCHASE_NO,
             C.ORDER_NO,
             TO_DATE(C.WORKDAY, 'YYYY-MM-DD'),
             C.TODAY_NO,
             C.PICK_DATE,
             C.ARRIVE_DATE,
             C.ASSEMBLE_DATE,
             C.NWL_MANAGER,
             C.WWL_MANAGER,
             C.ORDER_USE,
             C.CREATION_USER,
             SYSDATE,
             E.DEPOT_NO,
             NULL,
             D.SPE_ARRIVE_TIME,
             D.DEPART_TIME_POINT,
             D.PICKUP_CAR,
             NULL,
             D.ROUTE_NAME,
             C.PICK_DATE,
             C.ARRIVE_DATE,
             in_arr_factory,
             C.UNLOAD_PORT
        FROM (
              --直接从取货计划那里获取DCS数据，或者通过导入到临时表
              SELECT DISTINCT *
                FROM (SELECT MPOC.PICKUP_TYPE,
                              MPOC.AREA,
                              MPOC.CAR_TYPE,
                              MPOC.SUPPLIER_NO,
                              MPOC.SUP_FACTORY,
                              MPOC.ROUTE_CODE,
                              MPOC.TOTAL_BATCHS TOTAL_NO,
                              MPOC.MERGE_BATCHS MERGE_NO,
                              MPS.SUPPLIER_NAME,
                              MSO.PURCHASE_NO,
                              MSO.ORDER_NO,
                              TO_CHAR(MPOC.WORK_DATE, 'YYYY-MM-DD') WORKDAY,
                              MPOC.TODAY_CAR_BATCH TODAY_NO,
                              MPOC.PLAN_PICKUP_TIME PICK_DATE,
                              MPOC.PLAN_ARR_TIME ARRIVE_DATE,
                              MPOC.PLAN_ASSEMBLE_TIME ASSEMBLE_DATE,
                              NULL NWL_MANAGER,
                              NULL WWL_MANAGER,
                              NULL ORDER_USE,
                              in_opeId CREATION_USER,
                              in_arr_factory FACTORY_CODE,
                              MPOC.UNLOAD_PORT
                         FROM MM_SW_PICKUP_PLAN MPOC
                         LEFT JOIN (SELECT DISTINCT SUPPLIER_NO, SUPPLIER_NAME
                                     FROM MM_PUB_SUPPLIER) MPS
                           ON MPOC.SUPPLIER_NO = MPS.SUPPLIER_NO
                         LEFT JOIN MM_SW_ORDER MSO
                           ON MSO.PURCHASE_NO = MPOC.PURCHASE_NO
                        WHERE MPOC.FACTORY_CODE = in_arr_factory
                          AND TO_CHAR(MPOC.PLAN_PICKUP_TIME, 'YYYY-MM-DD') >=
                              in_workday_start
                          AND TO_CHAR(MPOC.PLAN_PICKUP_TIME, 'YYYY-MM-DD') <=
                              in_workday_end
                          AND NOT EXISTS
                       --排除DCS中已经执行的订单数据
                        (SELECT 1
                                 FROM MM_PUP_DCS_PICK_PLAN F
                                 LEFT JOIN MM_PUP_DCS_PICK_PLAN_DETAIL G
                                   ON F.PLAN_SHEET_NO = G.PLAN_SHEET_NO
                                WHERE F.EXCUTE_STATUS = 1
                                  AND MPOC.ORDER_NO = G.ORDER_NO)) B
               WHERE B.FACTORY_CODE = in_arr_factory
                 /*AND B.PICKUP_TYPE = '取货'*/
                 AND B.AREA = '省内') C
        LEFT JOIN MM_PUP_ROUTE D
          ON D.SUP_FACTORY = C.SUP_FACTORY
         AND D.SUPPLIER_NO = C.SUPPLIER_NO
         AND D.CAR_TYPE = C.CAR_TYPE
         AND D.FACTORY_CODE = C.FACTORY_CODE
         AND D.ROUTE_CODE = C.ROUTE_CODE
         AND C.WORKDAY IS NOT NULL
        LEFT JOIN MM_SW_ORDER E
          ON C.ORDER_NO = E.ORDER_NO;

    COMMIT;

    --生成DCS
    USP_GEN_DCS(in_arr_factory, in_opeId);

    --操作成功
    out_code := 0;

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        --操作失败
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_DCS_PLAN_TO_TEMP',
           err_num,
           err_msg,
           sysdate,
           '获取DCS任务');
        COMMIT;

        ROLLBACK;

      END;
  END USP_DCS_PLAN_TO_TEMP;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_DCS_IMPORT_PLAN_TO_TEMP
  --功能描述：DCS调整
  --参数说明：
  --in_uuid uuid
  --in_arr_factory 工厂代码
  --in_opeId 操作人员
  --out_code 返回代码 0 标识成功， 1 表示失败
  --创建人员: wangyu
  --创建时间： 2018/12/29
  PROCEDURE USP_DCS_IMPORT_PLAN_TO_TEMP(in_uuid        VARCHAR2,
                                        in_opeId       in VARCHAR2,
                                        in_arr_factory IN VARCHAR2,
                                        out_code       out number) AS
    err_num number;
    err_msg varchar2(200);
  BEGIN

    --写入之前先清除DCS临时表数据
    DELETE FROM MM_PUP_DCS_PLAN_TEMP A
     WHERE A.FACTORY_CODE = in_arr_factory;

    --将DCS任务写入DCS临时表
    INSERT INTO MM_PUP_DCS_PLAN_TEMP
      (PICKUP_TYPE,
       AREA,
       CAR_TYPE_DIST,
       SUPPLIER_NO,
       SUP_FACTORY,
       ROUTE_CODE,
       TOTAL_NO,
       MERGE_NO,
       SUPPLIER_NAME,
       PURCHASE_NO,
       ORDER_NO,
       WORKDAY,
       TODAY_NO,
       PICK_TIME,
       ARRIVE_TIME,
       ASSEMBLE_DATE,
       NWL_MANAGER,
       WWL_MANAGER,
       ORDER_USE,
       CREATION_USER,
       CREATION_TIME,
       ORDER_DEPOT,
       ORDER_DESC,
       SPE_ARRIVE_TIME,
       DEPART_TIME_POINT,
       PICKUP_CAR,
       PLAN_SHEET_NO,
       ROUTE_NAME,
       PLAN_BEGIN_TIME,
       PLAN_END_TIME,
       FACTORY_CODE,
       UNLOAD_PORT)
    --查询当前计算出来的DCS数据
      SELECT C.PICKUP_TYPE,
             C.AREA,
             C.CAR_TYPE,
             C.SUPPLIER_NO,
             C.SUP_FACTORY,
             C.ROUTE_CODE,
             C.TOTAL_NO,
             C.MERGE_NO,
             C.SUPPLIER_NAME,
             C.PURCHASE_NO,
             C.ORDER_NO,
             TO_DATE(C.WORKDAY, 'YYYY-MM-DD'),
             C.TODAY_NO,
             C.PICK_DATE,
             C.ARRIVE_DATE,
             C.ASSEMBLE_DATE,
             C.NWL_MANAGER,
             C.WWL_MANAGER,
             C.ORDER_USE,
             C.CREATION_USER,
             SYSDATE,
             E.DEPOT_NO,
             NULL,
             D.SPE_ARRIVE_TIME,
             D.DEPART_TIME_POINT,
             D.PICKUP_CAR,
             NULL,
             D.ROUTE_NAME,
             C.PICK_DATE,
             C.ARRIVE_DATE,
             in_arr_factory,
             C.UNLOAD_PORT
        FROM (
              --直接从取货计划那里获取DCS数据，或者通过导入到临时表
              SELECT DISTINCT *
                FROM (SELECT MPOC.PICKUP_TYPE,
                              MPOC.AREA,
                              MPOC.CAR_TYPE,
                              MPOC.SUPPLIER_NO,
                              MPOC.SUP_FACTORY,
                              MPOC.ROUTE_CODE,
                              MPOC.TOTAL_NO,
                              MPOC.MERGE_NO,
                              MPOC.SUPPLIER_NAME,
                              MSO.PURCHASE_NO,
                              MSO.ORDER_NO,
                              MPOC.WORKDAY,
                              MPOC.TODAY_NO,
                              MPOC.PICK_DATE,
                              MPOC.ARRIVE_DATE,
                              MPOC.ASSEMBLE_DATE,
                              MPOC.NWL_MANAGER,
                              MPOC.WWL_MANAGER,
                              NULL               ORDER_USE,
                              in_opeId           CREATION_USER,
                              in_arr_factory     FACTORY_CODE,
                              MPOC.UNLOAD_PORT
                         FROM MM_PUP_DCS_DATA_IMP MPOC
                         LEFT JOIN MM_SW_ORDER MSO
                           ON MSO.PURCHASE_NO = MPOC.PURCHASE_NO
                        WHERE MPOC.FACTORY_CODE = in_arr_factory
                          AND MPOC.IMP_UUID = in_uuid
                          AND NOT EXISTS
                       --排除DCS中已经执行的订单数据
                        (SELECT 1
                                 FROM MM_PUP_DCS_PICK_PLAN F
                                 LEFT JOIN MM_PUP_DCS_PICK_PLAN_DETAIL G
                                   ON F.PLAN_SHEET_NO = G.PLAN_SHEET_NO
                                WHERE F.EXCUTE_STATUS = 1
                                  AND MPOC.ORDER_NO = G.ORDER_NO)) B
               WHERE B.FACTORY_CODE = in_arr_factory
                 /*AND B.PICKUP_TYPE = '取货'*/
                 AND B.AREA = '省内') C
        LEFT JOIN MM_PUP_ROUTE D
          ON D.SUP_FACTORY = C.SUP_FACTORY
         AND D.SUPPLIER_NO = C.SUPPLIER_NO
         AND D.CAR_TYPE = C.CAR_TYPE
         AND D.FACTORY_CODE = C.FACTORY_CODE
         AND D.ROUTE_CODE = C.ROUTE_CODE
         AND C.WORKDAY IS NOT NULL
        LEFT JOIN MM_SW_ORDER E
          ON C.ORDER_NO = E.ORDER_NO;

    COMMIT;

    --生成DCS
    USP_GEN_DCS(in_arr_factory, in_opeId);

    --更新导入状态
    UPDATE MM_PUP_DCS_DATA_IMP A
       SET A.IMPORT_STATUS = 1
     WHERE A.IMP_UUID = in_uuid;

    --操作成功
    out_code := 0;

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        --操作失败
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_DCS_IMPORT_PLAN_TO_TEMP',
           err_num,
           err_msg,
           sysdate,
           'DCS调整');
        COMMIT;

        ROLLBACK;

      END;
  END USP_DCS_IMPORT_PLAN_TO_TEMP;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_GEN_DCS
  --功能描述：生成DCS单
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/12/29
  PROCEDURE USP_GEN_DCS(in_arr_factory IN VARCHAR2, in_opeId in VARCHAR2) AS
    err_num           number;
    err_msg           varchar2(200);
    v_plan_begin_date date;
    v_plan_end_date   date;
  BEGIN

    --先删除DCS订单表中状态为未执行的DCS单对应的明细数据
    DELETE FROM MM_PUP_DCS_PICK_PLAN_DETAIL A
     WHERE EXISTS (SELECT 1
              FROM MM_PUP_DCS_PICK_PLAN B
             WHERE B.EXCUTE_STATUS = 0
               AND B.FACTORY_CODE = in_arr_factory
               AND A.PLAN_SHEET_NO = B.PLAN_SHEET_NO);

    --删除MM_PUP_DCS_SEAL_TEMP
    DELETE FROM MM_PUP_DCS_SEAL_TEMP A
     WHERE EXISTS (SELECT 1
              FROM MM_PUP_DCS_PICK_PLAN B
             WHERE A.PLAN_SHEET_NO = B.PLAN_SHEET_NO
               AND B.EXCUTE_STATUS = 0
               AND B.FACTORY_CODE = in_arr_factory)
       AND A.FACTORY_CODE = in_arr_factory;

    --写入之前先清除DCS订单表中状态为未执行的DCS单
    DELETE FROM MM_PUP_DCS_PICK_PLAN A
     WHERE A.EXCUTE_STATUS = 0
       AND A.FACTORY_CODE = in_arr_factory;

    COMMIT;

    --发车时间基准处理
    UPDATE MM_PUP_DCS_PLAN_TEMP A
       SET A.PLAN_BEGIN_TIME = A.PLAN_BEGIN_TIME - A.DEPART_TIME_POINT
     WHERE A.DEPART_TIME_POINT IS NOT NULL
       AND A.FACTORY_CODE = in_arr_factory;
    COMMIT;

    --累计车次处理
    UPDATE MM_PUP_DCS_PLAN_TEMP A
       SET A.PLAN_SHEET_NO = 'ZX-' || A.FACTORY_CODE || A.ROUTE_CODE ||
                             A.CAR_TYPE_DIST || A.UNLOAD_PORT || A.TOTAL_NO||TO_CHAR(A.PICK_TIME,'YYYY-MM-DD')
     WHERE (A.MERGE_NO = 0 OR A.MERGE_NO IS NULL)
       AND A.TOTAL_NO != '0'
       AND SUBSTR(A.ORDER_NO, 0, 2) != 'AE'
       AND A.FACTORY_CODE = in_arr_factory;
    COMMIT;

    --合并车次处理
    UPDATE MM_PUP_DCS_PLAN_TEMP A
       SET A.PLAN_SHEET_NO = 'HB-' || A.FACTORY_CODE || A.ROUTE_CODE || '-' ||
                             LPAD(A.MERGE_NO, 3, '0') ||
                             TO_CHAR(A.WORKDAY, 'YYMMDD') ||
                             TO_CHAR(A.PLAN_END_TIME, 'YYMMDD')
     WHERE A.MERGE_NO > 0
       AND SUBSTR(A.ORDER_NO, 0, 2) != 'AE'
       AND A.FACTORY_CODE = in_arr_factory;
    COMMIT;

    --DCS单号处理--例外车次
    UPDATE MM_PUP_DCS_PLAN_TEMP A
       SET A.PLAN_SHEET_NO = 'LW-' || A.FACTORY_CODE || A.ROUTE_CODE || '-' ||
                             TO_CHAR(A.WORKDAY, 'YYYYMMDD')
     WHERE SUBSTR(A.ORDER_NO, 0, 2) = 'AE'
       AND A.FACTORY_CODE = in_arr_factory;
    COMMIT;

    --循环DCS订单头
    FOR dcs_head IN (SELECT DISTINCT A.PLAN_SHEET_NO, A.FACTORY_CODE
                       FROM MM_PUP_DCS_PLAN_TEMP A
                      WHERE A.FACTORY_CODE = in_arr_factory
                        AND A.PLAN_SHEET_NO IS NOT NULL) LOOP

      --查询该DCS单号的最小发车时间
      SELECT MIN(TP.PLAN_BEGIN_TIME)
        INTO v_plan_begin_date
        FROM MM_PUP_DCS_PLAN_TEMP TP
       WHERE TP.FACTORY_CODE = in_arr_factory
         AND TP.PLAN_SHEET_NO IS NOT NULL
         AND TP.PLAN_SHEET_NO = dcs_head.PLAN_SHEET_NO;

      --查询该DCS单号的最小到厂时间
      SELECT MIN(TP.PLAN_END_TIME)
        INTO v_plan_end_date
        FROM MM_PUP_DCS_PLAN_TEMP TP
       WHERE TP.FACTORY_CODE = in_arr_factory
         AND TP.PLAN_SHEET_NO IS NOT NULL
         AND TP.PLAN_SHEET_NO = dcs_head.PLAN_SHEET_NO;

      --写入累计车次的DCS头表
      INSERT INTO MM_PUP_DCS_PICK_PLAN
        (PLAN_SHEET_NO,
         FACTORY_CODE,
         ROUTE_CODE,
         PLAN_START_TIME,
         PLAN_ARRIVE_TIME,
         WORKDAY,
         PLAN_TYPE,
         --PICK_TYPE,
         CAR_NUM,
         TAKE_CAR,
         ROUTE_NAME,
         CREATION_TIME,
         CREATION_USER,
         RET_EMPTY_PLATFORM)
        SELECT DISTINCT dcs_head.PLAN_SHEET_NO,
                        T.FACTORY_CODE,
                        T.ROUTE_CODE,
                        v_plan_begin_date,
                        v_plan_end_date,
                        TO_DATE(TO_CHAR(T.PICK_TIME, 'YYYY-MM-DD'), 'YYYY-MM-DD') WORKDAY,
                        T.AREA,
                        T.TOTAL_NO,
                        T.PICKUP_CAR,
                        T.ROUTE_NAME,
                        SYSDATE,
                        T.CREATION_USER,
                        E.RET_EMPTY_PLATFORM
          FROM MM_PUP_DCS_PLAN_TEMP T
          LEFT JOIN (SELECT DISTINCT D.ROUTE_CODE, D.RET_EMPTY_PLATFORM
                       FROM MM_PUP_ROUTE D
                      WHERE D.FACTORY_CODE = in_arr_factory) E
            ON T.ROUTE_CODE = E.ROUTE_CODE
         WHERE NVL(T.MERGE_NO, 0) = 0
           AND T.PLAN_SHEET_NO = dcs_head.PLAN_SHEET_NO
           AND SUBSTR(T.PLAN_SHEET_NO, 0, 2) != 'LW'
           AND T.FACTORY_CODE = in_arr_factory;

      --写入合并车次的DCS头表
      INSERT INTO MM_PUP_DCS_PICK_PLAN
        (PLAN_SHEET_NO,
         FACTORY_CODE,
         ROUTE_CODE,
         PLAN_START_TIME,
         PLAN_ARRIVE_TIME,
         WORKDAY,
         PLAN_TYPE,
         --PICK_TYPE,
         CAR_NUM,
         TAKE_CAR,
         ROUTE_NAME,
         CREATION_TIME,
         CREATION_USER,
         RET_EMPTY_PLATFORM)
        SELECT DISTINCT dcs_head.PLAN_SHEET_NO,
                        T.FACTORY_CODE,
                        T.ROUTE_CODE,
                        v_plan_begin_date,
                        v_plan_end_date,
                        T.WORKDAY,
                        T.AREA,
                        T.MERGE_NO,
                        T.PICKUP_CAR,
                        T.ROUTE_NAME,
                        SYSDATE,
                        T.CREATION_USER,
                        E.RET_EMPTY_PLATFORM
          FROM MM_PUP_DCS_PLAN_TEMP T
          LEFT JOIN (SELECT DISTINCT D.ROUTE_CODE, D.RET_EMPTY_PLATFORM
                       FROM MM_PUP_ROUTE D
                      WHERE D.FACTORY_CODE = in_arr_factory) E
            ON T.ROUTE_CODE = E.ROUTE_CODE
         WHERE T.MERGE_NO > 0
           AND T.PLAN_SHEET_NO = dcs_head.PLAN_SHEET_NO
           AND T.FACTORY_CODE = in_arr_factory;
      COMMIT;

      --写入例外车次的DCS头表
      INSERT INTO MM_PUP_DCS_PICK_PLAN(PLAN_SHEET_NO,
         FACTORY_CODE,
         ROUTE_CODE,
         PLAN_START_TIME,
         PLAN_ARRIVE_TIME,
         WORKDAY,
         PLAN_TYPE,
         --PICK_TYPE,
         CAR_NUM,
         TAKE_CAR,
         ROUTE_NAME,
         CREATION_TIME,
         CREATION_USER,
         RET_EMPTY_PLATFORM)SELECT DISTINCT dcs_head.PLAN_SHEET_NO,
                        T.FACTORY_CODE,
                        T.ROUTE_CODE,
                        v_plan_begin_date,
                        v_plan_end_date,
                        TO_DATE(TO_CHAR(T.PICK_TIME, 'YYYY-MM-DD'), 'YYYY-MM-DD') WORKDAY,
                        T.AREA,
                        0,
                        T.PICKUP_CAR,
                        T.ROUTE_NAME,
                        SYSDATE,
                        T.CREATION_USER,
                        E.RET_EMPTY_PLATFORM
          FROM MM_PUP_DCS_PLAN_TEMP T
          LEFT JOIN (SELECT DISTINCT D.ROUTE_CODE, D.RET_EMPTY_PLATFORM
                       FROM MM_PUP_ROUTE D
                      WHERE D.FACTORY_CODE = in_arr_factory) E
            ON T.ROUTE_CODE = E.ROUTE_CODE
         WHERE NVL(T.MERGE_NO, 0) = 0
           AND T.PLAN_SHEET_NO = dcs_head.PLAN_SHEET_NO
           AND SUBSTR(T.PLAN_SHEET_NO, 0, 2) = 'LW'
           AND T.FACTORY_CODE = in_arr_factory;

      --写入改DCS明细数据
      INSERT INTO MM_PUP_DCS_PICK_PLAN_DETAIL
        (PLAN_SHEET_NO,
         PURCHASE_NO,
         SUPPLIER_NO,
         ORDER_NO,
         ORDER_DEPOT,
         PICK_TIME)
        SELECT distinct TD.PLAN_SHEET_NO,
                        TD.PURCHASE_NO,
                        TD.SUPPLIER_NO,
                        TD.ORDER_NO,
                        TD.ORDER_DEPOT,
                        TD.PLAN_BEGIN_TIME
          FROM MM_PUP_DCS_PLAN_TEMP TD
         WHERE TD.PLAN_SHEET_NO = dcs_head.PLAN_SHEET_NO
           AND TD.FACTORY_CODE = dcs_head.FACTORY_CODE;
      COMMIT;
    END LOOP;
    COMMIT;

    --更新集货类型, 累计
    UPDATE MM_PUP_DCS_PICK_PLAN A
       SET A.PICK_TYPE = 1
     WHERE SUBSTR(A.PLAN_SHEET_NO, 0, 2) = 'ZX';
    COMMIT;

    --更新集货类型，合并
    UPDATE MM_PUP_DCS_PICK_PLAN A
       SET A.PICK_TYPE = 0
     WHERE SUBSTR(A.PLAN_SHEET_NO, 0, 2) = 'HB';
    COMMIT;

    --更新集货类型，例外
    UPDATE MM_PUP_DCS_PICK_PLAN A
       SET A.PICK_TYPE = 2
     WHERE SUBSTR(A.PLAN_SHEET_NO, 0, 2) = 'LW';
    COMMIT;

  END USP_GEN_DCS;
  --***************************************************************************

  --***************************************************************************
  --存储过程名：USP_PUP_EMPTY_OUT_DIR
  --功能描述：空容器备件出库指示处理
  --参数说明：
  --in_arr_factory 工厂代码
  --创建人员: wangyu
  --创建时间： 2018/10/24
  /*PROCEDURE USP_PUP_EMPTY_OUT_DIR(in_arr_factory IN VARCHAR2) AS
    err_num number;
    err_msg varchar2(200);
  BEGIN
    --删除生产计划数据
    DELETE FROM MM_PUP_PRO_PLAN A WHERE A.FACTORY_CODE = in_arr_factory;

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUP_EMPTY_OUT_DIR',
           err_num,
           err_msg,
           sysdate,
           '空容器备件出库指示处理');
        COMMIT;

      END;
  END USP_PUP_EMPTY_OUT_DIR;
  --****************************************************************************/

  --***************************************************************************
  --存储过程名：USP_PUP_VERSION_CLEAR
  --功能描述：每周定时删除上一周之前的物流计划版本数据
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2019/02/19
  PROCEDURE USP_PUP_VERSION_CLEAR AS
    err_num number;
    err_msg varchar2(200);
  BEGIN
    --删除一周之前的版本数据
    DELETE FROM MM_PUP_VERSION_RECORD A
     WHERE A.CREATION_TIME < TRUNC(SYSDATE - 7, 'D') + 1;

    COMMIT;

  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUP_VERSION_CLEAR',
           err_num,
           err_msg,
           sysdate,
           '每周定时删除上一周之前的物流计划版本数据');
        COMMIT;

      END;
  END USP_PUP_VERSION_CLEAR;
  --***************************************************************************

end PKG_PUP_MAIN;
/

prompt
prompt Creating package body PKG_REC_MAIN
prompt ==================================
prompt
create or replace package body PKG_REC_MAIN is

  --***************************************************************************
  --存储过程名：USP_DEAL_PARTLABEL_SH
  --功能描述：标签扫描收货处理
  --参数说明：
  --in_uuid uuid
  --out_code
  --out_type
  --创建人员: wangyu
  --创建时间： 2018/09/19
  PROCEDURE USP_DEAL_PARTLABEL_SH(in_uuid  IN VARCHAR2,
                                  out_code OUT INT,
                                  out_type OUT VARCHAR2) AS

    v_num     number;
    v_status  number;
    err_num   number;
    err_msg   varchar2(300);
    v_cur_seq number; --当前看板批次

    CURSOR cur_order_head IS
      SELECT DISTINCT A.FACTORY_CODE,
                      A.ORDER_NO,
                      A.ORDER_SEQ,
                      A.ORDER_TYPE,
                      A.OPE_USER,
                      A.IP,
                      A.DEPOT_NO
        FROM MM_INV_REC_TEMP A
       WHERE A.UUID = in_uuid;

  BEGIN
    v_num := 0;
    --MODIFY wangyu 2019-06-05
    --检查标签是否已存在
    DELETE FROM MM_iNV_REC_TEMP A
     WHERE A.UUID = in_uuid
       AND EXISTS
     (SELECT 1
              FROM MM_PDA_LABEL_SCAN_LOG B
             WHERE SUBSTR(A.PARTLABEL, INSTR(A.PARTLABEL, '#', -1) + 1) =
                   B.BAR_UUID
               AND B.TYPE = 1);

    SELECT COUNT(*)
      INTO v_num
      FROM MM_INV_REC_TEMP B
     WHERE B.UUID = in_uuid;

    --标签已经被别人扫描提交过了
    IF (v_num = 0) THEN
      out_code := 4;
    ELSE
      --查询订单类型
      FOR cur_rec_type IN (SELECT DISTINCT A.ORDER_NO
                             FROM MM_INV_REC_TEMP A
                            WHERE A.UUID = in_uuid) LOOP
        --拉动订单处理
        SELECT COUNT(*)
          INTO v_num
          FROM MM_JIT_ORDER A
         WHERE A.ORDER_NO = cur_rec_type.ORDER_NO;

        IF v_num <> 0 THEN
          out_type := 'JIT';
          --更新临时拉动收货数据
          MERGE INTO MM_INV_REC_TEMP T3
          USING (SELECT T1.thisShNum,
                        T2.ORDER_NO,
                        T2.ROW_NO,
                        T2.THIS_SH_NUM,
                        DECODE(SIGN(T1.thisShNum - T2.THIS_SH_NUM), -1, 2, 1) flag,
                        T1.CURR_BATCH_SEQNO,
                        T1.ARRIVE_COUNT,
                        T1.PART_NO,
                        T1.HEAD_COUNT,
                        T2.FACTORY_CODE,
                        T1.ARR_DEPOT
                   FROM (SELECT A.ORDER_NO,
                                A.ROW_NO,
                                SUM(NVL(A.THIS_SH_NUM, 0)) THIS_SH_NUM,
                                MIN(A.FACTORY_CODE) FACTORY_CODE
                           FROM MM_INV_REC_TEMP A
                          WHERE A.UUID = in_uuid
                            AND A.ORDER_NO = cur_rec_type.ORDER_NO
                          GROUP BY A.ORDER_NO, A.ROW_NO) T2
                   LEFT JOIN (SELECT B.ORDER_NO,
                                    C.ORDER_ROWNO,
                                    C.REQUIRE_NUM - NVL(C.ARRIVE_NUM, 0) AS thisShNum,
                                    E.CURR_BATCH_SEQNO,
                                    C.ARRIVE_COUNT,
                                    C.PART_NO,
                                    B.ARRIVE_COUNT HEAD_COUNT,
                                    B.ARR_DEPOT
                               FROM MM_JIT_ORDER B
                               LEFT JOIN MM_JIT_ORDER_DETAIL C
                                 ON B.ORDER_NO = C.ORDER_NO
                                AND B.ORDER_NO = cur_rec_type.ORDER_NO
                                AND C.ORDER_NO = cur_rec_type.ORDER_NO
                               LEFT JOIN MM_PUB_PLAN_CODE D
                                 ON B.PLAN_CODE = D.PLAN_CODE
                               LEFT JOIN MM_MON_KB E
                                 ON D.KB_ID = E.ID
                                AND D.FACTORY_CODE = E.FACTORY_CODE) T1
                     ON T1.ORDER_NO = T2.ORDER_NO
                    AND T1.ORDER_ROWNO = T2.ROW_NO) T4
          ON (T3.FACTORY_CODE = T4.FACTORY_CODE AND T3.ORDER_NO = T4.ORDER_NO AND T3.ROW_NO = T4.ROW_NO AND T3.UUID = in_uuid AND T3.ORDER_NO = cur_rec_type.ORDER_NO)
          WHEN MATCHED THEN
            UPDATE
               SET T3.CHECK_CODE = T4.FLAG,
                   T3.KB_SEQ_NO  = T4.CURR_BATCH_SEQNO,
                   T3.PART_NO    = T4.PART_NO,
                   T3.DEPOT_NO   = T4.ARR_DEPOT,
                   T3.ORDER_SEQ  = NVL(T4.HEAD_COUNT, 0) + 1,
                   T3.DETAIL_SEQ = NVL(T4.ARRIVE_COUNT, 0) + 1,
                   T3.ORDER_TYPE = 'JIT';
        END IF;

        IF v_num = 0 THEN
          out_type := 'SW';
          --更新临时协同收货数据
          MERGE INTO MM_INV_REC_TEMP T3
          USING (SELECT T1.thisShNum,
                        T2.ORDER_NO,
                        T2.ROW_NO,
                        T2.THIS_SH_NUM,
                        DECODE(SIGN(T1.thisShNum - T2.THIS_SH_NUM), -1, 2, 1) flag,
                        T1.RECEIVE_COUNT,
                        T1.PART_NO,
                        T1.HEAD_COUNT,
                        T2.FACTORY_CODE,
                        T1.DEPOT_NO
                   FROM (SELECT A.ORDER_NO,
                                A.ROW_NO,
                                SUM(NVL(A.THIS_SH_NUM, 0)) THIS_SH_NUM,
                                MIN(A.FACTORY_CODE) FACTORY_CODE
                           FROM MM_INV_REC_TEMP A
                          WHERE A.UUID = in_uuid
                            AND A.ORDER_NO = cur_rec_type.ORDER_NO
                          GROUP BY A.ORDER_NO, A.ROW_NO) T2
                   LEFT JOIN (SELECT B.ORDER_NO,
                                    C.ORDER_ROWNO,
                                    C.ORDER_QTY - NVL(C.ARRIVE_NUM, 0) AS thisShNum,
                                    C.RECEIVE_COUNT,
                                    C.PART_NO,
                                    B.RECEIVE_COUNT HEAD_COUNT,
                                    B.DEPOT_NO
                               FROM MM_SW_ORDER B
                               LEFT JOIN MM_SW_ORDER_DETAIL C
                                 ON B.ORDER_NO = C.PURCHASE_NO
                                AND B.ORDER_NO = cur_rec_type.ORDER_NO
                                AND C.PURCHASE_NO = cur_rec_type.ORDER_NO) T1
                     ON T1.ORDER_NO = T2.ORDER_NO
                    AND T1.ORDER_ROWNO = T2.ROW_NO) T4
          ON (T3.FACTORY_CODE = T4.FACTORY_CODE AND T3.ORDER_NO = T4.ORDER_NO AND T3.ROW_NO = T4.ROW_NO AND T3.UUID = in_uuid AND T3.ORDER_NO = cur_rec_type.ORDER_NO)
          WHEN MATCHED THEN
            UPDATE
               SET T3.CHECK_CODE = T4.FLAG,
                   T3.PART_NO    = T4.PART_NO,
                   T3.ORDER_SEQ  = NVL(T4.HEAD_COUNT, 0) + 1,
                   T3.DETAIL_SEQ = NVL(T4.RECEIVE_COUNT, 0) + 1,
                   T3.DEPOT_NO   = T4.DEPOT_NO,
                   T3.ORDER_TYPE = 'SW';
        END IF;
      END LOOP;
      COMMIT;

      --校验收货数量是否超出,flag=2 数量异常,
      SELECT COUNT(*)
        INTO v_num
        FROM MM_INV_REC_TEMP A
       WHERE NVL(A.CHECK_CODE, 0) <> 1
         AND A.UUID = in_uuid;

      IF v_num > 0 THEN
        out_code := 2;
      ELSE
        v_num := 1;
        SELECT COUNT(*)
          INTO v_num
          FROM (SELECT A.ORDER_TYPE
                  FROM MM_INV_REC_TEMP A
                 WHERE A.UUID = in_uuid
                   AND A.ORDER_TYPE IN ('SW', 'JIT')
                 GROUP BY A.ORDER_TYPE);
        IF v_num <> 1 THEN
          IF v_num < 1 THEN
            out_code := 6; --订单信息有误
            UPDATE MM_INV_REC_TEMP A
               SET A.CHECK_CODE = out_code
             WHERE A.UUID = in_uuid;
            RETURN;
          END IF;
          out_code := 5; --订单类型不同
          UPDATE MM_INV_REC_TEMP A
             SET A.CHECK_CODE = out_code
           WHERE A.UUID = in_uuid;
          RETURN;
        END IF;

        --数据合法开始写入数据
        FOR v_order in cur_order_head LOOP
          --如果是协同订单
          IF v_order.ORDER_TYPE = 'SW' THEN
            --写入日志表
            INSERT INTO MM_INV_IN
              (REC_NO,
               FACTORY_CODE,
               ORDER_NO,
               REC_TIMES,
               DEPOT_NO,
               OPE_IP,
               REC_CLIENT,
               ORDER_TYPE,
               ACTUAL_ARR_PRO_SEQNO,
               CREATION_USER,
               CREATION_TIME)
            VALUES
              (v_order.ORDER_NO || '_' || v_order.ORDER_SEQ,
               v_order.FACTORY_CODE,
               v_order.ORDER_NO,
               v_order.ORDER_SEQ,
               v_order.DEPOT_NO,
               v_order.IP,
               2,
               'SW',
               NULL,
               v_order.Ope_User,
               SYSDATE);

            --更新协同订单明细
            MERGE INTO MM_SW_ORDER_DETAIL T
            USING (SELECT A.ORDER_NO,
                          A.ROW_NO,
                          SUM(A.THIS_SH_NUM) TOTAL_NUM,
                          A.DETAIL_SEQ
                     FROM MM_INV_REC_TEMP A
                    WHERE A.UUID = in_uuid
                      AND A.ORDER_NO = v_order.ORDER_NO
                    GROUP BY A.ORDER_NO, A.ROW_NO, A.DETAIL_SEQ) T1
            ON (T.PURCHASE_NO = T1.ORDER_NO AND T.ORDER_ROWNO = T1.ROW_NO)
            WHEN MATCHED THEN
              UPDATE
                 SET T.ARRIVE_NUM     = NVL(T.ARRIVE_NUM, 0) + TO_NUMBER(T1.TOTAL_NUM),
                     T.RECEIVE_DATE   = SYSDATE,
                     T.RECEIVE_COUNT  = T1.DETAIL_SEQ,
                     T.RECEIVE_STATUS = CASE
                                          WHEN NVL(T.ARRIVE_NUM, 0) + TO_NUMBER(T1.TOTAL_NUM) =
                                               NVL(T.ORDER_QTY, 0) - NVL(T.CANCEL_NUM, 0) THEN
                                           2
                                          WHEN NVL(T.ARRIVE_NUM, 0) + TO_NUMBER(T1.TOTAL_NUM) <
                                               NVL(T.ORDER_QTY, 0) - NVL(T.CANCEL_NUM, 0) AND
                                               NVL(T.ARRIVE_NUM, 0) + TO_NUMBER(T1.TOTAL_NUM) > 0 THEN
                                           1
                                          ELSE
                                           0
                                        END;

            --协同日志明细
            INSERT INTO MM_INV_IN_DETAIL
              (REC_NO,
               ROW_NO,
               REC_TIMES,
               PART_NO,
               ORDER_QTY,
               REC_QTY,
               CREATION_TIME)
              SELECT B.RECEIVE_NO,
                     B.ROW_NO,
                     B.DETAIL_SEQ,
                     B.PART_NO,
                     B.ORDER_QTY,
                     B.THIS_SH_NUM,
                     SYSDATE
                FROM (SELECT A.ORDER_NO || '_' || A.ORDER_SEQ AS RECEIVE_NO,
                             A.ROW_NO,
                             A.DETAIL_SEQ,
                             SUM(NVL(A.THIS_SH_NUM, 0)) THIS_SH_NUM,
                             A.OPE_USER,
                             A.PART_NO,
                             MIN(C.ORDER_QTY) ORDER_QTY
                        FROM MM_INV_REC_TEMP A
                        LEFT JOIN MM_SW_ORDER_DETAIL C
                          ON A.ORDER_NO = C.PURCHASE_NO
                         AND A.ROW_NO = C.ORDER_ROWNO
                       WHERE A.UUID = in_uuid
                         AND A.ORDER_NO = v_order.ORDER_NO
                       GROUP BY A.ORDER_NO,
                                A.ORDER_SEQ,
                                A.PART_NO,
                                A.ROW_NO,
                                A.DETAIL_SEQ,
                                A.OPE_USER) B;

            --查询协同收货状态
            SELECT CASE
                     WHEN SUM(shStatus) / COUNT(*) < 1 THEN
                      CEIL(SUM(shStatus) / COUNT(*))
                     ELSE
                      FLOOR(SUM(shStatus) / COUNT(*))
                   END
              INTO v_status
              FROM (SELECT CASE A.ORDER_QTY - NVL(A.ARRIVE_NUM, 0) -
                            NVL(A.CANCEL_NUM, 0)
                             WHEN A.ORDER_QTY THEN
                              0
                             WHEN 0 THEN
                              2
                             ELSE
                              1
                           END shStatus
                      FROM MM_SW_ORDER_DETAIL A
                     WHERE A.PURCHASE_NO = v_order.ORDER_NO
                       AND A.ORDER_QTY - NVL(A.CANCEL_NUM, 0) > 0);

            --更新订单头表的收货状态
            UPDATE MM_SW_ORDER A
               SET A.RECEIVE_DATE   = SYSDATE,
                   A.RECEIVE_COUNT  = NVL(A.RECEIVE_COUNT, 0) + 1,
                   A.RECEIVE_STATUS = v_status,
                   --新增更新订单的内部接口处理状态，需要将收货状态同步到门户
                   A.DEAL_FLAG = 0
             WHERE A.ORDER_NO = v_order.ORDER_NO;

          ELSIF v_order.ORDER_TYPE = 'JIT' THEN

            --查询当前看板批次
            SELECT A.PRODUCT_SEQNO
              INTO v_cur_seq
              FROM MM_MON_KB A, MM_PUB_PLAN_CODE B, MM_JIT_ORDER C
             WHERE A.ID = B.KB_ID
               AND A.FACTORY_CODE = B.FACTORY_CODE
               AND B.PLAN_CODE = C.PLAN_CODE
               AND C.ORDER_NO = v_order.ORDER_NO;

            --写入日志表
            INSERT INTO MM_INV_IN
              (REC_NO,
               FACTORY_CODE,
               ORDER_NO,
               REC_TIMES,
               DEPOT_NO,
               OPE_IP,
               REC_CLIENT,
               ORDER_TYPE,
               ACTUAL_ARR_PRO_SEQNO,
               CREATION_USER,
               CREATION_TIME)
            VALUES
              (v_order.ORDER_NO || '_' || v_order.ORDER_SEQ,
               v_order.FACTORY_CODE,
               v_order.ORDER_NO,
               v_order.ORDER_SEQ,
               v_order.DEPOT_NO,
               v_order.IP,
               2,
               'JIT',
               v_cur_seq,
               v_order.Ope_User,
               SYSDATE);

            --写入拉动日志明细
            INSERT INTO MM_INV_IN_DETAIL
              (REC_NO,
               ROW_NO,
               REC_TIMES,
               PART_NO,
               ORDER_QTY,
               REC_QTY,
               CREATION_TIME)
              SELECT B.RECEIVE_NO,
                     B.ROW_NO,
                     B.DETAIL_SEQ,
                     B.PART_NO,
                     B.REQUIRE_NUM,
                     B.THIS_SH_NUM,
                     SYSDATE
                FROM (SELECT A.ORDER_NO || '_' || A.ORDER_SEQ AS RECEIVE_NO,
                             A.ROW_NO,
                             A.DETAIL_SEQ,
                             SUM(NVL(A.THIS_SH_NUM, 0)) THIS_SH_NUM,
                             A.OPE_USER,
                             A.PART_NO,
                             MIN(C.REQUIRE_NUM) REQUIRE_NUM
                        FROM MM_INV_REC_TEMP A
                        LEFT JOIN MM_JIT_ORDER_DETAIL C
                          ON A.ORDER_NO = C.ORDER_NO
                         AND A.ROW_NO = C.ORDER_ROWNO
                       WHERE A.UUID = in_uuid
                         AND A.ORDER_NO = v_order.ORDER_NO
                       GROUP BY A.ORDER_NO,
                                A.ORDER_SEQ,
                                A.PART_NO,
                                A.ROW_NO,
                                A.DETAIL_SEQ,
                                A.OPE_USER) B;

            --更新拉动订单行数据
            MERGE INTO MM_JIT_ORDER_DETAIL T
            USING (SELECT A.ORDER_NO,
                          A.DETAIL_SEQ,
                          A.KB_SEQ_NO,
                          A.ROW_NO,
                          SUM(TO_NUMBER(NVL(A.THIS_SH_NUM, 0))) TOTAL_NUM
                     FROM MM_INV_REC_TEMP A
                    WHERE A.UUID = in_uuid
                      AND A.ORDER_NO = v_order.order_no
                    GROUP BY A.ORDER_NO, A.DETAIL_SEQ, A.ROW_NO, A.KB_SEQ_NO) T1
            ON (T.ORDER_ROWNO = T1.ROW_NO AND T.ORDER_NO = T1.ORDER_NO)
            WHEN MATCHED THEN
              UPDATE
                 SET T.ARRIVE_NUM               = NVL(T.ARRIVE_NUM, 0) +
                                                  TO_NUMBER(T1.TOTAL_NUM),
                     T.ACTUAL_ARR_PRODUCT_SEQNO = T1.KB_SEQ_NO,
                     T.ARRIVE_COUNT             = T1.DETAIL_SEQ,
                     T.RECEIVE_DATE             = SYSDATE,
                     T.ARRIVE_STATUS            = CASE
                                                    WHEN NVL(T.ARRIVE_NUM, 0) + TO_NUMBER(T1.TOTAL_NUM) =
                                                         NVL(T.REQUIRE_NUM, 0) THEN
                                                     2
                                                    WHEN NVL(T.ARRIVE_NUM, 0) + TO_NUMBER(T1.TOTAL_NUM) <
                                                         NVL(T.REQUIRE_NUM, 0) AND
                                                         NVL(T.ARRIVE_NUM, 0) + TO_NUMBER(T1.TOTAL_NUM) > 0 THEN
                                                     1
                                                    ELSE
                                                     0
                                                  END;

            --查询拉动收货状态
            SELECT CASE
                     WHEN SUM(shStatus) / COUNT(*) < 1 THEN
                      CEIL(SUM(shStatus) / COUNT(*))
                     ELSE
                      FLOOR(SUM(shStatus) / COUNT(*))
                   END
              INTO v_status
              FROM (SELECT CASE A.REQUIRE_NUM - NVL(A.ARRIVE_NUM, 0)
                             WHEN A.REQUIRE_NUM THEN
                              0
                             WHEN 0 THEN
                              2
                             ELSE
                              1
                           END shStatus
                      FROM MM_JIT_ORDER_DETAIL A
                     WHERE A.ORDER_NO = v_order.order_no);

            --更新拉动收货状态
            UPDATE MM_JIT_ORDER T
               SET T.ARRIVE_COUNT             = v_order.ORDER_SEQ,
                   T.ARRIVE_STATUS            = v_status,
                   T.ACTUAL_ARR_PRODUCT_SEQNO = v_cur_seq,
                   T.RECEIVE_DATE = SYSDATE
             WHERE T.ORDER_NO = v_order.ORDER_NO;

          END IF;

          --保存标签信息
          INSERT INTO MM_PDA_LABEL_SCAN_LOG
            (FACTORY_CODE,
             BAR_CODE,
             ORDER_NO,
             ROW_NO,
             PART_NO,
             QTY,
             BAR_UUID,
             TYPE,
             CREATE_USER,
             CREATE_TIME,
             IP)
            SELECT A.FACTORY_CODE,
                   A.PARTLABEL,
                   A.ORDER_NO,
                   A.ROW_NO,
                   A.PART_NO,
                   A.THIS_SH_NUM,
                   SUBSTR(A.PARTLABEL, INSTR(A.PARTLABEL, '#', -1) + 1),
                   '1',
                   A.OPE_USER,
                   SYSDATE,
                   A.IP
              FROM MM_INV_REC_TEMP A
             WHERE A.UUID = in_uuid
               AND A.ORDER_NO = v_order.ORDER_NO;

        END LOOP;
        out_code := 1;
      END IF;
    END IF;

    UPDATE MM_INV_REC_TEMP A
       SET A.CHECK_CODE = out_code
     WHERE A.UUID = in_uuid;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_DEAL_PARTLABEL_SH',
           err_num,
           err_msg,
           sysdate,
           '标签扫描收货处理');
        COMMIT;
      END;
  END USP_DEAL_PARTLABEL_SH;

  --***************************************************************************
  --存储过程名：USP_DEAL_JISOLABEL_SH
  --功能描述：同步指示票扫描收货
  --参数说明：
  --in_uuid uuid
  --out_code
  --out_type
  --创建人员: wangyu
  --创建时间： 2018/09/21
  PROCEDURE USP_DEAL_JISOLABEL_SH(in_uuid IN VARCHAR2, out_code OUT INT) IS
    tempnum1 number;
    tempnum2 number;
    v_status number;
    err_num  number;
    err_msg  varchar2(300);
    --当前看板批次
    cur_seq number;
  BEGIN
    --删除数量为0的数据
    DELETE FROM MM_INV_REC_TEMP A
     WHERE A.UUID = in_uuid
       AND A.THIS_SH_NUM <= 0;

    --新增指示票记录
    MERGE INTO MM_PDA_JISO_LABEL A
    USING (SELECT T1.INS_NO, T1.PART_NO, E.ORDER_ROWNO, T1.REQUIRE_NUM
             FROM (SELECT A.INS_NO,
                          B.PART_NO,
                          SUM(B.REQUIRE_NUM) REQUIRE_NUM,
                          MIN(A.ORDER_NO) ORDER_NO
                     FROM MM_JISO_INS A, MM_JISO_INS_DETAIL B
                    WHERE A.INS_NO = B.INS_NO
                      AND EXISTS (SELECT 1
                             FROM MM_INV_REC_TEMP T
                            WHERE A.INS_NO = T.PARTLABEL
                              AND T.UUID = in_uuid)
                      AND B.REQUIRE_NUM IS NOT NULL
                      AND B.REQUIRE_NUM > 0
                    GROUP BY A.INS_NO, B.PART_NO) T1
             LEFT JOIN MM_JISO_ORDER D
               ON T1.ORDER_NO = D.ORDER_NO
             LEFT JOIN MM_JISO_ORDER_DETAIL E
               ON D.ORDER_NO = E.ORDER_NO
              AND T1.PART_NO = E.PART_NO) B
    ON (A.INS_NO = B.INS_NO AND A.PART_NO = B.PART_NO AND A.ORDER_ROWNO = B.ORDER_ROWNO)
    WHEN NOT MATCHED THEN
      INSERT
        (INS_NO,
         PART_NO,
         ORDER_ROWNO,
         REQUIRE_NUM,
         CREATION_TIME,
         LAST_MODIFIED_TIME)
      VALUES
        (B.INS_NO,
         B.PART_NO,
         B.ORDER_ROWNO,
         B.REQUIRE_NUM,
         SYSDATE,
         SYSDATE);

    --检测指示票是否已收齐
    /*    SELECT MIN(SIGN(NVL(B.REQUIRE_NUM, 0) - NVL(B.ARRIVE_NUM, 0) -
                  NVL(A.THIS_SH_NUM, 0))),
         MIN(SIGN(NVL(C.REQUIRE_NUM, 0) - NVL(C.ARRIVE_NUM, 0) -
                  NVL(A.THIS_SH_NUM, 0)))
    INTO tempnum1, tempnum2
    FROM (SELECT * FROM MM_INV_REC_TEMP WHERE UUID = in_uuid) A
    LEFT JOIN MM_PDA_JISO_LABEL B
      ON A.PARTLABEL = B.INS_NO
     AND A.ROW_NO = B.ORDER_ROWNO
     AND A.PART_NO = B.PART_NO
    LEFT JOIN MM_JISO_ORDER_DETAIL C
      ON C.ORDER_ROWNO = A.ROW_NO
     AND C.ORDER_NO = C.ORDER_NO;*/

    --检测指示票是否收齐
    SELECT MIN(SIGN(NVL(B.REQUIRE_NUM, 0) - NVl(B.ARRIVE_NUM, 0) -
                    NVL(A.THIS_SH_NUM, 0)))
      INTO tempnum1
      FROM MM_INV_REC_TEMP A
      LEFT JOIN MM_PDA_JISO_LABEL B
        ON A.PARTLABEL = B.INS_NO
       AND A.ROW_NO = B.ORDER_ROWNO
       AND A.PART_NO = B.PART_NO
     WHERE A.UUID = in_uuid;

    --检测订单是否收齐
    SELECT MIN(SIGN(NVL(B.REQUIRE_NUM, 0) - NVL(B.ARRIVE_NUM, 0) -
                    NVL(A.THIS_SH_NUM, 0)))
      INTO tempnum2
      FROM MM_INV_REC_TEMP A
      LEFT JOIN MM_JISO_ORDER_DETAIL B
        ON A.ORDER_NO = B.ORDER_NO
       AND A.ROW_NO = B.ORDER_ROWNO
     WHERE A.UUID = in_uuid;

    IF (tempnum2 < 0) THEN
      --数据异常超过订单数量
      out_code := 2;
      RETURN;
    END IF;
    IF (tempnum1 < 0) THEN
      --数据异常超过指示票数量
      out_code := 3;
      RETURN;
    END IF;

    --更新临时表收货次数
    MERGE INTO MM_INV_REC_TEMP D
    USING (SELECT NVL(B.ARRIVE_COUNT, 0) + 1 ORDER_SEQ,
                  NVL(C.ARRIVE_COUNT, 0) + 1 DETAIL_SEQ,
                  A.ORDER_NO,
                  A.ROW_NO
             FROM (SELECT DISTINCT A.ORDER_NO, A.ROW_NO
                     FROM MM_INV_REC_TEMP A
                    WHERE A.UUID = in_uuid) A
             LEFT JOIN MM_JISO_ORDER B
               ON A.ORDER_NO = B.ORDER_NO
             LEFT JOIN MM_JISO_ORDER_DETAIL C
               ON B.ORDER_NO = C.ORDER_NO
              AND A.ROW_NO = C.ORDER_ROWNO) F
    ON (D.ORDER_NO = F.ORDER_NO AND D.ROW_NO = F.ROW_NO)
    WHEN MATCHED THEN
      UPDATE SET D.ORDER_SEQ = F.ORDER_SEQ, D.DETAIL_SEQ = F.DETAIL_SEQ;

    FOR cur_order IN (SELECT DISTINCT A.FACTORY_CODE,
                                      A.ORDER_NO,
                                      A.ORDER_SEQ
                        FROM MM_INV_REC_TEMP A
                       WHERE A.UUID = in_uuid) LOOP

      --查询当前看板批次
      BEGIN
        SELECT D.PRODUCT_SEQNO
          INTO cur_seq
          FROM MM_JISO_ORDER B
          LEFT JOIN MM_PUB_PLAN_CODE C
            ON B.PLAN_CODE = C.PLAN_CODE
          LEFT JOIN MM_MON_KB D
            ON C.KB_ID = D.ID
           AND C.FACTORY_CODE = D.FACTORY_CODE
         WHERE B.ORDER_NO = cur_order.ORDER_NO;
      EXCEPTION
        WHEN OTHERS THEN
          cur_seq := 0;
      END;

      --写入同步日志头
      INSERT INTO MM_INV_IN
        (REC_NO,
         FACTORY_CODE,
         ORDER_NO,
         REC_TIMES,
         OPE_IP,
         REC_CLIENT,
         ORDER_TYPE,
         DEPOT_NO,
         ACTUAL_ARR_PRO_SEQNO,
         CREATION_USER,
         CREATION_TIME)
        SELECT DISTINCT A.ORDER_NO || '_' || A.ORDER_SEQ,
                        A.FACTORY_CODE,
                        A.ORDER_NO,
                        A.ORDER_SEQ,
                        A.IP,
                        '2',
                        'JISO',
                        CASE
                          WHEN SUBSTR(C.WORKCENTER, 0, 1) = 'A' THEN
                           'AW11'
                          WHEN SUBSTR(C.WORKCENTER, 0, 1) = 'W' THEN
                           'WW11'
                        END,
                        D.CURR_BATCH_SEQNO,
                        A.OPE_USER,
                        SYSDATE
          FROM MM_INV_REC_TEMP A
          LEFT JOIN MM_JISO_ORDER B
            ON A.ORDER_NO = B.ORDER_NO
          LEFT JOIN MM_PUB_PLAN_CODE C
            ON B.PLAN_CODE = C.PLAN_CODE
          LEFT JOIN MM_MON_KB D
            ON C.KB_ID = D.ID
           AND C.FACTORY_CODE = D.FACTORY_CODE
         WHERE A.UUID = in_uuid
           AND A.ORDER_NO = cur_order.ORDER_NO;

      --同步日志明细
      INSERT INTO MM_INV_IN_DETAIL
        (REC_NO,
         ROW_NO,
         REC_TIMES,
         PART_NO,
         ORDER_QTY,
         REC_QTY,
         CREATION_TIME)
        SELECT B.RECEIVE_NO,
               B.ROW_NO,
               B.DETAIL_SEQ,
               B.PART_NO,
               B.REQUIRE_NUM,
               B.THIS_SH_NUM,
               SYSDATE
          FROM (SELECT A.ORDER_NO || '_' || A.ORDER_SEQ AS RECEIVE_NO,
                       A.ROW_NO,
                       A.DETAIL_SEQ,
                       SUM(NVL(A.THIS_SH_NUM, 0)) THIS_SH_NUM,
                       A.OPE_USER,
                       A.PART_NO,
                       MIN(C.REQUIRE_NUM) REQUIRE_NUM
                  FROM MM_INV_REC_TEMP A
                  LEFT JOIN MM_JISO_ORDER_DETAIL C
                    ON A.ORDER_NO = C.ORDER_NO
                   AND A.ROW_NO = C.ORDER_ROWNO
                 WHERE A.UUID = in_uuid
                   AND A.ORDER_NO = cur_order.ORDER_NO
                 GROUP BY A.ORDER_NO,
                          A.ORDER_SEQ,
                          A.PART_NO,
                          A.ROW_NO,
                          A.DETAIL_SEQ,
                          A.OPE_USER) B;

      --更新同步订单行数据
      MERGE INTO MM_JISO_ORDER_DETAIL T
      USING (SELECT A.ORDER_NO,
                    A.DETAIL_SEQ,
                    A.ROW_NO,
                    SUM(TO_NUMBER(NVL(A.THIS_SH_NUM, 0))) THIS_SH_NUM
               FROM MM_INV_REC_TEMP A
              WHERE A.UUID = in_uuid
                AND A.ORDER_NO = cur_order.ORDER_NO
              GROUP BY A.ORDER_NO, A.DETAIL_SEQ, A.ROW_NO) T1
      ON (T.ORDER_ROWNO = T1.ROW_NO AND T.ORDER_NO = T1.ORDER_NO)
      WHEN MATCHED THEN
        UPDATE
           SET T.ARRIVE_NUM               = NVL(T.ARRIVE_NUM, 0) +
                                            TO_NUMBER(T1.THIS_SH_NUM),
               T.ACTUAL_ARR_PRODUCT_SEQNO = cur_seq,
               T.ARRIVE_COUNT             = T1.DETAIL_SEQ,
               T.RECEIVE_DATE             = SYSDATE,
               T.ARRIVE_STATUS            = CASE
                                              WHEN NVL(T.ARRIVE_NUM, 0) + TO_NUMBER(T1.THIS_SH_NUM) =
                                                   NVL(T.REQUIRE_NUM, 0) THEN
                                               2
                                              WHEN NVL(T.ARRIVE_NUM, 0) + TO_NUMBER(T1.THIS_SH_NUM) <
                                                   NVL(T.REQUIRE_NUM, 0) AND
                                                   NVL(T.ARRIVE_NUM, 0) + TO_NUMBER(T1.THIS_SH_NUM) > 0 THEN
                                               1
                                              ELSE
                                               0
                                            END;

      --查询同步收货状态
      SELECT CASE
               WHEN SUM(shStatus) / COUNT(*) < 1 THEN
                CEIL(SUM(shStatus) / COUNT(*))
               ELSE
                FLOOR(SUM(shStatus) / COUNT(*))
             END
        INTO v_status
        FROM (SELECT CASE A.REQUIRE_NUM - NVL(A.ARRIVE_NUM, 0)
                       WHEN A.REQUIRE_NUM THEN
                        0
                       WHEN 0 THEN
                        2
                       ELSE
                        1
                     END shStatus
                FROM MM_JISO_ORDER_DETAIL A
               WHERE A.ORDER_NO = cur_order.ORDER_NO);

      --更新同步收货状态
      UPDATE MM_JISO_ORDER A
         SET A.ARRIVE_COUNT             = cur_order.ORDER_SEQ,
             A.ARRIVE_STATUS            = v_status,
             A.ACTUAL_ARR_PRODUCT_SEQNO = cur_seq,
             A.RECEIVE_DATE = SYSDATE
       WHERE A.ORDER_NO = cur_order.ORDER_NO;
    END LOOP;

    --更新指示票收货数据
    MERGE INTO MM_PDA_JISO_LABEL A
    USING (SELECT NVL(B.THIS_SH_NUM, 0) THIS_SH_NUM, B.ROW_NO, B.PARTLABEL
             FROM MM_INV_REC_TEMP B
            WHERE B.UUID = in_uuid) B
    ON (A.ORDER_ROWNO = B.ROW_NO AND A.INS_NO = B.PARTLABEL)
    WHEN MATCHED THEN
      UPDATE
         SET A.ARRIVE_NUM         = NVL(A.ARRIVE_NUM, 0) + B.THIS_SH_NUM,
             A.LAST_MODIFIED_TIME = SYSDATE;
    COMMIT;
    --收货成功
    out_code := 1;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        err_num := sqlcode;
        err_msg := substrb(sqlerrm || dbms_utility.format_error_backtrace(),
                           1,
                           200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_DEAL_JISOLABEL_SH',
           err_num,
           err_msg,
           sysdate,
           '指示票扫描收货处理');
        COMMIT;
      END;
  END USP_DEAL_JISOLABEL_SH;

end PKG_REC_MAIN;
/

prompt
prompt Creating package body PKG_SPS
prompt =============================
prompt
create or replace package body PKG_SPS is

  --****************************************************************************
  --过程名  : USP_SPS_GET_PASS_QUEUE
  --功能描述: SPS获取车序队列
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-28
  --****************************************************************************
  PROCEDURE USP_SPS_GET_PASS_QUEUE(in_plan_code in varchar2) IS
    v_max_pass_time    mm_jiso_queue_config.max_pass_time%type; --已获取队列最大过点时间
    v_exec_flag        number(1); --是否获取队列标志，0：未获取 1：获取
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    --获取过点车序队列配置表信息
    for cur_queue_config in (select a.factory_code, a.station_code, b.*
                               from mm_pub_plan_code a,
                                    mm_sps_queue_config b
                              where a.plan_code = b.plan_code
                                and a.plan_code = in_plan_code)
    loop
      v_max_pass_time    := cur_queue_config.max_pass_time;
      v_exec_flag := 0;

      --1 计划信息点，0 实绩信息点
      if cur_queue_config.is_plan = 1 then
        for cur_queue in (select a.*
                                 from if_veh_lock_plan a
                                where a.factory_code = cur_queue_config.factory_code
                                and to_date(a.weon_time,'yyyy-mm-dd hh24:mi:ss') >  cur_queue_config.max_pass_time
                                  order by to_date(a.weon_time,'yyyy-mm-dd hh24:mi:ss'))
         loop
          v_exec_flag     :=1;
          v_max_pass_time := to_date(cur_queue.weon_time, 'yyyy-mm-dd hh24:mi:ss');

          --写入推算队列
          insert into mm_sps_veh_queue
            (plan_code,
             order_no,
             erp_order_no,
             vin,
             model_code,
             phase,
             pass_time,
             wc_seqno,
             pl_seqno,
             mtco)
          values
            (in_plan_code,
             cur_queue.order_no,
             cur_queue.erp_order_no,
             cur_queue.vin,
             cur_queue.model_code,
             cur_queue.phase,
             v_max_pass_time,
             '',
             '',
             cur_queue.mtoc);
        end loop;
      else
        --根据配置信息获取获取过点队列数据
        for cur_queue in (select a.*
                            from mm_pub_veh_pass a
                           where a.factory_code = cur_queue_config.factory_code
                             and a.station_code = cur_queue_config.station_code
                             and a.pass_time > cur_queue_config.max_pass_time
                           order by a.pass_time)
        loop
          v_exec_flag     :=1;
          v_max_pass_time := cur_queue.pass_time;

          --写入推算队列
          insert into mm_sps_veh_queue
            (plan_code,
             order_no,
             erp_order_no,
             vin,
             model_code,
             phase,
             pass_time,
             wc_seqno,
             pl_seqno,
             mtco)
          values
            (in_plan_code,
             cur_queue.order_no,
             cur_queue.erp_order_no,
             cur_queue.vin,
             cur_queue.model_code,
             cur_queue.phase,
             v_max_pass_time,
             cur_queue.wc_seqno,
             cur_queue.pl_seqno,
             cur_queue.mtoc);
        end loop;
      end if;
      --更新过点车序队列配置信息
      if v_exec_flag = 1 then
        update mm_sps_queue_config t
           set t.max_pass_time    = v_max_pass_time
         where t.plan_code = in_plan_code;
      end if;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_SPS_GET_PASS_QUEUE_TEST'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_SPS_GET_PASS_QUEUE;

  --****************************************************************************
  --过程名  : USP_SPS_CREATE_INS
  --功能描述: 计算生成分拣单
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-28
  --修改记录：
  --          调整单据前缀获取逻辑 mod by wxl 20190129
  --****************************************************************************
  PROCEDURE USP_SPS_CREATE_INS(in_plan_code in varchar2) IS
    v_factory_prefix   varchar(1); --指示票号:工厂前缀
    v_work_date        date; --当前时间的工作日期(不包含时分秒) mod by wxl 20181226
    v_date_char        varchar(10); --指示票号:日期
    v_seq_no           number(4); --指示票号:流水
    v_ins_no           mm_sps_ins.ins_no%type; --指示票号
    v_factory_code     mm_pub_plan_code.factory_code%type; --工厂代码 mod by dtp 2019-6-2
    v_flag             number(1); --临时标识
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    --mod by dtp 20190602 工厂代码
    for cur_fc in (select * from mm_pub_plan_code c where c.plan_code = in_plan_code)
      loop
        v_factory_code := cur_fc.factory_code;
      end loop;
    --遍历未组票的车辆信息
    for cur_queue in (select a.factory_code, a.workcenter, b.*,c.vehicle_level_desc_s,
                             c.in_color_desc_s,c.out_color_desc_s,c.battery_power_s,nvl(b.mtco, c.mtoc) as mtcoDesc
                        from mm_pub_plan_code a,
                             mm_sps_veh_queue b
                       left join if_veh_lock_plan c on c.erp_order_no = b.erp_order_no
                       where a.plan_code = b.plan_code
                         and b.exec_status = 0
                         and a.plan_code = in_plan_code
                       order by b.pass_time)
    loop
      v_factory_prefix := null;
      --mod by wxl 20190129
      for cur_prefix in (select a.factory_code_str
                           from mm_pub_bill_prefix a
                          where a.bill_group = 'SPS_INS'
                            and a.plan_code = cur_queue.plan_code)
      loop
        v_factory_prefix := cur_prefix.factory_code_str;
      end loop;
      --按模板进行组票
      for cur_mould in (select b.id, b.plan_code, b.mould_code, b.assembly_ins
                          from mm_sps_mould b
                         where b.plan_code = cur_queue.plan_code
                           and b.model_code = cur_queue.model_code
                           and b.is_enable = 1)
      loop
        --生成指示票号、分零件组指示票代码
        v_work_date      := PKG_PUB.USF_GET_WORK_DATE(cur_queue.factory_code, cur_queue.workcenter, cur_queue.pass_time);
        v_date_char      := to_char(v_work_date, 'yyyymmdd') ;
        select count(1)
          into v_flag
          from mm_sps_ins_sn a
         where a.plan_code = cur_mould.plan_code
           and a.mould_code = cur_mould.mould_code
           and a.use_date = v_work_date;
        if v_flag = 0 then
          v_seq_no := 1;
          insert into mm_sps_ins_sn
            (plan_code, mould_code, use_date, seq_no)
          values
            (cur_mould.plan_code, cur_mould.mould_code, v_work_date, 1);
        else
          select seq_no + 1
            into v_seq_no
            from mm_sps_ins_sn a
           where a.plan_code = cur_mould.plan_code
             and a.mould_code = cur_mould.mould_code
             and a.use_date = v_work_date;
          update mm_sps_ins_sn a
             set a.seq_no = v_seq_no
           where a.plan_code = cur_mould.plan_code
             and a.mould_code = cur_mould.mould_code
             and a.use_date = v_work_date;
        end if;
        v_ins_no := v_factory_prefix || v_date_char || cur_mould.mould_code || lpad(v_seq_no, 4, '0');

        --写入指示票主信息
        insert into mm_sps_ins
          (ins_no,
           mould_id,
           plan_code,
           order_no,
           vin,
           model_code,
           phase,
           wc_seqno,
           pl_seqno,
           pass_time)
        values
          (v_ins_no,
           cur_mould.id,
           cur_mould.plan_code,
           cur_queue.order_no,
           cur_queue.vin,
           cur_queue.model_code,
           cur_queue.phase,
           cur_queue.wc_seqno,
           cur_queue.pl_seqno,
           cur_queue.pass_time);
        --写入指示票明细信息
        --固定值
        insert into mm_sps_ins_detail
          (ins_no,
           mould_place,
           config_code,
           config_desc,
           config_type,
           part_no,
           part_name,
           quantity,
           show_value)
          select v_ins_no,
                 a.mould_place,
                 b.config_code,
                 b.config_desc,
                 b.config_type,
                 null,
                 null,
                 null,
                 b.config_value
            from mm_sps_mould_config a, mm_sps_config b
           where a.mould_id = cur_mould.id
             --and b.id = a.config_id
             and b.config_code = a.config_code
             and b.config_type = '2';
        --车辆信息
        insert into mm_sps_ins_detail
          (ins_no,
           mould_place,
           config_code,
           config_desc,
           config_type,
           part_no,
           part_name,
           quantity,
           show_value)
          select v_ins_no,
                 a.mould_place,
                 b.config_code,
                 b.config_desc,
                 b.config_type,
                 null,
                 null,
                 null,
                 case
                   when b.config_code = 'VIN' then
                    cur_queue.vin
                   when b.config_code = 'MODEL' then
                    cur_queue.model_code
                   when b.config_code = 'WC_SEQNO' then
                    cur_queue.wc_seqno
                   when b.config_code = 'PL_SEQNO' then
                    cur_queue.pl_seqno
                   when b.config_code = 'PASS_TIME' then
                    to_char(cur_queue.pass_time, 'yyyy-mm-dd hh24:mi:ss')
                   when b.config_code = 'VEHICLE_LEVEL' then
                    cur_queue.vehicle_level_desc_s
                   when b.config_code = 'IN_COLOR' then
                    cur_queue.in_color_desc_s
                   when b.config_code = 'OUT_COLOR' then
                    cur_queue.out_color_desc_s
                   when b.config_code = 'BATTERY_POWER' then
                    cur_queue.battery_power_s
                   when b.config_code = 'MTCO_CODE' then
                    cur_queue.mtcoDesc
                 end as config_value
            from mm_sps_mould_config a, mm_sps_config b
           where a.mould_id = cur_mould.id
             --and b.id = a.config_id
             and b.config_code = a.config_code
             and b.config_type = '1';
        --特征值
        /*insert into mm_sps_ins_detail
          (ins_no,
           mould_place,
           config_code,
           config_desc,
           config_type,
           part_no,
           part_name,
           quantity,
           show_value)
          select v_ins_no,
                 a.mould_place,
                 b.config_name,
                 b.config_desc,
                 '4',
                 null,
                 null,
                 null,
                 wmsys.wm_concat(c.display_value)
            from mm_sps_mould_config    a,
                 mm_pub_sps_config      b,
                 mm_pub_feature_group   c,
                 mm_pub_assembly_config d,
                 mm_pub_order_feature   e1,
                 mm_pub_order_feature   e2,
                 mm_pub_order_feature   e3,
                 mm_pub_order_feature   e4
           where a.mould_id = cur_mould.id
             and a.config_code is null
             and d.assembly_name = cur_mould.assembly_ins
             and d.location = a.mould_place
             and b.config_name = d.config_name
             and c.feature_group = b.feature_group
             and e1.factory_code = cur_queue.factory_code
             and e1.order_no = cur_queue.erp_order_no
             and e1.feature_code = c.feature_code1
             and e1.feature_value = c.feature_value1
             and e2.factory_code = cur_queue.factory_code
             and e2.order_no = cur_queue.erp_order_no
             and e2.feature_code = c.feature_code2
             and e2.feature_value = c.feature_value2
             and e3.factory_code = cur_queue.factory_code
             and e3.order_no = cur_queue.erp_order_no
             and e3.feature_code = c.feature_code3
             and e3.feature_value = c.feature_value3
             and e4.factory_code = cur_queue.factory_code
             and e4.order_no = cur_queue.erp_order_no
             and e4.feature_code = c.feature_code4
             and e4.feature_value = c.feature_value4
           group by a.mould_place, b.config_name, b.config_desc;*/
        --物料
        insert into mm_sps_ins_detail
          (ins_no,
           mould_place,
           config_code,
           config_desc,
           config_type,
           part_no,
           part_name,
           quantity,
           show_value)
          select v_ins_no,
                 mould_place,
                 config_code,
                 config_desc,
                 config_type,
                 part_no,
                 part_name_cn,
                 sum(num),
                 show_value
            from (select a.mould_place,
                         c.config_code,
                         c.config_desc,
                         c.config_type,
                         e.part_no,
                         e.num,
                         p.part_name_cn,
                         a.config_show,
                         rank() over(partition by c.config_code, c.config_desc, c.config_type order by e.part_no) sn,
                         case
                           when e.part_no is not null and a.config_show = '1' then
                             b.part_mark
                             --nvl(b.part_mark,(SELECT T.PARAM_VAL FROM MM_PUB_SYS_PARAM T WHERE T.PARAM_CODE = 'SPS_POINT'))
                           when e.part_no is not null and a.config_show = '2' then
                             b.shelf_no
                             --nvl(b.shelf_no,(SELECT T.PARAM_VAL FROM MM_PUB_SYS_PARAM T WHERE T.PARAM_CODE = 'SPS_POINT'))
                           when e.part_no is null and a.config_show = '1' then
                             (SELECT T.PARAM_VAL FROM MM_PUB_SYS_PARAM T WHERE T.PARAM_CODE = 'SPS_POINT_PART_MARK')
                           when e.part_no is null and a.config_show = '2' then
                             (SELECT T.PARAM_VAL FROM MM_PUB_SYS_PARAM T WHERE T.PARAM_CODE = 'SPS_POINT_SHELF_NO')
                           when a.config_show = '3' then
                             c.config_desc
                         end as show_value
                    from mm_sps_mould_config a, mm_sps_config_detail b
                    left join mm_pub_order_bom e
                      on e.factory_code = cur_queue.factory_code
                     and e.order_no = cur_queue.erp_order_no
                     and e.workcenter = cur_queue.workcenter
                     --and e.station_code = b.station_code
                     and (b.station_code is null or (b.station_code is not null and
                         e.station_code = b.station_code))
                     and e.part_no = b.part_no
                    left join mm_pub_part p
                    --i-LMS2019053001 mod by dtp
                      on p.part_no = e.part_no and p.factory_code = v_factory_code, mm_sps_config c
                   where a.mould_id = cur_mould.id
                        --and b.config_id = a.config_id
                     and b.model_code = cur_queue.model_code
                        --and c.id = b.config_id
                     and b.config_id = c.id
                     and c.config_code = a.config_code
                     and c.config_type = '3')
                     where (sn < 2 or (sn > 1 and part_no is not null))
           group by mould_place,
                    config_code,
                    config_desc,
                    config_type,
                    part_no,
                    part_name_cn,
                    show_value;
      end loop;

      --更新车序组票状态
      update mm_sps_veh_queue a
         set a.exec_status = 1, a.exec_time = sysdate
       where a.plan_code = cur_queue.plan_code
         and a.order_no = cur_queue.order_no
         and a.exec_status = 0;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_SPS_CREATE_INS'||in_plan_code, err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_SPS_CREATE_INS;

  --****************************************************************************
  --过程名  : USP_SPS_CREATE_TEST_INS
  --功能描述: 计算生成分拣单(试打印)
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: dtp
  --创建时间: 2019-02-22
  --****************************************************************************
  PROCEDURE USP_SPS_CREATE_TEST_INS(IN_VAR_UUID in varchar2)IS
    v_factory_prefix   varchar(1); --指示票号:工厂前缀
    v_work_date        date; --当前时间的工作日期(不包含时分秒) mod by wxl 20181226
    v_date_char        varchar(10); --指示票号:日期
    v_seq_no           number(4); --指示票号:流水
    v_ins_no           mm_sps_ins.ins_no%type; --指示票号
    v_flag             number(1); --临时标识
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    --遍历试打印的车辆信息
    for cur_queue in (select a.factory_code, a.workcenter, b.*, d.id impId,
                        c.vehicle_level_desc_s,c.in_color_desc_s,c.out_color_desc_s,
                        c.battery_power_s,nvl(c.material_no_s, b.mtco) as mtcoDesc
                        from mm_pub_plan_code a,
                             mm_sps_veh_queue b,
                             mm_sps_test_print_imp d
                         left join if_veh_lock_plan c on c.erp_order_no = d.erp_order_no
                       where a.plan_code = b.plan_code
                       and a.plan_code = d.plan_code
                       and b.erp_order_no = d.erp_order_no
                       and d.uuid = IN_VAR_UUID
                       order by b.pass_time)
    loop
      v_factory_prefix := null;
      --mod by wxl 20190129
      for cur_prefix in (select a.factory_code_str
                           from mm_pub_bill_prefix a
                          where a.bill_group = 'SPS_INS'
                            and a.plan_code = cur_queue.plan_code)
      loop
        v_factory_prefix := cur_prefix.factory_code_str;
      end loop;
      --按模板进行组票
      for cur_mould in (select b.id, b.plan_code, b.mould_code, b.assembly_ins
                          from mm_sps_mould b,
                               mm_sps_test_print_imp c
                         where b.id = c.mould_id
                         and rownum = 1
                         and c.uuid = IN_VAR_UUID)
      loop
        --生成指示票号、分零件组指示票代码
        v_work_date      := PKG_PUB.USF_GET_WORK_DATE(cur_queue.factory_code, cur_queue.workcenter, cur_queue.pass_time);
        v_date_char      := to_char(v_work_date, 'yyyymmdd') ;
        select count(1)
          into v_flag
          from mm_sps_ins_sn a
         where a.plan_code = cur_mould.plan_code
           and a.mould_code = cur_mould.mould_code
           and a.use_date = v_work_date;
        if v_flag = 0 then
          v_seq_no := 1;
          insert into mm_sps_ins_sn
            (plan_code, mould_code, use_date, seq_no)
          values
            (cur_mould.plan_code, cur_mould.mould_code, v_work_date, 1);
        else
          select seq_no + 1
            into v_seq_no
            from mm_sps_ins_sn a
           where a.plan_code = cur_mould.plan_code
             and a.mould_code = cur_mould.mould_code
             and a.use_date = v_work_date;
          update mm_sps_ins_sn a
             set a.seq_no = v_seq_no
           where a.plan_code = cur_mould.plan_code
             and a.mould_code = cur_mould.mould_code
             and a.use_date = v_work_date;
        end if;
        v_ins_no := 'F' || v_date_char || cur_mould.mould_code || lpad(v_seq_no, 4, '0');

        --写入指示票主信息
        insert into mm_sps_ins
          (
          ins_no,
           mould_id,
           plan_code,
           order_no,
           vin,
           model_code,
           phase,
           wc_seqno,
           pl_seqno,
           pass_time,
           is_load)
        values
          (v_ins_no,
           cur_mould.id,
           cur_mould.plan_code,
           cur_queue.order_no,
           cur_queue.vin,
           cur_queue.model_code,
           cur_queue.phase,
           cur_queue.wc_seqno,
           cur_queue.pl_seqno,
           cur_queue.pass_time,
           '1');
        --写入指示票明细信息
        --固定值
        insert into mm_sps_ins_detail
          (ins_no,
           mould_place,
           config_code,
           config_desc,
           config_type,
           part_no,
           part_name,
           quantity,
           show_value)
          select v_ins_no,
                 a.mould_place,
                 b.config_code,
                 b.config_desc,
                 b.config_type,
                 null,
                 null,
                 null,
                 b.config_value
            from mm_sps_mould_config a, mm_sps_config b
           where a.mould_id = cur_mould.id
             --and b.id = a.config_id
             and b.config_code = a.config_code
             and b.config_type = '2';
        --车辆信息
        insert into mm_sps_ins_detail
          (ins_no,
           mould_place,
           config_code,
           config_desc,
           config_type,
           part_no,
           part_name,
           quantity,
           show_value)
          select v_ins_no,
                 a.mould_place,
                 b.config_code,
                 b.config_desc,
                 b.config_type,
                 null,
                 null,
                 null,
                 case
                   when b.config_code = 'VIN' then
                    cur_queue.vin
                   when b.config_code = 'MODEL' then
                    cur_queue.model_code
                   when b.config_code = 'WC_SEQNO' then
                    cur_queue.wc_seqno
                   when b.config_code = 'PL_SEQNO' then
                    cur_queue.pl_seqno
                   when b.config_code = 'PASS_TIME' then
                    --to_char(cur_queue.pass_time, 'yyyy-mm-dd hh24:mi:ss')
                    null
                   when b.config_code = 'VEHICLE_LEVEL' then
                    cur_queue.vehicle_level_desc_s
                   when b.config_code = 'IN_COLOR' then
                    cur_queue.in_color_desc_s
                   when b.config_code = 'OUT_COLOR' then
                    cur_queue.out_color_desc_s
                   when b.config_code = 'BATTERY_POWER' then
                    cur_queue.battery_power_s
                   when b.config_code = 'MTCO_CODE' then
                    cur_queue.mtcoDesc
                 end as config_value
            from mm_sps_mould_config a, mm_sps_config b
           where a.mould_id = cur_mould.id
             --and b.id = a.config_id
             and b.config_code = a.config_code
             and b.config_type = '1';
        --特征值
        /*insert into mm_sps_ins_detail
          (ins_no,
           mould_place,
           config_code,
           config_desc,
           config_type,
           part_no,
           part_name,
           quantity,
           show_value)
          select v_ins_no,
                 a.mould_place,
                 b.config_name,
                 b.config_desc,
                 '4',
                 null,
                 null,
                 null,
                 wmsys.wm_concat(c.display_value)
            from mm_sps_mould_config    a,
                 mm_pub_sps_config      b,
                 mm_pub_feature_group   c,
                 mm_pub_assembly_config d,
                 mm_pub_order_feature   e1,
                 mm_pub_order_feature   e2,
                 mm_pub_order_feature   e3,
                 mm_pub_order_feature   e4
           where a.mould_id = cur_mould.id
             and a.config_code is null
             and d.assembly_name = cur_mould.assembly_ins
             and d.location = a.mould_place
             and b.config_name = d.config_name
             and c.feature_group = b.feature_group
             and e1.factory_code = cur_queue.factory_code
             and e1.order_no = cur_queue.erp_order_no
             and e1.feature_code = c.feature_code1
             and e1.feature_value = c.feature_value1
             and e2.factory_code = cur_queue.factory_code
             and e2.order_no = cur_queue.erp_order_no
             and e2.feature_code = c.feature_code2
             and e2.feature_value = c.feature_value2
             and e3.factory_code = cur_queue.factory_code
             and e3.order_no = cur_queue.erp_order_no
             and e3.feature_code = c.feature_code3
             and e3.feature_value = c.feature_value3
             and e4.factory_code = cur_queue.factory_code
             and e4.order_no = cur_queue.erp_order_no
             and e4.feature_code = c.feature_code4
             and e4.feature_value = c.feature_value4
           group by a.mould_place, b.config_name, b.config_desc;*/
        --物料
        insert into mm_sps_ins_detail
          (ins_no,
           mould_place,
           config_code,
           config_desc,
           config_type,
           part_no,
           part_name,
           quantity,
           show_value)
          select v_ins_no,
                 mould_place,
                 config_code,
                 config_desc,
                 config_type,
                 part_no,
                 part_name_cn,
                 sum(num),
                 show_value
            from (select a.mould_place,
                         c.config_code,
                         c.config_desc,
                         c.config_type,
                         e.part_no,
                         e.num,
                         p.part_name_cn,
                         a.config_show,
                         rank() over(partition by c.config_code, c.config_desc, c.config_type order by e.part_no) sn,
                         case
                           when e.part_no is not null and a.config_show = '1' then
                             --nvl(b.part_mark,(SELECT T.PARAM_VAL FROM MM_PUB_SYS_PARAM T WHERE T.PARAM_CODE = 'SPS_POINT'))
                             b.part_mark
                           when e.part_no is not null and a.config_show = '2' then
                             --nvl(b.shelf_no,(SELECT T.PARAM_VAL FROM MM_PUB_SYS_PARAM T WHERE T.PARAM_CODE = 'SPS_POINT'))
                             b.shelf_no
                           when e.part_no is null and a.config_show = '1' then
                             (SELECT T.PARAM_VAL FROM MM_PUB_SYS_PARAM T WHERE T.PARAM_CODE = 'SPS_POINT_PART_MARK'
                                     AND T.FACTORY_CODE = cur_queue.factory_code)
                           when e.part_no is null and a.config_show = '2' then
                             (SELECT T.PARAM_VAL FROM MM_PUB_SYS_PARAM T WHERE T.PARAM_CODE = 'SPS_POINT_SHELF_NO'
                                     AND T.FACTORY_CODE = cur_queue.factory_code)
                           when a.config_show = '3' then
                             c.config_desc
                         end as show_value
                    from mm_sps_mould_config a, mm_sps_config_detail b
                    left join mm_pub_order_bom e
                      on e.factory_code = cur_queue.factory_code
                     and e.order_no = cur_queue.erp_order_no
                     and e.workcenter = cur_queue.workcenter
                     --and e.station_code = b.station_code
                     and (b.station_code is null or (b.station_code is not null and
                         e.station_code = b.station_code))
                     and e.part_no = b.part_no
                    left join mm_pub_part p
                    --i-LMS2019053001 mod by dtp
                      on p.part_no = e.part_no and p.factory_code = cur_queue.factory_code, mm_sps_config c
                   where a.mould_id = cur_mould.id
                        --and b.config_id = a.config_id
                     and b.model_code = cur_queue.model_code
                        --and c.id = b.config_id
                     and b.config_id = c.id
                     and c.config_code = a.config_code
                     and c.config_type = '3')
                     where (sn < 2 or (sn > 1 and part_no is not null))
           group by mould_place,
                    config_code,
                    config_desc,
                    config_type,
                    part_no,
                    part_name_cn,
                    show_value;
       --指示票信息写入试打印表
       update mm_sps_test_print_imp t
         set t.ins_no = v_ins_no
         where t.id = cur_queue.impid;
      end loop;
    end loop;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_SPS_CREATE_TEST_INS', err_num, err_msg, sysdate,'');
        COMMIT;
  END USP_SPS_CREATE_TEST_INS;

  --****************************************************************************
  --过程名  : USP_SPS_CAL_EXEC
  --功能描述: 执行SPS推算
  --参数说明:
  -- in_plan_code  :信息点
  --创建人员: wxl
  --创建时间: 2018-09-28
  --****************************************************************************
  PROCEDURE USP_SPS_CAL_EXEC(in_plan_code in varchar2) IS
    v_flag             number(1); --临时标识
    v_exec_start_time  date; --存储过程执行开始时间点
    err_num            number(10); --错误代码
    err_msg            varchar2(200); --错误信息
  BEGIN
    --判断自动计算服务是否开启
    select a.is_auto_exec into v_flag from mm_pub_plan_code a where a.plan_code = in_plan_code;
    if v_flag = 0 then
      return;
    end if;
    --判断执行标识位是否为执行中
    select a.exec_state into v_flag from mm_pub_plan_code a where a.plan_code = in_plan_code;
    if v_flag = 1 then
      return;
    end if;
    --更新执行标识位为执行中
    update mm_pub_plan_code a
       set a.exec_state = 1
     where a.plan_code = in_plan_code;
    commit;

    v_exec_start_time := sysdate;
    --获取推算队列
    USP_SPS_GET_PASS_QUEUE(in_plan_code);
    --组票
    USP_SPS_CREATE_INS(in_plan_code);

    --更新执行标识位为未执行
    update mm_pub_plan_code a
       set a.exec_state = 0, a.last_exec_time = v_exec_start_time
     where a.plan_code = in_plan_code;

    --统计存储过程执行消耗时间
    insert into mm_pub_exec_time_log
      (exec_code, exec_desc, start_time, end_time)
    values
      ('USP_SPS_CAL_EXEC'||in_plan_code, '执行SPS推算', v_exec_start_time, sysdate);

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        err_num := SQLCODE;
        err_msg := SUBSTR (SQLERRM||dbms_utility.format_error_backtrace(), 1, 200);
        insert into mm_pub_pro_error
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        values
          (SEQ_PUB_PRO_ERROR.nextval, 'USP_SPS_CAL_EXEC'||in_plan_code, err_num, err_msg, sysdate,'');

        --更新执行标识位为未执行
        update mm_pub_plan_code a
           set a.exec_state = 0
         where a.plan_code = in_plan_code;
        COMMIT;
  END USP_SPS_CAL_EXEC;
end PKG_SPS;
/

prompt
prompt Creating package body PKG_TEST
prompt ==============================
prompt
create or replace package body PKG_TEST is
  --***************************************************************************
  --存储过程名：USP_PUB_WAREHOUSE
  --功能描述: 仓库主数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2) AS
    v_diff_num number(10);
  
    v_a1_first_time date;
    v_w1_first_time date;
    v_t1_first_time date;
  
    v_receive_time date;
    v_curr_rec_num NUMBER;
    v_count        number;
  BEGIN
    --查询每个车间的最早下线时间
    SELECT MIN(A.PASS_TIME)
      INTO v_a1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'AF-OFF';
  
    SELECT MIN(A.PASS_TIME)
      INTO v_w1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'WE-OFF';
  
    SELECT MIN(A.PASS_TIME)
      INTO v_t1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'PA-OFF';
  
    --找出所有手工收货比系统收货多的数据
    FOR cur_rec IN (SELECT C.DEPOT_NO,
                           C.SUP,
                           C.PART_NO,
                           NVL(C.SH_NUM, 0) - NVL(C.DEAL_NUM, 0) DIFF_NUM
                      FROM test_wxl_af_sh C
                     WHERE NVL(C.SH_NUM, 0) - NVL(C.DEAL_NUM, 0) > 0
                       AND C.DEPOT_NO IS NOT NULL) LOOP
      v_diff_num := cur_rec.DIFF_NUM;
    
      --查询仓库对应的收货时间
      BEGIN
        SELECT DISTINCT DECODE(A.WORK_CENTER,
                               'W1',
                               v_w1_first_time,
                               'A1',
                               v_a1_first_time,
                               'T1',
                               v_t1_first_time) - 1
          INTO v_receive_time
          FROM MM_INV_UNLOAD A
         WHERE A.WARE_CODE = cur_rec.DEPOT_NO;
      EXCEPTION
        WHEN OTHERS THEN
          v_receive_time := v_w1_first_time;
      END;
    
      --找出所有取货订单中未收齐的订单零件号和仓库代码和上面一致的数据
      FOR cur_sw_order IN (SELECT A.ORDER_NO,
                                  A.FACTORY_CODE,
                                  A.SUPPLIER_NO,
                                  B.ORDER_ROWNO,
                                  A.DEPOT_NO,
                                  A.ARRIVE_DATE,
                                  B.ORDER_QTY,
                                  B.CANCEL_NUM,
                                  B.ARRIVE_NUM,
                                  NVL(B.ORDER_QTY, 0) - NVL(B.ARRIVE_NUM, 0) -
                                  NVL(B.CANCEL_NUM, 0) NOT_ARRIVE_NUM,
                                  NVL(B.RECEIVE_COUNT, 0) RECEIVE_COUNT,
                                  NVL(B.RECEIVE_COUNT, 0) PART_REC_TIMES,
                                  B.PART_NO
                             FROM MM_SW_ORDER A
                             LEFT JOIN MM_SW_ORDER_DETAIL B
                               ON A.ORDER_NO = B.ORDER_NO
                            WHERE A.ORDER_TYPE = '01'
                              AND B.PART_NO = cur_rec.PART_NO
                              AND A.DEPOT_NO = cur_rec.DEPOT_NO
                              AND TO_CHAR(A.CREATION_TIME, 'YYYY-MM-DD') =
                                  '2019-03-26'
                              AND NVL(B.ARRIVE_NUM, 0) <
                                  NVL(B.ORDER_QTY, 0) - NVL(B.CANCEL_NUM, 0)
                            ORDER BY A.ARRIVE_DATE) LOOP
      
        IF v_diff_num > 0 THEN
          --判断这个订单未收货的数量是否大于差异数量
          IF cur_sw_order.NOT_ARRIVE_NUM < v_diff_num THEN
            v_curr_rec_num := cur_sw_order.NOT_ARRIVE_NUM;
          
          ELSE
            v_curr_rec_num := v_diff_num;
          END IF;
          SELECT COUNT(1)
            INTO v_count
            FROM TEST_MM_INV_IN H
           WHERE H.REC_NO = cur_sw_order.Order_No || '_' ||
                 (cur_sw_order.RECEIVE_COUNT + 1);
          IF v_count <= 0 THEN
          
            --写入收货明细表
            INSERT INTO TEST_MM_INV_IN
              (REC_NO,
               FACTORY_CODE,
               ORDER_NO,
               REC_TIMES,
               DEPOT_NO,
               ORDER_TYPE,
               CREATION_USER,
               CREATION_TIME,
               NOTE)
            VALUES
              (cur_sw_order.Order_No || '_' ||
               (cur_sw_order.RECEIVE_COUNT + 1),
               cur_sw_order.Factory_Code,
               cur_sw_order.Order_No,
               cur_sw_order.RECEIVE_COUNT + 1,
               cur_sw_order.Depot_No,
               'SW',
               'SYSTEM',
               v_receive_time,
               '手工录入');
          END IF;
        
          INSERT INTO TEST_MM_INV_IN_DETAIL
            (REC_NO,
             ROW_NO,
             REC_TIMES,
             PART_NO,
             ORDER_QTY,
             REC_QTY,
             CREATION_TIME)
          VALUES
            (cur_sw_order.Order_No || '_' ||
             (cur_sw_order.RECEIVE_COUNT + 1),
             cur_sw_order.order_rowno,
             cur_sw_order.Part_Rec_Times + 1,
             cur_sw_order.PART_NO,
             cur_sw_order.Order_Qty,
             v_curr_rec_num,
             v_receive_time);
        
          UPDATE test_wxl_af_sh A
             SET A.DEAL_NUM = A.DEAL_NUM + v_curr_rec_num
           WHERE A.PART_NO = cur_sw_order.Part_No
             AND A.DEPOT_NO = cur_sw_order.Depot_No;
        
          v_diff_num := v_diff_num - v_curr_rec_num;
        
          COMMIT;
        ELSE
          --跳出循环
          EXIT;
        END IF;
      
      END LOOP;
    END LOOP;
  
    --找出所有手工收货比系统收货多的数据
    FOR cur_jit_rec IN (SELECT C.DEPOT_NO,
                               C.SUP,
                               C.PART_NO,
                               NVL(C.SH_NUM, 0) - NVL(C.DEAL_NUM, 0) DIFF_NUM
                          FROM test_wxl_af_sh C
                         WHERE NVL(C.SH_NUM, 0) - NVL(C.DEAL_NUM, 0) > 0
                           AND C.DEPOT_NO IS NOT NULL) LOOP
      v_diff_num := cur_jit_rec.DIFF_NUM;
    
      --查询仓库对应的收货时间
      BEGIN
        SELECT DISTINCT DECODE(A.WORK_CENTER,
                               'W1',
                               v_w1_first_time,
                               'A1',
                               v_a1_first_time,
                               'T1',
                               v_t1_first_time) - 1
          INTO v_receive_time
          FROM MM_INV_UNLOAD A
         WHERE A.WARE_CODE = cur_jit_rec.DEPOT_NO;
      EXCEPTION
        WHEN OTHERS THEN
          v_receive_time := v_w1_first_time;
      END;
    
      --找出所有拉动订单中未收齐的订单零件号和仓库代码和上面一致的数据
      FOR cur_jit_order IN (SELECT A.ORDER_NO,
                                   A.SUPPLIER_NO,
                                   B.ORDER_ROWNO,
                                   A.ARR_DEPOT,
                                   A.ARRIVE_TIME,
                                   B.REQUIRE_NUM,
                                   B.ARRIVE_NUM,
                                   A.ARRIVE_PRODUCT_SEQNO,
                                   NVL(B.REQUIRE_NUM, 0) -
                                   NVL(B.ARRIVE_NUM, 0) NOT_ARRIVE_NUM,
                                   NVL(A.ARRIVE_COUNT, 0) RECEIVE_COUNT,
                                   NVL(B.ARRIVE_COUNT, 0) PART_REC_TIMES,
                                   B.PART_NO
                              FROM MM_JIT_ORDER A
                              LEFT JOIN Mm_Jit_Order_Detail B
                                ON A.ORDER_NO = B.ORDER_NO
                             WHERE B.PART_NO = cur_jit_rec.PART_NO
                               AND A.ARR_DEPOT = cur_jit_rec.DEPOT_NO
                               AND A.CREATION_TIME < SYSDATE - 20
                               AND NVL(B.ARRIVE_NUM, 0) <
                                   NVL(B.REQUIRE_NUM, 0)
                             ORDER BY A.Creation_Time,
                                      A.Arrive_Product_Seqno) LOOP
      
        IF v_diff_num > 0 THEN
          --判断这个订单未收货的数量是否大于差异数量
          IF cur_jit_order.NOT_ARRIVE_NUM < v_diff_num THEN
            v_curr_rec_num := cur_jit_order.NOT_ARRIVE_NUM;
          
          ELSE
            v_curr_rec_num := v_diff_num;
          END IF;
        
          SELECT COUNT(1)
            INTO v_count
            FROM TEST_MM_INV_IN H
           WHERE H.REC_NO = cur_JIT_order.Order_No || '_' ||
                 (cur_jit_order.RECEIVE_COUNT + 1);
          IF v_count <= 0 THEN
            --写入收货明细表
            INSERT INTO TEST_MM_INV_IN
              (REC_NO,
               FACTORY_CODE,
               ORDER_NO,
               REC_TIMES,
               DEPOT_NO,
               ORDER_TYPE,
               INV_TIME,
               CREATION_USER,
               CREATION_TIME,
               NOTE,
               ACTUAL_ARR_PRO_SEQNO)
            VALUES
              (cur_jit_order.Order_No || '_' ||
               (cur_jit_order.RECEIVE_COUNT + 1),
               '2000',
               cur_jit_order.Order_No,
               cur_jit_order.RECEIVE_COUNT + 1,
               cur_jit_order.ARR_DEPOT,
               'JIT',
               SYSDATE,
               'SYSTEM',
               v_receive_time,
               '手工录入',
               cur_jit_order.Arrive_Product_Seqno);
          END IF;
          INSERT INTO TEST_MM_INV_IN_DETAIL
            (REC_NO,
             ROW_NO,
             REC_TIMES,
             PART_NO,
             ORDER_QTY,
             REC_QTY,
             CREATION_TIME)
          VALUES
            (cur_jit_order.Order_No || '_' ||
             (cur_jit_order.RECEIVE_COUNT + 1),
             cur_jit_order.order_rowno,
             cur_jit_order.Part_Rec_Times + 1,
             cur_jit_order.PART_NO,
             cur_jit_order.REQUIRE_NUM,
             v_curr_rec_num,
             v_receive_time);
        
          UPDATE test_wxl_af_sh A
             SET A.DEAL_NUM = A.DEAL_NUM + v_curr_rec_num
           WHERE A.PART_NO = cur_jit_order.Part_No
             AND A.DEPOT_NO = cur_jit_order.Arr_Depot;
        
          COMMIT;
        
          v_diff_num := v_diff_num - v_curr_rec_num;
        ELSE
          --跳出循环
          EXIT;
        END IF;
      
      END LOOP;
    END LOOP;
  
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        ERROR_TAG     := 1;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'TEST',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '仓库主数据写入业务表');
        COMMIT;
      
        ROLLBACK;
      END;
  END TEST;

  --***************************************************************************
  --存储过程名：USP_PUB_WAREHOUSE
  --功能描述: 仓库主数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST_EXC(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2) AS
    v_diff_num number(10);
  
    v_a1_first_time date;
    v_w1_first_time date;
    v_t1_first_time date;
  
    v_receive_time date;
    v_curr_rec_num NUMBER;
    v_count        number;
  BEGIN
    --查询每个车间的最早下线时间
    SELECT MIN(A.PASS_TIME)
      INTO v_a1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'AF-OFF';
  
    SELECT MIN(A.PASS_TIME)
      INTO v_w1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'WE-OFF';
  
    SELECT MIN(A.PASS_TIME)
      INTO v_t1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'PA-OFF';
  
    --找出所有手工收货比系统收货多的数据
    FOR cur_rec IN (SELECT C.DEPOT_NO,
                           C.SUP,
                           C.PART_NO,
                           NVL(C.SH_NUM, 0),
                           NVL(C.DEAL_NUM, 0),
                           NVL(F.REC_QTY, 0),
                           NVL(C.SH_NUM, 0) - NVL(C.DEAL_NUM, 0) -
                           NVL(F.REC_QTY, 0) DIFF_NUM
                      FROM test_wxl_af_exp C
                      LEFT JOIN (SELECT D.DEPOT_NO,
                                       E.PART_NO,
                                       SUM(E.REC_QTY) REC_QTY
                                  FROM MM_INV_IN D
                                  LEFT JOIN Mm_Inv_In_Detail E
                                    ON D.REC_NO = E.REC_NO
                                  LEFT JOIN MM_SW_ORDER NN
                                    ON D.ORDER_NO = NN.ORDER_NO
                                 WHERE NN.ORDER_TYPE = '02'
                                 GROUP BY D.DEPOT_NO, E.PART_NO) F
                        ON C.DEPOT_NO = F.DEPOT_NO
                       AND C.PART_NO = F.PART_NO
                     WHERE NVL(C.SH_NUM, 0) - NVL(C.DEAL_NUM, 0) >
                           NVL(F.REC_QTY, 0)
                       AND C.DEPOT_NO IS NOT NULL) LOOP
      v_diff_num := cur_rec.DIFF_NUM;
    
      --查询仓库对应的收货时间
      BEGIN
        SELECT DISTINCT DECODE(A.WORK_CENTER,
                               'W1',
                               v_w1_first_time,
                               'A1',
                               v_a1_first_time,
                               'T1',
                               v_t1_first_time) - 1
          INTO v_receive_time
          FROM MM_INV_UNLOAD A
         WHERE A.WARE_CODE = cur_rec.DEPOT_NO;
      EXCEPTION
        WHEN OTHERS THEN
          v_receive_time := v_w1_first_time;
      END;
    
      --找出所有取货订单中未收齐的订单零件号和仓库代码和上面一致的数据
      FOR cur_sw_order IN (SELECT A.ORDER_NO,
                                  A.FACTORY_CODE,
                                  A.SUPPLIER_NO,
                                  B.ORDER_ROWNO,
                                  A.DEPOT_NO,
                                  A.ARRIVE_DATE,
                                  B.ORDER_QTY,
                                  B.CANCEL_NUM,
                                  B.ARRIVE_NUM,
                                  NVL(B.ORDER_QTY, 0) - NVL(B.ARRIVE_NUM, 0) NOT_ARRIVE_NUM,
                                  NVL(B.RECEIVE_COUNT, 0) RECEIVE_COUNT,
                                  NVL(B.RECEIVE_COUNT, 0) PART_REC_TIMES,
                                  B.PART_NO
                             FROM MM_SW_ORDER A
                             LEFT JOIN MM_SW_ORDER_DETAIL B
                               ON A.ORDER_NO = B.ORDER_NO
                            WHERE A.ORDER_TYPE = '02'
                              AND B.PART_NO = cur_rec.PART_NO
                              AND A.DEPOT_NO = cur_rec.DEPOT_NO
                              AND NVL(B.ARRIVE_NUM, 0) < NVL(B.ORDER_QTY, 0)
                            ORDER BY A.ARRIVE_DATE) LOOP
      
        IF v_diff_num > 0 THEN
          --判断这个订单未收货的数量是否大于差异数量
          IF cur_sw_order.NOT_ARRIVE_NUM < v_diff_num THEN
            v_curr_rec_num := cur_sw_order.NOT_ARRIVE_NUM;
          
          ELSE
            v_curr_rec_num := v_diff_num;
          END IF;
          SELECT COUNT(1)
            INTO v_count
            FROM TEST_MM_INV_IN H
           WHERE H.REC_NO = cur_sw_order.Order_No || '_' ||
                 (cur_sw_order.RECEIVE_COUNT + 1);
          IF v_count <= 0 THEN
          
            --写入收货明细表
            INSERT INTO TEST_MM_INV_IN
              (REC_NO,
               FACTORY_CODE,
               ORDER_NO,
               REC_TIMES,
               DEPOT_NO,
               ORDER_TYPE,
               INV_TIME,
               CREATION_USER,
               CREATION_TIME,
               NOTE)
            VALUES
              (cur_sw_order.Order_No || '_' ||
               (cur_sw_order.RECEIVE_COUNT + 1),
               cur_sw_order.Factory_Code,
               cur_sw_order.Order_No,
               cur_sw_order.RECEIVE_COUNT + 1,
               cur_sw_order.Depot_No,
               'SW',
               SYSDATE,
               'SYSTEM',
               v_receive_time,
               '手工录入');
          END IF;
        
          INSERT INTO TEST_MM_INV_IN_DETAIL
            (REC_NO,
             ROW_NO,
             REC_TIMES,
             PART_NO,
             ORDER_QTY,
             REC_QTY,
             CREATION_TIME)
          VALUES
            (cur_sw_order.Order_No || '_' ||
             (cur_sw_order.RECEIVE_COUNT + 1),
             cur_sw_order.order_rowno,
             cur_sw_order.Part_Rec_Times + 1,
             cur_sw_order.PART_NO,
             cur_sw_order.Order_Qty,
             v_curr_rec_num,
             v_receive_time);
        
          UPDATE test_wxl_af_exp A
             SET A.DEAL_NUM = A.DEAL_NUM + v_curr_rec_num
           WHERE A.PART_NO = cur_sw_order.Part_No
             AND A.DEPOT_NO = cur_sw_order.Depot_No;
        
          v_diff_num := v_diff_num - v_curr_rec_num;
        
          COMMIT;
        ELSE
          --跳出循环
          EXIT;
        END IF;
      
      END LOOP;
    
    END LOOP;
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        ERROR_TAG     := 1;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_WAREHOUSE',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '仓库主数据写入业务表');
        COMMIT;
      
        ROLLBACK;
      END;
  END TEST_EXC;

  --***************************************************************************
  --存储过程名：USP_PUB_WAREHOUSE
  --功能描述: 仓库主数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST_EXC_WE(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2) AS
    v_diff_num number(10);
  
    v_a1_first_time date;
    v_w1_first_time date;
    v_t1_first_time date;
  
    v_receive_time date;
    v_curr_rec_num NUMBER;
    v_count        number;
  BEGIN
    --查询每个车间的最早下线时间
    SELECT MIN(A.PASS_TIME)
      INTO v_a1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'AF-OFF';
  
    SELECT MIN(A.PASS_TIME)
      INTO v_w1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'WE-OFF';
  
    SELECT MIN(A.PASS_TIME)
      INTO v_t1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'PA-OFF';
  
    --找出所有手工收货比系统收货多的数据
    FOR cur_rec IN (SELECT C.DEPOT_NO,
                           C.SUP,
                           C.PART_NO,
                           NVL(C.SH_NUM, 0),
                           NVL(C.DEAL_NUM, 0),
                           NVL(F.REC_QTY, 0),
                           NVL(C.SH_NUM, 0) - NVL(C.DEAL_NUM, 0) -
                           NVL(F.REC_QTY, 0) DIFF_NUM
                      FROM test_wxl_we_exp C
                      LEFT JOIN (SELECT D.DEPOT_NO,
                                       E.PART_NO,
                                       SUM(E.REC_QTY) REC_QTY
                                  FROM MM_INV_IN D
                                  LEFT JOIN Mm_Inv_In_Detail E
                                    ON D.REC_NO = E.REC_NO
                                  LEFT JOIN MM_SW_ORDER NN
                                    ON D.ORDER_NO = NN.ORDER_NO
                                 WHERE NN.ORDER_TYPE = '02'
                                 GROUP BY D.DEPOT_NO, E.PART_NO) F
                        ON C.DEPOT_NO = F.DEPOT_NO
                       AND C.PART_NO = F.PART_NO
                     WHERE NVL(C.SH_NUM, 0) - NVL(C.DEAL_NUM, 0) >
                           NVL(F.REC_QTY, 0)
                       AND C.DEPOT_NO IS NOT NULL) LOOP
      v_diff_num := cur_rec.DIFF_NUM;
    
      --查询仓库对应的收货时间
      BEGIN
        SELECT DISTINCT DECODE(A.WORK_CENTER,
                               'W1',
                               v_w1_first_time,
                               'A1',
                               v_a1_first_time,
                               'T1',
                               v_t1_first_time) - 1
          INTO v_receive_time
          FROM MM_INV_UNLOAD A
         WHERE A.WARE_CODE = cur_rec.DEPOT_NO;
      EXCEPTION
        WHEN OTHERS THEN
          v_receive_time := v_w1_first_time;
      END;
    
      --找出所有取货订单中未收齐的订单零件号和仓库代码和上面一致的数据
      FOR cur_sw_order IN (SELECT A.ORDER_NO,
                                  A.FACTORY_CODE,
                                  A.SUPPLIER_NO,
                                  B.ORDER_ROWNO,
                                  A.DEPOT_NO,
                                  A.ARRIVE_DATE,
                                  B.ORDER_QTY,
                                  B.CANCEL_NUM,
                                  B.ARRIVE_NUM,
                                  NVL(B.ORDER_QTY, 0) - NVL(B.ARRIVE_NUM, 0) NOT_ARRIVE_NUM,
                                  NVL(B.RECEIVE_COUNT, 0) RECEIVE_COUNT,
                                  NVL(B.RECEIVE_COUNT, 0) PART_REC_TIMES,
                                  B.PART_NO
                             FROM MM_SW_ORDER A
                             LEFT JOIN MM_SW_ORDER_DETAIL B
                               ON A.ORDER_NO = B.ORDER_NO
                            WHERE A.ORDER_TYPE = '02'
                              AND B.PART_NO = cur_rec.PART_NO
                              AND A.DEPOT_NO = cur_rec.DEPOT_NO
                              AND NVL(B.ARRIVE_NUM, 0) < NVL(B.ORDER_QTY, 0)
                            ORDER BY A.ARRIVE_DATE) LOOP
      
        IF v_diff_num > 0 THEN
          --判断这个订单未收货的数量是否大于差异数量
          IF cur_sw_order.NOT_ARRIVE_NUM < v_diff_num THEN
            v_curr_rec_num := cur_sw_order.NOT_ARRIVE_NUM;
          
          ELSE
            v_curr_rec_num := v_diff_num;
          END IF;
          SELECT COUNT(1)
            INTO v_count
            FROM TEST_MM_INV_IN H
           WHERE H.REC_NO = cur_sw_order.Order_No || '_' ||
                 (cur_sw_order.RECEIVE_COUNT + 1);
          IF v_count <= 0 THEN
          
            --写入收货明细表
            INSERT INTO TEST_MM_INV_IN
              (REC_NO,
               FACTORY_CODE,
               ORDER_NO,
               REC_TIMES,
               DEPOT_NO,
               ORDER_TYPE,
               INV_TIME,
               CREATION_USER,
               CREATION_TIME,
               NOTE)
            VALUES
              (cur_sw_order.Order_No || '_' ||
               (cur_sw_order.RECEIVE_COUNT + 1),
               cur_sw_order.Factory_Code,
               cur_sw_order.Order_No,
               cur_sw_order.RECEIVE_COUNT + 1,
               cur_sw_order.Depot_No,
               'SW',
               SYSDATE,
               'SYSTEM',
               v_receive_time,
               '手工录入');
          END IF;
        
          INSERT INTO TEST_MM_INV_IN_DETAIL
            (REC_NO,
             ROW_NO,
             REC_TIMES,
             PART_NO,
             ORDER_QTY,
             REC_QTY,
             CREATION_TIME)
          VALUES
            (cur_sw_order.Order_No || '_' ||
             (cur_sw_order.RECEIVE_COUNT + 1),
             cur_sw_order.order_rowno,
             cur_sw_order.Part_Rec_Times + 1,
             cur_sw_order.PART_NO,
             cur_sw_order.Order_Qty,
             v_curr_rec_num,
             v_receive_time);
        
          UPDATE test_wxl_we_exp A
             SET A.DEAL_NUM = A.DEAL_NUM + v_curr_rec_num
           WHERE A.PART_NO = cur_sw_order.Part_No
             AND A.DEPOT_NO = cur_sw_order.Depot_No;
        
          v_diff_num := v_diff_num - v_curr_rec_num;
        
          COMMIT;
        ELSE
          --跳出循环
          EXIT;
        END IF;
      
      END LOOP;
    
    END LOOP;
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        ERROR_TAG     := 1;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_WAREHOUSE',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '仓库主数据写入业务表');
        COMMIT;
      
        ROLLBACK;
      END;
  END TEST_EXC_WE;

  --***************************************************************************
  --存储过程名：USP_PUB_WAREHOUSE
  --功能描述: 仓库主数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST_WE(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2) AS
    v_diff_num number(10);
  
    v_a1_first_time date;
    v_w1_first_time date;
    v_t1_first_time date;
  
    v_receive_time date;
    v_curr_rec_num NUMBER;
    v_count        number;
  BEGIN
    --查询每个车间的最早下线时间
    SELECT MIN(A.PASS_TIME)
      INTO v_a1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'AF-OFF';
  
    SELECT MIN(A.PASS_TIME)
      INTO v_w1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'WE-OFF';
  
    SELECT MIN(A.PASS_TIME)
      INTO v_t1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'PA-OFF';
  
    --找出所有手工收货比系统收货多的数据
    FOR cur_rec IN (SELECT C.DEPOT_NO,
                           C.SUP,
                           C.PART_NO,
                           NVL(C.SH_NUM, 0) - NVL(C.DEAL_NUM, 0) -
                           NVL(F.REC_QTY, 0) DIFF_NUM
                      FROM test_wxl_WE_sh C
                      LEFT JOIN (SELECT D.DEPOT_NO,
                                       E.PART_NO,
                                       SUM(E.REC_QTY) REC_QTY
                                  FROM MM_INV_IN D
                                  LEFT JOIN Mm_Inv_In_Detail E
                                    ON D.REC_NO = E.REC_NO
                                  LEFT JOIN MM_SW_ORDER NN
                                    ON D.ORDER_NO = NN.ORDER_NO
                                 WHERE NN.ORDER_TYPE = '01'
                                 GROUP BY D.DEPOT_NO, E.PART_NO) F
                        ON C.DEPOT_NO = F.DEPOT_NO
                       AND C.PART_NO = F.PART_NO
                     WHERE NVL(C.SH_NUM, 0) - NVL(C.DEAL_NUM, 0) >
                           NVL(F.REC_QTY, 0)
                       AND C.DEPOT_NO IS NOT NULL) LOOP
      v_diff_num := cur_rec.DIFF_NUM;
    
      --查询仓库对应的收货时间
      BEGIN
        SELECT DISTINCT DECODE(A.WORK_CENTER,
                               'W1',
                               v_w1_first_time,
                               'A1',
                               v_a1_first_time,
                               'T1',
                               v_t1_first_time) - 1
          INTO v_receive_time
          FROM MM_INV_UNLOAD A
         WHERE A.WARE_CODE = cur_rec.DEPOT_NO;
      EXCEPTION
        WHEN OTHERS THEN
          v_receive_time := v_w1_first_time;
      END;
    
      --找出所有取货订单中未收齐的订单零件号和仓库代码和上面一致的数据
      FOR cur_sw_order IN (SELECT A.ORDER_NO,
                                  A.FACTORY_CODE,
                                  A.SUPPLIER_NO,
                                  B.ORDER_ROWNO,
                                  A.DEPOT_NO,
                                  A.ARRIVE_DATE,
                                  B.ORDER_QTY,
                                  B.CANCEL_NUM,
                                  B.ARRIVE_NUM,
                                  B.ORDER_QTY - B.ARRIVE_NUM NOT_ARRIVE_NUM,
                                  NVL(B.RECEIVE_COUNT, 0) RECEIVE_COUNT,
                                  NVL(B.RECEIVE_COUNT, 0) PART_REC_TIMES,
                                  B.PART_NO
                             FROM MM_SW_ORDER A
                             LEFT JOIN MM_SW_ORDER_DETAIL B
                               ON A.ORDER_NO = B.ORDER_NO
                            WHERE A.ORDER_TYPE = '01'
                              AND B.PART_NO = cur_rec.PART_NO
                              AND A.DEPOT_NO = cur_rec.DEPOT_NO
                              AND TO_CHAR(A.CREATION_TIME, 'YYYY-MM-DD') =
                                  '2019-03-26'
                              AND NVL(B.ARRIVE_NUM, 0) < NVL(B.ORDER_QTY, 0)
                            ORDER BY A.ARRIVE_DATE) LOOP
      
        IF v_diff_num > 0 THEN
          --判断这个订单未收货的数量是否大于差异数量
          IF cur_sw_order.NOT_ARRIVE_NUM < v_diff_num THEN
            v_curr_rec_num := cur_sw_order.NOT_ARRIVE_NUM;
          
          ELSE
            v_curr_rec_num := v_diff_num;
          END IF;
          SELECT COUNT(1)
            INTO v_count
            FROM TEST_MM_INV_IN H
           WHERE H.REC_NO = cur_sw_order.Order_No || '_' ||
                 (cur_sw_order.RECEIVE_COUNT + 1);
          IF v_count <= 0 THEN
          
            --写入收货明细表
            INSERT INTO TEST_MM_INV_IN
              (REC_NO,
               FACTORY_CODE,
               ORDER_NO,
               REC_TIMES,
               DEPOT_NO,
               ORDER_TYPE,
               INV_TIME,
               CREATION_USER,
               CREATION_TIME,
               NOTE)
            VALUES
              (cur_sw_order.Order_No || '_' ||
               (cur_sw_order.RECEIVE_COUNT + 1),
               cur_sw_order.Factory_Code,
               cur_sw_order.Order_No,
               cur_sw_order.RECEIVE_COUNT + 1,
               cur_sw_order.Depot_No,
               'SW',
               SYSDATE,
               'SYSTEM',
               v_receive_time,
               '手工录入');
          END IF;
        
          INSERT INTO TEST_MM_INV_IN_DETAIL
            (REC_NO,
             ROW_NO,
             REC_TIMES,
             PART_NO,
             ORDER_QTY,
             REC_QTY,
             CREATION_TIME)
          VALUES
            (cur_sw_order.Order_No || '_' ||
             (cur_sw_order.RECEIVE_COUNT + 1),
             cur_sw_order.order_rowno,
             cur_sw_order.Part_Rec_Times + 1,
             cur_sw_order.PART_NO,
             cur_sw_order.Order_Qty,
             v_curr_rec_num,
             v_receive_time);
        
          UPDATE test_wxl_we_sh A
             SET A.DEAL_NUM = A.DEAL_NUM + v_curr_rec_num
           WHERE A.PART_NO = cur_sw_order.Part_No
             AND A.DEPOT_NO = cur_sw_order.Depot_No;
        
          v_diff_num := v_diff_num - v_curr_rec_num;
        ELSE
          --跳出循环
          EXIT;
        END IF;
      
      END LOOP;
    
      --找出所有拉动订单中未收齐的订单零件号和仓库代码和上面一致的数据
      FOR cur_jit_order IN (SELECT A.ORDER_NO,
                                   A.SUPPLIER_NO,
                                   B.ORDER_ROWNO,
                                   A.ARR_DEPOT,
                                   A.ARRIVE_TIME,
                                   B.REQUIRE_NUM,
                                   B.ARRIVE_NUM,
                                   A.ARRIVE_PRODUCT_SEQNO,
                                   B.REQUIRE_NUM - B.ARRIVE_NUM NOT_ARRIVE_NUM,
                                   NVL(A.ARRIVE_COUNT, 0) RECEIVE_COUNT,
                                   NVL(B.ARRIVE_COUNT, 0) PART_REC_TIMES,
                                   B.PART_NO
                              FROM MM_JIT_ORDER A
                              LEFT JOIN Mm_Jit_Order_Detail B
                                ON A.ORDER_NO = B.ORDER_NO
                             WHERE B.PART_NO = cur_rec.PART_NO
                               AND A.ARR_DEPOT = cur_rec.DEPOT_NO
                               AND A.CREATION_TIME < SYSDATE - 10
                               AND NVL(B.ARRIVE_NUM, 0) <
                                   NVL(B.REQUIRE_NUM, 0)
                             ORDER BY A.ARRIVE_TIME) LOOP
      
        IF v_diff_num > 0 THEN
          --判断这个订单未收货的数量是否大于差异数量
          IF cur_jit_order.NOT_ARRIVE_NUM < v_diff_num THEN
            v_curr_rec_num := cur_jit_order.NOT_ARRIVE_NUM;
          
          ELSE
            v_curr_rec_num := v_diff_num;
          END IF;
        
          SELECT COUNT(1)
            INTO v_count
            FROM TEST_MM_INV_IN H
           WHERE H.REC_NO = cur_JIT_order.Order_No || '_' ||
                 (cur_jit_order.RECEIVE_COUNT + 1);
          IF v_count <= 0 THEN
            --写入收货明细表
            INSERT INTO TEST_MM_INV_IN
              (REC_NO,
               FACTORY_CODE,
               ORDER_NO,
               REC_TIMES,
               DEPOT_NO,
               ORDER_TYPE,
               INV_TIME,
               CREATION_USER,
               CREATION_TIME,
               NOTE,
               ACTUAL_ARR_PRO_SEQNO)
            VALUES
              (cur_jit_order.Order_No || '_' ||
               (cur_jit_order.RECEIVE_COUNT + 1),
               '2000',
               cur_jit_order.Order_No,
               cur_jit_order.RECEIVE_COUNT + 1,
               cur_jit_order.ARR_DEPOT,
               'JIT',
               SYSDATE,
               'SYSTEM',
               v_receive_time,
               '手工录入',
               cur_jit_order.Arrive_Product_Seqno);
          END IF;
          INSERT INTO TEST_MM_INV_IN_DETAIL
            (REC_NO,
             ROW_NO,
             REC_TIMES,
             PART_NO,
             ORDER_QTY,
             REC_QTY,
             CREATION_TIME)
          VALUES
            (cur_jit_order.Order_No || '_' ||
             (cur_jit_order.RECEIVE_COUNT + 1),
             cur_jit_order.order_rowno,
             cur_jit_order.Part_Rec_Times + 1,
             cur_jit_order.PART_NO,
             cur_jit_order.REQUIRE_NUM,
             v_curr_rec_num,
             v_receive_time);
        
          UPDATE test_wxl_we_sh A
             SET A.DEAL_NUM = A.DEAL_NUM + v_curr_rec_num
           WHERE A.PART_NO = cur_jit_order.Part_No
             AND A.DEPOT_NO = cur_jit_order.Arr_Depot;
        
          v_diff_num := v_diff_num - v_curr_rec_num;
        ELSE
          --跳出循环
          EXIT;
        END IF;
      
      END LOOP;
    
    END LOOP;
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        ERROR_TAG     := 1;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_WAREHOUSE',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '仓库主数据写入业务表');
        COMMIT;
      
        ROLLBACK;
      END;
  END TEST_WE;

  --***************************************************************************
  --存储过程名：USP_PUB_WAREHOUSE
  --功能描述: 仓库主数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST_DEAL_RECEIVE_LOG(ERROR_TAG     OUT NUMBER,
                                  ERROR_MESSAGE OUT VARCHAR2) AS
    v_diff_num number(10);
  
    v_a1_first_time date;
    v_w1_first_time date;
    v_t1_first_time date;
  
    v_receive_time date;
    v_curr_rec_num NUMBER;
    v_count        number;
  
    v_status number;
  BEGIN
  
    FOR cur_rec IN (SELECT * FROM TEST_MM_INV_IN A ORDER BY A.CREATION_TIME) LOOP
      /* --判断订单类型，如果为循环取货
      IF cur_rec.Order_Type = 'SW' THEN
        FOR cur_rec_detail IN (SELECT *
                                 FROM TEST_MM_INV_IN_DETAIL B
                                WHERE B.REC_NO = cur_rec.Rec_No) LOOP
        
          UPDATE MM_SW_ORDER_DETAIL C
             SET C.ARRIVE_NUM     = NVL(C.ARRIVE_NUM, 0) +
                                    cur_rec_detail.Rec_Qty,
                 C.RECEIVE_COUNT  = cur_rec_detail.Rec_Times,
                 C.RECEIVE_DATE   = cur_rec_detail.creation_time,
                 C.RECEIVE_STATUS = CASE
                                      WHEN NVL(C.ORDER_QTY, 0) -
                                           NVL(C.CANCEL_NUM, 0) <=
                                           NVL(C.ARRIVE_NUM, 0) +
                                           NVL(cur_rec_detail.Rec_Qty, 0) THEN
                                       2
                                      WHEN NVL(C.ARRIVE_NUM, 0) +
                                           NVL(cur_rec_detail.Rec_Qty, 0) > 0 THEN
                                       1
                                      ELSE
                                       0
                                    END
           WHERE C.PURCHASE_NO = cur_rec.Order_No
             AND C.PURCHASE_ROWNO = cur_rec_detail.row_no;
        
        END LOOP;
      
        SELECT CASE
                 WHEN SUM(shStatus) / COUNT(*) < 1 THEN
                  CEIL(SUM(shStatus) / COUNT(*))
                 ELSE
                  FLOOR(SUM(shStatus) / COUNT(*))
               END shStatus
          INTO v_status
          FROM (SELECT CASE
                         WHEN NVL(C.ARRIVE_NUM, 0) = 0 AND
                              NVL(C.ORDER_QTY, 0) > 0 THEN
                          0
                         WHEN NVL(C.ARRIVE_NUM, 0) >= NVL(C.ORDER_QTY, 0) THEN
                          2
                         ELSE
                          1
                       END shStatus
                  FROM MM_SW_ORDER_DETAIL C
                 WHERE C.ORDER_NO = cur_rec.order_no);
      
        UPDATE MM_SW_ORDER A
           SET A.RECEIVE_DATE   = cur_rec.Creation_Time,
               A.RECEIVE_COUNT  = cur_rec.Rec_Times,
               A.RECEIVE_STATUS = v_status
         WHERE A.ORDER_NO = cur_rec.Order_No;
      
        --如果为拉动
      ELSIF cur_rec.Order_Type = 'JIT' THEN
      
        FOR cur_rec_detail IN (SELECT *
                                 FROM TEST_MM_INV_IN_DETAIL B
                                WHERE B.REC_NO = cur_rec.Rec_No) LOOP
        
          UPDATE MM_JIT_ORDER_DETAIL C
             SET C.ARRIVE_NUM               = NVL(C.ARRIVE_NUM, 0) +
                                              cur_rec_detail.Rec_Qty,
                 C.ARRIVE_COUNT             = cur_rec_detail.Rec_Times,
                 C.ACTUAL_ARR_PRODUCT_SEQNO = cur_rec.Actual_Arr_Pro_Seqno,
                 C.ARRIVE_STATUS = CASE
                                     WHEN NVL(C.REQUIRE_NUM, 0) <
                                          NVL(C.ARRIVE_NUM, 0) +
                                          NVL(cur_rec_detail.Rec_Qty, 0) THEN
                                      2
                                     WHEN NVL(C.ARRIVE_NUM, 0) +
                                          NVL(cur_rec_detail.Rec_Qty, 0) > 0 THEN
                                      1
                                     ELSE
                                      0
                                   END
           WHERE C.ORDER_NO = cur_rec.Order_No
             AND C.ORDER_ROWNO = cur_rec_detail.row_no;
        
        END LOOP;
      
        SELECT CASE
                 WHEN SUM(shStatus) / COUNT(*) < 1 THEN
                  CEIL(SUM(shStatus) / COUNT(*))
                 ELSE
                  FLOOR(SUM(shStatus) / COUNT(*))
               END shStatus
          INTO v_status
          FROM (SELECT CASE
                         WHEN NVL(C.ARRIVE_NUM, 0) = 0 AND
                              NVL(C.REQUIRE_NUM, 0) > 0 THEN
                          0
                         WHEN NVL(C.ARRIVE_NUM, 0) >= NVL(C.REQUIRE_NUM, 0) THEN
                          2
                         ELSE
                          1
                       END shStatus
                  FROM MM_JIT_ORDER_DETAIL C
                 WHERE C.ORDER_NO = cur_rec.order_no);
      
        UPDATE Mm_Jit_Order A
           SET A.RECEIVE_DATE             = cur_rec.Creation_Time,
               A.ARRIVE_COUNT             = cur_rec.Rec_Times,
               A.ARRIVE_STATUS            = v_status,
               A.ACTUAL_ARR_PRODUCT_SEQNO = cur_rec.Actual_Arr_Pro_Seqno
         WHERE A.ORDER_NO = cur_rec.Order_No;
      */
      --如果为同步
      IF cur_rec.Order_Type = 'JISO' THEN
      
        FOR cur_rec_detail IN (SELECT *
                                 FROM TEST_MM_INV_IN_DETAIL B
                                WHERE B.REC_NO = cur_rec.Rec_No) LOOP
        
          UPDATE MM_JISO_ORDER_DETAIL C
             SET C.Arrive_Num               = NVL(C.ARRIVE_NUM, 0) +
                                              cur_rec_detail.Rec_Qty,
                 C.ARRIVE_COUNT             = cur_rec_detail.Rec_Times,
                 C.ACTUAL_ARR_PRODUCT_SEQNO = cur_rec.Actual_Arr_Pro_Seqno,
                 C.ARRIVE_STATUS = CASE
                                     WHEN NVL(C.REQUIRE_NUM, 0) <
                                          NVL(C.ARRIVE_NUM, 0) +
                                          NVL(cur_rec_detail.Rec_Qty, 0) THEN
                                      2
                                     WHEN NVL(C.ARRIVE_NUM, 0) +
                                          NVL(cur_rec_detail.Rec_Qty, 0) > 0 THEN
                                      1
                                     ELSE
                                      0
                                   END
           WHERE C.ORDER_NO = cur_rec.Order_No
             AND C.ORDER_ROWNO = cur_rec_detail.row_no;
        
        END LOOP;
      
        SELECT CASE
                 WHEN SUM(shStatus) / COUNT(*) < 1 THEN
                  CEIL(SUM(shStatus) / COUNT(*))
                 ELSE
                  FLOOR(SUM(shStatus) / COUNT(*))
               END shStatus
          INTO v_status
          FROM (SELECT CASE
                         WHEN NVL(C.ARRIVE_NUM, 0) = 0 AND
                              NVL(C.REQUIRE_NUM, 0) > 0 THEN
                          0
                         WHEN NVL(C.ARRIVE_NUM, 0) >= NVL(C.REQUIRE_NUM, 0) THEN
                          2
                         ELSE
                          1
                       END shStatus
                  FROM MM_JISO_ORDER_DETAIL C
                 WHERE C.ORDER_NO = cur_rec.order_no);
      
        UPDATE MM_JISO_ORDER A
           SET A.RECEIVE_DATE             = cur_rec.Creation_Time,
               A.ARRIVE_COUNT             = cur_rec.Rec_Times,
               A.ARRIVE_STATUS            = v_status,
               A.ACTUAL_ARR_PRODUCT_SEQNO = cur_rec.Actual_Arr_Pro_Seqno
         WHERE A.ORDER_NO = cur_rec.Order_No;
      
      END IF;
    
    END LOOP;
  
    INSERT INTO MM_INV_IN
      SELECT * FROM TEST_MM_INV_IN;
    INSERT INTO MM_INV_IN_DETAIL
      SELECT * FROM TEST_MM_INV_IN_DETAIL;
  
    COMMIT;
  
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        ROLLBACK;
        ERROR_TAG     := 1;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_WAREHOUSE',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '仓库主数据写入业务表');
        COMMIT;
      
      END;
  END TEST_DEAL_RECEIVE_LOG;

  --***************************************************************************
  --存储过程名：USP_PUB_WAREHOUSE
  --功能描述: 仓库主数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST_JISO(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2) AS
    v_diff_num number(10);
  
    v_receive_time date;
    v_curr_rec_num NUMBER;
    v_count        number;
  BEGIN
  
    --找出所有手工收货比系统收货多的数据
    FOR cur_rec IN (
                    /*      SELECT C.DEPOT_NO,
                                                                                                           C.PART_NO,
                                                                                                           T.SUPPLIER_NO,
                                                                                                           NVL(C.SH_NUM, 0) SH_NUM,
                                                                                                           NVL(F.REC_QTY, 0) REC_QTY
                                                                                                      FROM (SELECT 'AW11' DEPOT_NO,
                                                                                                                   B.PART_NO,
                                                                                                                   NVL(SUM(B.NUM), 0) SH_NUM
                                                                                                              FROM MM_PUB_VEH_PASS A, MM_PUB_ORDER_BOM B
                                                                                                             WHERE A.STATION_CODE = 'AF-OFF'
                                                                                                               AND A.FACTORY_CODE = B.FACTORY_CODE
                                                                                                               AND A.ERP_ORDER_NO = B.ORDER_NO
                                                                                                               AND B.WORKCENTER = 'A1'
                                                                                                               AND A.PASS_TIME >
                                                                                                                   TO_DATE('2019-04-28 21:26:47',
                                                                                                                           'yyyy-mm-dd hh24:mi:ss')
                                                                                                               AND A.CREATION_TIME >
                                                                                                                   TO_DATE('2019-04-28 21:30:56',
                                                                                                                           'yyyy-mm-dd hh24:mi:ss')
                                                                                                               AND A.PASS_TIME <
                                                                                                                   TO_DATE('2019-05-01 00:00:00',
                                                                                                                           'yyyy-mm-dd hh24:mi:ss')
                                                                                                               AND A.CREATION_TIME <=
                                                                                                                   TO_DATE('2019-05-01 00:00:00',
                                                                                                                           'yyyy-mm-dd hh24:mi:ss')
                                                                                                             GROUP BY B.PART_NO) C
                                                                                                      LEFT JOIN MM_PUB_PART_UDA T
                                                                                                        ON T.PART_NO = C.PART_NO
                                                                                                      LEFT JOIN (SELECT D.DEPOT_NO,
                                                                                                                       E.PART_NO,
                                                                                                                       SUM(E.REC_QTY) REC_QTY
                                                                                                                  FROM MM_INV_IN D
                                                                                                                  LEFT JOIN MM_INV_IN_DETAIL E
                                                                                                                    ON D.REC_NO = E.REC_NO
                                                                                                                  LEFT JOIN MM_JISO_ORDER NN
                                                                                                                    ON D.ORDER_NO = NN.ORDER_NO
                                                                                                                 GROUP BY D.DEPOT_NO, E.PART_NO) F
                                                                                                        ON C.DEPOT_NO = F.DEPOT_NO
                                                                                                       AND C.PART_NO = F.PART_NO
                                                                                                     WHERE NVL(C.SH_NUM, 0) > NVL(F.REC_QTY, 0)
                                                                                                       AND C.DEPOT_NO IS NOT NULL
                                                                                                       AND EXISTS (SELECT 1
                                                                                                              FROM MM_JISO_ORDER_DETAIL M
                                                                                                             WHERE M.PART_NO = C.PART_NO)*/
                    SELECT C.DEPOT_NO,
                            C.PART_NO,
                            T.SUPPLIER_NO,
                            NVL(C.SH_NUM, 0) SH_NUM,
                            0 REC_QTY
                      FROM (SELECT 'AW11' DEPOT_NO,
                                    B.PART_NO,
                                    NVL(SUM(B.NUM), 0) SH_NUM
                               FROM MM_PUB_VEH_PASS A, MM_PUB_ORDER_BOM B
                              WHERE A.STATION_CODE = 'AF-OFF'
                                AND A.FACTORY_CODE = B.FACTORY_CODE
                                AND A.ERP_ORDER_NO = B.ORDER_NO
                                AND B.WORKCENTER = 'A1'
                                AND A.PASS_TIME >
                                    TO_DATE('2019-06-01 00:00:00',
                                            'yyyy-mm-dd hh24:mi:ss')
                                AND A.CREATION_TIME >
                                    TO_DATE('2019-06-01 00:00:00',
                                            'yyyy-mm-dd hh24:mi:ss')
                                AND A.PASS_TIME <
                                    TO_DATE('2019-07-01 00:00:00',
                                            'yyyy-mm-dd hh24:mi:ss')
                                AND A.CREATION_TIME <=
                                    TO_DATE('2019-07-01 00:00:00',
                                            'yyyy-mm-dd hh24:mi:ss')
                                AND EXISTS
                              (SELECT 1
                                       FROM MM_JISO_PART MJP
                                      WHERE MJP.PARTGROUP_ID IN ('154', '159')
                                        AND MJP.PART_NO = B.PART_NO)
                              GROUP BY B.PART_NO) C
                      LEFT JOIN MM_PUB_PART_UDA T
                        ON T.PART_NO = C.PART_NO) LOOP
      v_diff_num := cur_rec.sh_num - cur_rec.rec_qty;
    
      --找出所有取货订单中未收齐的订单零件号和仓库代码和上面一致的数据
      FOR cur_jiso_order IN (SELECT A.ORDER_NO,
                                    '2000' FACTORY_CODE,
                                    A.SUPPLIER_NO,
                                    B.ORDER_ROWNO,
                                    A.Arr_Depot,
                                    A.Receive_Date,
                                    B.Require_Num,
                                    0 CANCEL_NUM,
                                    B.ARRIVE_NUM,
                                    NVL(B.Require_Num, 0) -
                                    NVL(B.ARRIVE_NUM, 0) NOT_ARRIVE_NUM,
                                    NVL(B.Arrive_Count, 0) RECEIVE_COUNT,
                                    NVL(B.Arrive_Count, 0) PART_REC_TIMES,
                                    B.PART_NO,
                                    A.Arrive_Time,
                                    A.Arrive_Product_Seqno
                               FROM mm_jiso_order A
                               LEFT JOIN mm_jiso_order_detail B
                                 ON A.ORDER_NO = B.ORDER_NO
                              WHERE NVL(B.ARRIVE_NUM, 0) <
                                    NVL(B.REQUIRE_NUM, 0)
                                AND B.PART_NO = cur_rec.part_no
                              ORDER BY A.Creation_Time,
                                       A.Arrive_Product_Seqno) LOOP
      
        IF v_diff_num > 0 THEN
          --判断这个订单未收货的数量是否大于差异数量
          IF cur_jiso_order.NOT_ARRIVE_NUM < v_diff_num THEN
            v_curr_rec_num := cur_jiso_order.NOT_ARRIVE_NUM;
          
          ELSE
            v_curr_rec_num := v_diff_num;
          END IF;
        
          SELECT COUNT(1)
            INTO v_count
            FROM TEST_MM_INV_IN H
           WHERE H.REC_NO = cur_jiso_order.Order_No || '_' ||
                 (cur_jiso_order.RECEIVE_COUNT + 1);
          IF v_count <= 0 THEN
            --写入收货明细表
            INSERT INTO TEST_MM_INV_IN
              (REC_NO,
               FACTORY_CODE,
               ORDER_NO,
               REC_TIMES,
               DEPOT_NO,
               ORDER_TYPE,
               INV_TIME,
               CREATION_USER,
               CREATION_TIME,
               NOTE,
               ACTUAL_ARR_PRO_SEQNO)
            VALUES
              (cur_jiso_order.Order_No || '_' ||
               (cur_jiso_order.RECEIVE_COUNT + 1),
               '2000',
               cur_jiso_order.Order_No,
               cur_jiso_order.RECEIVE_COUNT + 1,
               'AW11',
               'JISO',
               SYSDATE,
               'SYSTEM',
               TO_DATE('2019-06-30 23:59:59', 'YYYY-MM-DD HH24:MI:SS'),
               '手工录入',
               cur_jiso_order.Arrive_Product_Seqno);
          END IF;
          INSERT INTO TEST_MM_INV_IN_DETAIL
            (REC_NO,
             ROW_NO,
             REC_TIMES,
             PART_NO,
             ORDER_QTY,
             REC_QTY,
             CREATION_TIME)
          VALUES
            (cur_jiso_order.Order_No || '_' ||
             (cur_jiso_order.RECEIVE_COUNT + 1),
             cur_jiso_order.order_rowno,
             cur_jiso_order.Part_Rec_Times + 1,
             cur_jiso_order.PART_NO,
             cur_jiso_order.REQUIRE_NUM,
             v_curr_rec_num,
             cur_jiso_order.arrive_time);
        
          /*select count(1)
            into v_count
            from test_wxl_af_sh A
           WHERE A.PART_NO = cur_jiso_order.Part_No
             AND A.DEPOT_NO = cur_jiso_order.Arr_Depot
             and rownum = 1;
          if v_count > 0 then
            UPDATE test_wxl_af_sh A
               SET A.DEAL_NUM = A.DEAL_NUM + v_curr_rec_num,
                   A.DEAL_WAY = 'sys'
             WHERE A.PART_NO = cur_jiso_order.Part_No
               AND A.DEPOT_NO = cur_jiso_order.Arr_Depot;
          else
            insert into test_wxl_af_sh
            values
              (cur_jiso_order.Arr_Depot,
               cur_rec.supplier_no,
               cur_jiso_order.Part_No,
               0,
               v_curr_rec_num,
               'sys');
          end if;*/
          COMMIT;
        
          v_diff_num := v_diff_num - v_curr_rec_num;
        ELSE
          --跳出循环
          EXIT;
        END IF;
      
      END LOOP;
    
    END LOOP;
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        ERROR_TAG     := 1;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_PUB_WAREHOUSE',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '仓库主数据写入业务表');
        COMMIT;
      
        ROLLBACK;
      END;
  END TEST_JISO;

  --***************************************************************************
  --存储过程名：USP_PUB_WAREHOUSE
  --功能描述: 仓库主数据写入业务表
  --参数说明：
  --创建人员: wangyu
  --创建时间： 2018/10/24
  PROCEDURE TEST_AF_JISO(ERROR_TAG OUT NUMBER, ERROR_MESSAGE OUT VARCHAR2) AS
    v_diff_num number(10);
  
    v_a1_first_time date;
    v_w1_first_time date;
    v_t1_first_time date;
  
    v_receive_time date;
    v_curr_rec_num NUMBER;
    v_count        number;
  BEGIN
    --查询每个车间的最早下线时间
    SELECT MIN(A.PASS_TIME)
      INTO v_a1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'AF-OFF';
  
    SELECT MIN(A.PASS_TIME)
      INTO v_w1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'WE-OFF';
  
    SELECT MIN(A.PASS_TIME)
      INTO v_t1_first_time
      FROM MM_PUB_VEH_PASS A
     WHERE A.STATION_CODE = 'PA-OFF';
  
    --找出所有手工收货比系统收货多的数据
    FOR cur_jit_rec IN (SELECT C.DEPOT_NO,
                               C.SUP,
                               C.PART_NO,
                               NVL(C.SH_NUM, 0) - NVL(C.DEAL_NUM, 0) DIFF_NUM
                          FROM test_wxl_af_sh C
                         WHERE NVL(C.SH_NUM, 0) - NVL(C.DEAL_NUM, 0) > 0
                           AND C.DEPOT_NO IS NOT NULL) LOOP
      v_diff_num := cur_jit_rec.DIFF_NUM;
    
      --查询仓库对应的收货时间
      BEGIN
        SELECT DISTINCT DECODE(A.WORK_CENTER,
                               'W1',
                               v_w1_first_time,
                               'A1',
                               v_a1_first_time,
                               'T1',
                               v_t1_first_time) - 1
          INTO v_receive_time
          FROM MM_INV_UNLOAD A
         WHERE A.WARE_CODE = cur_jit_rec.DEPOT_NO;
      EXCEPTION
        WHEN OTHERS THEN
          v_receive_time := v_w1_first_time;
      END;
    
      --找出所有拉动订单中未收齐的订单零件号和仓库代码和上面一致的数据
      FOR cur_jit_order IN (SELECT A.ORDER_NO,
                                   A.SUPPLIER_NO,
                                   B.ORDER_ROWNO,
                                   A.ARR_DEPOT,
                                   A.ARRIVE_TIME,
                                   B.REQUIRE_NUM,
                                   B.ARRIVE_NUM,
                                   A.ARRIVE_PRODUCT_SEQNO,
                                   NVL(B.REQUIRE_NUM, 0) -
                                   NVL(B.ARRIVE_NUM, 0) NOT_ARRIVE_NUM,
                                   NVL(A.ARRIVE_COUNT, 0) RECEIVE_COUNT,
                                   NVL(B.ARRIVE_COUNT, 0) PART_REC_TIMES,
                                   B.PART_NO
                              FROM MM_JISO_ORDER A
                              LEFT JOIN MM_JISO_ORDER_DETAIL B
                                ON A.ORDER_NO = B.ORDER_NO
                             WHERE B.PART_NO = cur_jit_rec.Part_No
                               AND NVL(B.ARRIVE_NUM, 0) <
                                   NVL(B.REQUIRE_NUM, 0)
                             ORDER BY A.Creation_Time,
                                      A.Arrive_Product_Seqno) LOOP
      
        IF v_diff_num > 0 THEN
          --判断这个订单未收货的数量是否大于差异数量
          IF cur_jit_order.NOT_ARRIVE_NUM < v_diff_num THEN
            v_curr_rec_num := cur_jit_order.NOT_ARRIVE_NUM;
          
          ELSE
            v_curr_rec_num := v_diff_num;
          END IF;
        
          SELECT COUNT(1)
            INTO v_count
            FROM TEST_MM_INV_IN H
           WHERE H.REC_NO = cur_JIT_order.Order_No || '_' ||
                 (cur_jit_order.RECEIVE_COUNT + 1);
          IF v_count <= 0 THEN
            --写入收货明细表
            INSERT INTO TEST_MM_INV_IN
              (REC_NO,
               FACTORY_CODE,
               ORDER_NO,
               REC_TIMES,
               DEPOT_NO,
               ORDER_TYPE,
               INV_TIME,
               CREATION_USER,
               CREATION_TIME,
               NOTE,
               ACTUAL_ARR_PRO_SEQNO)
            VALUES
              (cur_jit_order.Order_No || '_' ||
               (cur_jit_order.RECEIVE_COUNT + 1),
               '2000',
               cur_jit_order.Order_No,
               cur_jit_order.RECEIVE_COUNT + 1,
               cur_jit_order.ARR_DEPOT,
               'JISO',
               SYSDATE,
               'SYSTEM',
               v_receive_time,
               '手工录入',
               cur_jit_order.Arrive_Product_Seqno);
          END IF;
          INSERT INTO TEST_MM_INV_IN_DETAIL
            (REC_NO,
             ROW_NO,
             REC_TIMES,
             PART_NO,
             ORDER_QTY,
             REC_QTY,
             CREATION_TIME)
          VALUES
            (cur_jit_order.Order_No || '_' ||
             (cur_jit_order.RECEIVE_COUNT + 1),
             cur_jit_order.order_rowno,
             cur_jit_order.Part_Rec_Times + 1,
             cur_jit_order.PART_NO,
             cur_jit_order.REQUIRE_NUM,
             v_curr_rec_num,
             v_receive_time);
        
          UPDATE test_wxl_af_sh A
             SET A.DEAL_NUM = A.DEAL_NUM + v_curr_rec_num
           WHERE A.PART_NO = cur_jit_order.Part_No;
        
          COMMIT;
        
          v_diff_num := v_diff_num - v_curr_rec_num;
        ELSE
          --跳出循环
          EXIT;
        END IF;
      
      END LOOP;
    END LOOP;
  
    ERROR_TAG     := 0;
    ERROR_MESSAGE := '执行存储成功!';
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        ERROR_TAG     := 1;
        ERROR_MESSAGE := substrb(sqlerrm ||
                                 dbms_utility.format_error_backtrace(),
                                 1,
                                 200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'TEST',
           ERROR_TAG,
           ERROR_MESSAGE,
           sysdate,
           '仓库主数据写入业务表');
        COMMIT;
      
        ROLLBACK;
      END;
  END TEST_AF_JISO;

  --***************************************************************************
  --存储过程名：USP_MP_DEMAND_PARTIF_GEN
  --功能描述：一级件零件需求预测计算
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --foreType 预测类型
  --out_code 返回代码
  --创建人员: luoxianqin
  --创建时间： 2019/04/28
  PROCEDURE USP_MP_DEMAND_PARTIF_GEN(in_arr_factory in VARCHAR2,
                                     in_account     in VARCHAR2,
                                     in_foreType    in VARCHAR2,
                                     in_startDate   in VARCHAR2,
                                     in_endDate     in VARCHAR2,
                                     out_code       out VARCHAR2) AS
  
    err_num       number;
    err_msg       varchar2(200);
    V_NUM         NUMBER(5);
    V_UNLOAD_PORT VARCHAR2(100);
    V_MM_MODEL    VARCHAR2(100);
    --ERROR_TAG          NUMBER(10);
    --ERROR_MESSAGE      VARCHAR2(1000);
    V_AREA             VARCHAR2(20); --区域
    V_OUT_TIME         NUMBER(10); --生产节拍
    V_ADVANCE_TIME     NUMBER(10); --提前取货时间
    V_TRANS_TIME       NUMBER(10); --运输时长
    v_loc_num          number(10); --落点车体流动数
    v_use_location_num VARCHAR2(30);
    v_location         VARCHAR2(20);
    V_TIME             DATE; --厂内装配时间
    V_TIME1            NUMBER(10); --厂内提前时间
    V_WORKCENTER       VARCHAR2(30); --车间
    v_af_max_loc       NUMBER;
    v_pa_max_loc       NUMBER;
    v_we_max_loc       NUMBER;
    v_wbs_max_loc      NUMBER;
    v_pbs_max_loc      NUMBER;
    V_VERSION_EXIST    NUMBER(10); --判断版本是否存在
    v_dateNum          NUMBER(10); --判断用户输入的时间范围是否有对应的生成计划数据
  
  BEGIN
    select count(1)
      into v_dateNum
      from TEST_MM_PUB_PRO_PLAN P
      left join MM_PUB_ORDER_BOM BOM
        ON P.ORDER_NO = BOM.ORDER_NO
     WHERE substr(P.AFOFF_TIME, 0, 10) >=
           to_date(in_startDate, 'yyyy-mm-dd')
       AND substr(P.AFOFF_TIME, 0, 10) < =
           to_date(in_endDate, 'yyyy-mm-dd')
       AND P.FACTORY_CODE = in_arr_factory
       AND BOM.PURCHASE_TYPE in ('W', 'AW');
  
    if v_dateNum = 0 then
      out_code := 2;
    else
      delete from TEST_SW_DEMAND_FORECAST_IMP;
      FOR SUB_FORECAST IN (SELECT P.FACTORY_CODE COMP,
                                  --P.AFOFF_TIME REC_DATE,
                                  P.MODEL_CODE MODEL_CODE,
                                  P.PHASE      PHASE,
                                  BOM.PART_NO  PART_NO,
                                  --BOM.NUM ORDER_NUM,
                                  BOM.PURCHASE_TYPE PURCHASE_TYPE,
                                  PS.SUPPLIER_NO,
                                  T.PART_UNIT,
                                  to_char(SE.START_DATE, 'yyyy-mm-dd') START_DATE,
                                  to_char(SE.END_DATE, 'yyyy-mm-dd') END_DATE,
                                  to_char(SE.START_DATE, 'yyyy-mm-dd') OBJ_WEEK,
                                  to_char(trunc(to_date(to_char(sysdate,
                                                                'yyyy-mm-dd'),
                                                        'yyyy-mm-dd'),
                                                'd') + 1,
                                          'yyyy-mm-dd') PUBLISH_WEEK,
                                  --TS.REC_DATE,
                                  --TS.ORDER_NUM,
                                  SUM(BOM.NUM) ORDER_NUM,
                                  to_date(SUBSTR(to_char(P.AFOFF_TIME,
                                                         'yyyy-mm-dd hh24:mi:ss'),
                                                 0,
                                                 10),
                                          'yyyy-mm-dd hh24:mi:ss') REC_DATE
                             FROM TEST_MM_PUB_PRO_PLAN P
                             LEFT JOIN MM_PUB_ORDER_BOM BOM
                               ON P.ORDER_NO = BOM.ORDER_NO
                             LEFT JOIN MM_PUB_PART_SUPPLIER PS
                               ON BOM.PART_NO = PS.PART_NO
                              AND BOM.FACTORY_CODE = PS.FACTORY_CODE
                             LEFT JOIN MM_PUB_PART T
                               ON BOM.PART_NO = T.PART_NO
                              AND BOM.FACTORY_CODE = T.FACTORY_CODE
                             LEFT JOIN (SELECT MIN(A.AFOFF_TIME) START_DATE,
                                              MAX(A.AFOFF_TIME) END_DATE
                                         FROM MM_PUB_PRO_PLAN A
                                       /*WHERE A.AFOFF_TIME >=
                                           trunc(to_date(to_char(sysdate, 'yyyy-mm-dd'),
                                                         'yyyy-mm-dd'),
                                                 'd') + 1
                                       AND A.AFOFF_TIME < =
                                           trunc(to_date(to_char(sysdate, 'yyyy-mm-dd'),
                                                         'yyyy-mm-dd'),
                                                 'd') + 28*/
                                        WHERE substr(A.AFOFF_TIME, 0, 10) >=
                                              to_date(in_startDate,
                                                      'yyyy-mm-dd')
                                          AND substr(A.AFOFF_TIME, 0, 10) < =
                                              to_date(in_endDate,
                                                      'yyyy-mm-dd')) SE
                               ON 1 = 1
                           
                           /* WHERE P.AFOFF_TIME >=
                               trunc(to_date(to_char(sysdate, 'yyyy-mm-dd'), 'yyyy-mm-dd'), 'd') + 1
                           AND P.AFOFF_TIME < =
                               trunc(to_date(to_char(sysdate, 'yyyy-mm-dd'), 'yyyy-mm-dd'), 'd') + 28*/
                            WHERE substr(P.AFOFF_TIME, 0, 10) >=
                                  to_date(in_startDate, 'yyyy-mm-dd')
                              AND substr(P.AFOFF_TIME, 0, 10) < =
                                  to_date(in_endDate, 'yyyy-mm-dd')
                              AND P.FACTORY_CODE = in_arr_factory
                              AND (BOM.PURCHASE_TYPE = 'W'
                                   -- OR BOM.PURCHASE_TYPE = 'FW' 
                                   OR BOM.PURCHASE_TYPE = 'AW')
                            GROUP BY to_date(SUBSTR(to_char(P.AFOFF_TIME,
                                                            'yyyy-mm-dd hh24:mi:ss'),
                                                    0,
                                                    10),
                                             'yyyy-mm-dd hh24:mi:ss'),
                                     BOM.PART_NO,
                                     P.FACTORY_CODE,
                                     P.MODEL_CODE,
                                     P.PHASE,
                                     BOM.PURCHASE_TYPE,
                                     PS.SUPPLIER_NO,
                                     T.PART_UNIT,
                                     to_char(SE.START_DATE, 'yyyy-mm-dd'),
                                     to_char(SE.END_DATE, 'yyyy-mm-dd'),
                                     to_char(SE.START_DATE, 'yyyy-mm-dd'),
                                     to_char(trunc(to_date(to_char(sysdate,
                                                                   'yyyy-mm-dd'),
                                                           'yyyy-mm-dd'),
                                                   'd') + 1,
                                             'yyyy-mm-dd')) LOOP
      
        --计算提前取货时间
        FOR CUR_ADVAN IN (
                          
                          SELECT ACC.WORKCENTER,
                                  ACC.ARRIVE_NUM,
                                  ACC.DISTRIBUTION_NUM
                            FROM (SELECT C.ARRIVE_NUM,
                                          C.DISTRIBUTION_NUM,
                                          C.PART_NO,
                                          C.WORKCENTER
                                     FROM MM_MP_PART C
                                   UNION
                                   SELECT D.ARRIVE_NUM,
                                          D.DISTRIBUTION_NUM,
                                          D.PART_NO,
                                          CD.WORKCENTER
                                     FROM MM_JIT_PART D
                                     LEFT JOIN MM_PUB_PLAN_CODE CD
                                       ON D.PLAN_CODE = CD.PLAN_CODE
                                   UNION
                                   SELECT PP.ARRIVE_NUM,
                                          PP.DISTRIBUTION_NUM,
                                          JI.PART_NO,
                                          CDD.WORKCENTER
                                     FROM MM_JISO_PARTGROUP PP
                                     LEFT JOIN MM_JISO_PART JI
                                       ON PP.ID = JI.PARTGROUP_ID
                                     LEFT JOIN MM_PUB_PLAN_CODE CDD
                                       ON PP.PLAN_CODE = CDD.PLAN_CODE) ACC
                           WHERE ACC.PART_NO = SUB_FORECAST.PART_NO) LOOP
        
          --获取属地信息
          v_location := null;
          v_loc_num  := 0;
          --v_distri_person := null;
          --1、根据零件获取属地信息中任一落点信息
          for cur_loc in (select a.location, a.location_num, a.distri_person
                            from mm_inv_part_location a
                           where a.factory_code = SUB_FORECAST.COMP
                             and a.workcenter = CUR_ADVAN.workcenter
                             and a.part_no = SUB_FORECAST.part_NO
                             and a.eff_start <= sysdate
                             and a.eff_end > sysdate
                           order by a.location_num desc) loop
            v_location := cur_loc.location;
            v_loc_num  := cur_loc.location_num;
            --v_distri_person := cur_loc.distri_person;
            v_use_location_num := 'LOC';
            exit;
          end loop;
          --2、获取属地信息中车间最大工深
          if v_location is null then
            select decode(max(a.location_num), null, 0, max(a.location_num))
              into v_loc_num
              from mm_inv_part_location a
             where a.factory_code = SUB_FORECAST.COMP
                  --and a.workcenter = SUB_FORECAST.workcenter
               and a.eff_start <= sysdate
               and a.eff_end > sysdate;
            v_use_location_num := 'WC';
          end if;
          --3、获取系统参数中车间最大工深
          --if v_location is null then
          if CUR_ADVAN.WORKCENTER = 'A1' THEN
            V_WORKCENTER := 'AF';
          ELSIF CUR_ADVAN.WORKCENTER = 'W1' THEN
            V_WORKCENTER := 'WE';
          ELSIF CUR_ADVAN.WORKCENTER = 'T1' THEN
            V_WORKCENTER := 'PA';
          ELSE
            V_WORKCENTER := 'AF';
          END IF;
        
          ----最大工深获取方式修改为如下------------------------------------------------------------------- 
          BEGIN
            --判断如果是总装
            SELECT NVL(A.PARAM_VAL, 0)
              INTO v_af_max_loc
              FROM MM_PUB_SYS_PARAM A
             WHERE A.PARAM_GROUP = 'MAX_LOC'
               AND A.FACTORY_CODE = SUB_FORECAST.COMP
               AND A.PARAM_CODE = 'AF_TOTAL_PRO_NUM';
          
            --判断如果是焊装
            SELECT NVL(A.PARAM_VAL, 0)
              INTO v_we_max_loc
              FROM MM_PUB_SYS_PARAM A
             WHERE A.PARAM_GROUP = 'MAX_LOC'
               AND A.FACTORY_CODE = SUB_FORECAST.COMP
               AND A.PARAM_CODE = 'WE_TOTAL_PRO_NUM';
          
            --判断如果是涂装
            SELECT NVL(A.PARAM_VAL, 0)
              INTO v_pa_max_loc
              FROM MM_PUB_SYS_PARAM A
             WHERE A.PARAM_GROUP = 'MAX_LOC'
               AND A.FACTORY_CODE = SUB_FORECAST.COMP
               AND A.PARAM_CODE = 'PA_TOTAL_PRO_NUM';
            --判断如果是涂装
            SELECT NVL(A.PARAM_VAL, 0)
              INTO v_wbs_max_loc
              FROM MM_PUB_SYS_PARAM A
             WHERE A.PARAM_GROUP = 'MAX_LOC'
               AND A.FACTORY_CODE = SUB_FORECAST.COMP
               AND A.PARAM_CODE = 'WBS_TOTAL_PRO_NUM';
          
            --判断如果是涂装
            SELECT NVL(A.PARAM_VAL, 0)
              INTO v_pbs_max_loc
              FROM MM_PUB_SYS_PARAM A
             WHERE A.PARAM_GROUP = 'MAX_LOC'
               AND A.FACTORY_CODE = SUB_FORECAST.COMP
               AND A.PARAM_CODE = 'PBS_TOTAL_PRO_NUM';
          END;
        
          IF CUR_ADVAN.WORKCENTER = 'A1' AND NVL(v_loc_num, 0) = 0 THEN
            v_loc_num := v_af_max_loc;
          ELSIF CUR_ADVAN.WORKCENTER = 'A1' AND NVL(v_loc_num, 0) != 0 THEN
            v_loc_num := NVL(v_loc_num, 0);
          ELSIF CUR_ADVAN.WORKCENTER = 'T1' AND NVL(v_loc_num, 0) = 0 THEN
            v_loc_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc;
          ELSIF CUR_ADVAN.WORKCENTER = 'T1' AND NVL(v_loc_num, 0) != 0 THEN
            v_loc_num := v_af_max_loc + v_pbs_max_loc + NVL(v_loc_num, 0);
          ELSIF CUR_ADVAN.WORKCENTER = 'W1' AND NVL(v_loc_num, 0) = 0 THEN
            v_loc_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc +
                         v_wbs_max_loc + v_we_max_loc;
          ELSIF CUR_ADVAN.WORKCENTER = 'W1' AND NVL(v_loc_num, 0) != 0 THEN
            v_loc_num := v_af_max_loc + v_pbs_max_loc + v_pa_max_loc +
                         v_wbs_max_loc + NVL(v_loc_num, 0);
          END IF;
        
          ------------------------------------------------------------------------     
        
          /*            v_loc_num          := to_number(PKG_PUB.USF_GET_SYS_PARAM(SUB_FORECAST.Comp,
          'MAX_LOC',
          V_WORKCENTER ||
          'TOTAL_PRO_NUM'));*/
          v_use_location_num := 'SYS';
        
          --end if;
        
          if v_loc_num is null then
            v_loc_num          := 0;
            v_use_location_num := null;
          end if;
          IF CUR_ADVAN.WORKCENTER IN ('W1', 'A1', 'T1') THEN
          
            --台套数对应时间
            V_OUT_TIME := PKG_PUB.USF_GET_PRODUCE_TIME(SUB_FORECAST.COMP,
                                                       CUR_ADVAN.WORKCENTER,
                                                       NULL) *
                          (nvl(v_loc_num, 0) + nvl(CUR_ADVAN.ARRIVE_NUM, 0) +
                           nvl(CUR_ADVAN.DISTRIBUTION_NUM, 0));
          
            --DBMS_OUTPUT.put_line(to_char(SUB_FORECAST.REC_DATE,'yyyy-mm-dd hh24:mi:ss'));
            --厂内装配时间
            V_TIME := PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                   CUR_ADVAN.WORKCENTER,
                                                   SUB_FORECAST.REC_DATE,
                                                   -V_OUT_TIME);
          
          ELSE
            --台套数对应时间
            --如果车间不是总装焊装涂装，使用总装计算
            V_OUT_TIME := PKG_PUB.USF_GET_PRODUCE_TIME(SUB_FORECAST.COMP,
                                                       'A1',
                                                       NULL) *
                          (v_loc_num + CUR_ADVAN.ARRIVE_NUM +
                           CUR_ADVAN.DISTRIBUTION_NUM);
          
            --厂内装配时间
            --如果车间不是总装焊装涂装，使用总装计算
            V_TIME := PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                   'A1',
                                                   SUB_FORECAST.REC_DATE,
                                                   -V_OUT_TIME);
          
          END IF;
        
          -- DBMS_OUTPUT.put_line(to_date(SUB_FORECAST.REC_DATE,'yyyy-mm-dd'));
          --DBMS_OUTPUT.put_line(TO_CHAR(V_TIME, 'YYYY-MM-DD HH24:mi:ss'));
          V_TIME1 := V_TIME - SUB_FORECAST.REC_DATE;
          /*    V_ENDTIME := 0;
          IF V_ENDTIME > V_TIME1 THEN 
            V_ENDTIME := V_TIME1;
            END IF;*/
          --从路线中获取省内省外和运输时长                                                         
          SELECT MAX(A.AREA), MAX(A.TRANS_TIME)
            INTO V_AREA, V_TRANS_TIME
            FROM MM_PUP_ROUTE A
           WHERE A.FACTORY_CODE = SUB_FORECAST.COMP
             AND A.SUPPLIER_NO = SUB_FORECAST.SUPPLIER_NO
             AND A.SUP_FACTORY =
                 (SELECT UDA.SUP_FACTORY
                    FROM MM_PUB_PART_UDA UDA
                   WHERE UDA.PART_NO = SUB_FORECAST.PART_NO)
             AND A.CAR_TYPE = SUB_FORECAST.MODEL_CODE;
        
          V_ADVANCE_TIME := 0;
        
          IF V_AREA IS NOT NULL AND V_TRANS_TIME IS NOT NULL THEN
            IF V_TRANS_TIME = 0 THEN
              V_TRANS_TIME := 1;
            END IF;
            IF V_AREA = '省内' THEN
              --V_ADVANCE_TIME := CEIL(V_ENDTIME - V_TRANS_TIME/24);
              IF CUR_ADVAN.WORKCENTER IN ('A1', 'W1', 'T1') THEN
              
                V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                  PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                               CUR_ADVAN.WORKCENTER,
                                                               V_TIME,
                                                               -V_TRANS_TIME);
              ELSE
                V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                  PKG_PUB.USF_GET_CAL_WORKTIME(SUB_FORECAST.COMP,
                                                               'A1',
                                                               V_TIME,
                                                               -V_TRANS_TIME);
              END IF;
            END IF;
            --SELECT ceil(V_OUT_TIME + V_TRANS_TIME) INTO V_ADVANCE_TIME FROM DUAL;
            IF V_AREA = '省外' THEN
              --SELECT ceil(V_OUT_TIME + V_TRANS_TIME) / 24 INTO V_ADVANCE_TIME FROM DUAL;
              --V_ADVANCE_TIME := CEIL(V_ENDTIME + V_TRANS_TIME/24);
            
              IF CUR_ADVAN.WORKCENTER IN ('A1', 'W1', 'T1') THEN
              
                V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                  TO_DATE(USF_MM_MP_FORBAKWORKDATE(TO_CHAR(V_TIME,
                                                                           'YYYY-MM-DD'),
                                                                   CEIL(NVL(V_TRANS_TIME,
                                                                            0) / 24),
                                                                   CUR_ADVAN.WORKCENTER,
                                                                   SUB_FORECAST.COMP,
                                                                   0) ||
                                          TO_CHAR(V_TIME, 'HH24:MI:SS'),
                                          'YYYY-MM-DD HH24:MI:SS');
              ELSE
                V_ADVANCE_TIME := SUB_FORECAST.REC_DATE -
                                  TO_DATE(USF_MM_MP_FORBAKWORKDATE(TO_CHAR(V_TIME,
                                                                           'YYYY-MM-DD'),
                                                                   CEIL(NVL(V_TRANS_TIME,
                                                                            0) / 24),
                                                                   'A1',
                                                                   SUB_FORECAST.COMP,
                                                                   0) ||
                                          TO_CHAR(V_TIME, 'HH24:MI:SS'),
                                          'YYYY-MM-DD HH24:MI:SS');
              END IF;
            END IF;
          END IF;
        
        END LOOP;
      
        BEGIN
          SELECT MAX(UNLOAD_PORT) --获取卸货口
            INTO V_UNLOAD_PORT
            FROM (SELECT DISTINCT SD.UNLOAD_PORT
                    FROM MM_INV_PART_LOCATION SD
                   WHERE SD.PART_NO = SUB_FORECAST.PART_NO
                     AND SUB_FORECAST.COMP = SD.FACTORY_CODE
                     AND SD.EFF_START <= SYSDATE
                     AND SYSDATE <= SD.EFF_END);
        
        EXCEPTION
          WHEN OTHERS THEN
            V_UNLOAD_PORT := '';
        END;
      
        BEGIN
          SELECT Max(OAD.LOGISTICS_MODEL)
            INTO V_MM_MODEL --获取物流模式
            FROM MM_PUB_PART_UNLOAD OAD
           WHERE OAD.PART_NO = SUB_FORECAST.PART_NO;
        
        EXCEPTION
          WHEN OTHERS THEN
            V_MM_MODEL := '';
        END;
      
        INSERT INTO TEST_SW_DEMAND_FORECAST_IMP
          (ID,
           FACTORY_CODE,
           FORE_TYPE,
           PLAN_DELIVERY,
           START_DATE,
           END_DATE,
           PHASE,
           UNLOAD_PORT,
           PART_NO,
           PART_UNIT,
           ORDER_QTY,
           SUPPLIER_NO,
           MODEL_CODE,
           LOGISTICS_MODE,
           CREATION_USER,
           CREATION_TIME,
           PUBLISH_WEEK,
           OBJ_WEEK,
           ADVANCE_TIME,
           RELEASE_STATUS,
           FEEDBACK_STATUS,
           DO_FLAG,
           DEAL_FLAG)
        VALUES
          (SEQ_TEMP_DEMAND_FORECAST_IMP.NEXTVAL,
           SUB_FORECAST.COMP,
           in_foreType,
           SUB_FORECAST.REC_DATE,
           to_date(SUB_FORECAST.START_DATE, 'yyyy-mm-dd'),
           to_date(SUB_FORECAST.END_DATE, 'yyyy-mm-dd'),
           decode(SUB_FORECAST.PHASE, '5', '1', '7', '1', '2'),
           V_UNLOAD_PORT,
           SUB_FORECAST.PART_NO,
           SUB_FORECAST.PART_UNIT,
           SUB_FORECAST.ORDER_NUM,
           SUB_FORECAST.SUPPLIER_NO,
           SUB_FORECAST.MODEL_CODE,
           V_MM_MODEL,
           in_account,
           SYSDATE,
           SUB_FORECAST.PUBLISH_WEEK,
           SUB_FORECAST.OBJ_WEEK,
           V_ADVANCE_TIME,
           '0',
           '0',
           'I',
           '0');
      END LOOP;
      COMMIT;
      out_code := 0;
    end if;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
      
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_MP_DEMAND_PARTIF_GEN',
           err_num,
           err_msg,
           sysdate,
           '一级件零件预测计算');
        COMMIT;
      
        ROLLBACK;
      
      END;
  END USP_MP_DEMAND_PARTIF_GEN;

  --****************************************************************************
  --过程名  : USP_SW_PICK_PLAN
  --功能描述: 将预测数据信息同步至信息共享平台
  --参数说明: 无
  --创建人员: lbx
  --创建时间: 2019-01-09
  --****************************************************************************
  PROCEDURE USP_SW_DEMAND_FORECAST IS
    err_num         number(10); --错误代码
    err_msg         varchar2(200); --错误信息
    V_VERSION_EXIST NUMBER(10); --判断版本是否存在
  BEGIN
  
    /*   FOR VERSION_FORECASE IN (
      SELECT COUNT(1) NUM, A.VERSION, A.FORE_TYPE
        from MM_SW_DEMAND_FORECAST A
        WHERE A.DEAL_FLAG = 0
        GROUP BY A.VERSION,A.FORE_TYPE
        ORDER BY A.VERSION) LOOP 
    
    IF VERSION_FORECASE.NUM > 0 THEN 
      SELECT COUNT(1) INTO V_VERSION_EXIST FROM ilmsportal.MM_SW_DEMAND_FORECAST@mm_if_in A WHERE A.VERSION = VERSION_FORECASE.VERSION; --判断下发下来的版本是否已存在
      IF V_VERSION_EXIST > 0 THEN 
          UPDATE MM_SW_DEMAND_FORECAST A SET A.DEAL_FLAG = 1 WHERE A.DEAL_FLAG = 0 
          AND A.VERSION = VERSION_FORECASE.VERSION; --如果存在则直接将该版本修改为已处理
        ELSE 
          DELETE ilmsportal.MM_SW_DEMAND_FORECAST@mm_if_in A WHERE A.FORE_TYPE = VERSION_FORECASE.FORE_TYPE; --如果不存在则删除上一个版本的数据，区分周预测和月预测
       END IF;
    END IF ;
    END LOOP;*/
    --查询未处理订单
    FOR CUR_ORDER_NO IN (SELECT T.*
                           FROM TEST_SW_DEMAND_FORECAST_IMP T
                          WHERE T.DEAL_FLAG = 0
                          ORDER BY T.CREATION_TIME) LOOP
    
      IF CUR_ORDER_NO.DO_FLAG = 'I' THEN
        insert into ilmsportal.MM_SW_DEMAND_FORECAST@mm_if_in
          (ID,
           FACTORY_CODE,
           FORE_TYPE,
           VERSION,
           PLAN_DELIVERY,
           START_DATE,
           END_DATE,
           PHASE,
           UNLOAD_PORT,
           PART_NO,
           PART_UNIT,
           ORDER_QTY,
           SUPPLIER_NO,
           SUPPLIER_NAME,
           SUP_FACTORY_ADDR,
           SUP_FACTORY,
           MODEL_CODE,
           LOGISTICS_MODE,
           DOWNLOAD_STATUS,
           DOWNLOAD_TIME,
           CREATION_USER,
           CREATION_TIME,
           LAST_MODIFIED_USER,
           LAST_MODIFIED_TIME,
           RELEASE_STATUS,
           FEEDBACK_STATUS,
           FEEDBACK_REMARK,
           PUBLISH_MONTH,
           OBJ_MONTH,
           PUBLISH_WEEK,
           OBJ_WEEK,
           ADVANCE_TIME,
           P_SUPPLIER)
        values
          (ilmsportal.SEQ_MM_SW_DEMAND_FORE.nextval@mm_if_in,
           CUR_ORDER_NO.FACTORY_CODE,
           CUR_ORDER_NO.FORE_TYPE,
           CUR_ORDER_NO.VERSION,
           CUR_ORDER_NO.PLAN_DELIVERY,
           CUR_ORDER_NO.START_DATE,
           CUR_ORDER_NO.END_DATE,
           CUR_ORDER_NO.PHASE,
           CUR_ORDER_NO.UNLOAD_PORT,
           CUR_ORDER_NO.PART_NO,
           CUR_ORDER_NO.PART_UNIT,
           CUR_ORDER_NO.ORDER_QTY,
           CUR_ORDER_NO.SUPPLIER_NO,
           CUR_ORDER_NO.SUPPLIER_NAME,
           CUR_ORDER_NO.SUP_FACTORY_ADDR,
           CUR_ORDER_NO.SUP_FACTORY,
           CUR_ORDER_NO.MODEL_CODE,
           CUR_ORDER_NO.LOGISTICS_MODE,
           CUR_ORDER_NO.DOWNLOAD_STATUS,
           CUR_ORDER_NO.DOWNLOAD_TIME,
           CUR_ORDER_NO.CREATION_USER,
           CUR_ORDER_NO.CREATION_TIME,
           CUR_ORDER_NO.LAST_MODIFIED_USER,
           CUR_ORDER_NO.LAST_MODIFIED_TIME,
           CUR_ORDER_NO.RELEASE_STATUS,
           CUR_ORDER_NO.FEEDBACK_STATUS,
           CUR_ORDER_NO.FEEDBACK_REMARK,
           CUR_ORDER_NO.PUBLISH_MONTH,
           CUR_ORDER_NO.OBJ_MONTH,
           CUR_ORDER_NO.PUBLISH_WEEK,
           CUR_ORDER_NO.OBJ_WEEK,
           CUR_ORDER_NO.ADVANCE_TIME,
           CUR_ORDER_NO.P_SUPPLIER);
      
      ELSIF CUR_ORDER_NO.DO_FLAG = 'U' THEN
        update ilmsportal.MM_SW_DEMAND_FORECAST@mm_if_in a
           set FACTORY_CODE       = CUR_ORDER_NO.FACTORY_CODE,
               FORE_TYPE          = CUR_ORDER_NO.FORE_TYPE,
               VERSION            = CUR_ORDER_NO.VERSION,
               PLAN_DELIVERY      = CUR_ORDER_NO.PLAN_DELIVERY,
               START_DATE         = CUR_ORDER_NO.START_DATE,
               END_DATE           = CUR_ORDER_NO.END_DATE,
               PHASE              = CUR_ORDER_NO.PHASE,
               UNLOAD_PORT        = CUR_ORDER_NO.UNLOAD_PORT,
               PART_NO            = CUR_ORDER_NO.PART_NO,
               PART_UNIT          = CUR_ORDER_NO.PART_UNIT,
               ORDER_QTY          = CUR_ORDER_NO.ORDER_QTY,
               SUPPLIER_NO        = CUR_ORDER_NO.SUPPLIER_NO,
               SUPPLIER_NAME      = CUR_ORDER_NO.SUPPLIER_NAME,
               SUP_FACTORY_ADDR   = CUR_ORDER_NO.SUP_FACTORY_ADDR,
               SUP_FACTORY        = CUR_ORDER_NO.SUP_FACTORY,
               MODEL_CODE         = CUR_ORDER_NO.MODEL_CODE,
               LOGISTICS_MODE     = CUR_ORDER_NO.LOGISTICS_MODE,
               DOWNLOAD_STATUS    = CUR_ORDER_NO.DOWNLOAD_STATUS,
               DOWNLOAD_TIME      = CUR_ORDER_NO.DOWNLOAD_TIME,
               CREATION_USER      = CUR_ORDER_NO.CREATION_USER,
               CREATION_TIME      = sysdate,
               LAST_MODIFIED_USER = CUR_ORDER_NO.LAST_MODIFIED_USER,
               LAST_MODIFIED_TIME = CUR_ORDER_NO.LAST_MODIFIED_TIME,
               RELEASE_STATUS     = CUR_ORDER_NO.RELEASE_STATUS,
               FEEDBACK_STATUS    = CUR_ORDER_NO.FEEDBACK_STATUS,
               FEEDBACK_REMARK    = CUR_ORDER_NO.FEEDBACK_REMARK,
               PUBLISH_MONTH      = CUR_ORDER_NO.PUBLISH_MONTH,
               OBJ_MONTH          = CUR_ORDER_NO.OBJ_MONTH,
               PUBLISH_WEEK       = CUR_ORDER_NO.PUBLISH_WEEK,
               OBJ_WEEK           = CUR_ORDER_NO.OBJ_WEEK,
               ADVANCE_TIME       = CUR_ORDER_NO.ADVANCE_TIME,
               P_SUPPLIER         = CUR_ORDER_NO.P_SUPPLIER
         where a.FORE_TYPE = CUR_ORDER_NO.FORE_TYPE
           and a.VERSION = CUR_ORDER_NO.VERSION
           and a.PHASE = CUR_ORDER_NO.PHASE
           and a.PART_NO = CUR_ORDER_NO.PART_NO
           and a.SUPPLIER_NO = CUR_ORDER_NO.SUPPLIER_NO
           and a.MODEL_CODE = CUR_ORDER_NO.MODEL_CODE
           and a.PLAN_DELIVERY = CUR_ORDER_NO.PLAN_DELIVERY;
      
      ELSIF CUR_ORDER_NO.DO_FLAG = 'D' THEN
        delete from ilmsportal.MM_SW_DEMAND_FORECAST@mm_if_in a
         where a.FORE_TYPE = CUR_ORDER_NO.FORE_TYPE
           and a.VERSION = CUR_ORDER_NO.VERSION
           and a.PHASE = CUR_ORDER_NO.PHASE
           and a.PART_NO = CUR_ORDER_NO.PART_NO
           and a.SUPPLIER_NO = CUR_ORDER_NO.SUPPLIER_NO
           and a.MODEL_CODE = CUR_ORDER_NO.MODEL_CODE
           and a.PLAN_DELIVERY = CUR_ORDER_NO.PLAN_DELIVERY;
      
      END IF;
      --更新中间表处理标记位为已处理
      update TEST_SW_DEMAND_FORECAST_IMP a
         set a.deal_flag = 1, a.deal_time = sysdate
       where a.id = CUR_ORDER_NO.Id
         and a.factory_code = CUR_ORDER_NO.FACTORY_CODE;
      COMMIT;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      err_num := SQLCODE;
      err_msg := SUBSTR(SQLERRM || dbms_utility.format_error_backtrace(),
                        1,
                        200);
      insert into mm_pub_pro_error
        (id, alert_type, error_name, error_desc, creation_date, key_name)
      values
        (SEQ_PUB_PRO_ERROR.nextval,
         'USP_SW_DEMAND_FORECAST',
         err_num,
         err_msg,
         sysdate,
         '');
      COMMIT;
  END USP_SW_DEMAND_FORECAST;

  --***************************************************************************
  --存储过程名：USP_INV_GET_DIFFERENCE
  --功能描述：支给获取库存差异
  --参数说明：
  --account 操作人
  --in_arr_factory 工厂
  --out_code 返回代码
  --创建人员: luoxq
  --创建时间： 2019/05/30
  PROCEDURE USP_INV_GET_DIFFERENCE(in_arr_factory in VARCHAR2,
                                   in_account     in VARCHAR2,
                                   out_code       out VARCHAR2) AS
  
    err_num   number;
    err_msg   varchar2(200);
    V_NUM     NUMBER;
    v_count   number;
    v_count_a number;
    v_count_b number;
  BEGIN
    --每次生成之前删除上次的数据
    --EXECUTE IMMEDIATE 'truncate table mm_inv_difference';
    DELETE FROM MM_INV_DIFFERENCE;
    --删除支给件订单BOM
    --EXECUTE IMMEDIATE 'truncate table MM_SUPP_ORDER_BOM'; --新增之前删除临时支给bom
    DELETE FROM MM_INV_SUPP_ORDER_BOM;
    v_count := 1;
    select nvl(max(a.cal_week), 0)
      into v_count_a
      from mm_inv_week_cal a
     where a.factory_code = in_arr_factory;
  
    --初始化支给BOM数据
    INSERT INTO MM_INV_SUPP_ORDER_BOM
      (FACTORY_CODE,
       WARE_CODE,
       PART_NO,
       NUM,
       USAGE_AMOUNT_UNIT,
       PURCHASE_TYPE,
       CREATION_TIME,
       CREATION_USER,
       AFOFF_TIME)
      SELECT H.FACTORY_CODE,
             H.WARE_CODE,
             H.PART_NO,
             sum(H.NUM) NUM,
             H.USAGE_AMOUNT_UNIT,
             H.PURCHASE_TYPE,
             sysdate,
             in_account,
             to_date(TO_CHAR(H.AFOFF_TIME, 'YYYY-MM-DD'), 'yyyy-mm-dd')
        FROM (SELECT D.FACTORY_CODE,
                     CONNECT_BY_ROOT(D.ORDER_NO) ORDER_NO,
                     D. PART_ROWNO,
                     D.PART_NO,
                     D.WARE_CODE,
                     MY_EVAL_NUMBER(1 || SYS_CONNECT_BY_PATH(D.NUM, '*')) NUM,
                     D.USAGE_AMOUNT_UNIT,
                     D.PURCHASE_TYPE,
                     D. PARTF_ID,
                     SYSDATE,
                     in_account,
                     CONNECT_BY_ROOT(D.AFOFF_TIME) AFOFF_TIME
                FROM (SELECT A.FACTORY_CODE,
                             A.ORDER_NO,
                             A.MODEL_CODE,
                             A.PART_ROWNO,
                             A.VEHICLE_PART_NO,
                             A.PART_NO,
                             null                WARE_CODE,
                             A.STATION_CODE,
                             A.NUM,
                             A.USAGE_AMOUNT_UNIT,
                             NULL                PARTF_ID,
                             P.AFOFF_TIME        AFOFF_TIME,
                             A.PURCHASE_TYPE
                        FROM MM_PUB_ORDER_BOM A
                        LEFT JOIN MM_PUB_PRO_PLAN P
                          ON A.ORDER_NO = P.ORDER_NO
                       WHERE EXISTS
                       (SELECT 1
                                FROM MM_PUB_PRO_PLAN B
                               WHERE A.ORDER_NO = B.ORDER_NO
                                 AND A.FACTORY_CODE = B.FACTORY_CODE)
                         AND P.AFOFF_TIME >= TRUNC(SYSDATE + 7, 'D') + 1
                         AND P.AFOFF_TIME <=
                             TRUNC(SYSDATE + 7, 'D') + 1 + v_count_a
                         AND A.FACTORY_CODE = in_arr_factory
                      UNION ALL
                      SELECT C.FACTORY_CODE,
                             NULL                  ORDER_NO,
                             NULL                  MODEL_CODE,
                             NULL                  PART_ROWNO,
                             NULL                  VEHICLE_PART_NO,
                             C.PART_NO,
                             C.NEXT_PLACEMENT      WARE_CODE,
                             C.LINE_STATION,
                             C.NUM,
                             C.USE_AGE_AMOUNT_UNIT,
                             C.PARTF_ID,
                             NULL                  AFOFF_TIME,
                             C.PURCHASE_TYPE
                        FROM MM_PUB_SUPPORTING_PART C
                       WHERE C.FACTORY_CODE = in_arr_factory) D
               START WITH D.ORDER_NO IS NOT NULL
              CONNECT BY NOCYCLE PRIOR D.PART_NO = D.PARTF_ID) H
       WHERE H.PURCHASE_TYPE = 'FW'
       group by H.FACTORY_CODE,
                H.WARE_CODE,
                H.PART_NO,
                H.USAGE_AMOUNT_UNIT,
                H.PURCHASE_TYPE,
                in_account,
                to_date(TO_CHAR(H.AFOFF_TIME, 'YYYY-MM-DD'), 'yyyy-mm-dd');
  
    --COMMIT;
  
    --外层循环，循环次数，循环MM_INV_WEEK_CAL的最大天数
    loop
      INSERT INTO MM_INV_DIFFERENCE
        (ID,
         FACTORY_CODE,
         PART_NO,
         WARE_CODE,
         BASE_NUM,
         USE_NUM,
         AF_DATE,
         CREATION_USER,
         CREATION_TIME)
        SELECT PKG_PUB.USF_GET_SEQUENCE('SEQ_MM_INV_DIFFERENCE'),
               in_arr_factory,
               B.PART_NO,
               B.WARE_CODE,
               C.STOCK,
               B.NUM,
               --TRUNC(SYSDATE + 7, 'D') + 1 + v_count,
               B.AFOFF_TIME,
               in_account,
               SYSDATE
          FROM MM_INV_SUPP_ORDER_BOM B
          LEFT JOIN MM_INV_BENCHMARK C
            ON B.FACTORY_CODE = C.FACTORY_CODE
           AND B.WARE_CODE = C.WARE_CODE
           AND B.PART_NO = C.PART_NO
           AND C.FACTORY_CODE = in_arr_factory
         WHERE B.FACTORY_CODE = in_arr_factory
           AND B.AFOFF_TIME <= TRUNC(SYSDATE + 7, 'D') + 1 + v_count;
      --GROUP BY B.FACTORY_CODE, B.WARE_CODE, B.PART_NO;
    
      v_count := v_count + 1;
      --当天数大于最大天数时推出外层循环
      exit when v_count > 7;
    end loop;
    COMMIT;
    out_code := 0;
  EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        out_code := 1;
        err_num  := sqlcode;
        err_msg  := substrb(sqlerrm ||
                            dbms_utility.format_error_backtrace(),
                            1,
                            200);
        --异常的时候记录异常日志
        INSERT INTO MM_PUB_PRO_ERROR
          (id, alert_type, error_name, error_desc, creation_date, key_name)
        VALUES
          (seq_pub_pro_error.nextval,
           'USP_INV_GET_DIFFERENCE',
           err_num,
           err_msg,
           sysdate,
           '支给库存获取差异查询');
        COMMIT;
        ROLLBACK;
      
      END;
  END USP_INV_GET_DIFFERENCE;

end PKG_TEST;
/

prompt
prompt Creating type body MY_WM_CONCAT
prompt ===============================
prompt
CREATE OR REPLACE TYPE BODY "MY_WM_CONCAT" as
   static Function ODCIAGGREGATEINITIALIZE (INIT IN OUT MY_wm_concat)
      return NUMBER as
      begin
          init := MY_wm_concat('', ',', 'asc', MYARRAY());
          return ODCICONST.Success;
        END;
   member Function ODCIAGGREGATEITERATE (SELF IN OUT MY_wm_concat,COLVALUE IN VARCHAR2)
      return NUMBER as
      tempStr varchar(500);

          extendStr varchar(500);

          deStr varchar(100);

          deLen int default 0;

          segStr varchar(500);

          --????????
          TYPE varArry IS VARRAY(2) OF VARCHAR2(200);

          tempArry varArry := varArry('', '');

        begin

          if instr(colValue, ' ', 1) > 0 then
            tempStr := substr(colValue, 1, instr(colValue, ' ', 1) - 1);
          else
            tempStr := colValue;
          end if;

          --??????
          extendStr := REPLACE(colValue, tempStr || ' ');

          if instr(extendStr, ' ', 1) > 0 then

            tempArry(1) := substr(extendStr, 1, instr(extendStr, ' ', 1) - 1);

            tempArry(2) := substr(extendStr, instr(extendStr, ' ', 1));

            for i in 1 .. tempArry.count loop
              -- ?????
              if (tempArry(i) is not null) and
                 (instr(tempArry(i), 'delimiter=>') > 0) THEN

                deStr := 'delimiter=>';

                deLen := length(deStr);

                segStr := substr(trim(tempArry(i)),
                                 instr(trim(tempArry(i)), deStr) + deLen);

                self.delimiter := SUBSTR(segStr, 1, instr(segStr, ';', -1) - 1);
              END IF;

              -- ???????
              if tempArry(i) is not null and
                 (instr(tempArry(i), 'orderby=>') > 0) THEN

                deStr := 'orderby=>';

                deLen := length(deStr);

                segStr := substr(trim(tempArry(i)),
                                 instr(trim(tempArry(i)), deStr) + deLen);

                self.orderby := SUBSTR(segStr, 1, instr(segStr, ';', -1) - 1);

              END IF;

            end loop;

          end if;

          -- ?????
          self.strArray.extend;

          self.strArray(self.strArray.count) := tempStr;

          return ODCICONST.Success;
        END;
   member Function ODCIAGGREGATEMERGE (SELF IN OUT MY_wm_concat,NEXT MY_wm_concat)
      return NUMBER as
      begin

          -- ?next?????????self????????
          for i in 1 .. next.strArray.count loop

            self.strArray.extend;

            self.strArray(self.strArray.count) := next.strArray(i);

          end loop;

          return ODCICONST.Success;
        END;
   member Function ODCIAGGREGATETERMINATE (SELF IN MY_wm_concat,RETURNVALUE OUT VARCHAR2,FLAGS IN NUMBER)
      return NUMBER as
      temp_rtnValue varchar2(32767);

        BEGIN
          -- ??
          if INSTR(self.orderby, 'desc') > 0 THEN

            for x in (select column_value
                        from Table(self.strArray)
                       order by 1 DESC) loop

              temp_rtnValue := temp_rtnValue || self.delimiter || x.column_value;

            end loop;
          ELSE
            for x in (select column_value from Table(self.strArray) order by 1 ASC) loop

              temp_rtnValue := temp_rtnValue || self.delimiter || x.column_value;

            end loop;

          END IF;

          returnValue := ltrim(temp_rtnValue, self.delimiter);

          return ODCICONST.Success;
        END;
end;
/

prompt
prompt Creating trigger TRIG_MM_INV_PART_LOCATION
prompt ==========================================
prompt
CREATE OR REPLACE TRIGGER TRIG_MM_INV_PART_LOCATION
       AFTER INSERT OR UPDATE ON MM_INV_PART_LOCATION
  for each row
declare
   VAR_WORK_DATE VARCHAR2(32);
begin
  IF INSERTING THEN
    INSERT INTO IF_MM_INV_PART_LOCATION T
      (ID,
       FACTORY_CODE,
       PART_NO,
       SUPPLIER_NO,
       WARE_CODE,
       STATION_CODE,
       UNLOAD_PORT,
       DEP_NO,
       PREPARE_PERSON,
       CARPOOL,
       DISTRI_PERSON,
       LOCATION,
       SHELF_NO,
       LOCATION_NUM,
       MODEL_CODE,
       STORAGE,
       EFF_START,
       EFF_END,
       CREATION_USER,
       CREATION_TIME,
       LAST_MODIFIED_USER,
       LAST_MODIFIED_TIME,
       WORKCENTER,
       DEAL_FLAG,
       DEAL_TIME,
       GUID,
       UDA1,
       UDA2,
       UDA3,
       UDA4,
       UDA5,
       DO_FLAG)
       VALUES
       (
       :NEW.ID,
       :NEW.FACTORY_CODE,
       :NEW.PART_NO,
       :NEW.SUPPLIER_NO,
       :NEW.WARE_CODE,
       :NEW.STATION_CODE,
       :NEW.UNLOAD_PORT,
       :NEW.DEP_NO,
       :NEW.PREPARE_PERSON,
       :NEW.CARPOOL,
       :NEW.DISTRI_PERSON,
       :NEW.LOCATION,
       :NEW.SHELF_NO,
       :NEW.LOCATION_NUM,
       :NEW.MODEL_CODE,
       :NEW.STORAGE,
       :NEW.EFF_START,
       :NEW.EFF_END,
       :NEW.CREATION_USER,
       :NEW.CREATION_TIME,
       :NEW.LAST_MODIFIED_USER,
       :NEW.LAST_MODIFIED_TIME,
       :NEW.WORKCENTER,
       '0',
       :NEW.CREATION_TIME,
       SYS_GUID(),
       NULL,
       NULL,
       NULL,
       NULL,
       NULL,
       'I'
       );
    ELSIF UPDATING THEN
     INSERT INTO IF_MM_INV_PART_LOCATION T
      (ID,
       FACTORY_CODE,
       PART_NO,
       SUPPLIER_NO,
       WARE_CODE,
       STATION_CODE,
       UNLOAD_PORT,
       DEP_NO,
       PREPARE_PERSON,
       CARPOOL,
       DISTRI_PERSON,
       LOCATION,
       SHELF_NO,
       LOCATION_NUM,
       MODEL_CODE,
       STORAGE,
       EFF_START,
       EFF_END,
       CREATION_USER,
       CREATION_TIME,
       LAST_MODIFIED_USER,
       LAST_MODIFIED_TIME,
       WORKCENTER,
       DEAL_FLAG,
       DEAL_TIME,
       GUID,
       UDA1,
       UDA2,
       UDA3,
       UDA4,
       UDA5,
       DO_FLAG)
       VALUES
       (
       :NEW.ID,
       :NEW.FACTORY_CODE,
       :NEW.PART_NO,
       :NEW.SUPPLIER_NO,
       :NEW.WARE_CODE,
       :NEW.STATION_CODE,
       :NEW.UNLOAD_PORT,
       :NEW.DEP_NO,
       :NEW.PREPARE_PERSON,
       :NEW.CARPOOL,
       :NEW.DISTRI_PERSON,
       :NEW.LOCATION,
       :NEW.SHELF_NO,
       :NEW.LOCATION_NUM,
       :NEW.MODEL_CODE,
       :NEW.STORAGE,
       :NEW.EFF_START,
       :NEW.EFF_END,
       :NEW.CREATION_USER,
       :NEW.CREATION_TIME,
       :NEW.LAST_MODIFIED_USER,
       :NEW.LAST_MODIFIED_TIME,
       :NEW.WORKCENTER,
       '0',
       :NEW.CREATION_TIME,
       SYS_GUID(),
       NULL,
       NULL,
       NULL,
       NULL,
       NULL,
       'U'
       );
    END IF;
end TRIG_MM_INV_PART_LOCATION;
/

prompt
prompt Creating trigger TRIG_MM_PKG_BOX
prompt ================================
prompt
CREATE OR REPLACE TRIGGER TRIG_MM_PKG_BOX
  AFTER INSERT OR UPDATE OR DELETE ON MM_PKG_BOX
  FOR EACH ROW
BEGIN
  IF INSERTING THEN
  INSERT INTO IF_MM_PKG_BOX
    (ID,
     BOX_CODE,
     BOX_TYPE,
     PACK_LENGTH,
     PACK_WIDTH,
     PACK_HEIGHT,
     STATUS,
     CREATION_USER,
     CREATION_TIME,
     LAST_MODIFIED_USER,
     LAST_MODIFIED_TIME,
     FACTORY_CODE,
     DO_FLAG,
     DEAL_FLAG,
     Deal_Time)
  VALUES
    (SEQ_IF_PKG_BOX.NEXTVAL,
     :NEW.BOX_CODE,
     :NEW.BOX_TYPE,
     :NEW.PACK_LENGTH,
     :NEW.PACK_WIDTH,
     :NEW.PACK_HEIGHT,
     :NEW.STATUS,
     :NEW.CREATION_USER,
     SYSDATE,
     :NEW.LAST_MODIFIED_USER,
     :NEW.LAST_MODIFIED_TIME,
     :NEW.FACTORY_CODE,
     'I',
     0,
     '');
  ELSIF UPDATING THEN
    INSERT INTO IF_MM_PKG_BOX
    (ID,
     BOX_CODE,
     BOX_TYPE,
     PACK_LENGTH,
     PACK_WIDTH,
     PACK_HEIGHT,
     STATUS,
     CREATION_USER,
     CREATION_TIME,
     LAST_MODIFIED_USER,
     LAST_MODIFIED_TIME,
     FACTORY_CODE,
     DO_FLAG,
     DEAL_FLAG,
     Deal_Time)
  VALUES
    (SEQ_IF_PKG_BOX.NEXTVAL,
     :NEW.BOX_CODE,
     :NEW.BOX_TYPE,
     :NEW.PACK_LENGTH,
     :NEW.PACK_WIDTH,
     :NEW.PACK_HEIGHT,
     :NEW.STATUS,
     :NEW.CREATION_USER,
     SYSDATE,
     :NEW.LAST_MODIFIED_USER,
     :NEW.LAST_MODIFIED_TIME,
     :NEW.FACTORY_CODE,
     'U',
     0,
     '');
  ELSIF DELETING THEN
    INSERT INTO IF_MM_PKG_BOX
    (ID,
     BOX_CODE,
     BOX_TYPE,
     PACK_LENGTH,
     PACK_WIDTH,
     PACK_HEIGHT,
     STATUS,
     CREATION_USER,
     CREATION_TIME,
     LAST_MODIFIED_USER,
     LAST_MODIFIED_TIME,
     FACTORY_CODE,
     DO_FLAG,
     DEAL_FLAG,
     Deal_Time)
  VALUES
    (SEQ_IF_PKG_BOX.NEXTVAL,
     :OLD.BOX_CODE,
     :OLD.BOX_TYPE,
     :OLD.PACK_LENGTH,
     :OLD.PACK_WIDTH,
     :OLD.PACK_HEIGHT,
     :OLD.STATUS,
     :OLD.CREATION_USER,
     SYSDATE,
     :OLD.LAST_MODIFIED_USER,
     :OLD.LAST_MODIFIED_TIME,
     :OLD.FACTORY_CODE,
     'D',
     0,
     '');
  END IF;
END;
/

prompt
prompt Creating trigger TRIG_MM_PKG_BOX_QTY
prompt ====================================
prompt
CREATE OR REPLACE TRIGGER TRIG_MM_PKG_BOX_QTY
  AFTER INSERT OR UPDATE OR DELETE ON MM_PKG_BOX_QTY
  FOR EACH ROW
BEGIN
  IF INSERTING THEN
  INSERT INTO IF_MM_PKG_BOX_QTY
    (ID,
     PROPOSAL_ID,
     PROVIDE_QTY,
     BOX_REQUIRE_QTY,
     HAIR_NOTE_MODEL,
     PLAN_DATE,
     DELAY_REASON,
     CREATION_USER,
     CREATION_TIME,
     LAST_MODIFIED_USER,
     LAST_MODIFIED_TIME,
     FACTORY_CODE,
     DO_FLAG,
     DEAL_FLAG,
     DEAL_TIME)
  VALUES
    (SEQ_IF_PKG_BOX_QTY.NEXTVAL,
     :NEW.PROPOSAL_ID,
     :NEW.PROVIDE_QTY,
     :NEW.BOX_REQUIRE_QTY,
     :NEW.HAIR_NOTE_MODEL,
     :NEW.PLAN_DATE,
     :NEW.DELAY_REASON,
     :NEW.CREATION_USER,
     SYSDATE,
     :NEW.LAST_MODIFIED_USER,
     :NEW.LAST_MODIFIED_TIME,
     :NEW.FACTORY_CODE,
     'I',
     0,
     '');
  ELSIF UPDATING THEN
    IF :NEW.PROVIDE_QTY IS NULL THEN 
    INSERT INTO IF_MM_PKG_BOX_QTY
    (ID,
     PROPOSAL_ID,
     PROVIDE_QTY,
     BOX_REQUIRE_QTY,
     HAIR_NOTE_MODEL,
     PLAN_DATE,
     DELAY_REASON,
     CREATION_USER,
     CREATION_TIME,
     LAST_MODIFIED_USER,
     LAST_MODIFIED_TIME,
     FACTORY_CODE,
     DO_FLAG,
     DEAL_FLAG,
     DEAL_TIME)
  VALUES
    (SEQ_IF_PKG_BOX_QTY.NEXTVAL,
     :NEW.PROPOSAL_ID,
     :NEW.PROVIDE_QTY,
     :NEW.BOX_REQUIRE_QTY,
     :NEW.HAIR_NOTE_MODEL,
     :NEW.PLAN_DATE,
     :NEW.DELAY_REASON,
     :NEW.CREATION_USER,
     SYSDATE,
     :NEW.LAST_MODIFIED_USER,
     :NEW.LAST_MODIFIED_TIME,
     :NEW.FACTORY_CODE,
     'U',
     0,
     '');
     END IF;
  ELSIF DELETING THEN
    INSERT INTO IF_MM_PKG_BOX_QTY
    (ID,
     PROPOSAL_ID,
     PROVIDE_QTY,
     BOX_REQUIRE_QTY,
     HAIR_NOTE_MODEL,
     PLAN_DATE,
     DELAY_REASON,
     CREATION_USER,
     CREATION_TIME,
     LAST_MODIFIED_USER,
     LAST_MODIFIED_TIME,
     FACTORY_CODE,
     DO_FLAG,
     DEAL_FLAG,
     DEAL_TIME)
  VALUES
    (SEQ_IF_PKG_BOX_QTY.NEXTVAL,
     :OLD.PROPOSAL_ID,
     :OLD.PROVIDE_QTY,
     :OLD.BOX_REQUIRE_QTY,
     :OLD.HAIR_NOTE_MODEL,
     :OLD.PLAN_DATE,
     :OLD.DELAY_REASON,
     :OLD.CREATION_USER,
     SYSDATE,
     :OLD.LAST_MODIFIED_USER,
     :OLD.LAST_MODIFIED_TIME,
     :OLD.FACTORY_CODE,
     'D',
     0,
     '');
  END IF;
END;
/

prompt
prompt Creating trigger TRIG_MM_PKG_PART
prompt =================================
prompt
CREATE OR REPLACE TRIGGER TRIG_MM_PKG_PART
  AFTER INSERT OR UPDATE OR DELETE ON MM_PKG_PART
  FOR EACH ROW
BEGIN
  IF INSERTING THEN
  INSERT INTO IF_MM_PKG_PART
    (ID,
     CAR_TYPE,
     PROJECT,
     PART_NO,
     PART_RESP_USER,
     SUPPLIER_NO,
     STATUS,
     CREATION_USER,
     CREATION_TIME,
     LAST_MODIFIED_USER,
     LAST_MODIFIED_TIME,
     FACTORY_CODE,
     PURCHASE_TYPE,
     EMAIL_FLAG,
     DO_FLAG,
     DEAL_FLAG,
     DEAL_TIME)
  VALUES
    (SEQ_IF_PKG_PART.NEXTVAL,
     :NEW.CAR_TYPE,
     :NEW.PROJECT,
     :NEW.PART_NO,
     :NEW.PART_RESP_USER,
     :NEW.SUPPLIER_NO,
     :NEW.STATUS,
     :NEW.CREATION_USER,
     SYSDATE,
     :NEW.LAST_MODIFIED_USER,
     :NEW.LAST_MODIFIED_TIME,
     :NEW.FACTORY_CODE,
     :NEW.PURCHASE_TYPE,
     0,
     'I',
     0,
     '');
  ELSIF UPDATING THEN
    INSERT INTO IF_MM_PKG_PART
    (ID,
     CAR_TYPE,
     PROJECT,
     PART_NO,
     PART_RESP_USER,
     SUPPLIER_NO,
     STATUS,
     CREATION_USER,
     CREATION_TIME,
     LAST_MODIFIED_USER,
     LAST_MODIFIED_TIME,
     FACTORY_CODE,
     PURCHASE_TYPE,
     EMAIL_FLAG,
     DO_FLAG,
     DEAL_FLAG,
     DEAL_TIME)
  VALUES
    (SEQ_IF_PKG_PART.NEXTVAL,
     :NEW.CAR_TYPE,
     :NEW.PROJECT,
     :NEW.PART_NO,
     :NEW.PART_RESP_USER,
     :NEW.SUPPLIER_NO,
     :NEW.STATUS,
     :NEW.CREATION_USER,
     SYSDATE,
     :NEW.LAST_MODIFIED_USER,
     :NEW.LAST_MODIFIED_TIME,
     :NEW.FACTORY_CODE,
     :NEW.PURCHASE_TYPE,
     0,
     'U',
     0,
     '');
  ELSIF DELETING THEN
    INSERT INTO IF_MM_PKG_PART
    (ID,
     CAR_TYPE,
     PROJECT,
     PART_NO,
     PART_RESP_USER,
     SUPPLIER_NO,
     STATUS,
     CREATION_USER,
     CREATION_TIME,
     LAST_MODIFIED_USER,
     LAST_MODIFIED_TIME,
     FACTORY_CODE,
     PURCHASE_TYPE,
     EMAIL_FLAG,
     DO_FLAG,
     DEAL_FLAG,
     DEAL_TIME)
  VALUES
    (SEQ_IF_PKG_PART.NEXTVAL,
     :OLD.CAR_TYPE,
     :OLD.PROJECT,
     :OLD.PART_NO,
     :OLD.PART_RESP_USER,
     :OLD.SUPPLIER_NO,
     :OLD.STATUS,
     :OLD.CREATION_USER,
     SYSDATE,
     :OLD.LAST_MODIFIED_USER,
     :OLD.LAST_MODIFIED_TIME,
     :OLD.FACTORY_CODE,
     :OLD.PURCHASE_TYPE,
     0,
     'D',
     0,
     '');
  END IF;
END;
/

prompt
prompt Creating trigger TRIG_MM_PKG_PROPOSAL
prompt =====================================
prompt
CREATE OR REPLACE TRIGGER TRIG_MM_PKG_PROPOSAL
  AFTER INSERT OR UPDATE OR DELETE ON MM_PKG_PROPOSAL
  FOR EACH ROW
BEGIN
  IF INSERTING THEN
    INSERT INTO IF_MM_PKG_PROPOSAL
    (ID,
     CAR_TYPE,
     SUPPLIER_NO,
     PART_NO,
     PROPOSAL_STATUS,
     PACK_TYPE,
     BOX_TYPE,
     REPLY_LIMIT_DATE,
     IS_COM_PACK,
     STATUS,
     SIGN_PRO_FILE,
     EFF_START,
     EFF_END,
     CREATION_USER,
     CREATION_TIME,
     LAST_MODIFIED_USER,
     LAST_MODIFIED_TIME,
     FACTORY_CODE,
     PART_RESP_USER,
     PROJECT,
     PURCHASE_TYPE,
     COM_PACK_REMARK,
     IS_SHOW_CHANGE,
     DO_FLAG,
     DEAL_FLAG,
     DEAL_TIME)
  VALUES
    (:NEW.ID,
     :NEW.CAR_TYPE,
     :NEW.SUPPLIER_NO,
     :NEW.PART_NO,
     :NEW.PROPOSAL_STATUS,
     :NEW.PACK_TYPE,
     :NEW.BOX_TYPE,
     :NEW.REPLY_LIMIT_DATE,
     :NEW.IS_COM_PACK,
     :NEW.STATUS,
     :NEW.SIGN_PRO_FILE,
     :NEW.EFF_START,
     :NEW.EFF_END,
     :NEW.CREATION_USER,
     SYSDATE,
     :NEW.LAST_MODIFIED_USER,
     :NEW.LAST_MODIFIED_TIME,
     :NEW.FACTORY_CODE,
     :NEW.PART_RESP_USER,
     :NEW.PROJECT,
     :NEW.PURCHASE_TYPE,
     :NEW.COM_PACK_REMARK,
     :NEW.IS_SHOW_CHANGE,
     'I',
     0,
     '');
  ELSIF UPDATING THEN
    IF 
      :NEW.PROPOSAL_STATUS !=2 THEN
    INSERT INTO IF_MM_PKG_PROPOSAL
    (ID,
     CAR_TYPE,
     SUPPLIER_NO,
     PART_NO,
     PROPOSAL_STATUS,
     PACK_TYPE,
     BOX_TYPE,
     REPLY_LIMIT_DATE,
     IS_COM_PACK,
     STATUS,
     SIGN_PRO_FILE,
     EFF_START,
     EFF_END,
     CREATION_USER,
     CREATION_TIME,
     LAST_MODIFIED_USER,
     LAST_MODIFIED_TIME,
     FACTORY_CODE,
     PART_RESP_USER,
     PROJECT,
     PURCHASE_TYPE,
     COM_PACK_REMARK,
     IS_SHOW_CHANGE,
     DO_FLAG,
     DEAL_FLAG,
     DEAL_TIME)
  VALUES
    (:NEW.ID,
     :NEW.CAR_TYPE,
     :NEW.SUPPLIER_NO,
     :NEW.PART_NO,
     :NEW.PROPOSAL_STATUS,
     :NEW.PACK_TYPE,
     :NEW.BOX_TYPE,
     :NEW.REPLY_LIMIT_DATE,
     :NEW.IS_COM_PACK,
     :NEW.STATUS,
     :NEW.SIGN_PRO_FILE,
     :NEW.EFF_START,
     :NEW.EFF_END,
     :NEW.CREATION_USER,
     SYSDATE,
     :NEW.LAST_MODIFIED_USER,
     :NEW.LAST_MODIFIED_TIME,
     :NEW.FACTORY_CODE,
     :NEW.PART_RESP_USER,
     :NEW.PROJECT,
     :NEW.PURCHASE_TYPE,
     :NEW.COM_PACK_REMARK,
     :NEW.IS_SHOW_CHANGE,
     'U',
     0,
     '');
     END IF ;
  
  END IF;
END;
/

prompt
prompt Creating trigger TRIG_MM_PKG_PROPOSAL_DETAIL
prompt ============================================
prompt
CREATE OR REPLACE TRIGGER TRIG_MM_PKG_PROPOSAL_DETAIL
  AFTER INSERT OR UPDATE OR DELETE ON MM_PKG_PROPOSAL_DETAIL
  FOR EACH ROW
BEGIN
  
  IF INSERTING THEN
    IF :NEW.IS_CHANGE = 1  THEN 
  INSERT INTO IF_MM_PKG_PROPOSAL_DETAIL
    (ID,
     PROPOSAL_ID,
     GROUP_NO,
     MAX_PACKAGE_NUM,
     STANDARD_PACKAGE,
     PART_WEIGHT,
     PART_TOTAL_WEIGHT,
     PACK_WEIGHT,
     PART_LENGTH,
     PART_WIDTH,
     PART_HEIGHT,
     EMPTY_TROLLEY_LENGTH,
     EMPTY_TROLLEY_WIDTH,
     EMPTY_TROLLEY_HEIGHT,
     REAL_TROLLEY_LENGTH,
     REAL_TROLLEY_WIDTH,
     REAL_TROLLEY_HEIGHT,
     TROLLEY_WEIGHT,
     TOTAL_WEIGHT,
     IS_TROLLEY_CODE,
     IS_POSITIONER,
     DUST_COVER,
     ONE_BY_PACKAGE,
     BOARD_LOCATION,
     WHEEL_DIAMETER,
     WORD_DESC,
     TRACTION_ROD_HEIGHT,
     IMPORTANT_POSTION_PIC,
     EMPTY_TRO_FRONT_PIC,
     EMPTY_TRO_SIDE_PIC,
     REAL_TRO_PIC,
     BOX_CODE,
     PACK_LENGTH,
     PACK_WIDTH,
     PACK_HEIGHT,
     TRAY_LENGTH,
     TRAY_WIDTH,
     TRAY_HEIGHT,
     WORK_REQUIRE,
     SINGLE_PART_PIC,
     SINGLE_PART_PUT_PIC,
     PACK_OVER_LOOK_PIC,
     PACK_SIDE_LOOK_PIC,
     CREATION_USER,
     CREATION_TIME,
     LAST_MODIFIED_USER,
     LAST_MODIFIED_TIME,
     FACTORY_CODE,
     SUP_NAME,
     MOBILE,
     MAIL,
     DO_FLAG,
     DEAL_FLAG,
     DEAL_TIME)
  VALUES
    (:NEW.ID,
     :NEW.PROPOSAL_ID,
     :NEW.GROUP_NO,
     :NEW.MAX_PACKAGE_NUM,
     :NEW.STANDARD_PACKAGE,
     :NEW.PART_WEIGHT,
     :NEW.PART_TOTAL_WEIGHT,
     :NEW.PACK_WEIGHT,
     :NEW.PART_LENGTH,
     :NEW.PART_WIDTH,
     :NEW.PART_HEIGHT,
     :NEW.EMPTY_TROLLEY_LENGTH,
     :NEW.EMPTY_TROLLEY_WIDTH,
     :NEW.EMPTY_TROLLEY_HEIGHT,
     :NEW.REAL_TROLLEY_LENGTH,
     :NEW.REAL_TROLLEY_WIDTH,
     :NEW.REAL_TROLLEY_HEIGHT,
     :NEW.TROLLEY_WEIGHT,
     :NEW.TOTAL_WEIGHT,
     :NEW.IS_TROLLEY_CODE,
     :NEW.IS_POSITIONER,
     :NEW.DUST_COVER,
     :NEW.ONE_BY_PACKAGE,
     :NEW.BOARD_LOCATION,
     :NEW.WHEEL_DIAMETER,
     :NEW.WORD_DESC,
     :NEW.TRACTION_ROD_HEIGHT,
     :NEW.IMPORTANT_POSTION_PIC,
     :NEW.EMPTY_TRO_FRONT_PIC,
     :NEW.EMPTY_TRO_SIDE_PIC,
     :NEW.REAL_TRO_PIC,
     :NEW.BOX_CODE,
     :NEW.PACK_LENGTH,
     :NEW.PACK_WIDTH,
     :NEW.PACK_HEIGHT,
     :NEW.TRAY_LENGTH,
     :NEW.TRAY_WIDTH,
     :NEW.TRAY_HEIGHT,
     :NEW.WORK_REQUIRE,
     :NEW.SINGLE_PART_PIC,
     :NEW.SINGLE_PART_PUT_PIC,
     :NEW.PACK_OVER_LOOK_PIC,
     :NEW.PACK_SIDE_LOOK_PIC,
     :NEW.CREATION_USER,
     SYSDATE,
     :NEW.LAST_MODIFIED_USER,
     :NEW.LAST_MODIFIED_TIME,
     :NEW.FACTORY_CODE,
     :NEW.SUP_NAME,
     :NEW.MOBILE,
     :NEW.MAIL,
     'I',
     0,
     '');
  ELSIF UPDATING THEN
    IF :NEW.IS_CHANGE = 1 THEN
    INSERT INTO IF_MM_PKG_PROPOSAL_DETAIL
    (ID,
     PROPOSAL_ID,
     GROUP_NO,
     MAX_PACKAGE_NUM,
     STANDARD_PACKAGE,
     PART_WEIGHT,
     PART_TOTAL_WEIGHT,
     PACK_WEIGHT,
     PART_LENGTH,
     PART_WIDTH,
     PART_HEIGHT,
     EMPTY_TROLLEY_LENGTH,
     EMPTY_TROLLEY_WIDTH,
     EMPTY_TROLLEY_HEIGHT,
     REAL_TROLLEY_LENGTH,
     REAL_TROLLEY_WIDTH,
     REAL_TROLLEY_HEIGHT,
     TROLLEY_WEIGHT,
     TOTAL_WEIGHT,
     IS_TROLLEY_CODE,
     IS_POSITIONER,
     DUST_COVER,
     ONE_BY_PACKAGE,
     BOARD_LOCATION,
     WHEEL_DIAMETER,
     WORD_DESC,
     TRACTION_ROD_HEIGHT,
     IMPORTANT_POSTION_PIC,
     EMPTY_TRO_FRONT_PIC,
     EMPTY_TRO_SIDE_PIC,
     REAL_TRO_PIC,
     BOX_CODE,
     PACK_LENGTH,
     PACK_WIDTH,
     PACK_HEIGHT,
     TRAY_LENGTH,
     TRAY_WIDTH,
     TRAY_HEIGHT,
     WORK_REQUIRE,
     SINGLE_PART_PIC,
     SINGLE_PART_PUT_PIC,
     PACK_OVER_LOOK_PIC,
     PACK_SIDE_LOOK_PIC,
     CREATION_USER,
     CREATION_TIME,
     LAST_MODIFIED_USER,
     LAST_MODIFIED_TIME,
     FACTORY_CODE,
     SUP_NAME,
     MOBILE,
     MAIL,
     DO_FLAG,
     DEAL_FLAG,
     DEAL_TIME)
  VALUES
    (:NEW.ID,
     :NEW.PROPOSAL_ID,
     :NEW.GROUP_NO,
     :NEW.MAX_PACKAGE_NUM,
     :NEW.STANDARD_PACKAGE,
     :NEW.PART_WEIGHT,
     :NEW.PART_TOTAL_WEIGHT,
     :NEW.PACK_WEIGHT,
     :NEW.PART_LENGTH,
     :NEW.PART_WIDTH,
     :NEW.PART_HEIGHT,
     :NEW.EMPTY_TROLLEY_LENGTH,
     :NEW.EMPTY_TROLLEY_WIDTH,
     :NEW.EMPTY_TROLLEY_HEIGHT,
     :NEW.REAL_TROLLEY_LENGTH,
     :NEW.REAL_TROLLEY_WIDTH,
     :NEW.REAL_TROLLEY_HEIGHT,
     :NEW.TROLLEY_WEIGHT,
     :NEW.TOTAL_WEIGHT,
     :NEW.IS_TROLLEY_CODE,
     :NEW.IS_POSITIONER,
     :NEW.DUST_COVER,
     :NEW.ONE_BY_PACKAGE,
     :NEW.BOARD_LOCATION,
     :NEW.WHEEL_DIAMETER,
     :NEW.WORD_DESC,
     :NEW.TRACTION_ROD_HEIGHT,
     :NEW.IMPORTANT_POSTION_PIC,
     :NEW.EMPTY_TRO_FRONT_PIC,
     :NEW.EMPTY_TRO_SIDE_PIC,
     :NEW.REAL_TRO_PIC,
     :NEW.BOX_CODE,
     :NEW.PACK_LENGTH,
     :NEW.PACK_WIDTH,
     :NEW.PACK_HEIGHT,
     :NEW.TRAY_LENGTH,
     :NEW.TRAY_WIDTH,
     :NEW.TRAY_HEIGHT,
     :NEW.WORK_REQUIRE,
     :NEW.SINGLE_PART_PIC,
     :NEW.SINGLE_PART_PUT_PIC,
     :NEW.PACK_OVER_LOOK_PIC,
     :NEW.PACK_SIDE_LOOK_PIC,
     :NEW.CREATION_USER,
     SYSDATE,
     :NEW.LAST_MODIFIED_USER,
     :NEW.LAST_MODIFIED_TIME,
     :NEW.FACTORY_CODE,
     :NEW.SUP_NAME,
     :NEW.MOBILE,
     :NEW.MAIL,
     'U',
     0,
     '');
   END IF;
  END IF;
  END IF;
END;
/

prompt
prompt Creating trigger TRIG_MM_PKG_TRAY_QTY
prompt =====================================
prompt
CREATE OR REPLACE TRIGGER TRIG_MM_PKG_TRAY_QTY
  AFTER INSERT OR UPDATE OR DELETE ON MM_PKG_TRAY_QTY
  FOR EACH ROW
BEGIN
  IF INSERTING THEN
    INSERT INTO IF_MM_PKG_TRAY_QTY
      (ID,
       CAR_TYPE,
       SUPPLIER_NO,
       PROVIDE_QTY,
       TRAY_REQUIRE_QTY,
       PLAN_DATE,
       DELAY_REASON,
       CREATION_USER,
       CREATION_TIME,
       LAST_MODIFIED_USER,
       LAST_MODIFIED_TIME,
       FACTORY_CODE,
       DO_FLAG,
       DEAL_FLAG,
       DEAL_TIME)
    VALUES
      (SEQ_IF_PKG_TRAY_QTY.NEXTVAL,
       :NEW.CAR_TYPE,
       :NEW.SUPPLIER_NO,
       :NEW.PROVIDE_QTY,
       :NEW.TRAY_REQUIRE_QTY,
       :NEW.PLAN_DATE,
       :NEW.DELAY_REASON,
       :NEW.CREATION_USER,
       SYSDATE,
       :NEW.LAST_MODIFIED_USER,
       :NEW.LAST_MODIFIED_TIME,
       :NEW.FACTORY_CODE,
       'I',
       0,
       '');
  ELSIF UPDATING THEN
    IF
      :NEW.TRAY_REQUIRE_QTY IS NOT NULL 
      THEN
    INSERT INTO IF_MM_PKG_TRAY_QTY
      (ID,
       CAR_TYPE,
       SUPPLIER_NO,
       PROVIDE_QTY,
       TRAY_REQUIRE_QTY,
       PLAN_DATE,
       DELAY_REASON,
       CREATION_USER,
       CREATION_TIME,
       LAST_MODIFIED_USER,
       LAST_MODIFIED_TIME,
       FACTORY_CODE,
       DO_FLAG,
       DEAL_FLAG,
       DEAL_TIME)
    VALUES
      (SEQ_IF_PKG_TRAY_QTY.NEXTVAL,
       :NEW.CAR_TYPE,
       :NEW.SUPPLIER_NO,
       :NEW.PROVIDE_QTY,
       :NEW.TRAY_REQUIRE_QTY,
       :NEW.PLAN_DATE,
       :NEW.DELAY_REASON,
       :NEW.CREATION_USER,
       SYSDATE,
       :NEW.LAST_MODIFIED_USER,
       :NEW.LAST_MODIFIED_TIME,
       :NEW.FACTORY_CODE,
       'U',
       0,
       '');
       END IF;
  END IF;
END;
/

prompt
prompt Creating trigger TRIG_MM_PUB_PART_UDA
prompt =====================================
prompt
CREATE OR REPLACE TRIGGER TRIG_MM_PUB_PART_UDA
  AFTER INSERT OR UPDATE OR DELETE ON MM_PUB_PART_UDA
  FOR EACH ROW

BEGIN
  IF INSERTING THEN
    INSERT INTO IF_MM_PUB_PART_UDA
      (ID,
       FACTORY_CODE,
       PART_NO,
       SUPPLIER_NO,
       SUP_FACTORY,
       PART_SHORT_NO,
       PART_NAME_CN,
       SUPPLIER_NAME,
       STANDARD_PACKAGE,
       DO_FLAG,
       UDA1,
       UDA2,
       UDA3,
       UDA4,
       UDA5, CREATION_TIME,
       GUID)
    VALUES
      (SEQ_IF_MM_PUB_PART_UDA_IN.NEXTVAL,
       :NEW.FACTORY_CODE,
       :NEW.PART_NO,
       :NEW.SUPPLIER_NO,
       :NEW.SUP_FACTORY,
       :NEW.PART_SHORT_NO,
       :NEW.PART_NAME_CN,
       :NEW.SUPPLIER_NAME,
       :NEW.STANDARD_PACKAGE,
       'I',
       NULL,
       NULL,
       NULL,
       NULL,
       NULL,
       SYSDATE,
       SYS_GUID());
  ELSIF UPDATING THEN
    INSERT INTO IF_MM_PUB_PART_UDA
      (ID,
       FACTORY_CODE,
       PART_NO,
       SUPPLIER_NO,
       SUP_FACTORY,
       PART_SHORT_NO,
       PART_NAME_CN,
       SUPPLIER_NAME,
       STANDARD_PACKAGE,
       DO_FLAG,
       UDA1,
       UDA2,
       UDA3,
       UDA4,
       UDA5, CREATION_TIME,
       GUID)
    VALUES
      (SEQ_IF_MM_PUB_PART_UDA_IN.NEXTVAL,
       :NEW.FACTORY_CODE,
       :NEW.PART_NO,
       :NEW.SUPPLIER_NO,
       :NEW.SUP_FACTORY,
       :NEW.PART_SHORT_NO,
       :NEW.PART_NAME_CN,
       :NEW.SUPPLIER_NAME,
       :NEW.STANDARD_PACKAGE,
       'U',
       NULL,
       NULL,
       NULL,
       NULL,
       NULL,
       SYSDATE,
       SYS_GUID());
  ELSIF DELETING THEN
    INSERT INTO IF_MM_PUB_PART_UDA
      (ID,
       FACTORY_CODE,
       PART_NO,
       SUPPLIER_NO,
       SUP_FACTORY,
       PART_SHORT_NO,
       PART_NAME_CN,
       SUPPLIER_NAME,
       STANDARD_PACKAGE,
       DO_FLAG,
       UDA1,
       UDA2,
       UDA3,
       UDA4,
       UDA5, CREATION_TIME,
       GUID)
    VALUES
      (SEQ_IF_MM_PUB_PART_UDA_IN.NEXTVAL,
       :OLD.FACTORY_CODE,
       :OLD.PART_NO,
       :OLD.SUPPLIER_NO,
       :OLD.SUP_FACTORY,
       :OLD.PART_SHORT_NO,
       :OLD.PART_NAME_CN,
       :OLD.SUPPLIER_NAME,
       :OLD.STANDARD_PACKAGE,
       'D',
       NULL,
       NULL,
       NULL,
       NULL,
       NULL,
       SYSDATE,
       SYS_GUID());
  END IF;
END;
/

prompt
prompt Creating trigger TRIG_MM_SW_PICKUP_PLAN
prompt =======================================
prompt
CREATE OR REPLACE TRIGGER TRIG_MM_SW_PICKUP_PLAN
  AFTER INSERT OR UPDATE OR DELETE ON MM_SW_PICKUP_PLAN
  FOR EACH ROW
BEGIN
  IF INSERTING THEN
  INSERT INTO IF_MM_SW_PICKUP_PLAN
         (ID,
         ORDER_NO,
         PURCHASE_NO,
         CONFIRM_DAYS,
         INTER_LOGIS_MANAGER,
         ORDER_USE,
         PLAN_ASSEMBLE_TIME,
         PLAN_ARR_TIME,
         PLAN_PICKUP_TIME,
         TODAY_CAR_BATCH,
         FEEDBACK_STATUS,
         LOGISTICS_MODE,
         AREA,
         CAR_TYPE,
         ROUTE_CODE,
         TOTAL_BATCHS,
         MERGE_BATCHS,
         SUP_FACTORY,
         SUPPLIER_NO,
         WORK_DATE,
         FACTORY_CODE,
         DIFF_FLAG,
         ORDER_DESC,
         PICKUP_TYPE,
         ORDER_ARR_DATE,
         UNLOAD_PORT,
         ADJ_STATUS,
         DOWNLOAD_STATUS,
         DOWNLOAD_TIME,
         CREATION_USER,
         CREATION_TIME,
         LAST_MODIFIED_USER,
         LAST_MODIFIED_TIME,
         DO_FLAG,
         DEAL_FLAG,
         DEAL_TIME)
      VALUES
        (SEQ_IF_MM_SW_PICKUP_PLAN.NEXTVAL,
         :NEW.ORDER_NO,
         :NEW.PURCHASE_NO,
         :NEW.CONFIRM_DAYS,
         :NEW.INTER_LOGIS_MANAGER,
         :NEW.ORDER_USE,
         :NEW.PLAN_ASSEMBLE_TIME,
         :NEW.PLAN_ARR_TIME,
         :NEW.PLAN_PICKUP_TIME,
         :NEW.TODAY_CAR_BATCH,
         :NEW.FEEDBACK_STATUS,
         :NEW.LOGISTICS_MODE,
         :NEW.AREA,
         :NEW.CAR_TYPE,
         :NEW.ROUTE_CODE,
         :NEW.TOTAL_BATCHS,
         :NEW.MERGE_BATCHS,
         :NEW.SUP_FACTORY,
         :NEW.SUPPLIER_NO,
         :NEW.WORK_DATE,
         :NEW.FACTORY_CODE,
         :NEW.DIFF_FLAG,
         :NEW.ORDER_DESC,
         :NEW.PICKUP_TYPE,
         :NEW.ORDER_ARR_DATE,
         :NEW.UNLOAD_PORT,
         :NEW.ADJ_STATUS,
         :NEW.DOWNLOAD_STATUS,
         :NEW.DOWNLOAD_TIME,
         :NEW.CREATION_USER,
         :NEW.CREATION_TIME,
         :NEW.LAST_MODIFIED_USER,
         :NEW.LAST_MODIFIED_TIME,
         'I',
         '0',
         '');

  ELSIF UPDATING THEN
    INSERT INTO IF_MM_SW_PICKUP_PLAN
     (ID,
         ORDER_NO,
         PURCHASE_NO,
         CONFIRM_DAYS,
         INTER_LOGIS_MANAGER,
         ORDER_USE,
         PLAN_ASSEMBLE_TIME,
         PLAN_ARR_TIME,
         PLAN_PICKUP_TIME,
         TODAY_CAR_BATCH,
         FEEDBACK_STATUS,
         LOGISTICS_MODE,
         AREA,
         CAR_TYPE,
         ROUTE_CODE,
         TOTAL_BATCHS,
         MERGE_BATCHS,
         SUP_FACTORY,
         SUPPLIER_NO,
         WORK_DATE,
         FACTORY_CODE,
         DIFF_FLAG,
         ORDER_DESC,
         PICKUP_TYPE,
         ORDER_ARR_DATE,
         UNLOAD_PORT,
         ADJ_STATUS,
         DOWNLOAD_STATUS,
         DOWNLOAD_TIME,
         CREATION_USER,
         CREATION_TIME,
         LAST_MODIFIED_USER,
         LAST_MODIFIED_TIME,
         DO_FLAG,
         DEAL_FLAG,
         DEAL_TIME)
      VALUES
        (SEQ_IF_MM_SW_PICKUP_PLAN.NEXTVAL,
         :NEW.ORDER_NO,
         :NEW.PURCHASE_NO,
         :NEW.CONFIRM_DAYS,
         :NEW.INTER_LOGIS_MANAGER,
         :NEW.ORDER_USE,
         :NEW.PLAN_ASSEMBLE_TIME,
         :NEW.PLAN_ARR_TIME,
         :NEW.PLAN_PICKUP_TIME,
         :NEW.TODAY_CAR_BATCH,
         :NEW.FEEDBACK_STATUS,
         :NEW.LOGISTICS_MODE,
         :NEW.AREA,
         :NEW.CAR_TYPE,
         :NEW.ROUTE_CODE,
         :NEW.TOTAL_BATCHS,
         :NEW.MERGE_BATCHS,
         :NEW.SUP_FACTORY,
         :NEW.SUPPLIER_NO,
         :NEW.WORK_DATE,
         :NEW.FACTORY_CODE,
         :NEW.DIFF_FLAG,
         :NEW.ORDER_DESC,
         :NEW.PICKUP_TYPE,
         :NEW.ORDER_ARR_DATE,
         :NEW.UNLOAD_PORT,
         :NEW.ADJ_STATUS,
         :NEW.DOWNLOAD_STATUS,
         :NEW.DOWNLOAD_TIME,
         :NEW.CREATION_USER,
         :NEW.CREATION_TIME,
         :NEW.LAST_MODIFIED_USER,
         :NEW.LAST_MODIFIED_TIME,
         'U',
         '0',
         '');
  ELSIF DELETING THEN
    INSERT INTO IF_MM_SW_PICKUP_PLAN
     (ID,
         ORDER_NO,
         PURCHASE_NO,
         CONFIRM_DAYS,
         INTER_LOGIS_MANAGER,
         ORDER_USE,
         PLAN_ASSEMBLE_TIME,
         PLAN_ARR_TIME,
         PLAN_PICKUP_TIME,
         TODAY_CAR_BATCH,
         FEEDBACK_STATUS,
         LOGISTICS_MODE,
         AREA,
         CAR_TYPE,
         ROUTE_CODE,
         TOTAL_BATCHS,
         MERGE_BATCHS,
         SUP_FACTORY,
         SUPPLIER_NO,
         WORK_DATE,
         FACTORY_CODE,
         DIFF_FLAG,
         ORDER_DESC,
         PICKUP_TYPE,
         ORDER_ARR_DATE,
         UNLOAD_PORT,
         ADJ_STATUS,
         DOWNLOAD_STATUS,
         DOWNLOAD_TIME,
         CREATION_USER,
         CREATION_TIME,
         LAST_MODIFIED_USER,
         LAST_MODIFIED_TIME,
         DO_FLAG,
         DEAL_FLAG,
         DEAL_TIME)
      VALUES
        (SEQ_IF_MM_SW_PICKUP_PLAN.NEXTVAL,
         :OLD.ORDER_NO,
         :OLD.PURCHASE_NO,
         :OLD.CONFIRM_DAYS,
         :OLD.INTER_LOGIS_MANAGER,
         :OLD.ORDER_USE,
         :OLD.PLAN_ASSEMBLE_TIME,
         :OLD.PLAN_ARR_TIME,
         :OLD.PLAN_PICKUP_TIME,
         :OLD.TODAY_CAR_BATCH,
         :OLD.FEEDBACK_STATUS,
         :OLD.LOGISTICS_MODE,
         :OLD.AREA,
         :OLD.CAR_TYPE,
         :OLD.ROUTE_CODE,
         :OLD.TOTAL_BATCHS,
         :OLD.MERGE_BATCHS,
         :OLD.SUP_FACTORY,
         :OLD.SUPPLIER_NO,
         :OLD.WORK_DATE,
         :OLD.FACTORY_CODE,
         :OLD.DIFF_FLAG,
         :OLD.ORDER_DESC,
         :OLD.PICKUP_TYPE,
         :OLD.ORDER_ARR_DATE,
         :OLD.UNLOAD_PORT,
         :OLD.ADJ_STATUS,
         :OLD.DOWNLOAD_STATUS,
         :OLD.DOWNLOAD_TIME,
         :OLD.CREATION_USER,
         :OLD.CREATION_TIME,
         :OLD.LAST_MODIFIED_USER,
         :OLD.LAST_MODIFIED_TIME,
         'D',
         '0',
         '');
  END IF;
END;
/


spool off
